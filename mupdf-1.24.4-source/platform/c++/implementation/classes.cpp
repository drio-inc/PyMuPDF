/**
This file was auto-generated by mupdfwrap.py.
*/


#include "mupdf/classes.h"
#include "mupdf/classes2.h"
#include "mupdf/exceptions.h"
#include "mupdf/internal.h"

#include "mupdf/fitz/geometry.h"

#include <map>
#include <mutex>
#include <sstream>
#include <string.h>
#include <thread>

#include <string.h>

#ifndef NDEBUG
	static const int    s_trace = mupdf::internal_env_flag("MUPDF_trace");
	static const bool   s_trace_keepdrop = mupdf::internal_env_flag("MUPDF_trace_keepdrop");
	static const bool   s_trace_director = mupdf::internal_env_flag("MUPDF_trace_director");
#else
	static const int    s_trace = mupdf::internal_env_flag_check_unset("#ifndef NDEBUG", "MUPDF_trace");
	static const bool   s_trace_keepdrop = mupdf::internal_env_flag_check_unset("#ifndef NDEBUG", "MUPDF_trace_keepdrop");
	static const bool   s_trace_director = mupdf::internal_env_flag_check_unset("#ifndef NDEBUG", "MUPDF_trace_director");
#endif

namespace mupdf
{

/* Support for checking that reference counts of underlying
MuPDF structs are not smaller than the number of wrapper class
instances. Enable at runtime by setting environmental variable
MUPDF_check_refs to "1". */

static const bool   s_check_refs = internal_env_flag("MUPDF_check_refs");

/* For each MuPDF struct that has an 'int refs' member, we create
a static instance of this class template with T set to our wrapper
class, for example:

	static RefsCheck<fz_document, FzDocument> s_FzDocument_refs_check;

Then if s_check_refs is true, each constructor function calls
.add(), the destructor calls .remove() and other class functions
call .check(). This ensures that we check reference counting after
each class operation.

If <allow_int_this> is true, we allow _this->m_internal to be
an invalid pointer less than 4096, in which case we don't try
to check refs. This is used for_pdf_obj because in Python the
enums PDF_ENUM_NAME_* are converted to mupdf.PdfObj's containg
.m_internal's which are the enum values cast to (for_pdf_obj*), so
that they can be used directly.

If m_size is -1, we don't attempt any checking; this is for fz_xml
which is reference counted but does not have a simple .refs member.
*/
#ifndef NDEBUG
template<typename Struct, typename ClassWrapper, bool allow_int_this=false>
struct RefsCheck
{
	std::mutex              m_mutex;
	int                     m_offset;
	int                     m_size;
	std::map<Struct*, int>  m_this_to_num;

	RefsCheck(int offset, int size)
	: m_offset(offset), m_size(size)
	{
		assert(offset >= 0 && offset < 1000);
		assert(m_size == 32 || m_size == 16 || m_size == 8 || m_size == -1);
	}

	void change( const ClassWrapper* this_, const char* file, int line, const char* fn, int delta)
	{
		assert( s_check_refs);
		if (m_size == -1)
		{
			/* No well-defined .refs member for us to check, e.g. fz_xml. */
			return;
		}
		if (!this_->m_internal) return;
		if (allow_int_this)
		{
			#if 0   // Historic diagnostics, might still be useful.
			std::cerr << __FILE__ << ":" << __LINE__
					<< " " << file << ":" << line << ":" << fn << ":"
					<< " this_->m_internal=" << this_->m_internal
					<< "\n";
			#endif
			if ((intptr_t) this_->m_internal < 4096)
			{
				#if 0   // Historic diagnostics, might still be useful.
				std::cerr << __FILE__ << ":" << __LINE__
						<< " " << file << ":" << line << ":" << fn << ":"
						<< " Ignoring this_->m_internal=" << this_->m_internal
						<< "\n";
				#endif
				return;
			}
		}
		std::lock_guard< std::mutex> lock( m_mutex);
		/* Our lock doesn't make our access to
		this_->m_internal->refs thead-safe - other threads
		could be modifying it via fz_keep_<Struct>() or
		fz_drop_<Struct>(). But hopefully our read will be atomic
		in practise anyway? */
		void* refs_ptr = (char*) this_->m_internal + m_offset;
		int refs;
		if (m_size == 32)   refs = *(int32_t*) refs_ptr;
		if (m_size == 16)   refs = *(int16_t*) refs_ptr;
		if (m_size ==  8)   refs = *(int8_t* ) refs_ptr;

		int& n = m_this_to_num[ this_->m_internal];
		int n_prev = n;
		assert( n >= 0);
		n += delta;
		#if 0   // Historic diagnostics, might still be useful.
		std::cerr << file << ":" << line << ":" << fn << "():"
				// << " " << typeid(ClassWrapper).name() << ":"
				<< " this_=" << this_
				<< " this_->m_internal=" << this_->m_internal
				<< " refs=" << refs
				<< " n: " << n_prev << " => " << n
				<< "\n";
		#endif
		if ( n < 0)
		{
			#if 0   // Historic diagnostics, might still be useful.
			std::cerr << file << ":" << line << ":" << fn << "():"
					// << " " << typeid(ClassWrapper).name() << ":"
					<< " this_=" << this_
					<< " this_->m_internal=" << this_->m_internal
					<< " bad n: " << n_prev << " => " << n
					<< "\n";
			#endif
			abort();
		}
		if ( n && refs < n)
		{
			#if 0   // Historic diagnostics, might still be useful.
			std::cerr << file << ":" << line << ":" << fn << "():"
					// << " " << typeid(ClassWrapper).name() << ":"
					<< " this_=" << this_
					<< " this_->m_internal=" << this_->m_internal
					<< " refs=" << refs
					<< " n: " << n_prev << " => " << n
					<< " refs mismatch (refs<n):"
					<< "\n";
			#endif
			abort();
		}
		if (n && ::abs( refs - n) > 1000)
		{
			/* This traps case where n > 0 but underlying struct is
			freed and .ref is set to bogus value by fz_free() or
			similar. */
			#if 0   // Historic diagnostics, might still be useful.
			std::cerr << file << ":" << line << ":" << fn << "(): " << ": " << typeid(ClassWrapper).name()
					<< " bad change to refs."
					<< " this_=" << this_
					<< " refs=" << refs
					<< " n: " << n_prev << " => " << n
					<< "\n";
			#endif
			abort();
		}
		if (n == 0) m_this_to_num.erase( this_->m_internal);
	}
	void add( const ClassWrapper* this_, const char* file, int line, const char* fn)
	{
		change( this_, file, line, fn, +1);
	}
	void remove( const ClassWrapper* this_, const char* file, int line, const char* fn)
	{
		change( this_, file, line, fn, -1);
	}
	void check( const ClassWrapper* this_, const char* file, int line, const char* fn)
	{
		change( this_, file, line, fn, 0);
	}
};
#endif


/* Implementation of methods for FzAaContext (wrapper for fz_aa_context). */

/** Default constructor, sets each member to default value. */
FZ_FUNCTION FzAaContext::FzAaContext()
{
	this->hscale = {};
	this->vscale = {};
	this->scale = {};
	this->bits = {};
	this->text_bits = {};
	this->min_line_width = {};
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzAaContext::FzAaContext(const ::fz_aa_context* internal)
{
	assert( internal);
	this->hscale = internal->hscale;
	this->vscale = internal->vscale;
	this->scale = internal->scale;
	this->bits = internal->bits;
	this->text_bits = internal->text_bits;
	this->min_line_width = internal->min_line_width;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzAaContext::FzAaContext(const ::fz_aa_context internal)
{
	this->hscale = internal.hscale;
	this->vscale = internal.vscale;
	this->scale = internal.scale;
	this->bits = internal.bits;
	this->text_bits = internal.text_bits;
	this->min_line_width = internal.min_line_width;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::fz_aa_context`. */
FZ_FUNCTION ::fz_aa_context* FzAaContext::internal()
{
	auto ret = (::fz_aa_context*) &this->hscale;
	return ret;
}

/** Constructor using raw copy of pre-existing `::fz_aa_context`. */
FZ_FUNCTION const ::fz_aa_context* FzAaContext::internal() const
{
	auto ret = (const ::fz_aa_context*) &this->hscale;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION FzAaContext::~FzAaContext()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzAaContext::s_num_instances = 0;

FZ_FUNCTION std::string FzAaContext::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool FzAaContext::operator==(const FzAaContext& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool FzAaContext::operator!=(const FzAaContext& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for FzAes (wrapper for fz_aes). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzAes::FzAes()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_aes_crypt_cbc()`.  */
FZ_FUNCTION void FzAes::fz_aes_crypt_cbc(int mode, size_t length, unsigned char iv[16], const unsigned char *input, unsigned char *output) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_aes_crypt_cbc()\n";
	}
	#endif
	mupdf::fz_aes_crypt_cbc(*this, mode, length, iv, input, output);
}

/* Class-aware wrapper for `::fz_aes_setkey_dec()`.  */
FZ_FUNCTION int FzAes::fz_aes_setkey_dec(const unsigned char *key, int keysize) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_aes_setkey_dec()\n";
	}
	#endif
	auto ret = mupdf::fz_aes_setkey_dec(*this, key, keysize);
	return ret;
}

/* Class-aware wrapper for `::fz_aes_setkey_enc()`.  */
FZ_FUNCTION int FzAes::fz_aes_setkey_enc(const unsigned char *key, int keysize) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_aes_setkey_enc()\n";
	}
	#endif
	auto ret = mupdf::fz_aes_setkey_enc(*this, key, keysize);
	return ret;
}

FZ_FUNCTION FzAes::FzAes(::fz_aes* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzAes::~FzAes()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzAes::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzAes::s_num_instances = 0;


/* Implementation of methods for FzAllocContext (wrapper for fz_alloc_context). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzAllocContext::FzAllocContext()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzAllocContext::FzAllocContext(::fz_alloc_context* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzAllocContext::~FzAllocContext()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzAllocContext::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzAllocContext::s_num_instances = 0;


/* Implementation of methods for FzArc4 (wrapper for fz_arc4). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzArc4::FzArc4()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_arc4_encrypt()`.  */
FZ_FUNCTION void FzArc4::fz_arc4_encrypt(unsigned char *dest, const unsigned char *src, size_t len) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_arc4_encrypt()\n";
	}
	#endif
	mupdf::fz_arc4_encrypt(*this, dest, src, len);
}

/* Class-aware wrapper for `::fz_arc4_final()`.  */
FZ_FUNCTION void FzArc4::fz_arc4_final() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_arc4_final()\n";
	}
	#endif
	mupdf::fz_arc4_final(*this);
}

/* Class-aware wrapper for `::fz_arc4_init()`.  */
FZ_FUNCTION void FzArc4::fz_arc4_init(const unsigned char *key, size_t len) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_arc4_init()\n";
	}
	#endif
	mupdf::fz_arc4_init(*this, key, len);
}

FZ_FUNCTION FzArc4::FzArc4(::fz_arc4* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzArc4::~FzArc4()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzArc4::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzArc4::s_num_instances = 0;


/* Implementation of methods for FzArchive (wrapper for fz_archive). */

#ifndef NDEBUG
static RefsCheck<::fz_archive, FzArchive> s_FzArchive_refs_check(offsetof(::fz_archive, refs), 32);
#endif

/* Constructor using `fz_new_archive_of_size()`. */
FZ_FUNCTION FzArchive::FzArchive(const FzStream& file, int size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_archive_of_size()\n";
	}
	#endif
	this->m_internal = ll_fz_new_archive_of_size(file.m_internal, size);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_multi_archive()`. */
FZ_FUNCTION FzArchive::FzArchive()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_multi_archive()\n";
	}
	#endif
	this->m_internal = ll_fz_new_multi_archive();
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_tree_archive()`. */
FZ_FUNCTION FzArchive::FzArchive(const FzTree& tree)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_tree_archive()\n";
	}
	#endif
	this->m_internal = ll_fz_new_tree_archive(tree.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_archive()`. */
FZ_FUNCTION FzArchive::FzArchive(const FzArchive& rhs)
: m_internal(ll_fz_keep_archive(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_archive(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_archive()` and `fz_drop_archive()`. */
FZ_FUNCTION FzArchive& FzArchive::operator=(const FzArchive& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_archive(this->m_internal)"
				<< " and ll_fz_keep_archive(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_archive(this->m_internal);
	ll_fz_keep_archive(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/* Class-aware wrapper for `::fz_archive_format()`.  */
FZ_FUNCTION const char *FzArchive::fz_archive_format() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_archive_format()\n";
	}
	#endif
	auto ret = mupdf::fz_archive_format(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_count_archive_entries()`.  */
FZ_FUNCTION int FzArchive::fz_count_archive_entries() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_count_archive_entries()\n";
	}
	#endif
	auto ret = mupdf::fz_count_archive_entries(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_has_archive_entry()`.  */
FZ_FUNCTION int FzArchive::fz_has_archive_entry(const char *name) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_has_archive_entry()\n";
	}
	#endif
	auto ret = mupdf::fz_has_archive_entry(*this, name);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_list_archive_entry()`.  */
FZ_FUNCTION const char *FzArchive::fz_list_archive_entry(int idx) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_list_archive_entry()\n";
	}
	#endif
	auto ret = mupdf::fz_list_archive_entry(*this, idx);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_mount_multi_archive()`.  */
FZ_FUNCTION void FzArchive::fz_mount_multi_archive(const FzArchive& sub, const char *path) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_mount_multi_archive()\n";
	}
	#endif
	mupdf::fz_mount_multi_archive(*this, sub, path);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_open_archive_entry()`.  */
FZ_FUNCTION FzStream FzArchive::fz_open_archive_entry(const char *name) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_archive_entry()\n";
	}
	#endif
	auto ret = mupdf::fz_open_archive_entry(*this, name);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_parse_xml_archive_entry()`.  */
FZ_FUNCTION FzXml FzArchive::fz_parse_xml_archive_entry(const char *filename, int preserve_white) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_parse_xml_archive_entry()\n";
	}
	#endif
	auto ret = mupdf::fz_parse_xml_archive_entry(*this, filename, preserve_white);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_archive_entry()`.  */
FZ_FUNCTION FzBuffer FzArchive::fz_read_archive_entry(const char *name) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_archive_entry()\n";
	}
	#endif
	auto ret = mupdf::fz_read_archive_entry(*this, name);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_tree_archive_add_buffer()`.  */
FZ_FUNCTION void FzArchive::fz_tree_archive_add_buffer(const char *name, const FzBuffer& buf) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_tree_archive_add_buffer()\n";
	}
	#endif
	mupdf::fz_tree_archive_add_buffer(*this, name, buf);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_tree_archive_add_data()`.  */
FZ_FUNCTION void FzArchive::fz_tree_archive_add_data(const char *name, const void *data, size_t size) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_tree_archive_add_data()\n";
	}
	#endif
	mupdf::fz_tree_archive_add_data(*this, name, data, size);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_try_open_archive_entry()`.  */
FZ_FUNCTION FzStream FzArchive::fz_try_open_archive_entry(const char *name) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_try_open_archive_entry()\n";
	}
	#endif
	auto ret = mupdf::fz_try_open_archive_entry(*this, name);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_try_parse_xml_archive_entry()`.  */
FZ_FUNCTION FzXml FzArchive::fz_try_parse_xml_archive_entry(const char *filename, int preserve_white) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_try_parse_xml_archive_entry()\n";
	}
	#endif
	auto ret = mupdf::fz_try_parse_xml_archive_entry(*this, filename, preserve_white);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_try_read_archive_entry()`.  */
FZ_FUNCTION FzBuffer FzArchive::fz_try_read_archive_entry(const char *name) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_try_read_archive_entry()\n";
	}
	#endif
	auto ret = mupdf::fz_try_read_archive_entry(*this, name);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

FZ_FUNCTION FzArchive::FzArchive(::fz_archive* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzArchive::~FzArchive()
{
	ll_fz_drop_archive(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzArchive_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzArchive::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzArchive::s_num_instances = 0;


/* Implementation of methods for FzArchiveHandler (wrapper for fz_archive_handler). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzArchiveHandler::FzArchiveHandler()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_register_archive_handler()`.  */
FZ_FUNCTION void FzArchiveHandler::fz_register_archive_handler() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_register_archive_handler()\n";
	}
	#endif
	mupdf::fz_register_archive_handler(*this);
}

FZ_FUNCTION FzArchiveHandler::FzArchiveHandler(::fz_archive_handler* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzArchiveHandler::~FzArchiveHandler()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzArchiveHandler::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzArchiveHandler::s_num_instances = 0;


/* Implementation of methods for FzArchiveHandlerContext (wrapper for fz_archive_handler_context). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzArchiveHandlerContext::FzArchiveHandlerContext()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzArchiveHandlerContext::FzArchiveHandlerContext(::fz_archive_handler_context* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzArchiveHandlerContext::~FzArchiveHandlerContext()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzArchiveHandlerContext::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzArchiveHandlerContext::s_num_instances = 0;


/* Implementation of methods for FzBandWriter (wrapper for fz_band_writer). */

/* Constructor using `fz_new_band_writer_of_size()`. */
FZ_FUNCTION FzBandWriter::FzBandWriter(size_t size, const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_band_writer_of_size()\n";
	}
	#endif
	this->m_internal = ll_fz_new_band_writer_of_size(size, out.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_color_pcl_band_writer()`. */
/* Disabled because same args as fz_new_mono_pcl_band_writer.
FZ_FUNCTION FzBandWriter::FzBandWriter(const FzOutput& out, const FzPclOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_color_pcl_band_writer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_color_pcl_band_writer(out.m_internal, options.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

*/
/* Constructor using `fz_new_mono_pcl_band_writer()`. */
FZ_FUNCTION FzBandWriter::FzBandWriter(const FzOutput& out, const FzPclOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_mono_pcl_band_writer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_mono_pcl_band_writer(out.m_internal, options.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_mono_pwg_band_writer()`. */
FZ_FUNCTION FzBandWriter::FzBandWriter(const FzOutput& out, FzPwgOptions& pwg)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_mono_pwg_band_writer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_mono_pwg_band_writer(out.m_internal, &pwg.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_pam_band_writer()`. */
/* Disabled because same args as fz_new_png_band_writer.
FZ_FUNCTION FzBandWriter::FzBandWriter(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pam_band_writer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pam_band_writer(out.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

*/
/* Constructor using `fz_new_pbm_band_writer()`. */
/* Disabled because same args as fz_new_png_band_writer.
FZ_FUNCTION FzBandWriter::FzBandWriter(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pbm_band_writer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pbm_band_writer(out.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

*/
/* Constructor using `fz_new_pclm_band_writer()`. */
FZ_FUNCTION FzBandWriter::FzBandWriter(const FzOutput& out, const FzPclmOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pclm_band_writer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pclm_band_writer(out.m_internal, options.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_pdfocr_band_writer()`. */
FZ_FUNCTION FzBandWriter::FzBandWriter(const FzOutput& out, FzPdfocrOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pdfocr_band_writer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pdfocr_band_writer(out.m_internal,  options.internal());
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_pkm_band_writer()`. */
/* Disabled because same args as fz_new_png_band_writer.
FZ_FUNCTION FzBandWriter::FzBandWriter(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pkm_band_writer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pkm_band_writer(out.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

*/
/* Constructor using `fz_new_png_band_writer()`. */
FZ_FUNCTION FzBandWriter::FzBandWriter(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_png_band_writer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_png_band_writer(out.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_pnm_band_writer()`. */
/* Disabled because same args as fz_new_png_band_writer.
FZ_FUNCTION FzBandWriter::FzBandWriter(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pnm_band_writer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pnm_band_writer(out.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

*/
/* Constructor using `fz_new_ps_band_writer()`. */
/* Disabled because same args as fz_new_png_band_writer.
FZ_FUNCTION FzBandWriter::FzBandWriter(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_ps_band_writer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_ps_band_writer(out.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

*/
/* Constructor using `fz_new_psd_band_writer()`. */
/* Disabled because same args as fz_new_png_band_writer.
FZ_FUNCTION FzBandWriter::FzBandWriter(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_psd_band_writer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_psd_band_writer(out.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

*/
/* Constructor using `fz_new_pwg_band_writer()`. */
/* Disabled because same args as fz_new_mono_pwg_band_writer.
FZ_FUNCTION FzBandWriter::FzBandWriter(const FzOutput& out, FzPwgOptions& pwg)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pwg_band_writer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pwg_band_writer(out.m_internal, &pwg.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

*/
/** Custom constructor. */
FZ_FUNCTION FzBandWriter::FzBandWriter(FzOutput& out, Cm cm, const FzPclOptions& options)
{
	::fz_output*            out2 = out.m_internal;
	const ::fz_pcl_options* options2 = options.m_internal;
	if (0)  {}
	else if (cm == MONO)    m_internal = ll_fz_new_mono_pcl_band_writer( out2, options2);
	else if (cm == COLOR)   m_internal = ll_fz_new_color_pcl_band_writer( out2, options2);
	else throw std::runtime_error( "Unrecognised fz_band_writer_s Cm type");
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION FzBandWriter::FzBandWriter(FzOutput& out, P p)
{
	::fz_output*    out2 = out.m_internal;
	if (0)  {}
	else if (p == PNG)  m_internal = ll_fz_new_png_band_writer( out2);
	else if (p == PNM)  m_internal = ll_fz_new_pnm_band_writer( out2);
	else if (p == PAM)  m_internal = ll_fz_new_pam_band_writer( out2);
	else if (p == PBM)  m_internal = ll_fz_new_pbm_band_writer( out2);
	else if (p == PKM)  m_internal = ll_fz_new_pkm_band_writer( out2);
	else if (p == PS)   m_internal = ll_fz_new_ps_band_writer( out2);
	else if (p == PSD)  m_internal = ll_fz_new_psd_band_writer( out2);
	else throw std::runtime_error( "Unrecognised fz_band_writer_s P type");
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION FzBandWriter::FzBandWriter(FzOutput& out, Cm cm, const FzPwgOptions& options)
{
	::fz_output*            out2 = out.m_internal;
	const ::fz_pwg_options* options2 = &options.m_internal;
	if (0)  {}
	else if (cm == MONO)    m_internal = ll_fz_new_mono_pwg_band_writer( out2, options2);
	else if (cm == COLOR)   m_internal = ll_fz_new_pwg_band_writer( out2, options2);
	else throw std::runtime_error( "Unrecognised fz_band_writer_s Cm type");
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzBandWriter::FzBandWriter()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_close_band_writer()`.  */
FZ_FUNCTION void FzBandWriter::fz_close_band_writer() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_close_band_writer()\n";
	}
	#endif
	mupdf::fz_close_band_writer(*this);
}

/* Class-aware wrapper for `::fz_pdfocr_band_writer_set_progress()`.  */
FZ_FUNCTION void FzBandWriter::fz_pdfocr_band_writer_set_progress(::fz_pdfocr_progress_fn *progress_fn, void *progress_arg) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pdfocr_band_writer_set_progress()\n";
	}
	#endif
	mupdf::fz_pdfocr_band_writer_set_progress(*this, progress_fn, progress_arg);
}

/* Class-aware wrapper for `::fz_write_band()`.  */
FZ_FUNCTION void FzBandWriter::fz_write_band(int stride, int band_height, const unsigned char *samples) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_band()\n";
	}
	#endif
	mupdf::fz_write_band(*this, stride, band_height, samples);
}

/* Class-aware wrapper for `::fz_write_header()`.  */
FZ_FUNCTION void FzBandWriter::fz_write_header(int w, int h, int n, int alpha, int xres, int yres, int pagenum, const FzColorspace& cs, const FzSeparations& seps) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_header()\n";
	}
	#endif
	mupdf::fz_write_header(*this, w, h, n, alpha, xres, yres, pagenum, cs, seps);
}

FZ_FUNCTION FzBandWriter::FzBandWriter(::fz_band_writer* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzBandWriter::~FzBandWriter()
{
	ll_fz_drop_band_writer(m_internal);
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzBandWriter::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzBandWriter::s_num_instances = 0;


/* Implementation of methods for FzBitmap (wrapper for fz_bitmap). */

#ifndef NDEBUG
static RefsCheck<::fz_bitmap, FzBitmap> s_FzBitmap_refs_check(offsetof(::fz_bitmap, refs), 32);
#endif

/* Constructor using `fz_new_bitmap()`. */
FZ_FUNCTION FzBitmap::FzBitmap(int w, int h, int n, int xres, int yres)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_bitmap()\n";
	}
	#endif
	this->m_internal = ll_fz_new_bitmap(w, h, n, xres, yres);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBitmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_bitmap_from_pixmap()`. */
FZ_FUNCTION FzBitmap::FzBitmap(const FzPixmap& pix, const FzHalftone& ht)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_bitmap_from_pixmap()\n";
	}
	#endif
	this->m_internal = ll_fz_new_bitmap_from_pixmap(pix.m_internal, ht.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBitmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_bitmap_from_pixmap_band()`. */
FZ_FUNCTION FzBitmap::FzBitmap(const FzPixmap& pix, const FzHalftone& ht, int band_start)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_bitmap_from_pixmap_band()\n";
	}
	#endif
	this->m_internal = ll_fz_new_bitmap_from_pixmap_band(pix.m_internal, ht.m_internal, band_start);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBitmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_bitmap()`. */
FZ_FUNCTION FzBitmap::FzBitmap(const FzBitmap& rhs)
: m_internal(ll_fz_keep_bitmap(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_bitmap(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBitmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_bitmap()` and `fz_drop_bitmap()`. */
FZ_FUNCTION FzBitmap& FzBitmap::operator=(const FzBitmap& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_bitmap(this->m_internal)"
				<< " and ll_fz_keep_bitmap(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_bitmap(this->m_internal);
	ll_fz_keep_bitmap(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBitmap_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBitmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzBitmap::FzBitmap()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBitmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_bitmap_details()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_bitmap_details()` => `(int w, int h, int n, int stride)`
	 */
FZ_FUNCTION void FzBitmap::fz_bitmap_details(int *w, int *h, int *n, int *stride) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_bitmap_details()\n";
	}
	#endif
	mupdf::fz_bitmap_details(*this, w, h, n, stride);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBitmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_clear_bitmap()`.  */
FZ_FUNCTION void FzBitmap::fz_clear_bitmap() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clear_bitmap()\n";
	}
	#endif
	mupdf::fz_clear_bitmap(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBitmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_invert_bitmap()`.  */
FZ_FUNCTION void FzBitmap::fz_invert_bitmap() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_invert_bitmap()\n";
	}
	#endif
	mupdf::fz_invert_bitmap(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBitmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_save_bitmap_as_pbm()`.  */
FZ_FUNCTION void FzBitmap::fz_save_bitmap_as_pbm(const char *filename) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_bitmap_as_pbm()\n";
	}
	#endif
	mupdf::fz_save_bitmap_as_pbm(*this, filename);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBitmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_save_bitmap_as_pcl()`.  */
FZ_FUNCTION void FzBitmap::fz_save_bitmap_as_pcl(char *filename, int append, const FzPclOptions& pcl) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_bitmap_as_pcl()\n";
	}
	#endif
	mupdf::fz_save_bitmap_as_pcl(*this, filename, append, pcl);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBitmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_save_bitmap_as_pkm()`.  */
FZ_FUNCTION void FzBitmap::fz_save_bitmap_as_pkm(const char *filename) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_bitmap_as_pkm()\n";
	}
	#endif
	mupdf::fz_save_bitmap_as_pkm(*this, filename);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBitmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_save_bitmap_as_pwg()`.  */
FZ_FUNCTION void FzBitmap::fz_save_bitmap_as_pwg(char *filename, int append, FzPwgOptions& pwg) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_bitmap_as_pwg()\n";
	}
	#endif
	mupdf::fz_save_bitmap_as_pwg(*this, filename, append, pwg);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBitmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

FZ_FUNCTION FzBitmap::FzBitmap(::fz_bitmap* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBitmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION int FzBitmap::refs()
{
	return m_internal->refs;
}

FZ_FUNCTION int FzBitmap::w()
{
	return m_internal->w;
}

FZ_FUNCTION int FzBitmap::h()
{
	return m_internal->h;
}

FZ_FUNCTION int FzBitmap::stride()
{
	return m_internal->stride;
}

FZ_FUNCTION int FzBitmap::n()
{
	return m_internal->n;
}

FZ_FUNCTION int FzBitmap::xres()
{
	return m_internal->xres;
}

FZ_FUNCTION int FzBitmap::yres()
{
	return m_internal->yres;
}

FZ_FUNCTION const unsigned char *FzBitmap::samples()
{
	return m_internal->samples;
}

FZ_FUNCTION FzBitmap::~FzBitmap()
{
	ll_fz_drop_bitmap(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBitmap_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzBitmap::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzBitmap::s_num_instances = 0;


/* Implementation of methods for FzBuffer (wrapper for fz_buffer). */

#ifndef NDEBUG
static RefsCheck<::fz_buffer, FzBuffer> s_FzBuffer_refs_check(offsetof(::fz_buffer, refs), 32);
#endif

/* Constructor using `fz_new_buffer()`. */
FZ_FUNCTION FzBuffer::FzBuffer(size_t capacity)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_buffer(capacity);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_buffer_from_base64()`. */
FZ_FUNCTION FzBuffer::FzBuffer(const char *data, size_t size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_base64()\n";
	}
	#endif
	this->m_internal = ll_fz_new_buffer_from_base64(data, size);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_buffer_from_data()`. */
FZ_FUNCTION FzBuffer::FzBuffer(unsigned char *data, size_t size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_data()\n";
	}
	#endif
	this->m_internal = ll_fz_new_buffer_from_data(data, size);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_buffer_from_display_list()`. */
FZ_FUNCTION FzBuffer::FzBuffer(const FzDisplayList& list, FzStextOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_display_list()\n";
	}
	#endif
	this->m_internal = ll_fz_new_buffer_from_display_list(list.m_internal,  options.internal());
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_buffer_from_image_as_jpeg()`. */
FZ_FUNCTION FzBuffer::FzBuffer(const FzImage& image, const FzColorParams& color_params, int quality, int invert_cmyk)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_image_as_jpeg()\n";
	}
	#endif
	this->m_internal = ll_fz_new_buffer_from_image_as_jpeg(image.m_internal, * color_params.internal(), quality, invert_cmyk);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_buffer_from_image_as_jpx()`. */
FZ_FUNCTION FzBuffer::FzBuffer(const FzImage& image, const FzColorParams& color_params, int quality)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_image_as_jpx()\n";
	}
	#endif
	this->m_internal = ll_fz_new_buffer_from_image_as_jpx(image.m_internal, * color_params.internal(), quality);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_buffer_from_image_as_png()`. */
FZ_FUNCTION FzBuffer::FzBuffer(const FzImage& image, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_image_as_png()\n";
	}
	#endif
	this->m_internal = ll_fz_new_buffer_from_image_as_png(image.m_internal, * color_params.internal());
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_buffer_from_page()`. */
FZ_FUNCTION FzBuffer::FzBuffer(const FzPage& page, FzStextOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_page()\n";
	}
	#endif
	this->m_internal = ll_fz_new_buffer_from_page(page.m_internal,  options.internal());
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_buffer_from_page_number()`. */
FZ_FUNCTION FzBuffer::FzBuffer(const FzDocument& doc, int number, FzStextOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_page_number()\n";
	}
	#endif
	this->m_internal = ll_fz_new_buffer_from_page_number(doc.m_internal, number,  options.internal());
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_buffer_from_page_with_format()`. */
FZ_FUNCTION FzBuffer::FzBuffer(const FzPage& page, const char *format, const char *options, const FzMatrix& transform, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_page_with_format()\n";
	}
	#endif
	this->m_internal = ll_fz_new_buffer_from_page_with_format(page.m_internal, format, options, * transform.internal(), &cookie.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_buffer_from_pixmap_as_jpeg()`. */
FZ_FUNCTION FzBuffer::FzBuffer(const FzPixmap& pixmap, const FzColorParams& color_params, int quality, int invert_cmyk)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_pixmap_as_jpeg()\n";
	}
	#endif
	this->m_internal = ll_fz_new_buffer_from_pixmap_as_jpeg(pixmap.m_internal, * color_params.internal(), quality, invert_cmyk);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_buffer_from_pixmap_as_jpx()`. */
FZ_FUNCTION FzBuffer::FzBuffer(const FzPixmap& pix, const FzColorParams& color_params, int quality)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_pixmap_as_jpx()\n";
	}
	#endif
	this->m_internal = ll_fz_new_buffer_from_pixmap_as_jpx(pix.m_internal, * color_params.internal(), quality);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_buffer_from_pixmap_as_png()`. */
FZ_FUNCTION FzBuffer::FzBuffer(const FzPixmap& pixmap, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_pixmap_as_png()\n";
	}
	#endif
	this->m_internal = ll_fz_new_buffer_from_pixmap_as_png(pixmap.m_internal, * color_params.internal());
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_buffer_from_shared_data()`. */
FZ_FUNCTION FzBuffer::FzBuffer(const unsigned char *data, size_t size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_shared_data()\n";
	}
	#endif
	this->m_internal = ll_fz_new_buffer_from_shared_data(data, size);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_buffer_from_stext_page()`. */
FZ_FUNCTION FzBuffer::FzBuffer(const FzStextPage& text)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_stext_page()\n";
	}
	#endif
	this->m_internal = ll_fz_new_buffer_from_stext_page(text.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_read_file()`. */
FZ_FUNCTION FzBuffer::FzBuffer(const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_file()\n";
	}
	#endif
	this->m_internal = ll_fz_read_file(filename);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_buffer()`. */
FZ_FUNCTION FzBuffer::FzBuffer(const FzBuffer& rhs)
: m_internal(ll_fz_keep_buffer(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_buffer(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_buffer()` and `fz_drop_buffer()`. */
FZ_FUNCTION FzBuffer& FzBuffer::operator=(const FzBuffer& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_buffer(this->m_internal)"
				<< " and ll_fz_keep_buffer(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_buffer(this->m_internal);
	ll_fz_keep_buffer(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/* Class-aware wrapper for `::fz_new_buffer_from_copied_data()`.  */
FZ_FUNCTION FzBuffer FzBuffer::fz_new_buffer_from_copied_data(const unsigned char *data, size_t size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_copied_data()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_copied_data(data, size);
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_image_as_pnm()`.  */
FZ_FUNCTION FzBuffer FzBuffer::fz_new_buffer_from_image_as_pnm(const FzImage& image, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_image_as_pnm()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_image_as_pnm(image, color_params);
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_image_as_pam()`.  */
FZ_FUNCTION FzBuffer FzBuffer::fz_new_buffer_from_image_as_pam(const FzImage& image, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_image_as_pam()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_image_as_pam(image, color_params);
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_image_as_psd()`.  */
FZ_FUNCTION FzBuffer FzBuffer::fz_new_buffer_from_image_as_psd(const FzImage& image, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_image_as_psd()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_image_as_psd(image, color_params);
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pnm()`.  */
FZ_FUNCTION FzBuffer FzBuffer::fz_new_buffer_from_pixmap_as_pnm(const FzPixmap& pixmap, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_pixmap_as_pnm()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_pixmap_as_pnm(pixmap, color_params);
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pam()`.  */
FZ_FUNCTION FzBuffer FzBuffer::fz_new_buffer_from_pixmap_as_pam(const FzPixmap& pixmap, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_pixmap_as_pam()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_pixmap_as_pam(pixmap, color_params);
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_psd()`.  */
FZ_FUNCTION FzBuffer FzBuffer::fz_new_buffer_from_pixmap_as_psd(const FzPixmap& pix, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_pixmap_as_psd()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_pixmap_as_psd(pix, color_params);
	return ret;
}

/* Class-aware wrapper for `::fz_append_base64()`.  */
FZ_FUNCTION void FzBuffer::fz_append_base64(const unsigned char *data, size_t size, int newline) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_base64()\n";
	}
	#endif
	mupdf::fz_append_base64(*this, data, size, newline);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_append_base64_buffer()`.  */
FZ_FUNCTION void FzBuffer::fz_append_base64_buffer(const FzBuffer& data, int newline) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_base64_buffer()\n";
	}
	#endif
	mupdf::fz_append_base64_buffer(*this, data, newline);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_append_bits()`.  */
FZ_FUNCTION void FzBuffer::fz_append_bits(int value, int count) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_bits()\n";
	}
	#endif
	mupdf::fz_append_bits(*this, value, count);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_append_bits_pad()`.  */
FZ_FUNCTION void FzBuffer::fz_append_bits_pad() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_bits_pad()\n";
	}
	#endif
	mupdf::fz_append_bits_pad(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_append_buffer()`.  */
FZ_FUNCTION void FzBuffer::fz_append_buffer(const FzBuffer& source) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_buffer()\n";
	}
	#endif
	mupdf::fz_append_buffer(*this, source);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_append_byte()`.  */
FZ_FUNCTION void FzBuffer::fz_append_byte(int c) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_byte()\n";
	}
	#endif
	mupdf::fz_append_byte(*this, c);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_append_data()`.  */
FZ_FUNCTION void FzBuffer::fz_append_data(const void *data, size_t len) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_data()\n";
	}
	#endif
	mupdf::fz_append_data(*this, data, len);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_append_image_as_data_uri()`.  */
FZ_FUNCTION void FzBuffer::fz_append_image_as_data_uri(const FzImage& image) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_image_as_data_uri()\n";
	}
	#endif
	mupdf::fz_append_image_as_data_uri(*this, image);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_append_int16_be()`.  */
FZ_FUNCTION void FzBuffer::fz_append_int16_be(int x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_int16_be()\n";
	}
	#endif
	mupdf::fz_append_int16_be(*this, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_append_int16_le()`.  */
FZ_FUNCTION void FzBuffer::fz_append_int16_le(int x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_int16_le()\n";
	}
	#endif
	mupdf::fz_append_int16_le(*this, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_append_int32_be()`.  */
FZ_FUNCTION void FzBuffer::fz_append_int32_be(int x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_int32_be()\n";
	}
	#endif
	mupdf::fz_append_int32_be(*this, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_append_int32_le()`.  */
FZ_FUNCTION void FzBuffer::fz_append_int32_le(int x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_int32_le()\n";
	}
	#endif
	mupdf::fz_append_int32_le(*this, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_append_pdf_string()`.  */
FZ_FUNCTION void FzBuffer::fz_append_pdf_string(const char *text) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_pdf_string()\n";
	}
	#endif
	mupdf::fz_append_pdf_string(*this, text);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_append_pixmap_as_data_uri()`.  */
FZ_FUNCTION void FzBuffer::fz_append_pixmap_as_data_uri(const FzPixmap& pixmap) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_pixmap_as_data_uri()\n";
	}
	#endif
	mupdf::fz_append_pixmap_as_data_uri(*this, pixmap);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_append_rune()`.  */
FZ_FUNCTION void FzBuffer::fz_append_rune(int c) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_rune()\n";
	}
	#endif
	mupdf::fz_append_rune(*this, c);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_append_string()`.  */
FZ_FUNCTION void FzBuffer::fz_append_string(const char *data) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_string()\n";
	}
	#endif
	mupdf::fz_append_string(*this, data);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_append_vprintf()`.  */
FZ_FUNCTION void FzBuffer::fz_append_vprintf(const char *fmt, va_list args) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_vprintf()\n";
	}
	#endif
	mupdf::fz_append_vprintf(*this, fmt, args);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_buffer_extract()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_buffer_extract()` => `(size_t, unsigned char *data)`
	 */
FZ_FUNCTION size_t FzBuffer::fz_buffer_extract(unsigned char **data) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_buffer_extract()\n";
	}
	#endif
	auto ret = mupdf::fz_buffer_extract(*this, data);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_buffer_storage()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_buffer_storage()` => `(size_t, unsigned char *datap)`
	 */
FZ_FUNCTION size_t FzBuffer::fz_buffer_storage(unsigned char **datap) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_buffer_storage()\n";
	}
	#endif
	auto ret = mupdf::fz_buffer_storage(*this, datap);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_clear_buffer()`.  */
FZ_FUNCTION void FzBuffer::fz_clear_buffer() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clear_buffer()\n";
	}
	#endif
	mupdf::fz_clear_buffer(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_clone_buffer()`.  */
FZ_FUNCTION FzBuffer FzBuffer::fz_clone_buffer() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clone_buffer()\n";
	}
	#endif
	auto ret = mupdf::fz_clone_buffer(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_grow_buffer()`.  */
FZ_FUNCTION void FzBuffer::fz_grow_buffer() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_grow_buffer()\n";
	}
	#endif
	mupdf::fz_grow_buffer(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_load_jbig2_globals()`.  */
FZ_FUNCTION FzJbig2Globals FzBuffer::fz_load_jbig2_globals() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_jbig2_globals()\n";
	}
	#endif
	auto ret = mupdf::fz_load_jbig2_globals(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_md5_buffer()`.  */
FZ_FUNCTION void FzBuffer::fz_md5_buffer(unsigned char digest[16]) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_md5_buffer()\n";
	}
	#endif
	mupdf::fz_md5_buffer(*this, digest);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_new_display_list_from_svg()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_new_display_list_from_svg(const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`
	 */
FZ_FUNCTION FzDisplayList FzBuffer::fz_new_display_list_from_svg(const char *base_uri, const FzArchive& dir, float *w, float *h) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_display_list_from_svg()\n";
	}
	#endif
	auto ret = mupdf::fz_new_display_list_from_svg(*this, base_uri, dir, w, h);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_image_from_buffer()`.  */
FZ_FUNCTION FzImage FzBuffer::fz_new_image_from_buffer() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_from_buffer()\n";
	}
	#endif
	auto ret = mupdf::fz_new_image_from_buffer(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_image_from_svg()`.  */
FZ_FUNCTION FzImage FzBuffer::fz_new_image_from_svg(const char *base_uri, const FzArchive& dir) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_from_svg()\n";
	}
	#endif
	auto ret = mupdf::fz_new_image_from_svg(*this, base_uri, dir);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_buffer()`.  */
FZ_FUNCTION FzStream FzBuffer::fz_open_buffer() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_buffer()\n";
	}
	#endif
	auto ret = mupdf::fz_open_buffer(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_parse_xml()`.  */
FZ_FUNCTION FzXml FzBuffer::fz_parse_xml(int preserve_white) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_parse_xml()\n";
	}
	#endif
	auto ret = mupdf::fz_parse_xml(*this, preserve_white);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_parse_xml_from_html5()`.  */
FZ_FUNCTION FzXml FzBuffer::fz_parse_xml_from_html5() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_parse_xml_from_html5()\n";
	}
	#endif
	auto ret = mupdf::fz_parse_xml_from_html5(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_resize_buffer()`.  */
FZ_FUNCTION void FzBuffer::fz_resize_buffer(size_t capacity) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_resize_buffer()\n";
	}
	#endif
	mupdf::fz_resize_buffer(*this, capacity);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_save_buffer()`.  */
FZ_FUNCTION void FzBuffer::fz_save_buffer(const char *filename) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_buffer()\n";
	}
	#endif
	mupdf::fz_save_buffer(*this, filename);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_slice_buffer()`.  */
FZ_FUNCTION FzBuffer FzBuffer::fz_slice_buffer(int64_t start, int64_t end) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_slice_buffer()\n";
	}
	#endif
	auto ret = mupdf::fz_slice_buffer(*this, start, end);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_string_from_buffer()`.  */
FZ_FUNCTION const char *FzBuffer::fz_string_from_buffer() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_string_from_buffer()\n";
	}
	#endif
	auto ret = mupdf::fz_string_from_buffer(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_subset_cff_for_gids()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_subset_cff_for_gids(int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
	 */
FZ_FUNCTION FzBuffer FzBuffer::fz_subset_cff_for_gids(int *gids, int num_gids, int symbolic, int cidfont) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_subset_cff_for_gids()\n";
	}
	#endif
	auto ret = mupdf::fz_subset_cff_for_gids(*this, gids, num_gids, symbolic, cidfont);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_subset_ttf_for_gids()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_subset_ttf_for_gids(int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
	 */
FZ_FUNCTION FzBuffer FzBuffer::fz_subset_ttf_for_gids(int *gids, int num_gids, int symbolic, int cidfont) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_subset_ttf_for_gids()\n";
	}
	#endif
	auto ret = mupdf::fz_subset_ttf_for_gids(*this, gids, num_gids, symbolic, cidfont);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_terminate_buffer()`.  */
FZ_FUNCTION void FzBuffer::fz_terminate_buffer() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_terminate_buffer()\n";
	}
	#endif
	mupdf::fz_terminate_buffer(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_trim_buffer()`.  */
FZ_FUNCTION void FzBuffer::fz_trim_buffer() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_trim_buffer()\n";
	}
	#endif
	mupdf::fz_trim_buffer(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_append_token()`.  */
FZ_FUNCTION void FzBuffer::pdf_append_token(int tok, const PdfLexbuf& lex) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_append_token()\n";
	}
	#endif
	mupdf::pdf_append_token(*this, tok, lex);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_new_buffer_processor()`.  */
FZ_FUNCTION PdfProcessor FzBuffer::pdf_new_buffer_processor(int ahxencode, int newlines) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_buffer_processor()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_buffer_processor(*this, ahxencode, newlines);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

FZ_FUNCTION FzBuffer::FzBuffer(::fz_buffer* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzBuffer::~FzBuffer()
{
	ll_fz_drop_buffer(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzBuffer_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzBuffer::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzBuffer::s_num_instances = 0;


/* Implementation of methods for FzColorParams (wrapper for fz_color_params). */

/** Custom constructor. */
FZ_FUNCTION FzColorParams::FzColorParams()
{
	this->ri = fz_default_color_params.ri;
	this->bp = fz_default_color_params.bp;
	this->op = fz_default_color_params.op;
	this->opm = fz_default_color_params.opm;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzColorParams::FzColorParams(const ::fz_color_params* internal)
{
	assert( internal);
	this->ri = internal->ri;
	this->bp = internal->bp;
	this->op = internal->op;
	this->opm = internal->opm;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzColorParams::FzColorParams(const ::fz_color_params internal)
{
	this->ri = internal.ri;
	this->bp = internal.bp;
	this->op = internal.op;
	this->opm = internal.opm;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::fz_color_params`. */
FZ_FUNCTION ::fz_color_params* FzColorParams::internal()
{
	auto ret = (::fz_color_params*) &this->ri;
	return ret;
}

/** Constructor using raw copy of pre-existing `::fz_color_params`. */
FZ_FUNCTION const ::fz_color_params* FzColorParams::internal() const
{
	auto ret = (const ::fz_color_params*) &this->ri;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION FzColorParams::~FzColorParams()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzColorParams::s_num_instances = 0;

FZ_FUNCTION std::string FzColorParams::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool FzColorParams::operator==(const FzColorParams& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool FzColorParams::operator!=(const FzColorParams& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for FzColorspace (wrapper for fz_colorspace). */

#ifndef NDEBUG
static RefsCheck<::fz_colorspace, FzColorspace> s_FzColorspace_refs_check(offsetof(::fz_colorspace, key_storable.storable.refs), 32);
#endif

/* Constructor using `fz_new_cal_gray_colorspace()`. */
FZ_FUNCTION FzColorspace::FzColorspace(float wp[3], float bp[3], float gamma)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_cal_gray_colorspace()\n";
	}
	#endif
	this->m_internal = ll_fz_new_cal_gray_colorspace(wp, bp, gamma);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_cal_rgb_colorspace()`. */
FZ_FUNCTION FzColorspace::FzColorspace(float wp[3], float bp[3], float gamma[3], float matrix[9])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_cal_rgb_colorspace()\n";
	}
	#endif
	this->m_internal = ll_fz_new_cal_rgb_colorspace(wp, bp, gamma, matrix);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_colorspace()`. */
FZ_FUNCTION FzColorspace::FzColorspace(enum fz_colorspace_type type, int flags, int n, const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_colorspace()\n";
	}
	#endif
	this->m_internal = ll_fz_new_colorspace(type, flags, n, name);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_icc_colorspace()`. */
FZ_FUNCTION FzColorspace::FzColorspace(enum fz_colorspace_type type, int flags, const char *name, const FzBuffer& buf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_icc_colorspace()\n";
	}
	#endif
	this->m_internal = ll_fz_new_icc_colorspace(type, flags, name, buf.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_indexed_colorspace()`. */
FZ_FUNCTION FzColorspace::FzColorspace(const FzColorspace& base, int high, unsigned char *lookup)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_indexed_colorspace()\n";
	}
	#endif
	this->m_internal = ll_fz_new_indexed_colorspace(base.m_internal, high, lookup);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION FzColorspace::FzColorspace(Fixed fixed)
{
	if (0) {}
	else if ( fixed == Fixed_GRAY)  m_internal = ll_fz_device_gray();
	else if ( fixed == Fixed_RGB)   m_internal = ll_fz_device_rgb();
	else if ( fixed == Fixed_BGR)   m_internal = ll_fz_device_bgr();
	else if ( fixed == Fixed_CMYK)  m_internal = ll_fz_device_cmyk();
	else if ( fixed == Fixed_LAB)   m_internal = ll_fz_device_lab();
	else {
		std::string message = "Unrecognised fixed colorspace id";
		throw FzErrorGeneric(message.c_str());
	}
	ll_fz_keep_colorspace(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_colorspace()`. */
FZ_FUNCTION FzColorspace::FzColorspace(const FzColorspace& rhs)
: m_internal(ll_fz_keep_colorspace(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_colorspace(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_colorspace()` and `fz_drop_colorspace()`. */
FZ_FUNCTION FzColorspace& FzColorspace::operator=(const FzColorspace& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_colorspace(this->m_internal)"
				<< " and ll_fz_keep_colorspace(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_colorspace(this->m_internal);
	ll_fz_keep_colorspace(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzColorspace::FzColorspace()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_base_colorspace()`.  */
FZ_FUNCTION FzColorspace FzColorspace::fz_base_colorspace() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_base_colorspace()\n";
	}
	#endif
	auto ret = mupdf::fz_base_colorspace(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_clamp_color()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_clamp_color(const float *in)` => float out
	 */
FZ_FUNCTION void FzColorspace::fz_clamp_color(const float *in, float *out) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clamp_color()\n";
	}
	#endif
	mupdf::fz_clamp_color(*this, in, out);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_colorspace_colorant()`.  */
FZ_FUNCTION const char *FzColorspace::fz_colorspace_colorant(int n) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_colorant()\n";
	}
	#endif
	auto ret = mupdf::fz_colorspace_colorant(*this, n);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_colorspace_device_n_has_cmyk()`.  */
FZ_FUNCTION int FzColorspace::fz_colorspace_device_n_has_cmyk() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_device_n_has_cmyk()\n";
	}
	#endif
	auto ret = mupdf::fz_colorspace_device_n_has_cmyk(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_colorspace_device_n_has_only_cmyk()`.  */
FZ_FUNCTION int FzColorspace::fz_colorspace_device_n_has_only_cmyk() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_device_n_has_only_cmyk()\n";
	}
	#endif
	auto ret = mupdf::fz_colorspace_device_n_has_only_cmyk(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_colorspace_is_cmyk()`.  */
FZ_FUNCTION int FzColorspace::fz_colorspace_is_cmyk() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_cmyk()\n";
	}
	#endif
	auto ret = mupdf::fz_colorspace_is_cmyk(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_colorspace_is_device()`.  */
FZ_FUNCTION int FzColorspace::fz_colorspace_is_device() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_device()\n";
	}
	#endif
	auto ret = mupdf::fz_colorspace_is_device(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_colorspace_is_device_cmyk()`.  */
FZ_FUNCTION int FzColorspace::fz_colorspace_is_device_cmyk() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_device_cmyk()\n";
	}
	#endif
	auto ret = mupdf::fz_colorspace_is_device_cmyk(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_colorspace_is_device_gray()`.  */
FZ_FUNCTION int FzColorspace::fz_colorspace_is_device_gray() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_device_gray()\n";
	}
	#endif
	auto ret = mupdf::fz_colorspace_is_device_gray(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_colorspace_is_device_n()`.  */
FZ_FUNCTION int FzColorspace::fz_colorspace_is_device_n() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_device_n()\n";
	}
	#endif
	auto ret = mupdf::fz_colorspace_is_device_n(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_colorspace_is_gray()`.  */
FZ_FUNCTION int FzColorspace::fz_colorspace_is_gray() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_gray()\n";
	}
	#endif
	auto ret = mupdf::fz_colorspace_is_gray(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_colorspace_is_indexed()`.  */
FZ_FUNCTION int FzColorspace::fz_colorspace_is_indexed() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_indexed()\n";
	}
	#endif
	auto ret = mupdf::fz_colorspace_is_indexed(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_colorspace_is_lab()`.  */
FZ_FUNCTION int FzColorspace::fz_colorspace_is_lab() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_lab()\n";
	}
	#endif
	auto ret = mupdf::fz_colorspace_is_lab(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_colorspace_is_lab_icc()`.  */
FZ_FUNCTION int FzColorspace::fz_colorspace_is_lab_icc() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_lab_icc()\n";
	}
	#endif
	auto ret = mupdf::fz_colorspace_is_lab_icc(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_colorspace_is_rgb()`.  */
FZ_FUNCTION int FzColorspace::fz_colorspace_is_rgb() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_rgb()\n";
	}
	#endif
	auto ret = mupdf::fz_colorspace_is_rgb(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_colorspace_is_subtractive()`.  */
FZ_FUNCTION int FzColorspace::fz_colorspace_is_subtractive() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_subtractive()\n";
	}
	#endif
	auto ret = mupdf::fz_colorspace_is_subtractive(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_colorspace_n()`.  */
FZ_FUNCTION int FzColorspace::fz_colorspace_n() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_n()\n";
	}
	#endif
	auto ret = mupdf::fz_colorspace_n(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_colorspace_name()`.  */
FZ_FUNCTION const char *FzColorspace::fz_colorspace_name() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_name()\n";
	}
	#endif
	auto ret = mupdf::fz_colorspace_name(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_colorspace_name_colorant()`.  */
FZ_FUNCTION void FzColorspace::fz_colorspace_name_colorant(int n, const char *name) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_name_colorant()\n";
	}
	#endif
	mupdf::fz_colorspace_name_colorant(*this, n, name);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_colorspace_type()`.  */
FZ_FUNCTION enum fz_colorspace_type FzColorspace::fz_colorspace_type() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_type()\n";
	}
	#endif
	auto ret = mupdf::fz_colorspace_type(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_convert_color()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_convert_color(const float *sv, ::fz_colorspace *ds, ::fz_colorspace *is, ::fz_color_params params)` => float dv
	 */
FZ_FUNCTION void FzColorspace::fz_convert_color(const float *sv, const FzColorspace& ds, float *dv, const FzColorspace& is, const FzColorParams& params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_convert_color()\n";
	}
	#endif
	mupdf::fz_convert_color(*this, sv, ds, dv, is, params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_convert_separation_colors()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_convert_separation_colors(const float *src_color, ::fz_separations *dst_seps, ::fz_colorspace *dst_cs, ::fz_color_params color_params)` => float dst_color
	 */
FZ_FUNCTION void FzColorspace::fz_convert_separation_colors(const float *src_color, const FzSeparations& dst_seps, const FzColorspace& dst_cs, float *dst_color, const FzColorParams& color_params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_convert_separation_colors()\n";
	}
	#endif
	mupdf::fz_convert_separation_colors(*this, src_color, dst_seps, dst_cs, dst_color, color_params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_is_valid_blend_colorspace()`.  */
FZ_FUNCTION int FzColorspace::fz_is_valid_blend_colorspace() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_valid_blend_colorspace()\n";
	}
	#endif
	auto ret = mupdf::fz_is_valid_blend_colorspace(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_indexed_colorspace()`.  */
FZ_FUNCTION FzColorspace FzColorspace::fz_new_indexed_colorspace(int high, unsigned char *lookup) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_indexed_colorspace()\n";
	}
	#endif
	auto ret = mupdf::fz_new_indexed_colorspace(*this, high, lookup);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_pixmap()`.  */
FZ_FUNCTION FzPixmap FzColorspace::fz_new_pixmap(int w, int h, const FzSeparations& seps, int alpha) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap()\n";
	}
	#endif
	auto ret = mupdf::fz_new_pixmap(*this, w, h, seps, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_pixmap_with_bbox()`.  */
FZ_FUNCTION FzPixmap FzColorspace::fz_new_pixmap_with_bbox(const FzIrect& bbox, const FzSeparations& seps, int alpha) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_with_bbox()\n";
	}
	#endif
	auto ret = mupdf::fz_new_pixmap_with_bbox(*this, bbox, seps, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_pixmap_with_bbox_and_data()`.  */
FZ_FUNCTION FzPixmap FzColorspace::fz_new_pixmap_with_bbox_and_data(const FzIrect& rect, const FzSeparations& seps, int alpha, unsigned char *samples) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_with_bbox_and_data()\n";
	}
	#endif
	auto ret = mupdf::fz_new_pixmap_with_bbox_and_data(*this, rect, seps, alpha, samples);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_pixmap_with_data()`.  */
FZ_FUNCTION FzPixmap FzColorspace::fz_new_pixmap_with_data(int w, int h, const FzSeparations& seps, int alpha, int stride, unsigned char *samples) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_with_data()\n";
	}
	#endif
	auto ret = mupdf::fz_new_pixmap_with_data(*this, w, h, seps, alpha, stride, samples);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_is_tint_colorspace()`.  */
FZ_FUNCTION int FzColorspace::pdf_is_tint_colorspace() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_tint_colorspace()\n";
	}
	#endif
	auto ret = mupdf::pdf_is_tint_colorspace(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

FZ_FUNCTION FzColorspace::FzColorspace(::fz_colorspace* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzColorspace::~FzColorspace()
{
	ll_fz_drop_colorspace(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzColorspace_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzColorspace::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzColorspace::s_num_instances = 0;


/* Implementation of methods for FzColorspaceContext (wrapper for fz_colorspace_context). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzColorspaceContext::FzColorspaceContext()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzColorspaceContext::FzColorspaceContext(::fz_colorspace_context* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzColorspaceContext::~FzColorspaceContext()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzColorspaceContext::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzColorspaceContext::s_num_instances = 0;


/* Implementation of methods for FzCompressedBuffer (wrapper for fz_compressed_buffer). */

#ifndef NDEBUG
static RefsCheck<::fz_compressed_buffer, FzCompressedBuffer> s_FzCompressedBuffer_refs_check(offsetof(::fz_compressed_buffer, refs), 32);
#endif

/* Constructor using `fz_new_compressed_buffer()`. */
FZ_FUNCTION FzCompressedBuffer::FzCompressedBuffer()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_compressed_buffer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_compressed_buffer();
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzCompressedBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_compressed_buffer()`. */
FZ_FUNCTION FzCompressedBuffer::FzCompressedBuffer(const FzCompressedBuffer& rhs)
: m_internal(ll_fz_keep_compressed_buffer(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_compressed_buffer(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzCompressedBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_compressed_buffer()` and `fz_drop_compressed_buffer()`. */
FZ_FUNCTION FzCompressedBuffer& FzCompressedBuffer::operator=(const FzCompressedBuffer& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_compressed_buffer(this->m_internal)"
				<< " and ll_fz_keep_compressed_buffer(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_compressed_buffer(this->m_internal);
	ll_fz_keep_compressed_buffer(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzCompressedBuffer_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzCompressedBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/* Class-aware wrapper for `::fz_compressed_buffer_size()`.  */
FZ_FUNCTION size_t FzCompressedBuffer::fz_compressed_buffer_size() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_compressed_buffer_size()\n";
	}
	#endif
	auto ret = mupdf::fz_compressed_buffer_size(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzCompressedBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_compressed_buffer()`.  */
FZ_FUNCTION FzStream FzCompressedBuffer::fz_open_compressed_buffer() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_compressed_buffer()\n";
	}
	#endif
	auto ret = mupdf::fz_open_compressed_buffer(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzCompressedBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_image_decomp_stream_from_buffer()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_open_image_decomp_stream_from_buffer()` => `(fz_stream *, int l2factor)`
	 */
FZ_FUNCTION FzStream FzCompressedBuffer::fz_open_image_decomp_stream_from_buffer(int *l2factor) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_image_decomp_stream_from_buffer()\n";
	}
	#endif
	auto ret = mupdf::fz_open_image_decomp_stream_from_buffer(*this, l2factor);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzCompressedBuffer_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/** Custom method. */
FZ_FUNCTION FzBuffer FzCompressedBuffer::get_buffer()
{
	return FzBuffer(
			ll_fz_keep_buffer(m_internal->buffer)
			);
}

FZ_FUNCTION FzCompressedBuffer::FzCompressedBuffer(::fz_compressed_buffer* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzCompressedBuffer_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzCompressedBuffer::~FzCompressedBuffer()
{
	ll_fz_drop_compressed_buffer(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzCompressedBuffer_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzCompressedBuffer::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzCompressedBuffer::s_num_instances = 0;


/* Implementation of methods for FzCompressedImage (wrapper for fz_compressed_image). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzCompressedImage::FzCompressedImage()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_set_compressed_image_buffer()`.  */
FZ_FUNCTION void FzCompressedImage::fz_set_compressed_image_buffer(const FzCompressedBuffer& buf) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_compressed_image_buffer()\n";
	}
	#endif
	mupdf::fz_set_compressed_image_buffer(*this, buf);
}

FZ_FUNCTION FzCompressedImage::FzCompressedImage(::fz_compressed_image* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzCompressedImage::~FzCompressedImage()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzCompressedImage::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzCompressedImage::s_num_instances = 0;


/* Implementation of methods for FzCompressionParams (wrapper for fz_compression_params). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzCompressionParams::FzCompressionParams()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzCompressionParams::FzCompressionParams(::fz_compression_params* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzCompressionParams::~FzCompressionParams()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzCompressionParams::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzCompressionParams::s_num_instances = 0;


/* Implementation of methods for FzContext (wrapper for fz_context). */

/* Constructor using `fz_new_context_imp()`. */
FZ_FUNCTION FzContext::FzContext(const FzAllocContext& alloc, const FzLocksContext& locks, size_t max_store, const char *version)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_context_imp()\n";
	}
	#endif
	this->m_internal = ll_fz_new_context_imp(alloc.m_internal, locks.m_internal, max_store, version);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzContext::FzContext()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzContext::FzContext(::fz_context* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzContext::~FzContext()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzContext::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzContext::s_num_instances = 0;


/* Implementation of methods for FzCookie (wrapper for fz_cookie). */

/** Custom constructor. */
FZ_FUNCTION FzCookie::FzCookie()
{
	this->m_internal.abort = 0;
	this->m_internal.progress = 0;
	this->m_internal.progress_max = (size_t) -1;
	this->m_internal.errors = 0;
	this->m_internal.incomplete = 0;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION void FzCookie::set_abort(){ m_internal.abort = 1; }

/** Custom method. */
FZ_FUNCTION void FzCookie::increment_errors(int delta){ m_internal.errors += delta; }

FZ_FUNCTION int FzCookie::abort()
{
	return m_internal.abort;
}

FZ_FUNCTION int FzCookie::progress()
{
	return m_internal.progress;
}

FZ_FUNCTION size_t FzCookie::progress_max()
{
	return m_internal.progress_max;
}

FZ_FUNCTION int FzCookie::errors()
{
	return m_internal.errors;
}

FZ_FUNCTION int FzCookie::incomplete()
{
	return m_internal.incomplete;
}

#ifndef NDEBUG
FZ_FUNCTION FzCookie::~FzCookie()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzCookie::s_num_instances = 0;

FZ_FUNCTION std::string FzCookie::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool FzCookie::operator==(const FzCookie& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool FzCookie::operator!=(const FzCookie& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for FzDefaultColorspaces (wrapper for fz_default_colorspaces). */

#ifndef NDEBUG
static RefsCheck<::fz_default_colorspaces, FzDefaultColorspaces> s_FzDefaultColorspaces_refs_check(offsetof(::fz_default_colorspaces, refs), 32);
#endif

/* Constructor using `fz_new_default_colorspaces()`. */
FZ_FUNCTION FzDefaultColorspaces::FzDefaultColorspaces()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_default_colorspaces()\n";
	}
	#endif
	this->m_internal = ll_fz_new_default_colorspaces();
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDefaultColorspaces_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_default_colorspaces()`. */
FZ_FUNCTION FzDefaultColorspaces::FzDefaultColorspaces(const FzDefaultColorspaces& rhs)
: m_internal(ll_fz_keep_default_colorspaces(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_default_colorspaces(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDefaultColorspaces_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_default_colorspaces()` and `fz_drop_default_colorspaces()`. */
FZ_FUNCTION FzDefaultColorspaces& FzDefaultColorspaces::operator=(const FzDefaultColorspaces& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_default_colorspaces(this->m_internal)"
				<< " and ll_fz_keep_default_colorspaces(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_default_colorspaces(this->m_internal);
	ll_fz_keep_default_colorspaces(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDefaultColorspaces_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDefaultColorspaces_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/* Class-aware wrapper for `::fz_clone_default_colorspaces()`.  */
FZ_FUNCTION FzDefaultColorspaces FzDefaultColorspaces::fz_clone_default_colorspaces() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clone_default_colorspaces()\n";
	}
	#endif
	auto ret = mupdf::fz_clone_default_colorspaces(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDefaultColorspaces_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_default_cmyk()`.  */
FZ_FUNCTION FzColorspace FzDefaultColorspaces::fz_default_cmyk() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_default_cmyk()\n";
	}
	#endif
	auto ret = mupdf::fz_default_cmyk(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDefaultColorspaces_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_default_gray()`.  */
FZ_FUNCTION FzColorspace FzDefaultColorspaces::fz_default_gray() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_default_gray()\n";
	}
	#endif
	auto ret = mupdf::fz_default_gray(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDefaultColorspaces_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_default_output_intent()`.  */
FZ_FUNCTION FzColorspace FzDefaultColorspaces::fz_default_output_intent() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_default_output_intent()\n";
	}
	#endif
	auto ret = mupdf::fz_default_output_intent(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDefaultColorspaces_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_default_rgb()`.  */
FZ_FUNCTION FzColorspace FzDefaultColorspaces::fz_default_rgb() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_default_rgb()\n";
	}
	#endif
	auto ret = mupdf::fz_default_rgb(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDefaultColorspaces_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_set_default_cmyk()`.  */
FZ_FUNCTION void FzDefaultColorspaces::fz_set_default_cmyk(const FzColorspace& cs) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_default_cmyk()\n";
	}
	#endif
	mupdf::fz_set_default_cmyk(*this, cs);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDefaultColorspaces_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_set_default_gray()`.  */
FZ_FUNCTION void FzDefaultColorspaces::fz_set_default_gray(const FzColorspace& cs) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_default_gray()\n";
	}
	#endif
	mupdf::fz_set_default_gray(*this, cs);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDefaultColorspaces_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_set_default_output_intent()`.  */
FZ_FUNCTION void FzDefaultColorspaces::fz_set_default_output_intent(const FzColorspace& cs) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_default_output_intent()\n";
	}
	#endif
	mupdf::fz_set_default_output_intent(*this, cs);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDefaultColorspaces_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_set_default_rgb()`.  */
FZ_FUNCTION void FzDefaultColorspaces::fz_set_default_rgb(const FzColorspace& cs) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_default_rgb()\n";
	}
	#endif
	mupdf::fz_set_default_rgb(*this, cs);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDefaultColorspaces_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_update_default_colorspaces()`.  */
FZ_FUNCTION FzDefaultColorspaces FzDefaultColorspaces::pdf_update_default_colorspaces(const PdfObj& res) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_update_default_colorspaces()\n";
	}
	#endif
	auto ret = mupdf::pdf_update_default_colorspaces(*this, res);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDefaultColorspaces_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

FZ_FUNCTION FzDefaultColorspaces::FzDefaultColorspaces(::fz_default_colorspaces* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDefaultColorspaces_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzDefaultColorspaces::~FzDefaultColorspaces()
{
	ll_fz_drop_default_colorspaces(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDefaultColorspaces_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzDefaultColorspaces::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzDefaultColorspaces::s_num_instances = 0;


/* Implementation of methods for FzDevice (wrapper for fz_device). */

#ifndef NDEBUG
static RefsCheck<::fz_device, FzDevice> s_FzDevice_refs_check(offsetof(::fz_device, refs), 32);
#endif

/* Constructor using `fz_new_bbox_device()`. */
FZ_FUNCTION FzDevice::FzDevice(FzRect& rectp)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_bbox_device()\n";
	}
	#endif
	this->m_internal = ll_fz_new_bbox_device( rectp.internal());
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_device_of_size()`. */
FZ_FUNCTION FzDevice::FzDevice(int size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_device_of_size()\n";
	}
	#endif
	this->m_internal = ll_fz_new_device_of_size(size);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_draw_device()`. */
FZ_FUNCTION FzDevice::FzDevice(const FzMatrix& transform, const FzPixmap& dest)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_draw_device()\n";
	}
	#endif
	this->m_internal = ll_fz_new_draw_device(* transform.internal(), dest.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_draw_device_with_bbox()`. */
FZ_FUNCTION FzDevice::FzDevice(const FzMatrix& transform, const FzPixmap& dest, FzIrect& clip)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_draw_device_with_bbox()\n";
	}
	#endif
	this->m_internal = ll_fz_new_draw_device_with_bbox(* transform.internal(), dest.m_internal,  clip.internal());
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_draw_device_with_bbox_proof()`. */
FZ_FUNCTION FzDevice::FzDevice(const FzMatrix& transform, const FzPixmap& dest, FzIrect& clip, const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_draw_device_with_bbox_proof()\n";
	}
	#endif
	this->m_internal = ll_fz_new_draw_device_with_bbox_proof(* transform.internal(), dest.m_internal,  clip.internal(), cs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_draw_device_with_options()`. */
FZ_FUNCTION FzDevice::FzDevice(FzDrawOptions& options, const FzRect& mediabox, FzPixmap& pixmap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_draw_device_with_options()\n";
	}
	#endif
	/* Out-param pixmap.m_internal will be overwritten. */
	ll_fz_drop_pixmap(pixmap.m_internal);
	pixmap.m_internal = nullptr;
	this->m_internal = ll_fz_new_draw_device_with_options( options.internal(), * mediabox.internal(), &pixmap.m_internal);
	/* We assume that out-param pixmap.m_internal is a kept reference. */
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_draw_device_with_proof()`. */
FZ_FUNCTION FzDevice::FzDevice(const FzMatrix& transform, const FzPixmap& dest, const FzColorspace& proof_cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_draw_device_with_proof()\n";
	}
	#endif
	this->m_internal = ll_fz_new_draw_device_with_proof(* transform.internal(), dest.m_internal, proof_cs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_list_device()`. */
FZ_FUNCTION FzDevice::FzDevice(const FzDisplayList& list)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_list_device()\n";
	}
	#endif
	this->m_internal = ll_fz_new_list_device(list.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_ocr_device()`. */
FZ_FUNCTION FzDevice::FzDevice(const FzDevice& target, const FzMatrix& ctm, const FzRect& mediabox, int with_list, const char *language, const char *datadir, int (*progress)(::fz_context *, void *, int ), void *progress_arg)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_ocr_device()\n";
	}
	#endif
	this->m_internal = ll_fz_new_ocr_device(target.m_internal, * ctm.internal(), * mediabox.internal(), with_list, language, datadir, progress, progress_arg);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_stext_device()`. */
FZ_FUNCTION FzDevice::FzDevice(const FzStextPage& page, FzStextOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_stext_device()\n";
	}
	#endif
	this->m_internal = ll_fz_new_stext_device(page.m_internal,  options.internal());
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_svg_device()`. */
FZ_FUNCTION FzDevice::FzDevice(const FzOutput& out, float page_width, float page_height, int text_format, int reuse_images)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_svg_device()\n";
	}
	#endif
	this->m_internal = ll_fz_new_svg_device(out.m_internal, page_width, page_height, text_format, reuse_images);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_svg_device_with_id()`. */
FZ_FUNCTION FzDevice::FzDevice(const FzOutput& out, float page_width, float page_height, int text_format, int reuse_images, int *id)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_svg_device_with_id()\n";
	}
	#endif
	this->m_internal = ll_fz_new_svg_device_with_id(out.m_internal, page_width, page_height, text_format, reuse_images, id);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_test_device()`. */
FZ_FUNCTION FzDevice::FzDevice(int *is_color, float threshold, int options, const FzDevice& passthrough)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_test_device()\n";
	}
	#endif
	this->m_internal = ll_fz_new_test_device(is_color, threshold, options, passthrough.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_trace_device()`. */
FZ_FUNCTION FzDevice::FzDevice(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_trace_device()\n";
	}
	#endif
	this->m_internal = ll_fz_new_trace_device(out.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_pdf_device()`. */
FZ_FUNCTION FzDevice::FzDevice(const PdfDocument& doc, const FzMatrix& topctm, const PdfObj& resources, const FzBuffer& contents)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_pdf_device()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_pdf_device(doc.m_internal, * topctm.internal(), resources.m_internal, contents.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_device()`. */
FZ_FUNCTION FzDevice::FzDevice(const FzDevice& rhs)
: m_internal(ll_fz_keep_device(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_device(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_device()` and `fz_drop_device()`. */
FZ_FUNCTION FzDevice& FzDevice::operator=(const FzDevice& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_device(this->m_internal)"
				<< " and ll_fz_keep_device(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_device(this->m_internal);
	ll_fz_keep_device(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzDevice::FzDevice()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_new_xmltext_device()`.  */
FZ_FUNCTION FzDevice FzDevice::fz_new_xmltext_device(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_xmltext_device()\n";
	}
	#endif
	auto ret = mupdf::fz_new_xmltext_device(out);
	return ret;
}

/* Class-aware wrapper for `::fz_new_draw_device_type3()`.  */
FZ_FUNCTION FzDevice FzDevice::fz_new_draw_device_type3(const FzMatrix& transform, const FzPixmap& dest)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_draw_device_type3()\n";
	}
	#endif
	auto ret = mupdf::fz_new_draw_device_type3(transform, dest);
	return ret;
}

/* Class-aware wrapper for `::fz_begin_group()`.  */
FZ_FUNCTION void FzDevice::fz_begin_group(const FzRect& area, const FzColorspace& cs, int isolated, int knockout, int blendmode, float alpha) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_begin_group()\n";
	}
	#endif
	mupdf::fz_begin_group(*this, area, cs, isolated, knockout, blendmode, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_begin_layer()`.  */
FZ_FUNCTION void FzDevice::fz_begin_layer(const char *layer_name) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_begin_layer()\n";
	}
	#endif
	mupdf::fz_begin_layer(*this, layer_name);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_begin_mask()`.  */
FZ_FUNCTION void FzDevice::fz_begin_mask(const FzRect& area, int luminosity, const FzColorspace& colorspace, const float *bc, const FzColorParams& color_params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_begin_mask()\n";
	}
	#endif
	mupdf::fz_begin_mask(*this, area, luminosity, colorspace, bc, color_params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_begin_metatext()`.  */
FZ_FUNCTION void FzDevice::fz_begin_metatext(::fz_metatext meta, const char *text) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_begin_metatext()\n";
	}
	#endif
	mupdf::fz_begin_metatext(*this, meta, text);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_begin_structure()`.  */
FZ_FUNCTION void FzDevice::fz_begin_structure(::fz_structure standard, const char *raw, int idx) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_begin_structure()\n";
	}
	#endif
	mupdf::fz_begin_structure(*this, standard, raw, idx);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_begin_tile()`.  */
FZ_FUNCTION void FzDevice::fz_begin_tile(const FzRect& area, const FzRect& view, float xstep, float ystep, const FzMatrix& ctm) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_begin_tile()\n";
	}
	#endif
	mupdf::fz_begin_tile(*this, area, view, xstep, ystep, ctm);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_begin_tile_id()`.  */
FZ_FUNCTION int FzDevice::fz_begin_tile_id(const FzRect& area, const FzRect& view, float xstep, float ystep, const FzMatrix& ctm, int id) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_begin_tile_id()\n";
	}
	#endif
	auto ret = mupdf::fz_begin_tile_id(*this, area, view, xstep, ystep, ctm, id);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_clip_image_mask()`.  */
FZ_FUNCTION void FzDevice::fz_clip_image_mask(const FzImage& image, const FzMatrix& ctm, const FzRect& scissor) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clip_image_mask()\n";
	}
	#endif
	mupdf::fz_clip_image_mask(*this, image, ctm, scissor);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_clip_path()`.  */
FZ_FUNCTION void FzDevice::fz_clip_path(const FzPath& path, int even_odd, const FzMatrix& ctm, const FzRect& scissor) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clip_path()\n";
	}
	#endif
	mupdf::fz_clip_path(*this, path, even_odd, ctm, scissor);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_clip_stroke_path()`.  */
FZ_FUNCTION void FzDevice::fz_clip_stroke_path(const FzPath& path, const FzStrokeState& stroke, const FzMatrix& ctm, const FzRect& scissor) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clip_stroke_path()\n";
	}
	#endif
	mupdf::fz_clip_stroke_path(*this, path, stroke, ctm, scissor);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_clip_stroke_text()`.  */
FZ_FUNCTION void FzDevice::fz_clip_stroke_text(const FzText& text, const FzStrokeState& stroke, const FzMatrix& ctm, const FzRect& scissor) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clip_stroke_text()\n";
	}
	#endif
	mupdf::fz_clip_stroke_text(*this, text, stroke, ctm, scissor);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_clip_text()`.  */
FZ_FUNCTION void FzDevice::fz_clip_text(const FzText& text, const FzMatrix& ctm, const FzRect& scissor) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clip_text()\n";
	}
	#endif
	mupdf::fz_clip_text(*this, text, ctm, scissor);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_close_device()`.  */
FZ_FUNCTION void FzDevice::fz_close_device() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_close_device()\n";
	}
	#endif
	mupdf::fz_close_device(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_device_current_scissor()`.  */
FZ_FUNCTION FzRect FzDevice::fz_device_current_scissor() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_device_current_scissor()\n";
	}
	#endif
	auto ret = mupdf::fz_device_current_scissor(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_disable_device_hints()`.  */
FZ_FUNCTION void FzDevice::fz_disable_device_hints(int hints) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_disable_device_hints()\n";
	}
	#endif
	mupdf::fz_disable_device_hints(*this, hints);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_enable_device_hints()`.  */
FZ_FUNCTION void FzDevice::fz_enable_device_hints(int hints) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_enable_device_hints()\n";
	}
	#endif
	mupdf::fz_enable_device_hints(*this, hints);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_end_group()`.  */
FZ_FUNCTION void FzDevice::fz_end_group() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_end_group()\n";
	}
	#endif
	mupdf::fz_end_group(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_end_layer()`.  */
FZ_FUNCTION void FzDevice::fz_end_layer() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_end_layer()\n";
	}
	#endif
	mupdf::fz_end_layer(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_end_mask()`.  */
FZ_FUNCTION void FzDevice::fz_end_mask() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_end_mask()\n";
	}
	#endif
	mupdf::fz_end_mask(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_end_mask_tr()`.  */
FZ_FUNCTION void FzDevice::fz_end_mask_tr(const FzFunction& fn) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_end_mask_tr()\n";
	}
	#endif
	mupdf::fz_end_mask_tr(*this, fn);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_end_metatext()`.  */
FZ_FUNCTION void FzDevice::fz_end_metatext() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_end_metatext()\n";
	}
	#endif
	mupdf::fz_end_metatext(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_end_structure()`.  */
FZ_FUNCTION void FzDevice::fz_end_structure() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_end_structure()\n";
	}
	#endif
	mupdf::fz_end_structure(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_end_tile()`.  */
FZ_FUNCTION void FzDevice::fz_end_tile() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_end_tile()\n";
	}
	#endif
	mupdf::fz_end_tile(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_fill_image()`.  */
FZ_FUNCTION void FzDevice::fz_fill_image(const FzImage& image, const FzMatrix& ctm, float alpha, const FzColorParams& color_params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_fill_image()\n";
	}
	#endif
	mupdf::fz_fill_image(*this, image, ctm, alpha, color_params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_fill_image_mask()`.  */
FZ_FUNCTION void FzDevice::fz_fill_image_mask(const FzImage& image, const FzMatrix& ctm, const FzColorspace& colorspace, const float *color, float alpha, const FzColorParams& color_params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_fill_image_mask()\n";
	}
	#endif
	mupdf::fz_fill_image_mask(*this, image, ctm, colorspace, color, alpha, color_params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_fill_path()`.  */
FZ_FUNCTION void FzDevice::fz_fill_path(const FzPath& path, int even_odd, const FzMatrix& ctm, const FzColorspace& colorspace, const float *color, float alpha, const FzColorParams& color_params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_fill_path()\n";
	}
	#endif
	mupdf::fz_fill_path(*this, path, even_odd, ctm, colorspace, color, alpha, color_params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_fill_shade()`.  */
FZ_FUNCTION void FzDevice::fz_fill_shade(const FzShade& shade, const FzMatrix& ctm, float alpha, const FzColorParams& color_params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_fill_shade()\n";
	}
	#endif
	mupdf::fz_fill_shade(*this, shade, ctm, alpha, color_params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_fill_text()`.  */
FZ_FUNCTION void FzDevice::fz_fill_text(const FzText& text, const FzMatrix& ctm, const FzColorspace& colorspace, const float *color, float alpha, const FzColorParams& color_params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_fill_text()\n";
	}
	#endif
	mupdf::fz_fill_text(*this, text, ctm, colorspace, color, alpha, color_params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_ignore_text()`.  */
FZ_FUNCTION void FzDevice::fz_ignore_text(const FzText& text, const FzMatrix& ctm) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_ignore_text()\n";
	}
	#endif
	mupdf::fz_ignore_text(*this, text, ctm);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_new_ocr_device()`.  */
FZ_FUNCTION FzDevice FzDevice::fz_new_ocr_device(const FzMatrix& ctm, const FzRect& mediabox, int with_list, const char *language, const char *datadir, int (*progress)(::fz_context *, void *, int ), void *progress_arg) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_ocr_device()\n";
	}
	#endif
	auto ret = mupdf::fz_new_ocr_device(*this, ctm, mediabox, with_list, language, datadir, progress, progress_arg);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_pop_clip()`.  */
FZ_FUNCTION void FzDevice::fz_pop_clip() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pop_clip()\n";
	}
	#endif
	mupdf::fz_pop_clip(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_render_flags()`.  */
FZ_FUNCTION void FzDevice::fz_render_flags(int set, int clear) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_render_flags()\n";
	}
	#endif
	mupdf::fz_render_flags(*this, set, clear);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_render_t3_glyph_direct()`.  */
FZ_FUNCTION void FzDevice::fz_render_t3_glyph_direct(const FzFont& font, int gid, const FzMatrix& trm, void *gstate, const FzDefaultColorspaces& def_cs) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_render_t3_glyph_direct()\n";
	}
	#endif
	mupdf::fz_render_t3_glyph_direct(*this, font, gid, trm, gstate, def_cs);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_set_default_colorspaces()`.  */
FZ_FUNCTION void FzDevice::fz_set_default_colorspaces(const FzDefaultColorspaces& default_cs) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_default_colorspaces()\n";
	}
	#endif
	mupdf::fz_set_default_colorspaces(*this, default_cs);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_stroke_path()`.  */
FZ_FUNCTION void FzDevice::fz_stroke_path(const FzPath& path, const FzStrokeState& stroke, const FzMatrix& ctm, const FzColorspace& colorspace, const float *color, float alpha, const FzColorParams& color_params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_stroke_path()\n";
	}
	#endif
	mupdf::fz_stroke_path(*this, path, stroke, ctm, colorspace, color, alpha, color_params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_stroke_text()`.  */
FZ_FUNCTION void FzDevice::fz_stroke_text(const FzText& text, const FzStrokeState& stroke, const FzMatrix& ctm, const FzColorspace& colorspace, const float *color, float alpha, const FzColorParams& color_params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_stroke_text()\n";
	}
	#endif
	mupdf::fz_stroke_text(*this, text, stroke, ctm, colorspace, color, alpha, color_params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

FZ_FUNCTION FzDevice::FzDevice(::fz_device* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzDevice::~FzDevice()
{
	ll_fz_drop_device(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDevice_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzDevice::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzDevice::s_num_instances = 0;

/* Implementation of methods for `FzDevice2`, virtual_fnptrs wrapper for `fz_device`). */


FZ_FUNCTION FzDevice2::FzDevice2()
{

	
	m_internal = ll_fz_new_device_of_size(
			sizeof(*m_internal) + sizeof(FzDevice2*)
			);
	*((FzDevice2**) (m_internal + 1)) = this;
	
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::FzDevice2(): this=" << this << "\n";
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::FzDevice2(): m_internal=" << m_internal << "\n";
		FzDevice2* self = (*(FzDevice2**) (m_internal + 1));
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::FzDevice2(): self=" << self << "\n";
	}
	#endif
}
/* Static callback, calls self->close_device(). */
static void FzDevice2_s_close_device(::fz_context *arg_0, ::fz_device *arg_1)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_close_device(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->close_device(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_close_device(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->drop_device(). */
static void FzDevice2_s_drop_device(::fz_context *arg_0, ::fz_device *arg_1)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_drop_device(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->drop_device(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_drop_device(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->fill_path(). */
static void FzDevice2_s_fill_path(::fz_context *arg_0, ::fz_device *arg_1, const ::fz_path *arg_2, int arg_3, ::fz_matrix arg_4, ::fz_colorspace *arg_5, const float *arg_6, float arg_7, ::fz_color_params arg_8)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_fill_path(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->fill_path(arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_fill_path(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->stroke_path(). */
static void FzDevice2_s_stroke_path(::fz_context *arg_0, ::fz_device *arg_1, const ::fz_path *arg_2, const ::fz_stroke_state *arg_3, ::fz_matrix arg_4, ::fz_colorspace *arg_5, const float *arg_6, float arg_7, ::fz_color_params arg_8)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_stroke_path(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->stroke_path(arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_stroke_path(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->clip_path(). */
static void FzDevice2_s_clip_path(::fz_context *arg_0, ::fz_device *arg_1, const ::fz_path *arg_2, int arg_3, ::fz_matrix arg_4, ::fz_rect arg_5)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_clip_path(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->clip_path(arg_0, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_clip_path(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->clip_stroke_path(). */
static void FzDevice2_s_clip_stroke_path(::fz_context *arg_0, ::fz_device *arg_1, const ::fz_path *arg_2, const ::fz_stroke_state *arg_3, ::fz_matrix arg_4, ::fz_rect arg_5)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_clip_stroke_path(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->clip_stroke_path(arg_0, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_clip_stroke_path(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->fill_text(). */
static void FzDevice2_s_fill_text(::fz_context *arg_0, ::fz_device *arg_1, const ::fz_text *arg_2, ::fz_matrix arg_3, ::fz_colorspace *arg_4, const float *arg_5, float arg_6, ::fz_color_params arg_7)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_fill_text(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->fill_text(arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_fill_text(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->stroke_text(). */
static void FzDevice2_s_stroke_text(::fz_context *arg_0, ::fz_device *arg_1, const ::fz_text *arg_2, const ::fz_stroke_state *arg_3, ::fz_matrix arg_4, ::fz_colorspace *arg_5, const float *arg_6, float arg_7, ::fz_color_params arg_8)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_stroke_text(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->stroke_text(arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_stroke_text(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->clip_text(). */
static void FzDevice2_s_clip_text(::fz_context *arg_0, ::fz_device *arg_1, const ::fz_text *arg_2, ::fz_matrix arg_3, ::fz_rect arg_4)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_clip_text(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->clip_text(arg_0, arg_2, arg_3, arg_4);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_clip_text(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->clip_stroke_text(). */
static void FzDevice2_s_clip_stroke_text(::fz_context *arg_0, ::fz_device *arg_1, const ::fz_text *arg_2, const ::fz_stroke_state *arg_3, ::fz_matrix arg_4, ::fz_rect arg_5)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_clip_stroke_text(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->clip_stroke_text(arg_0, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_clip_stroke_text(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->ignore_text(). */
static void FzDevice2_s_ignore_text(::fz_context *arg_0, ::fz_device *arg_1, const ::fz_text *arg_2, ::fz_matrix arg_3)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_ignore_text(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->ignore_text(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_ignore_text(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->fill_shade(). */
static void FzDevice2_s_fill_shade(::fz_context *arg_0, ::fz_device *arg_1, ::fz_shade *arg_2, ::fz_matrix arg_3, float arg_4, ::fz_color_params arg_5)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_fill_shade(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->fill_shade(arg_0, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_fill_shade(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->fill_image(). */
static void FzDevice2_s_fill_image(::fz_context *arg_0, ::fz_device *arg_1, ::fz_image *arg_2, ::fz_matrix arg_3, float arg_4, ::fz_color_params arg_5)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_fill_image(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->fill_image(arg_0, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_fill_image(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->fill_image_mask(). */
static void FzDevice2_s_fill_image_mask(::fz_context *arg_0, ::fz_device *arg_1, ::fz_image *arg_2, ::fz_matrix arg_3, ::fz_colorspace *arg_4, const float *arg_5, float arg_6, ::fz_color_params arg_7)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_fill_image_mask(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->fill_image_mask(arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_fill_image_mask(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->clip_image_mask(). */
static void FzDevice2_s_clip_image_mask(::fz_context *arg_0, ::fz_device *arg_1, ::fz_image *arg_2, ::fz_matrix arg_3, ::fz_rect arg_4)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_clip_image_mask(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->clip_image_mask(arg_0, arg_2, arg_3, arg_4);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_clip_image_mask(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->pop_clip(). */
static void FzDevice2_s_pop_clip(::fz_context *arg_0, ::fz_device *arg_1)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_pop_clip(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->pop_clip(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_pop_clip(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->begin_mask(). */
static void FzDevice2_s_begin_mask(::fz_context *arg_0, ::fz_device *arg_1, ::fz_rect arg_2, int arg_3, ::fz_colorspace *arg_4, const float *arg_5, ::fz_color_params arg_6)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_begin_mask(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->begin_mask(arg_0, arg_2, arg_3, arg_4, arg_5, arg_6);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_begin_mask(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->end_mask(). */
static void FzDevice2_s_end_mask(::fz_context *arg_0, ::fz_device *arg_1, ::fz_function *arg_2)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_end_mask(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->end_mask(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_end_mask(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->begin_group(). */
static void FzDevice2_s_begin_group(::fz_context *arg_0, ::fz_device *arg_1, ::fz_rect arg_2, ::fz_colorspace *arg_3, int arg_4, int arg_5, int arg_6, float arg_7)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_begin_group(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->begin_group(arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_begin_group(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->end_group(). */
static void FzDevice2_s_end_group(::fz_context *arg_0, ::fz_device *arg_1)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_end_group(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->end_group(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_end_group(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->begin_tile(). */
static int FzDevice2_s_begin_tile(::fz_context *arg_0, ::fz_device *arg_1, ::fz_rect arg_2, ::fz_rect arg_3, float arg_4, float arg_5, ::fz_matrix arg_6, int arg_7)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_begin_tile(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->begin_tile(arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_begin_tile(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->end_tile(). */
static void FzDevice2_s_end_tile(::fz_context *arg_0, ::fz_device *arg_1)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_end_tile(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->end_tile(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_end_tile(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->render_flags(). */
static void FzDevice2_s_render_flags(::fz_context *arg_0, ::fz_device *arg_1, int arg_2, int arg_3)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_render_flags(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->render_flags(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_render_flags(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->set_default_colorspaces(). */
static void FzDevice2_s_set_default_colorspaces(::fz_context *arg_0, ::fz_device *arg_1, ::fz_default_colorspaces *arg_2)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_set_default_colorspaces(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->set_default_colorspaces(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_set_default_colorspaces(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->begin_layer(). */
static void FzDevice2_s_begin_layer(::fz_context *arg_0, ::fz_device *arg_1, const char *arg_2)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_begin_layer(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->begin_layer(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_begin_layer(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->end_layer(). */
static void FzDevice2_s_end_layer(::fz_context *arg_0, ::fz_device *arg_1)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_end_layer(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->end_layer(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_end_layer(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->begin_structure(). */
static void FzDevice2_s_begin_structure(::fz_context *arg_0, ::fz_device *arg_1, ::fz_structure arg_2, const char *arg_3, int arg_4)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_begin_structure(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->begin_structure(arg_0, arg_2, arg_3, arg_4);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_begin_structure(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->end_structure(). */
static void FzDevice2_s_end_structure(::fz_context *arg_0, ::fz_device *arg_1)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_end_structure(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->end_structure(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_end_structure(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->begin_metatext(). */
static void FzDevice2_s_begin_metatext(::fz_context *arg_0, ::fz_device *arg_1, ::fz_metatext arg_2, const char *arg_3)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_begin_metatext(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->begin_metatext(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_begin_metatext(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->end_metatext(). */
static void FzDevice2_s_end_metatext(::fz_context *arg_0, ::fz_device *arg_1)
{
	FzDevice2* self = (*(FzDevice2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_end_metatext(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->end_metatext(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2_s_end_metatext(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
FZ_FUNCTION void FzDevice2::use_virtual_close_device( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_close_device(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->close_device = (use) ? FzDevice2_s_close_device : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_drop_device( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_drop_device(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->drop_device = (use) ? FzDevice2_s_drop_device : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_fill_path( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_fill_path(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->fill_path = (use) ? FzDevice2_s_fill_path : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_stroke_path( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_stroke_path(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->stroke_path = (use) ? FzDevice2_s_stroke_path : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_clip_path( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_clip_path(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->clip_path = (use) ? FzDevice2_s_clip_path : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_clip_stroke_path( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_clip_stroke_path(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->clip_stroke_path = (use) ? FzDevice2_s_clip_stroke_path : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_fill_text( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_fill_text(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->fill_text = (use) ? FzDevice2_s_fill_text : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_stroke_text( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_stroke_text(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->stroke_text = (use) ? FzDevice2_s_stroke_text : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_clip_text( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_clip_text(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->clip_text = (use) ? FzDevice2_s_clip_text : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_clip_stroke_text( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_clip_stroke_text(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->clip_stroke_text = (use) ? FzDevice2_s_clip_stroke_text : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_ignore_text( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_ignore_text(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->ignore_text = (use) ? FzDevice2_s_ignore_text : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_fill_shade( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_fill_shade(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->fill_shade = (use) ? FzDevice2_s_fill_shade : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_fill_image( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_fill_image(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->fill_image = (use) ? FzDevice2_s_fill_image : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_fill_image_mask( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_fill_image_mask(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->fill_image_mask = (use) ? FzDevice2_s_fill_image_mask : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_clip_image_mask( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_clip_image_mask(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->clip_image_mask = (use) ? FzDevice2_s_clip_image_mask : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_pop_clip( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_pop_clip(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->pop_clip = (use) ? FzDevice2_s_pop_clip : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_begin_mask( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_begin_mask(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->begin_mask = (use) ? FzDevice2_s_begin_mask : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_end_mask( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_end_mask(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->end_mask = (use) ? FzDevice2_s_end_mask : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_begin_group( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_begin_group(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->begin_group = (use) ? FzDevice2_s_begin_group : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_end_group( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_end_group(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->end_group = (use) ? FzDevice2_s_end_group : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_begin_tile( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_begin_tile(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->begin_tile = (use) ? FzDevice2_s_begin_tile : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_end_tile( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_end_tile(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->end_tile = (use) ? FzDevice2_s_end_tile : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_render_flags( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_render_flags(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->render_flags = (use) ? FzDevice2_s_render_flags : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_set_default_colorspaces( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_set_default_colorspaces(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->set_default_colorspaces = (use) ? FzDevice2_s_set_default_colorspaces : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_begin_layer( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_begin_layer(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->begin_layer = (use) ? FzDevice2_s_begin_layer : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_end_layer( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_end_layer(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->end_layer = (use) ? FzDevice2_s_end_layer : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_begin_structure( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_begin_structure(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->begin_structure = (use) ? FzDevice2_s_begin_structure : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_end_structure( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_end_structure(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->end_structure = (use) ? FzDevice2_s_end_structure : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_begin_metatext( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_begin_metatext(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->begin_metatext = (use) ? FzDevice2_s_begin_metatext : nullptr;
}
FZ_FUNCTION void FzDevice2::use_virtual_end_metatext( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzDevice2::use_virtual_end_metatext(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->end_metatext = (use) ? FzDevice2_s_end_metatext : nullptr;
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::close_device(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::close_device(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::close_device()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::drop_device(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::drop_device(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::drop_device()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::fill_path(::fz_context *arg_0, const ::fz_path *arg_2, int arg_3, ::fz_matrix arg_4, ::fz_colorspace *arg_5, const float *arg_6, float arg_7, ::fz_color_params arg_8)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::fill_path(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::fill_path()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::stroke_path(::fz_context *arg_0, const ::fz_path *arg_2, const ::fz_stroke_state *arg_3, ::fz_matrix arg_4, ::fz_colorspace *arg_5, const float *arg_6, float arg_7, ::fz_color_params arg_8)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::stroke_path(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::stroke_path()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::clip_path(::fz_context *arg_0, const ::fz_path *arg_2, int arg_3, ::fz_matrix arg_4, ::fz_rect arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::clip_path(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::clip_path()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::clip_stroke_path(::fz_context *arg_0, const ::fz_path *arg_2, const ::fz_stroke_state *arg_3, ::fz_matrix arg_4, ::fz_rect arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::clip_stroke_path(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::clip_stroke_path()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::fill_text(::fz_context *arg_0, const ::fz_text *arg_2, ::fz_matrix arg_3, ::fz_colorspace *arg_4, const float *arg_5, float arg_6, ::fz_color_params arg_7)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::fill_text(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::fill_text()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::stroke_text(::fz_context *arg_0, const ::fz_text *arg_2, const ::fz_stroke_state *arg_3, ::fz_matrix arg_4, ::fz_colorspace *arg_5, const float *arg_6, float arg_7, ::fz_color_params arg_8)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::stroke_text(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::stroke_text()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::clip_text(::fz_context *arg_0, const ::fz_text *arg_2, ::fz_matrix arg_3, ::fz_rect arg_4)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::clip_text(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::clip_text()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::clip_stroke_text(::fz_context *arg_0, const ::fz_text *arg_2, const ::fz_stroke_state *arg_3, ::fz_matrix arg_4, ::fz_rect arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::clip_stroke_text(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::clip_stroke_text()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::ignore_text(::fz_context *arg_0, const ::fz_text *arg_2, ::fz_matrix arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::ignore_text(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::ignore_text()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::fill_shade(::fz_context *arg_0, ::fz_shade *arg_2, ::fz_matrix arg_3, float arg_4, ::fz_color_params arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::fill_shade(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::fill_shade()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::fill_image(::fz_context *arg_0, ::fz_image *arg_2, ::fz_matrix arg_3, float arg_4, ::fz_color_params arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::fill_image(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::fill_image()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::fill_image_mask(::fz_context *arg_0, ::fz_image *arg_2, ::fz_matrix arg_3, ::fz_colorspace *arg_4, const float *arg_5, float arg_6, ::fz_color_params arg_7)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::fill_image_mask(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::fill_image_mask()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::clip_image_mask(::fz_context *arg_0, ::fz_image *arg_2, ::fz_matrix arg_3, ::fz_rect arg_4)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::clip_image_mask(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::clip_image_mask()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::pop_clip(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::pop_clip(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::pop_clip()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::begin_mask(::fz_context *arg_0, ::fz_rect arg_2, int arg_3, ::fz_colorspace *arg_4, const float *arg_5, ::fz_color_params arg_6)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::begin_mask(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::begin_mask()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::end_mask(::fz_context *arg_0, ::fz_function *arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::end_mask(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::end_mask()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::begin_group(::fz_context *arg_0, ::fz_rect arg_2, ::fz_colorspace *arg_3, int arg_4, int arg_5, int arg_6, float arg_7)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::begin_group(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::begin_group()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::end_group(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::end_group(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::end_group()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION int FzDevice2::begin_tile(::fz_context *arg_0, ::fz_rect arg_2, ::fz_rect arg_3, float arg_4, float arg_5, ::fz_matrix arg_6, int arg_7)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::begin_tile(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::begin_tile()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::end_tile(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::end_tile(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::end_tile()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::render_flags(::fz_context *arg_0, int arg_2, int arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::render_flags(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::render_flags()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::set_default_colorspaces(::fz_context *arg_0, ::fz_default_colorspaces *arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::set_default_colorspaces(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::set_default_colorspaces()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::begin_layer(::fz_context *arg_0, const char *arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::begin_layer(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::begin_layer()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::end_layer(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::end_layer(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::end_layer()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::begin_structure(::fz_context *arg_0, ::fz_structure arg_2, const char *arg_3, int arg_4)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::begin_structure(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::begin_structure()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::end_structure(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::end_structure(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::end_structure()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::begin_metatext(::fz_context *arg_0, ::fz_metatext arg_2, const char *arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::begin_metatext(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::begin_metatext()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzDevice2::end_metatext(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::end_metatext(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzDevice2::end_metatext()");
}

/* Implementation of methods for FzDeviceContainerStack (wrapper for fz_device_container_stack). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzDeviceContainerStack::FzDeviceContainerStack()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzDeviceContainerStack::FzDeviceContainerStack(::fz_device_container_stack* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzDeviceContainerStack::~FzDeviceContainerStack()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzDeviceContainerStack::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzDeviceContainerStack::s_num_instances = 0;


/* Implementation of methods for FzDisplayList (wrapper for fz_display_list). */

#ifndef NDEBUG
static RefsCheck<::fz_display_list, FzDisplayList> s_FzDisplayList_refs_check(0, 32);
#endif

/* Constructor using `fz_new_display_list()`. */
FZ_FUNCTION FzDisplayList::FzDisplayList(const FzRect& mediabox)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_display_list()\n";
	}
	#endif
	this->m_internal = ll_fz_new_display_list(* mediabox.internal());
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_display_list_from_page()`. */
FZ_FUNCTION FzDisplayList::FzDisplayList(const FzPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_display_list_from_page()\n";
	}
	#endif
	this->m_internal = ll_fz_new_display_list_from_page(page.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_display_list_from_page_number()`. */
FZ_FUNCTION FzDisplayList::FzDisplayList(const FzDocument& doc, int number)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_display_list_from_page_number()\n";
	}
	#endif
	this->m_internal = ll_fz_new_display_list_from_page_number(doc.m_internal, number);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_display_list_from_svg()`. */
FZ_FUNCTION FzDisplayList::FzDisplayList(const FzBuffer& buf, const char *base_uri, const FzArchive& dir, float *w, float *h)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_display_list_from_svg()\n";
	}
	#endif
	this->m_internal = ll_fz_new_display_list_from_svg(buf.m_internal, base_uri, dir.m_internal, w, h);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_display_list_from_svg_xml()`. */
FZ_FUNCTION FzDisplayList::FzDisplayList(const FzXml& xmldoc, const FzXml& xml, const char *base_uri, const FzArchive& dir, float *w, float *h)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_display_list_from_svg_xml()\n";
	}
	#endif
	this->m_internal = ll_fz_new_display_list_from_svg_xml(xmldoc.m_internal, xml.m_internal, base_uri, dir.m_internal, w, h);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_display_list_from_annot()`. */
FZ_FUNCTION FzDisplayList::FzDisplayList(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_display_list_from_annot()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_display_list_from_annot(annot.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_display_list()`. */
FZ_FUNCTION FzDisplayList::FzDisplayList(const FzDisplayList& rhs)
: m_internal(ll_fz_keep_display_list(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_display_list(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_display_list()` and `fz_drop_display_list()`. */
FZ_FUNCTION FzDisplayList& FzDisplayList::operator=(const FzDisplayList& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_display_list(this->m_internal)"
				<< " and ll_fz_keep_display_list(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_display_list(this->m_internal);
	ll_fz_keep_display_list(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzDisplayList::FzDisplayList()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_new_display_list_from_page_contents()`.  */
FZ_FUNCTION FzDisplayList FzDisplayList::fz_new_display_list_from_page_contents(const FzPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_display_list_from_page_contents()\n";
	}
	#endif
	auto ret = mupdf::fz_new_display_list_from_page_contents(page);
	return ret;
}

/* Class-aware wrapper for `::fz_bound_display_list()`.  */
FZ_FUNCTION FzRect FzDisplayList::fz_bound_display_list() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_bound_display_list()\n";
	}
	#endif
	auto ret = mupdf::fz_bound_display_list(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_display_list_is_empty()`.  */
FZ_FUNCTION int FzDisplayList::fz_display_list_is_empty() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_display_list_is_empty()\n";
	}
	#endif
	auto ret = mupdf::fz_display_list_is_empty(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_fill_pixmap_from_display_list()`.  */
FZ_FUNCTION FzPixmap FzDisplayList::fz_fill_pixmap_from_display_list(const FzMatrix& ctm, const FzPixmap& pix) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_fill_pixmap_from_display_list()\n";
	}
	#endif
	auto ret = mupdf::fz_fill_pixmap_from_display_list(*this, ctm, pix);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_display_list()`.  */
FZ_FUNCTION FzBuffer FzDisplayList::fz_new_buffer_from_display_list(FzStextOptions& options) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_display_list()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_display_list(*this, options);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_list_device()`.  */
FZ_FUNCTION FzDevice FzDisplayList::fz_new_list_device() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_list_device()\n";
	}
	#endif
	auto ret = mupdf::fz_new_list_device(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_pixmap_from_display_list()`.  */
FZ_FUNCTION FzPixmap FzDisplayList::fz_new_pixmap_from_display_list(const FzMatrix& ctm, const FzColorspace& cs, int alpha) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_display_list()\n";
	}
	#endif
	auto ret = mupdf::fz_new_pixmap_from_display_list(*this, ctm, cs, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_pixmap_from_display_list_with_separations()`.  */
FZ_FUNCTION FzPixmap FzDisplayList::fz_new_pixmap_from_display_list_with_separations(const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_display_list_with_separations()\n";
	}
	#endif
	auto ret = mupdf::fz_new_pixmap_from_display_list_with_separations(*this, ctm, cs, seps, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_run_display_list()`.  */
FZ_FUNCTION void FzDisplayList::fz_run_display_list(const FzDevice& dev, const FzMatrix& ctm, const FzRect& scissor, FzCookie& cookie) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_run_display_list()\n";
	}
	#endif
	mupdf::fz_run_display_list(*this, dev, ctm, scissor, cookie);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_search_display_list()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_search_display_list(const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
	 */
FZ_FUNCTION int FzDisplayList::fz_search_display_list(const char *needle, int *hit_mark, FzQuad& hit_bbox, int hit_max) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_search_display_list()\n";
	}
	#endif
	auto ret = mupdf::fz_search_display_list(*this, needle, hit_mark, hit_bbox, hit_max);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

FZ_FUNCTION FzDisplayList::FzDisplayList(::fz_display_list* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzDisplayList::~FzDisplayList()
{
	ll_fz_drop_display_list(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDisplayList_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzDisplayList::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzDisplayList::s_num_instances = 0;


/* Implementation of methods for FzDocument (wrapper for fz_document). */

#ifndef NDEBUG
static RefsCheck<::fz_document, FzDocument> s_FzDocument_refs_check(offsetof(::fz_document, refs), 32);
#endif

/* Constructor using `fz_open_accelerated_document()`. */
FZ_FUNCTION FzDocument::FzDocument(const char *filename, const char *accel)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_accelerated_document()\n";
	}
	#endif
	this->m_internal = ll_fz_open_accelerated_document(filename, accel);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_open_accelerated_document_with_stream()`. */
FZ_FUNCTION FzDocument::FzDocument(const char *magic, const FzStream& stream, const FzStream& accel)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_accelerated_document_with_stream()\n";
	}
	#endif
	this->m_internal = ll_fz_open_accelerated_document_with_stream(magic, stream.m_internal, accel.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_open_accelerated_document_with_stream_and_dir()`. */
FZ_FUNCTION FzDocument::FzDocument(const char *magic, const FzStream& stream, const FzStream& accel, const FzArchive& dir)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_accelerated_document_with_stream_and_dir()\n";
	}
	#endif
	this->m_internal = ll_fz_open_accelerated_document_with_stream_and_dir(magic, stream.m_internal, accel.m_internal, dir.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_open_document()`. */
FZ_FUNCTION FzDocument::FzDocument(const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_document()\n";
	}
	#endif
	this->m_internal = ll_fz_open_document(filename);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_open_document_with_buffer()`. */
FZ_FUNCTION FzDocument::FzDocument(const char *magic, const FzBuffer& buffer)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_document_with_buffer()\n";
	}
	#endif
	this->m_internal = ll_fz_open_document_with_buffer(magic, buffer.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_open_document_with_stream()`. */
FZ_FUNCTION FzDocument::FzDocument(const char *magic, const FzStream& stream)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_document_with_stream()\n";
	}
	#endif
	this->m_internal = ll_fz_open_document_with_stream(magic, stream.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_open_document_with_stream_and_dir()`. */
FZ_FUNCTION FzDocument::FzDocument(const char *magic, const FzStream& stream, const FzArchive& dir)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_document_with_stream_and_dir()\n";
	}
	#endif
	this->m_internal = ll_fz_open_document_with_stream_and_dir(magic, stream.m_internal, dir.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION FzDocument::FzDocument(PdfDocument& pdfdocument)
{
	m_internal = ll_fz_keep_document(&pdfdocument.m_internal->super);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_document()`. */
FZ_FUNCTION FzDocument::FzDocument(const FzDocument& rhs)
: m_internal(ll_fz_keep_document(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_document(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_document()` and `fz_drop_document()`. */
FZ_FUNCTION FzDocument& FzDocument::operator=(const FzDocument& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_document(this->m_internal)"
				<< " and ll_fz_keep_document(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_document(this->m_internal);
	ll_fz_keep_document(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/* Class-aware wrapper for `::fz_new_xhtml_document_from_document()`.  */
FZ_FUNCTION FzDocument FzDocument::fz_new_xhtml_document_from_document(const FzDocument& old_doc, FzStextOptions& opts)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_xhtml_document_from_document()\n";
	}
	#endif
	auto ret = mupdf::fz_new_xhtml_document_from_document(old_doc, opts);
	return ret;
}

/* Class-aware wrapper for `::fz_authenticate_password()`.  */
FZ_FUNCTION int FzDocument::fz_authenticate_password(const char *password) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_authenticate_password()\n";
	}
	#endif
	auto ret = mupdf::fz_authenticate_password(*this, password);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_clamp_location()`.  */
FZ_FUNCTION FzLocation FzDocument::fz_clamp_location(const FzLocation& loc) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clamp_location()\n";
	}
	#endif
	auto ret = mupdf::fz_clamp_location(*this, loc);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_count_chapter_pages()`.  */
FZ_FUNCTION int FzDocument::fz_count_chapter_pages(int chapter) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_count_chapter_pages()\n";
	}
	#endif
	auto ret = mupdf::fz_count_chapter_pages(*this, chapter);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_count_chapters()`.  */
FZ_FUNCTION int FzDocument::fz_count_chapters() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_count_chapters()\n";
	}
	#endif
	auto ret = mupdf::fz_count_chapters(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_count_pages()`.  */
FZ_FUNCTION int FzDocument::fz_count_pages() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_count_pages()\n";
	}
	#endif
	auto ret = mupdf::fz_count_pages(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_document_output_intent()`.  */
FZ_FUNCTION FzColorspace FzDocument::fz_document_output_intent() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_document_output_intent()\n";
	}
	#endif
	auto ret = mupdf::fz_document_output_intent(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_document_supports_accelerator()`.  */
FZ_FUNCTION int FzDocument::fz_document_supports_accelerator() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_document_supports_accelerator()\n";
	}
	#endif
	auto ret = mupdf::fz_document_supports_accelerator(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_format_link_uri()`.  */
FZ_FUNCTION char *FzDocument::fz_format_link_uri(const FzLinkDest& dest) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_format_link_uri()\n";
	}
	#endif
	auto ret = mupdf::fz_format_link_uri(*this, dest);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_has_permission()`.  */
FZ_FUNCTION int FzDocument::fz_has_permission(::fz_permission p) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_has_permission()\n";
	}
	#endif
	auto ret = mupdf::fz_has_permission(*this, p);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_is_document_reflowable()`.  */
FZ_FUNCTION int FzDocument::fz_is_document_reflowable() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_document_reflowable()\n";
	}
	#endif
	auto ret = mupdf::fz_is_document_reflowable(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_last_page()`.  */
FZ_FUNCTION FzLocation FzDocument::fz_last_page() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_last_page()\n";
	}
	#endif
	auto ret = mupdf::fz_last_page(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_layout_document()`.  */
FZ_FUNCTION void FzDocument::fz_layout_document(float w, float h, float em) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_layout_document()\n";
	}
	#endif
	mupdf::fz_layout_document(*this, w, h, em);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_load_chapter_page()`.  */
FZ_FUNCTION FzPage FzDocument::fz_load_chapter_page(int chapter, int page) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_chapter_page()\n";
	}
	#endif
	auto ret = mupdf::fz_load_chapter_page(*this, chapter, page);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_load_outline()`.  */
FZ_FUNCTION FzOutline FzDocument::fz_load_outline() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_outline()\n";
	}
	#endif
	auto ret = mupdf::fz_load_outline(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_load_page()`.  */
FZ_FUNCTION FzPage FzDocument::fz_load_page(int number) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_page()\n";
	}
	#endif
	auto ret = mupdf::fz_load_page(*this, number);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_location_from_page_number()`.  */
FZ_FUNCTION FzLocation FzDocument::fz_location_from_page_number(int number) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_location_from_page_number()\n";
	}
	#endif
	auto ret = mupdf::fz_location_from_page_number(*this, number);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_lookup_bookmark()`.  */
FZ_FUNCTION FzLocation FzDocument::fz_lookup_bookmark(::fz_bookmark mark) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_bookmark()\n";
	}
	#endif
	auto ret = mupdf::fz_lookup_bookmark(*this, mark);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_lookup_metadata()`.  */
FZ_FUNCTION int FzDocument::fz_lookup_metadata(const char *key, char *buf, int size) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_metadata()\n";
	}
	#endif
	auto ret = mupdf::fz_lookup_metadata(*this, key, buf, size);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_lookup_metadata2()`.  */
FZ_FUNCTION std::string FzDocument::fz_lookup_metadata2(const char *key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_metadata2()\n";
	}
	#endif
	auto ret = mupdf::fz_lookup_metadata2(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_needs_password()`.  */
FZ_FUNCTION int FzDocument::fz_needs_password() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_needs_password()\n";
	}
	#endif
	auto ret = mupdf::fz_needs_password(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_page_number()`.  */
FZ_FUNCTION FzBuffer FzDocument::fz_new_buffer_from_page_number(int number, FzStextOptions& options) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_page_number()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_page_number(*this, number, options);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_display_list_from_page_number()`.  */
FZ_FUNCTION FzDisplayList FzDocument::fz_new_display_list_from_page_number(int number) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_display_list_from_page_number()\n";
	}
	#endif
	auto ret = mupdf::fz_new_display_list_from_page_number(*this, number);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_pixmap_from_page_number()`.  */
FZ_FUNCTION FzPixmap FzDocument::fz_new_pixmap_from_page_number(int number, const FzMatrix& ctm, const FzColorspace& cs, int alpha) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_page_number()\n";
	}
	#endif
	auto ret = mupdf::fz_new_pixmap_from_page_number(*this, number, ctm, cs, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_pixmap_from_page_number_with_separations()`.  */
FZ_FUNCTION FzPixmap FzDocument::fz_new_pixmap_from_page_number_with_separations(int number, const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_page_number_with_separations()\n";
	}
	#endif
	auto ret = mupdf::fz_new_pixmap_from_page_number_with_separations(*this, number, ctm, cs, seps, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_xhtml_document_from_document()`.  */
FZ_FUNCTION FzDocument FzDocument::fz_new_xhtml_document_from_document(FzStextOptions& opts) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_xhtml_document_from_document()\n";
	}
	#endif
	auto ret = mupdf::fz_new_xhtml_document_from_document(*this, opts);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_next_page()`.  */
FZ_FUNCTION FzLocation FzDocument::fz_next_page(const FzLocation& loc) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_next_page()\n";
	}
	#endif
	auto ret = mupdf::fz_next_page(*this, loc);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_reflowed_document()`.  */
FZ_FUNCTION FzDocument FzDocument::fz_open_reflowed_document(FzStextOptions& opts) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_reflowed_document()\n";
	}
	#endif
	auto ret = mupdf::fz_open_reflowed_document(*this, opts);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_output_accelerator()`.  */
FZ_FUNCTION void FzDocument::fz_output_accelerator(const FzOutput& accel) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_output_accelerator()\n";
	}
	#endif
	mupdf::fz_output_accelerator(*this, accel);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_page_number_from_location()`.  */
FZ_FUNCTION int FzDocument::fz_page_number_from_location(const FzLocation& loc) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_page_number_from_location()\n";
	}
	#endif
	auto ret = mupdf::fz_page_number_from_location(*this, loc);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_previous_page()`.  */
FZ_FUNCTION FzLocation FzDocument::fz_previous_page(const FzLocation& loc) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_previous_page()\n";
	}
	#endif
	auto ret = mupdf::fz_previous_page(*this, loc);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_process_opened_pages()`.  */
FZ_FUNCTION void *FzDocument::fz_process_opened_pages(::fz_process_opened_page_fn *process_openend_page, void *state) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_process_opened_pages()\n";
	}
	#endif
	auto ret = mupdf::fz_process_opened_pages(*this, process_openend_page, state);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_resolve_link()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_resolve_link(const char *uri)` => `(fz_location, float xp, float yp)`
	 */
FZ_FUNCTION FzLocation FzDocument::fz_resolve_link(const char *uri, float *xp, float *yp) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_resolve_link()\n";
	}
	#endif
	auto ret = mupdf::fz_resolve_link(*this, uri, xp, yp);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_run_document_structure()`.  */
FZ_FUNCTION void FzDocument::fz_run_document_structure(const FzDevice& dev, FzCookie& cookie) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_run_document_structure()\n";
	}
	#endif
	mupdf::fz_run_document_structure(*this, dev, cookie);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_save_accelerator()`.  */
FZ_FUNCTION void FzDocument::fz_save_accelerator(const char *accel) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_accelerator()\n";
	}
	#endif
	mupdf::fz_save_accelerator(*this, accel);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_search_chapter_page_number()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_search_chapter_page_number(int chapter, int page, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
	 */
FZ_FUNCTION int FzDocument::fz_search_chapter_page_number(int chapter, int page, const char *needle, int *hit_mark, FzQuad& hit_bbox, int hit_max) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_search_chapter_page_number()\n";
	}
	#endif
	auto ret = mupdf::fz_search_chapter_page_number(*this, chapter, page, needle, hit_mark, hit_bbox, hit_max);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_search_page2()`.  */
FZ_FUNCTION std::vector<fz_search_page2_hit> FzDocument::fz_search_page2(int number, const char *needle, int hit_max) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_search_page2()\n";
	}
	#endif
	auto ret = mupdf::fz_search_page2(*this, number, needle, hit_max);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_search_page_number()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_search_page_number(int number, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
	 */
FZ_FUNCTION int FzDocument::fz_search_page_number(int number, const char *needle, int *hit_mark, FzQuad& hit_bbox, int hit_max) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_search_page_number()\n";
	}
	#endif
	auto ret = mupdf::fz_search_page_number(*this, number, needle, hit_mark, hit_bbox, hit_max);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_set_metadata()`.  */
FZ_FUNCTION void FzDocument::fz_set_metadata(const char *key, const char *value) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_metadata()\n";
	}
	#endif
	mupdf::fz_set_metadata(*this, key, value);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_count_pages_imp()`.  */
FZ_FUNCTION int FzDocument::pdf_count_pages_imp(int chapter) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_count_pages_imp()\n";
	}
	#endif
	auto ret = mupdf::pdf_count_pages_imp(*this, chapter);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_document_from_fz_document()`.  */
FZ_FUNCTION PdfDocument FzDocument::pdf_document_from_fz_document() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_document_from_fz_document()\n";
	}
	#endif
	auto ret = mupdf::pdf_document_from_fz_document(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_page_imp()`.  */
FZ_FUNCTION FzPage FzDocument::pdf_load_page_imp(int chapter, int number) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_page_imp()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_page_imp(*this, chapter, number);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_page_label_imp()`.  */
FZ_FUNCTION void FzDocument::pdf_page_label_imp(int chapter, int page, char *buf, size_t size) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_label_imp()\n";
	}
	#endif
	mupdf::pdf_page_label_imp(*this, chapter, page, buf, size);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_specifics()`.  */
FZ_FUNCTION PdfDocument FzDocument::pdf_specifics() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_specifics()\n";
	}
	#endif
	auto ret = mupdf::pdf_specifics(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

FZ_FUNCTION FzDocument::FzDocument(::fz_document* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzDocument::~FzDocument()
{
	ll_fz_drop_document(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzDocument_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzDocument::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzDocument::s_num_instances = 0;


/* Implementation of methods for FzDocumentHandler (wrapper for fz_document_handler). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzDocumentHandler::FzDocumentHandler()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_register_document_handler()`.  */
FZ_FUNCTION void FzDocumentHandler::fz_register_document_handler() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_register_document_handler()\n";
	}
	#endif
	mupdf::fz_register_document_handler(*this);
}

FZ_FUNCTION FzDocumentHandler::FzDocumentHandler(::fz_document_handler* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzDocumentHandler::~FzDocumentHandler()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzDocumentHandler::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzDocumentHandler::s_num_instances = 0;


/* Implementation of methods for FzDocumentHandlerContext (wrapper for fz_document_handler_context). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzDocumentHandlerContext::FzDocumentHandlerContext()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzDocumentHandlerContext::FzDocumentHandlerContext(::fz_document_handler_context* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzDocumentHandlerContext::~FzDocumentHandlerContext()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzDocumentHandlerContext::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzDocumentHandlerContext::s_num_instances = 0;


/* Implementation of methods for FzDocumentWriter (wrapper for fz_document_writer). */

/* Constructor using `fz_new_document_writer_of_size()`. */
FZ_FUNCTION FzDocumentWriter::FzDocumentWriter(size_t size, ::fz_document_writer_begin_page_fn *begin_page, ::fz_document_writer_end_page_fn *end_page, ::fz_document_writer_close_writer_fn *close, ::fz_document_writer_drop_writer_fn *drop)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_document_writer_of_size()\n";
	}
	#endif
	this->m_internal = ll_fz_new_document_writer_of_size(size, begin_page, end_page, close, drop);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_document_writer_with_buffer()`. */
FZ_FUNCTION FzDocumentWriter::FzDocumentWriter(const FzBuffer& buf, const char *format, const char *options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_document_writer_with_buffer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_document_writer_with_buffer(buf.m_internal, format, options);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_jpeg_pixmap_writer()`. */
FZ_FUNCTION FzDocumentWriter::FzDocumentWriter(const char *path, const char *options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_jpeg_pixmap_writer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_jpeg_pixmap_writer(path, options);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_pixmap_writer()`. */
FZ_FUNCTION FzDocumentWriter::FzDocumentWriter(const char *path, const char *options, const char *default_path, int n, void (*save)(::fz_context *, ::fz_pixmap *, const char *))
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_writer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pixmap_writer(path, options, default_path, n, save);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_svg_writer_with_output()`. */
FZ_FUNCTION FzDocumentWriter::FzDocumentWriter(const FzOutput& out, const char *options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_svg_writer_with_output()\n";
	}
	#endif
	this->m_internal = ll_fz_new_svg_writer_with_output(out.m_internal, options);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION FzDocumentWriter::FzDocumentWriter(const char *path, const char *options, PathType path_type)
{
	if (0) {}
	else if (path_type == PathType_CBZ)         m_internal = ll_fz_new_cbz_writer(path, options);
	else if (path_type == PathType_DOCX)        m_internal = ll_fz_new_docx_writer(path, options);
	else if (path_type == PathType_ODT)         m_internal = ll_fz_new_odt_writer(path, options);
	else if (path_type == PathType_PAM_PIXMAP)  m_internal = ll_fz_new_pam_pixmap_writer(path, options);
	else if (path_type == PathType_PBM_PIXMAP)  m_internal = ll_fz_new_pbm_pixmap_writer(path, options);
	else if (path_type == PathType_PCL)         m_internal = ll_fz_new_pcl_writer(path, options);
	else if (path_type == PathType_PCLM)        m_internal = ll_fz_new_pclm_writer(path, options);
	else if (path_type == PathType_PDF)         m_internal = ll_fz_new_pdf_writer(path, options);
	else if (path_type == PathType_PDFOCR)      m_internal = ll_fz_new_pdfocr_writer(path, options);
	else if (path_type == PathType_PGM_PIXMAP)  m_internal = ll_fz_new_pgm_pixmap_writer(path, options);
	else if (path_type == PathType_PKM_PIXMAP)  m_internal = ll_fz_new_pkm_pixmap_writer(path, options);
	else if (path_type == PathType_PNG_PIXMAP)  m_internal = ll_fz_new_png_pixmap_writer(path, options);
	else if (path_type == PathType_PNM_PIXMAP)  m_internal = ll_fz_new_pnm_pixmap_writer(path, options);
	else if (path_type == PathType_PPM_PIXMAP)  m_internal = ll_fz_new_ppm_pixmap_writer(path, options);
	else if (path_type == PathType_PS)          m_internal = ll_fz_new_ps_writer(path, options);
	else if (path_type == PathType_PWG)         m_internal = ll_fz_new_pwg_writer(path, options);
	else if (path_type == PathType_SVG)         m_internal = ll_fz_new_svg_writer(path, options);
	else throw FzErrorAbort( "Unrecognised Type value");
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION FzDocumentWriter::FzDocumentWriter(FzOutput& out, const char *options, OutputType output_type)
{
	/* All fz_new_*_writer_with_output() functions take
	ownership of the fz_output, even if they throw an
	exception. So we need to set out.m_internal to null
	here so its destructor does nothing. */
	::fz_output* out2 = out.m_internal;
	out.m_internal = NULL;
	if (0) {}
	else if (output_type == OutputType_CBZ)     m_internal = ll_fz_new_cbz_writer_with_output(out2, options);
	else if (output_type == OutputType_DOCX)    m_internal = ll_fz_new_docx_writer_with_output(out2, options);
	else if (output_type == OutputType_ODT)     m_internal = ll_fz_new_odt_writer_with_output(out2, options);
	else if (output_type == OutputType_PCL)     m_internal = ll_fz_new_pcl_writer_with_output(out2, options);
	else if (output_type == OutputType_PCLM)    m_internal = ll_fz_new_pclm_writer_with_output(out2, options);
	else if (output_type == OutputType_PDF)     m_internal = ll_fz_new_pdf_writer_with_output(out2, options);
	else if (output_type == OutputType_PDFOCR)  m_internal = ll_fz_new_pdfocr_writer_with_output(out2, options);
	else if (output_type == OutputType_PS)      m_internal = ll_fz_new_ps_writer_with_output(out2, options);
	else if (output_type == OutputType_PWG)     m_internal = ll_fz_new_pwg_writer_with_output(out2, options);
	else
	{
		/* Ensure that out2 is dropped before we return. */
		ll_fz_drop_output(out2);
		throw FzErrorAbort( "Unrecognised OutputType value");
	}
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION FzDocumentWriter::FzDocumentWriter(const char *format, const char *path, const char *options, FormatPathType format_path_type)
{
	if (0) {}
	else if (format_path_type == FormatPathType_DOCUMENT)   m_internal = ll_fz_new_document_writer(format, path, options);
	else if (format_path_type == FormatPathType_TEXT)       m_internal = ll_fz_new_text_writer(format, path, options);
	else throw FzErrorAbort( "Unrecognised OutputType value");
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION FzDocumentWriter::FzDocumentWriter(FzOutput& out, const char *format, const char *options)
{
	/* Need to transfer ownership of <out>. */
	::fz_output* out2 = out.m_internal;
	out.m_internal = NULL;
	m_internal = ll_fz_new_document_writer_with_output(out2, format, options);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION FzDocumentWriter::FzDocumentWriter(const char *format, FzOutput& out, const char *options)
{
	/* Need to transfer ownership of <out>. */
	::fz_output* out2 = out.m_internal;
	out.m_internal = NULL;
	m_internal = ll_fz_new_text_writer_with_output(format, out2, options);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzDocumentWriter::FzDocumentWriter()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_begin_page()`.  */
FZ_FUNCTION FzDevice FzDocumentWriter::fz_begin_page(const FzRect& mediabox) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_begin_page()\n";
	}
	#endif
	auto ret = mupdf::fz_begin_page(*this, mediabox);
	return ret;
}

/* Class-aware wrapper for `::fz_close_document_writer()`.  */
FZ_FUNCTION void FzDocumentWriter::fz_close_document_writer() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_close_document_writer()\n";
	}
	#endif
	mupdf::fz_close_document_writer(*this);
}

/* Class-aware wrapper for `::fz_end_page()`.  */
FZ_FUNCTION void FzDocumentWriter::fz_end_page() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_end_page()\n";
	}
	#endif
	mupdf::fz_end_page(*this);
}

/* Class-aware wrapper for `::fz_pdfocr_writer_set_progress()`.  */
FZ_FUNCTION void FzDocumentWriter::fz_pdfocr_writer_set_progress(::fz_pdfocr_progress_fn *progress, void *arg_2) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pdfocr_writer_set_progress()\n";
	}
	#endif
	mupdf::fz_pdfocr_writer_set_progress(*this, progress, arg_2);
}

/* Class-aware wrapper for `::fz_write_document()`.  */
FZ_FUNCTION void FzDocumentWriter::fz_write_document(const FzDocument& doc) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_document()\n";
	}
	#endif
	mupdf::fz_write_document(*this, doc);
}

/* Class-aware wrapper for `::fz_write_stabilized_story()`.  */
FZ_FUNCTION void FzDocumentWriter::fz_write_stabilized_story(const char *user_css, float em, ::fz_write_story_contentfn contentfn, void *contentfn_ref, ::fz_write_story_rectfn rectfn, void *rectfn_ref, ::fz_write_story_pagefn pagefn, void *pagefn_ref, const FzArchive& dir) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_stabilized_story()\n";
	}
	#endif
	mupdf::fz_write_stabilized_story(*this, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir);
}

/* Class-aware wrapper for `::fz_write_story()`.  */
FZ_FUNCTION void FzDocumentWriter::fz_write_story(const FzStory& story, ::fz_write_story_rectfn rectfn, void *rectfn_ref, ::fz_write_story_positionfn positionfn, void *positionfn_ref, ::fz_write_story_pagefn pagefn, void *pagefn_ref) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_story()\n";
	}
	#endif
	mupdf::fz_write_story(*this, story, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref);
}

FZ_FUNCTION FzDocumentWriter::FzDocumentWriter(::fz_document_writer* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzDocumentWriter::~FzDocumentWriter()
{
	ll_fz_drop_document_writer(m_internal);
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzDocumentWriter::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzDocumentWriter::s_num_instances = 0;


/* Implementation of methods for FzDrawOptions (wrapper for fz_draw_options). */

/* Constructor using `fz_parse_draw_options()`. */
FZ_FUNCTION FzDrawOptions::FzDrawOptions(FzDrawOptions& options, const char *string)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_parse_draw_options()\n";
	}
	#endif
	*(::fz_draw_options*) &this->rotate = *ll_fz_parse_draw_options( options.internal(), string);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets each member to default value. */
FZ_FUNCTION FzDrawOptions::FzDrawOptions()
{
	this->rotate = {};
	this->x_resolution = {};
	this->y_resolution = {};
	this->width = {};
	this->height = {};
	this->colorspace = {};
	this->alpha = {};
	this->graphics = {};
	this->text = {};
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzDrawOptions::FzDrawOptions(const ::fz_draw_options* internal)
{
	assert( internal);
	this->rotate = internal->rotate;
	this->x_resolution = internal->x_resolution;
	this->y_resolution = internal->y_resolution;
	this->width = internal->width;
	this->height = internal->height;
	this->colorspace = internal->colorspace;
	this->alpha = internal->alpha;
	this->graphics = internal->graphics;
	this->text = internal->text;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzDrawOptions::FzDrawOptions(const ::fz_draw_options internal)
{
	this->rotate = internal.rotate;
	this->x_resolution = internal.x_resolution;
	this->y_resolution = internal.y_resolution;
	this->width = internal.width;
	this->height = internal.height;
	this->colorspace = internal.colorspace;
	this->alpha = internal.alpha;
	this->graphics = internal.graphics;
	this->text = internal.text;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::fz_draw_options`. */
FZ_FUNCTION ::fz_draw_options* FzDrawOptions::internal()
{
	auto ret = (::fz_draw_options*) &this->rotate;
	return ret;
}

/** Constructor using raw copy of pre-existing `::fz_draw_options`. */
FZ_FUNCTION const ::fz_draw_options* FzDrawOptions::internal() const
{
	auto ret = (const ::fz_draw_options*) &this->rotate;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION FzDrawOptions::~FzDrawOptions()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzDrawOptions::s_num_instances = 0;

FZ_FUNCTION std::string FzDrawOptions::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool FzDrawOptions::operator==(const FzDrawOptions& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool FzDrawOptions::operator!=(const FzDrawOptions& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for FzErrorContext (wrapper for fz_error_context). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzErrorContext::FzErrorContext()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzErrorContext::FzErrorContext(::fz_error_context* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzErrorContext::~FzErrorContext()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzErrorContext::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzErrorContext::s_num_instances = 0;


/* Implementation of methods for FzErrorStackSlot (wrapper for fz_error_stack_slot). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzErrorStackSlot::FzErrorStackSlot()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzErrorStackSlot::FzErrorStackSlot(::fz_error_stack_slot* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzErrorStackSlot::~FzErrorStackSlot()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzErrorStackSlot::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzErrorStackSlot::s_num_instances = 0;


/* Implementation of methods for FzFont (wrapper for fz_font). */

#ifndef NDEBUG
static RefsCheck<::fz_font, FzFont> s_FzFont_refs_check(offsetof(::fz_font, refs), 32);
#endif

/* Constructor using `fz_new_base14_font()`. */
FZ_FUNCTION FzFont::FzFont(const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_base14_font()\n";
	}
	#endif
	this->m_internal = ll_fz_new_base14_font(name);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_builtin_font()`. */
FZ_FUNCTION FzFont::FzFont(const char *name, int is_bold, int is_italic)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_builtin_font()\n";
	}
	#endif
	this->m_internal = ll_fz_new_builtin_font(name, is_bold, is_italic);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_cjk_font()`. */
FZ_FUNCTION FzFont::FzFont(int ordering)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_cjk_font()\n";
	}
	#endif
	this->m_internal = ll_fz_new_cjk_font(ordering);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_font_from_buffer()`. */
FZ_FUNCTION FzFont::FzFont(const char *name, const FzBuffer& buffer, int index, int use_glyph_bbox)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_font_from_buffer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_font_from_buffer(name, buffer.m_internal, index, use_glyph_bbox);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_font_from_file()`. */
FZ_FUNCTION FzFont::FzFont(const char *name, const char *path, int index, int use_glyph_bbox)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_font_from_file()\n";
	}
	#endif
	this->m_internal = ll_fz_new_font_from_file(name, path, index, use_glyph_bbox);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_font_from_memory()`. */
FZ_FUNCTION FzFont::FzFont(const char *name, const unsigned char *data, int len, int index, int use_glyph_bbox)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_font_from_memory()\n";
	}
	#endif
	this->m_internal = ll_fz_new_font_from_memory(name, data, len, index, use_glyph_bbox);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_type3_font()`. */
FZ_FUNCTION FzFont::FzFont(const char *name, const FzMatrix& matrix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_type3_font()\n";
	}
	#endif
	this->m_internal = ll_fz_new_type3_font(name, * matrix.internal());
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_font()`. */
FZ_FUNCTION FzFont::FzFont(const FzFont& rhs)
: m_internal(ll_fz_keep_font(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_font(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_font()` and `fz_drop_font()`. */
FZ_FUNCTION FzFont& FzFont::operator=(const FzFont& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_font(this->m_internal)"
				<< " and ll_fz_keep_font(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_font(this->m_internal);
	ll_fz_keep_font(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzFont::FzFont()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_advance_glyph()`.  */
FZ_FUNCTION float FzFont::fz_advance_glyph(int glyph, int wmode) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_advance_glyph()\n";
	}
	#endif
	auto ret = mupdf::fz_advance_glyph(*this, glyph, wmode);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_bound_glyph()`.  */
FZ_FUNCTION FzRect FzFont::fz_bound_glyph(int gid, const FzMatrix& trm) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_bound_glyph()\n";
	}
	#endif
	auto ret = mupdf::fz_bound_glyph(*this, gid, trm);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_decouple_type3_font()`.  */
FZ_FUNCTION void FzFont::fz_decouple_type3_font(void *t3doc) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_decouple_type3_font()\n";
	}
	#endif
	mupdf::fz_decouple_type3_font(*this, t3doc);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_encode_character()`.  */
FZ_FUNCTION int FzFont::fz_encode_character(int unicode) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_encode_character()\n";
	}
	#endif
	auto ret = mupdf::fz_encode_character(*this, unicode);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_encode_character_by_glyph_name()`.  */
FZ_FUNCTION int FzFont::fz_encode_character_by_glyph_name(const char *glyphname) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_encode_character_by_glyph_name()\n";
	}
	#endif
	auto ret = mupdf::fz_encode_character_by_glyph_name(*this, glyphname);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_encode_character_sc()`.  */
FZ_FUNCTION int FzFont::fz_encode_character_sc(int unicode) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_encode_character_sc()\n";
	}
	#endif
	auto ret = mupdf::fz_encode_character_sc(*this, unicode);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_encode_character_with_fallback()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_encode_character_with_fallback(int unicode, int script, int language, ::fz_font **out_font)` => `(int)`
	 */
FZ_FUNCTION int FzFont::fz_encode_character_with_fallback(int unicode, int script, int language, FzFont& out_font) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_encode_character_with_fallback()\n";
	}
	#endif
	auto ret = mupdf::fz_encode_character_with_fallback(*this, unicode, script, language, out_font);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_extract_ttf_from_ttc()`.  */
FZ_FUNCTION FzBuffer FzFont::fz_extract_ttf_from_ttc() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_extract_ttf_from_ttc()\n";
	}
	#endif
	auto ret = mupdf::fz_extract_ttf_from_ttc(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_font_ascender()`.  */
FZ_FUNCTION float FzFont::fz_font_ascender() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_ascender()\n";
	}
	#endif
	auto ret = mupdf::fz_font_ascender(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_font_bbox()`.  */
FZ_FUNCTION FzRect FzFont::fz_font_bbox() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_bbox()\n";
	}
	#endif
	auto ret = mupdf::fz_font_bbox(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_font_descender()`.  */
FZ_FUNCTION float FzFont::fz_font_descender() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_descender()\n";
	}
	#endif
	auto ret = mupdf::fz_font_descender(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_font_digest()`.  */
FZ_FUNCTION void FzFont::fz_font_digest(unsigned char digest[16]) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_digest()\n";
	}
	#endif
	mupdf::fz_font_digest(*this, digest);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_font_ft_face()`.  */
FZ_FUNCTION void *FzFont::fz_font_ft_face() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_ft_face()\n";
	}
	#endif
	auto ret = mupdf::fz_font_ft_face(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_font_is_bold()`.  */
FZ_FUNCTION int FzFont::fz_font_is_bold() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_is_bold()\n";
	}
	#endif
	auto ret = mupdf::fz_font_is_bold(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_font_is_italic()`.  */
FZ_FUNCTION int FzFont::fz_font_is_italic() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_is_italic()\n";
	}
	#endif
	auto ret = mupdf::fz_font_is_italic(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_font_is_monospaced()`.  */
FZ_FUNCTION int FzFont::fz_font_is_monospaced() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_is_monospaced()\n";
	}
	#endif
	auto ret = mupdf::fz_font_is_monospaced(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_font_is_serif()`.  */
FZ_FUNCTION int FzFont::fz_font_is_serif() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_is_serif()\n";
	}
	#endif
	auto ret = mupdf::fz_font_is_serif(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_font_name()`.  */
FZ_FUNCTION const char *FzFont::fz_font_name() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_name()\n";
	}
	#endif
	auto ret = mupdf::fz_font_name(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_font_t3_procs()`.  */
FZ_FUNCTION ::fz_buffer **FzFont::fz_font_t3_procs() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_t3_procs()\n";
	}
	#endif
	auto ret = mupdf::fz_font_t3_procs(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_get_glyph_name()`.  */
FZ_FUNCTION void FzFont::fz_get_glyph_name(int glyph, char *buf, int size) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_get_glyph_name()\n";
	}
	#endif
	mupdf::fz_get_glyph_name(*this, glyph, buf, size);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_get_glyph_name2()`.  */
FZ_FUNCTION std::string FzFont::fz_get_glyph_name2(int glyph) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_get_glyph_name2()\n";
	}
	#endif
	auto ret = mupdf::fz_get_glyph_name2(*this, glyph);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_glyph_cacheable()`.  */
FZ_FUNCTION int FzFont::fz_glyph_cacheable(int gid) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_glyph_cacheable()\n";
	}
	#endif
	auto ret = mupdf::fz_glyph_cacheable(*this, gid);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_measure_string()`.  */
FZ_FUNCTION FzMatrix FzFont::fz_measure_string(const FzMatrix& trm, const char *s, int wmode, int bidi_level, ::fz_bidi_direction markup_dir, ::fz_text_language language) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_measure_string()\n";
	}
	#endif
	auto ret = mupdf::fz_measure_string(*this, trm, s, wmode, bidi_level, markup_dir, language);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_outline_glyph()`.  */
FZ_FUNCTION FzPath FzFont::fz_outline_glyph(int gid, const FzMatrix& ctm) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_outline_glyph()\n";
	}
	#endif
	auto ret = mupdf::fz_outline_glyph(*this, gid, ctm);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_prepare_t3_glyph()`.  */
FZ_FUNCTION void FzFont::fz_prepare_t3_glyph(int gid) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_prepare_t3_glyph()\n";
	}
	#endif
	mupdf::fz_prepare_t3_glyph(*this, gid);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_render_glyph_pixmap()`.  */
FZ_FUNCTION FzPixmap FzFont::fz_render_glyph_pixmap(int gid, FzMatrix& ctm, FzIrect& scissor, int aa) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_render_glyph_pixmap()\n";
	}
	#endif
	auto ret = mupdf::fz_render_glyph_pixmap(*this, gid, ctm, scissor, aa);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_run_t3_glyph()`.  */
FZ_FUNCTION void FzFont::fz_run_t3_glyph(int gid, const FzMatrix& trm, const FzDevice& dev) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_run_t3_glyph()\n";
	}
	#endif
	mupdf::fz_run_t3_glyph(*this, gid, trm, dev);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_set_font_bbox()`.  */
FZ_FUNCTION void FzFont::fz_set_font_bbox(float xmin, float ymin, float xmax, float ymax) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_font_bbox()\n";
	}
	#endif
	mupdf::fz_set_font_bbox(*this, xmin, ymin, xmax, ymax);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_set_font_embedding()`.  */
FZ_FUNCTION void FzFont::fz_set_font_embedding(int embed) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_font_embedding()\n";
	}
	#endif
	mupdf::fz_set_font_embedding(*this, embed);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_font_writing_supported()`.  */
FZ_FUNCTION int FzFont::pdf_font_writing_supported() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_font_writing_supported()\n";
	}
	#endif
	auto ret = mupdf::pdf_font_writing_supported(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_layout_fit_text()`.  */
FZ_FUNCTION FzText FzFont::pdf_layout_fit_text(::fz_text_language lang, const char *str, const FzRect& bounds) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_layout_fit_text()\n";
	}
	#endif
	auto ret = mupdf::pdf_layout_fit_text(*this, lang, str, bounds);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

FZ_FUNCTION FzFont::FzFont(::fz_font* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzFont::~FzFont()
{
	ll_fz_drop_font(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFont_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzFont::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzFont::s_num_instances = 0;


/* Implementation of methods for FzFontContext (wrapper for fz_font_context). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzFontContext::FzFontContext()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzFontContext::FzFontContext(::fz_font_context* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzFontContext::~FzFontContext()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzFontContext::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzFontContext::s_num_instances = 0;


/* Implementation of methods for FzFontFlagsT (wrapper for fz_font_flags_t). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzFontFlagsT::FzFontFlagsT()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzFontFlagsT::FzFontFlagsT(::fz_font_flags_t* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzFontFlagsT::~FzFontFlagsT()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzFontFlagsT::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzFontFlagsT::s_num_instances = 0;


/* Implementation of methods for FzFunction (wrapper for fz_function). */

#ifndef NDEBUG
static RefsCheck<::fz_function, FzFunction> s_FzFunction_refs_check(offsetof(::fz_function, storable.refs), 32);
#endif

/* Constructor using `fz_new_function_of_size()`. */
FZ_FUNCTION FzFunction::FzFunction(int size, size_t size2, int m, int n, ::fz_function_eval_fn *eval, ::fz_store_drop_fn *drop)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_function_of_size()\n";
	}
	#endif
	this->m_internal = ll_fz_new_function_of_size(size, size2, m, n, eval, drop);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFunction_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_function()`. */
FZ_FUNCTION FzFunction::FzFunction(const FzFunction& rhs)
: m_internal(ll_fz_keep_function(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_function(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFunction_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_function()` and `fz_drop_function()`. */
FZ_FUNCTION FzFunction& FzFunction::operator=(const FzFunction& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_function(this->m_internal)"
				<< " and ll_fz_keep_function(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_function(this->m_internal);
	ll_fz_keep_function(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFunction_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFunction_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzFunction::FzFunction()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFunction_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_eval_function()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_eval_function(const float *in, int inlen, int outlen)` => float out
	 */
FZ_FUNCTION void FzFunction::fz_eval_function(const float *in, int inlen, float *out, int outlen) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_eval_function()\n";
	}
	#endif
	mupdf::fz_eval_function(*this, in, inlen, out, outlen);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFunction_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_function_size()`.  */
FZ_FUNCTION size_t FzFunction::fz_function_size() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_function_size()\n";
	}
	#endif
	auto ret = mupdf::fz_function_size(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFunction_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

FZ_FUNCTION FzFunction::FzFunction(::fz_function* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFunction_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzFunction::~FzFunction()
{
	ll_fz_drop_function(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzFunction_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzFunction::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzFunction::s_num_instances = 0;


/* Implementation of methods for FzGetoptLongOptions (wrapper for fz_getopt_long_options). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzGetoptLongOptions::FzGetoptLongOptions()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzGetoptLongOptions::FzGetoptLongOptions(::fz_getopt_long_options* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzGetoptLongOptions::~FzGetoptLongOptions()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzGetoptLongOptions::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzGetoptLongOptions::s_num_instances = 0;


/* Implementation of methods for FzGlyph (wrapper for fz_glyph). */

#ifndef NDEBUG
static RefsCheck<::fz_glyph, FzGlyph> s_FzGlyph_refs_check(0, 32);
#endif

/** Copy constructor using `fz_keep_glyph()`. */
FZ_FUNCTION FzGlyph::FzGlyph(const FzGlyph& rhs)
: m_internal(ll_fz_keep_glyph(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_glyph(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzGlyph_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_glyph()` and `fz_drop_glyph()`. */
FZ_FUNCTION FzGlyph& FzGlyph::operator=(const FzGlyph& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_glyph(this->m_internal)"
				<< " and ll_fz_keep_glyph(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_glyph(this->m_internal);
	ll_fz_keep_glyph(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzGlyph_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzGlyph_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzGlyph::FzGlyph()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzGlyph_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_glyph_bbox()`.  */
FZ_FUNCTION FzIrect FzGlyph::fz_glyph_bbox() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_glyph_bbox()\n";
	}
	#endif
	auto ret = mupdf::fz_glyph_bbox(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzGlyph_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_glyph_bbox_no_ctx()`.  */
FZ_FUNCTION FzIrect FzGlyph::fz_glyph_bbox_no_ctx() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_glyph_bbox_no_ctx()\n";
	}
	#endif
	auto ret = mupdf::fz_glyph_bbox_no_ctx(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzGlyph_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_glyph_height()`.  */
FZ_FUNCTION int FzGlyph::fz_glyph_height() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_glyph_height()\n";
	}
	#endif
	auto ret = mupdf::fz_glyph_height(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzGlyph_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_glyph_width()`.  */
FZ_FUNCTION int FzGlyph::fz_glyph_width() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_glyph_width()\n";
	}
	#endif
	auto ret = mupdf::fz_glyph_width(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzGlyph_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

FZ_FUNCTION FzGlyph::FzGlyph(::fz_glyph* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzGlyph_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzGlyph::~FzGlyph()
{
	ll_fz_drop_glyph(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzGlyph_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzGlyph::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzGlyph::s_num_instances = 0;


/* Implementation of methods for FzGlyphCache (wrapper for fz_glyph_cache). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzGlyphCache::FzGlyphCache()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzGlyphCache::FzGlyphCache(::fz_glyph_cache* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzGlyphCache::~FzGlyphCache()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzGlyphCache::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzGlyphCache::s_num_instances = 0;


/* Implementation of methods for FzHalftone (wrapper for fz_halftone). */

#ifndef NDEBUG
static RefsCheck<::fz_halftone, FzHalftone> s_FzHalftone_refs_check(0, 32);
#endif

/** Copy constructor using `fz_keep_halftone()`. */
FZ_FUNCTION FzHalftone::FzHalftone(const FzHalftone& rhs)
: m_internal(ll_fz_keep_halftone(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_halftone(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzHalftone_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_halftone()` and `fz_drop_halftone()`. */
FZ_FUNCTION FzHalftone& FzHalftone::operator=(const FzHalftone& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_halftone(this->m_internal)"
				<< " and ll_fz_keep_halftone(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_halftone(this->m_internal);
	ll_fz_keep_halftone(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzHalftone_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzHalftone_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

FZ_FUNCTION FzHalftone::FzHalftone(::fz_halftone* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzHalftone_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzHalftone::~FzHalftone()
{
	ll_fz_drop_halftone(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzHalftone_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzHalftone::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzHalftone::s_num_instances = 0;


/* Implementation of methods for FzHashTable (wrapper for fz_hash_table). */

/* Constructor using `fz_new_hash_table()`. */
FZ_FUNCTION FzHashTable::FzHashTable(int initialsize, int keylen, int lock, ::fz_hash_table_drop_fn *drop_val)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_hash_table()\n";
	}
	#endif
	this->m_internal = ll_fz_new_hash_table(initialsize, keylen, lock, drop_val);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzHashTable::FzHashTable()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_hash_filter()`.  */
FZ_FUNCTION void FzHashTable::fz_hash_filter(void *state, ::fz_hash_table_filter_fn *callback) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_hash_filter()\n";
	}
	#endif
	mupdf::fz_hash_filter(*this, state, callback);
}

/* Class-aware wrapper for `::fz_hash_find()`.  */
FZ_FUNCTION void *FzHashTable::fz_hash_find(const void *key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_hash_find()\n";
	}
	#endif
	auto ret = mupdf::fz_hash_find(*this, key);
	return ret;
}

/* Class-aware wrapper for `::fz_hash_for_each()`.  */
FZ_FUNCTION void FzHashTable::fz_hash_for_each(void *state, ::fz_hash_table_for_each_fn *callback) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_hash_for_each()\n";
	}
	#endif
	mupdf::fz_hash_for_each(*this, state, callback);
}

/* Class-aware wrapper for `::fz_hash_insert()`.  */
FZ_FUNCTION void *FzHashTable::fz_hash_insert(const void *key, void *val) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_hash_insert()\n";
	}
	#endif
	auto ret = mupdf::fz_hash_insert(*this, key, val);
	return ret;
}

/* Class-aware wrapper for `::fz_hash_remove()`.  */
FZ_FUNCTION void FzHashTable::fz_hash_remove(const void *key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_hash_remove()\n";
	}
	#endif
	mupdf::fz_hash_remove(*this, key);
}

FZ_FUNCTION FzHashTable::FzHashTable(::fz_hash_table* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzHashTable::~FzHashTable()
{
	ll_fz_drop_hash_table(m_internal);
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzHashTable::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzHashTable::s_num_instances = 0;


/* Implementation of methods for FzIccProfile (wrapper for fz_icc_profile). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzIccProfile::FzIccProfile()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzIccProfile::FzIccProfile(::fz_icc_profile* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzIccProfile::~FzIccProfile()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzIccProfile::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzIccProfile::s_num_instances = 0;


/* Implementation of methods for FzImage (wrapper for fz_image). */

#ifndef NDEBUG
static RefsCheck<::fz_image, FzImage> s_FzImage_refs_check(offsetof(::fz_image, key_storable.storable.refs), 32);
#endif

/* Constructor using `fz_new_image_from_buffer()`. */
FZ_FUNCTION FzImage::FzImage(const FzBuffer& buffer)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_from_buffer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_image_from_buffer(buffer.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_image_from_compressed_buffer()`. */
FZ_FUNCTION FzImage::FzImage(int w, int h, int bpc, const FzColorspace& colorspace, int xres, int yres, int interpolate, int imagemask, const float *decode, const int *colorkey, const FzCompressedBuffer& buffer, const FzImage& mask)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_from_compressed_buffer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_image_from_compressed_buffer(w, h, bpc, colorspace.m_internal, xres, yres, interpolate, imagemask, decode, colorkey, buffer.m_internal, mask.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_image_from_compressed_buffer2()`. */
FZ_FUNCTION FzImage::FzImage(int w, int h, int bpc, const FzColorspace& colorspace, int xres, int yres, int interpolate, int imagemask, const std::vector<float> &decode, const std::vector<int> &colorkey, const FzCompressedBuffer& buffer, const FzImage& mask)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_from_compressed_buffer2()\n";
	}
	#endif
	this->m_internal = ll_fz_new_image_from_compressed_buffer2(w, h, bpc, colorspace.m_internal, xres, yres, interpolate, imagemask, decode, colorkey, buffer.m_internal, mask.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_image_from_display_list()`. */
FZ_FUNCTION FzImage::FzImage(float w, float h, const FzDisplayList& list)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_from_display_list()\n";
	}
	#endif
	this->m_internal = ll_fz_new_image_from_display_list(w, h, list.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_image_from_file()`. */
FZ_FUNCTION FzImage::FzImage(const char *path)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_from_file()\n";
	}
	#endif
	this->m_internal = ll_fz_new_image_from_file(path);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_image_from_pixmap()`. */
FZ_FUNCTION FzImage::FzImage(const FzPixmap& pixmap, const FzImage& mask)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_from_pixmap()\n";
	}
	#endif
	this->m_internal = ll_fz_new_image_from_pixmap(pixmap.m_internal, mask.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_image_from_svg()`. */
FZ_FUNCTION FzImage::FzImage(const FzBuffer& buf, const char *base_uri, const FzArchive& dir)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_from_svg()\n";
	}
	#endif
	this->m_internal = ll_fz_new_image_from_svg(buf.m_internal, base_uri, dir.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_image_from_svg_xml()`. */
FZ_FUNCTION FzImage::FzImage(const FzXml& xmldoc, const FzXml& xml, const char *base_uri, const FzArchive& dir)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_from_svg_xml()\n";
	}
	#endif
	this->m_internal = ll_fz_new_image_from_svg_xml(xmldoc.m_internal, xml.m_internal, base_uri, dir.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_image_of_size()`. */
FZ_FUNCTION FzImage::FzImage(int w, int h, int bpc, const FzColorspace& colorspace, int xres, int yres, int interpolate, int imagemask, const float *decode, const int *colorkey, const FzImage& mask, size_t size, ::fz_image_get_pixmap_fn *get_pixmap, ::fz_image_get_size_fn *get_size, ::fz_drop_image_fn *drop)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_of_size()\n";
	}
	#endif
	this->m_internal = ll_fz_new_image_of_size(w, h, bpc, colorspace.m_internal, xres, yres, interpolate, imagemask, decode, colorkey, mask.m_internal, size, get_pixmap, get_size, drop);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_image()`. */
FZ_FUNCTION FzImage::FzImage(const FzImage& rhs)
: m_internal(ll_fz_keep_image(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_image(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_image()` and `fz_drop_image()`. */
FZ_FUNCTION FzImage& FzImage::operator=(const FzImage& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_image(this->m_internal)"
				<< " and ll_fz_keep_image(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_image(this->m_internal);
	ll_fz_keep_image(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzImage::FzImage()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_compressed_image_buffer()`.  */
FZ_FUNCTION FzCompressedBuffer FzImage::fz_compressed_image_buffer() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_compressed_image_buffer()\n";
	}
	#endif
	auto ret = mupdf::fz_compressed_image_buffer(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_compressed_image_type()`.  */
FZ_FUNCTION int FzImage::fz_compressed_image_type() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_compressed_image_type()\n";
	}
	#endif
	auto ret = mupdf::fz_compressed_image_type(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_get_pixmap_from_image()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_get_pixmap_from_image(const ::fz_irect *subarea, ::fz_matrix *ctm)` => `(fz_pixmap *, int w, int h)`
	 */
FZ_FUNCTION FzPixmap FzImage::fz_get_pixmap_from_image(FzIrect& subarea, FzMatrix& ctm, int *w, int *h) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_get_pixmap_from_image()\n";
	}
	#endif
	auto ret = mupdf::fz_get_pixmap_from_image(*this, subarea, ctm, w, h);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_get_unscaled_pixmap_from_image()`.  */
FZ_FUNCTION FzPixmap FzImage::fz_get_unscaled_pixmap_from_image() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_get_unscaled_pixmap_from_image()\n";
	}
	#endif
	auto ret = mupdf::fz_get_unscaled_pixmap_from_image(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_image_orientation()`.  */
FZ_FUNCTION uint8_t FzImage::fz_image_orientation() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_image_orientation()\n";
	}
	#endif
	auto ret = mupdf::fz_image_orientation(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_image_orientation_matrix()`.  */
FZ_FUNCTION FzMatrix FzImage::fz_image_orientation_matrix() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_image_orientation_matrix()\n";
	}
	#endif
	auto ret = mupdf::fz_image_orientation_matrix(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_image_resolution()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_image_resolution()` => `(int xres, int yres)`
	 */
FZ_FUNCTION void FzImage::fz_image_resolution(int *xres, int *yres) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_image_resolution()\n";
	}
	#endif
	mupdf::fz_image_resolution(*this, xres, yres);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_image_size()`.  */
FZ_FUNCTION size_t FzImage::fz_image_size() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_image_size()\n";
	}
	#endif
	auto ret = mupdf::fz_image_size(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_image_as_jpeg()`.  */
FZ_FUNCTION FzBuffer FzImage::fz_new_buffer_from_image_as_jpeg(const FzColorParams& color_params, int quality, int invert_cmyk) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_image_as_jpeg()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_image_as_jpeg(*this, color_params, quality, invert_cmyk);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_image_as_jpx()`.  */
FZ_FUNCTION FzBuffer FzImage::fz_new_buffer_from_image_as_jpx(const FzColorParams& color_params, int quality) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_image_as_jpx()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_image_as_jpx(*this, color_params, quality);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_image_as_pam()`.  */
FZ_FUNCTION FzBuffer FzImage::fz_new_buffer_from_image_as_pam(const FzColorParams& color_params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_image_as_pam()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_image_as_pam(*this, color_params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_image_as_png()`.  */
FZ_FUNCTION FzBuffer FzImage::fz_new_buffer_from_image_as_png(const FzColorParams& color_params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_image_as_png()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_image_as_png(*this, color_params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_image_as_pnm()`.  */
FZ_FUNCTION FzBuffer FzImage::fz_new_buffer_from_image_as_pnm(const FzColorParams& color_params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_image_as_pnm()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_image_as_pnm(*this, color_params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_image_as_psd()`.  */
FZ_FUNCTION FzBuffer FzImage::fz_new_buffer_from_image_as_psd(const FzColorParams& color_params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_image_as_psd()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_image_as_psd(*this, color_params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

FZ_FUNCTION FzImage::FzImage(::fz_image* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION ::fz_key_storable FzImage::key_storable()
{
	return m_internal->key_storable;
}

FZ_FUNCTION int FzImage::w()
{
	return m_internal->w;
}

FZ_FUNCTION int FzImage::h()
{
	return m_internal->h;
}

FZ_FUNCTION uint8_t FzImage::n()
{
	return m_internal->n;
}

FZ_FUNCTION uint8_t FzImage::bpc()
{
	return m_internal->bpc;
}

FZ_FUNCTION unsigned int FzImage::imagemask()
{
	return m_internal->imagemask;
}

FZ_FUNCTION unsigned int FzImage::interpolate()
{
	return m_internal->interpolate;
}

FZ_FUNCTION unsigned int FzImage::use_colorkey()
{
	return m_internal->use_colorkey;
}

FZ_FUNCTION unsigned int FzImage::use_decode()
{
	return m_internal->use_decode;
}

FZ_FUNCTION unsigned int FzImage::decoded()
{
	return m_internal->decoded;
}

FZ_FUNCTION unsigned int FzImage::scalable()
{
	return m_internal->scalable;
}

FZ_FUNCTION uint8_t FzImage::orientation()
{
	return m_internal->orientation;
}

FZ_FUNCTION FzImage FzImage::mask()
{
	ll_fz_keep_image(m_internal->mask);
	return m_internal->mask;
}

FZ_FUNCTION int FzImage::xres()
{
	return m_internal->xres;
}

FZ_FUNCTION int FzImage::yres()
{
	return m_internal->yres;
}

FZ_FUNCTION FzColorspace FzImage::colorspace()
{
	ll_fz_keep_colorspace(m_internal->colorspace);
	return m_internal->colorspace;
}

FZ_FUNCTION int * FzImage::colorkey()
{
	return m_internal->colorkey;
}

FZ_FUNCTION float * FzImage::decode()
{
	return m_internal->decode;
}

FZ_FUNCTION FzImage::~FzImage()
{
	ll_fz_drop_image(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzImage_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzImage::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzImage::s_num_instances = 0;


/* Implementation of methods for FzInstallLoadSystemFontFuncsArgs (wrapper for fz_install_load_system_font_funcs_args). */

/** Default constructor, sets each member to default value. */
FZ_FUNCTION FzInstallLoadSystemFontFuncsArgs::FzInstallLoadSystemFontFuncsArgs()
{
	this->m_internal.f = {};
	this->m_internal.f_cjk = {};
	this->m_internal.f_fallback = {};
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_install_load_system_font_funcs2()`.  */
FZ_FUNCTION void FzInstallLoadSystemFontFuncsArgs::fz_install_load_system_font_funcs2()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_install_load_system_font_funcs2()\n";
	}
	#endif
	mupdf::fz_install_load_system_font_funcs2(*this);
}

FZ_FUNCTION FzInstallLoadSystemFontFuncsArgs::FzInstallLoadSystemFontFuncsArgs(const ::fz_install_load_system_font_funcs_args* internal)
: m_internal(*internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzInstallLoadSystemFontFuncsArgs::~FzInstallLoadSystemFontFuncsArgs()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzInstallLoadSystemFontFuncsArgs::s_num_instances = 0;

FZ_FUNCTION std::string FzInstallLoadSystemFontFuncsArgs::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool FzInstallLoadSystemFontFuncsArgs::operator==(const FzInstallLoadSystemFontFuncsArgs& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool FzInstallLoadSystemFontFuncsArgs::operator!=(const FzInstallLoadSystemFontFuncsArgs& rhs)
{
	return ::operator!=( *this, rhs);
}

/* Implementation of methods for `FzInstallLoadSystemFontFuncsArgs2`, virtual_fnptrs wrapper for `fz_install_load_system_font_funcs_args`). */


FZ_FUNCTION FzInstallLoadSystemFontFuncsArgs2::FzInstallLoadSystemFontFuncsArgs2()
{

	
	/*
	There can only be one active instance of the wrapper
	class so we simply keep a pointer to it in a global
	variable.
	*/
	fz_install_load_system_font_funcs2_state = this;
	
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzInstallLoadSystemFontFuncsArgs2::FzInstallLoadSystemFontFuncsArgs2(): this=" << this << "\n";
	}
	#endif
}
/* Static callback, calls self->f(). */
static ::fz_font * FzInstallLoadSystemFontFuncsArgs2_s_f(::fz_context *arg_0, const char *arg_1, int arg_2, int arg_3, int arg_4)
{
	FzInstallLoadSystemFontFuncsArgs2* self = (FzInstallLoadSystemFontFuncsArgs2*) fz_install_load_system_font_funcs2_state;
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzInstallLoadSystemFontFuncsArgs2_s_f(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->f(arg_0, arg_1, arg_2, arg_3, arg_4);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzInstallLoadSystemFontFuncsArgs2_s_f(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->f_cjk(). */
static ::fz_font * FzInstallLoadSystemFontFuncsArgs2_s_f_cjk(::fz_context *arg_0, const char *arg_1, int arg_2, int arg_3)
{
	FzInstallLoadSystemFontFuncsArgs2* self = (FzInstallLoadSystemFontFuncsArgs2*) fz_install_load_system_font_funcs2_state;
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzInstallLoadSystemFontFuncsArgs2_s_f_cjk(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->f_cjk(arg_0, arg_1, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzInstallLoadSystemFontFuncsArgs2_s_f_cjk(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->f_fallback(). */
static ::fz_font * FzInstallLoadSystemFontFuncsArgs2_s_f_fallback(::fz_context *arg_0, int arg_1, int arg_2, int arg_3, int arg_4, int arg_5)
{
	FzInstallLoadSystemFontFuncsArgs2* self = (FzInstallLoadSystemFontFuncsArgs2*) fz_install_load_system_font_funcs2_state;
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzInstallLoadSystemFontFuncsArgs2_s_f_fallback(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->f_fallback(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzInstallLoadSystemFontFuncsArgs2_s_f_fallback(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
FZ_FUNCTION void FzInstallLoadSystemFontFuncsArgs2::use_virtual_f( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzInstallLoadSystemFontFuncsArgs2::use_virtual_f(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal.f = (use) ? FzInstallLoadSystemFontFuncsArgs2_s_f : nullptr;
}
FZ_FUNCTION void FzInstallLoadSystemFontFuncsArgs2::use_virtual_f_cjk( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzInstallLoadSystemFontFuncsArgs2::use_virtual_f_cjk(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal.f_cjk = (use) ? FzInstallLoadSystemFontFuncsArgs2_s_f_cjk : nullptr;
}
FZ_FUNCTION void FzInstallLoadSystemFontFuncsArgs2::use_virtual_f_fallback( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzInstallLoadSystemFontFuncsArgs2::use_virtual_f_fallback(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal.f_fallback = (use) ? FzInstallLoadSystemFontFuncsArgs2_s_f_fallback : nullptr;
}
/* Default implementation of virtual method. */
FZ_FUNCTION ::fz_font * FzInstallLoadSystemFontFuncsArgs2::f(::fz_context *arg_0, const char *arg_1, int arg_2, int arg_3, int arg_4)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzInstallLoadSystemFontFuncsArgs2::f(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzInstallLoadSystemFontFuncsArgs2::f()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION ::fz_font * FzInstallLoadSystemFontFuncsArgs2::f_cjk(::fz_context *arg_0, const char *arg_1, int arg_2, int arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzInstallLoadSystemFontFuncsArgs2::f_cjk(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzInstallLoadSystemFontFuncsArgs2::f_cjk()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION ::fz_font * FzInstallLoadSystemFontFuncsArgs2::f_fallback(::fz_context *arg_0, int arg_1, int arg_2, int arg_3, int arg_4, int arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzInstallLoadSystemFontFuncsArgs2::f_fallback(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzInstallLoadSystemFontFuncsArgs2::f_fallback()");
}

/* Implementation of methods for FzInt2 (wrapper for fz_int2). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzInt2::FzInt2()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzInt2::FzInt2(::fz_int2* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzInt2::~FzInt2()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzInt2::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzInt2::s_num_instances = 0;


/* Implementation of methods for FzInt2Heap (wrapper for fz_int2_heap). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzInt2Heap::FzInt2Heap()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_int2_heap_insert()`.  */
FZ_FUNCTION void FzInt2Heap::fz_int2_heap_insert(const FzInt2& v) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_int2_heap_insert()\n";
	}
	#endif
	mupdf::fz_int2_heap_insert(*this, v);
}

/* Class-aware wrapper for `::fz_int2_heap_sort()`.  */
FZ_FUNCTION void FzInt2Heap::fz_int2_heap_sort() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_int2_heap_sort()\n";
	}
	#endif
	mupdf::fz_int2_heap_sort(*this);
}

/* Class-aware wrapper for `::fz_int2_heap_uniq()`.  */
FZ_FUNCTION void FzInt2Heap::fz_int2_heap_uniq() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_int2_heap_uniq()\n";
	}
	#endif
	mupdf::fz_int2_heap_uniq(*this);
}

FZ_FUNCTION FzInt2Heap::FzInt2Heap(::fz_int2_heap* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzInt2Heap::~FzInt2Heap()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzInt2Heap::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzInt2Heap::s_num_instances = 0;


/* Implementation of methods for FzIntHeap (wrapper for fz_int_heap). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzIntHeap::FzIntHeap()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_int_heap_insert()`.  */
FZ_FUNCTION void FzIntHeap::fz_int_heap_insert(int v) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_int_heap_insert()\n";
	}
	#endif
	mupdf::fz_int_heap_insert(*this, v);
}

/* Class-aware wrapper for `::fz_int_heap_sort()`.  */
FZ_FUNCTION void FzIntHeap::fz_int_heap_sort() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_int_heap_sort()\n";
	}
	#endif
	mupdf::fz_int_heap_sort(*this);
}

/* Class-aware wrapper for `::fz_int_heap_uniq()`.  */
FZ_FUNCTION void FzIntHeap::fz_int_heap_uniq() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_int_heap_uniq()\n";
	}
	#endif
	mupdf::fz_int_heap_uniq(*this);
}

FZ_FUNCTION FzIntHeap::FzIntHeap(::fz_int_heap* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzIntHeap::~FzIntHeap()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzIntHeap::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzIntHeap::s_num_instances = 0;


/* Implementation of methods for FzIntptr (wrapper for fz_intptr). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzIntptr::FzIntptr()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzIntptr::FzIntptr(::fz_intptr* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzIntptr::~FzIntptr()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzIntptr::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzIntptr::s_num_instances = 0;


/* Implementation of methods for FzIntptrHeap (wrapper for fz_intptr_heap). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzIntptrHeap::FzIntptrHeap()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_intptr_heap_insert()`.  */
FZ_FUNCTION void FzIntptrHeap::fz_intptr_heap_insert(const FzIntptr& v) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_intptr_heap_insert()\n";
	}
	#endif
	mupdf::fz_intptr_heap_insert(*this, v);
}

/* Class-aware wrapper for `::fz_intptr_heap_sort()`.  */
FZ_FUNCTION void FzIntptrHeap::fz_intptr_heap_sort() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_intptr_heap_sort()\n";
	}
	#endif
	mupdf::fz_intptr_heap_sort(*this);
}

/* Class-aware wrapper for `::fz_intptr_heap_uniq()`.  */
FZ_FUNCTION void FzIntptrHeap::fz_intptr_heap_uniq() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_intptr_heap_uniq()\n";
	}
	#endif
	mupdf::fz_intptr_heap_uniq(*this);
}

FZ_FUNCTION FzIntptrHeap::FzIntptrHeap(::fz_intptr_heap* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzIntptrHeap::~FzIntptrHeap()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzIntptrHeap::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzIntptrHeap::s_num_instances = 0;


/* Implementation of methods for FzIrect (wrapper for fz_irect). */

/* Constructor using `fz_irect_from_rect()`. */
FZ_FUNCTION FzIrect::FzIrect(const FzRect& rect)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_irect_from_rect()\n";
	}
	#endif
	*(::fz_irect*) &this->x0 = ll_fz_irect_from_rect(* rect.internal());
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_make_irect()`. */
FZ_FUNCTION FzIrect::FzIrect(int x0, int y0, int x1, int y1)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_make_irect()\n";
	}
	#endif
	*(::fz_irect*) &this->x0 = ll_fz_make_irect(x0, y0, x1, y1);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets each member to default value. */
FZ_FUNCTION FzIrect::FzIrect()
{
	this->x0 = {};
	this->y0 = {};
	this->x1 = {};
	this->y1 = {};
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_expand_irect()`.  */
FZ_FUNCTION FzIrect FzIrect::fz_expand_irect(int expand)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_expand_irect()\n";
	}
	#endif
	auto ret = mupdf::fz_expand_irect(*this, expand);
	return ret;
}

/* Class-aware wrapper for `::fz_intersect_irect()`.  */
FZ_FUNCTION FzIrect FzIrect::fz_intersect_irect(const FzIrect& b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_intersect_irect()\n";
	}
	#endif
	auto ret = mupdf::fz_intersect_irect(*this, b);
	return ret;
}

/* Class-aware wrapper for `::fz_irect_height()`.  */
FZ_FUNCTION int FzIrect::fz_irect_height()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_irect_height()\n";
	}
	#endif
	auto ret = mupdf::fz_irect_height(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_irect_width()`.  */
FZ_FUNCTION unsigned int FzIrect::fz_irect_width()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_irect_width()\n";
	}
	#endif
	auto ret = mupdf::fz_irect_width(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_is_empty_irect()`.  */
FZ_FUNCTION int FzIrect::fz_is_empty_irect()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_empty_irect()\n";
	}
	#endif
	auto ret = mupdf::fz_is_empty_irect(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_is_infinite_irect()`.  */
FZ_FUNCTION int FzIrect::fz_is_infinite_irect()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_infinite_irect()\n";
	}
	#endif
	auto ret = mupdf::fz_is_infinite_irect(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_is_valid_irect()`.  */
FZ_FUNCTION int FzIrect::fz_is_valid_irect()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_valid_irect()\n";
	}
	#endif
	auto ret = mupdf::fz_is_valid_irect(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_rect_from_irect()`.  */
FZ_FUNCTION FzRect FzIrect::fz_rect_from_irect()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_rect_from_irect()\n";
	}
	#endif
	auto ret = mupdf::fz_rect_from_irect(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_translate_irect()`.  */
FZ_FUNCTION FzIrect FzIrect::fz_translate_irect(int xoff, int yoff)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_translate_irect()\n";
	}
	#endif
	auto ret = mupdf::fz_translate_irect(*this, xoff, yoff);
	return ret;
}

FZ_FUNCTION FzIrect::FzIrect(const ::fz_irect* internal)
{
	assert( internal);
	this->x0 = internal->x0;
	this->y0 = internal->y0;
	this->x1 = internal->x1;
	this->y1 = internal->y1;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzIrect::FzIrect(const ::fz_irect internal)
{
	this->x0 = internal.x0;
	this->y0 = internal.y0;
	this->x1 = internal.x1;
	this->y1 = internal.y1;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::fz_irect`. */
FZ_FUNCTION ::fz_irect* FzIrect::internal()
{
	auto ret = (::fz_irect*) &this->x0;
	return ret;
}

/** Constructor using raw copy of pre-existing `::fz_irect`. */
FZ_FUNCTION const ::fz_irect* FzIrect::internal() const
{
	auto ret = (const ::fz_irect*) &this->x0;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION FzIrect::~FzIrect()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzIrect::s_num_instances = 0;

FZ_FUNCTION std::string FzIrect::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool FzIrect::operator==(const FzIrect& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool FzIrect::operator!=(const FzIrect& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for FzJbig2Globals (wrapper for fz_jbig2_globals). */

#ifndef NDEBUG
static RefsCheck<::fz_jbig2_globals, FzJbig2Globals> s_FzJbig2Globals_refs_check(0, 32);
#endif

/** Copy constructor using `fz_keep_jbig2_globals()`. */
FZ_FUNCTION FzJbig2Globals::FzJbig2Globals(const FzJbig2Globals& rhs)
: m_internal(ll_fz_keep_jbig2_globals(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_jbig2_globals(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzJbig2Globals_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_jbig2_globals()` and `fz_drop_jbig2_globals()`. */
FZ_FUNCTION FzJbig2Globals& FzJbig2Globals::operator=(const FzJbig2Globals& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_jbig2_globals(this->m_internal)"
				<< " and ll_fz_keep_jbig2_globals(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_jbig2_globals(this->m_internal);
	ll_fz_keep_jbig2_globals(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzJbig2Globals_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzJbig2Globals_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzJbig2Globals::FzJbig2Globals()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzJbig2Globals_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_jbig2_globals_data()`.  */
FZ_FUNCTION FzBuffer FzJbig2Globals::fz_jbig2_globals_data() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_jbig2_globals_data()\n";
	}
	#endif
	auto ret = mupdf::fz_jbig2_globals_data(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzJbig2Globals_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

FZ_FUNCTION FzJbig2Globals::FzJbig2Globals(::fz_jbig2_globals* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzJbig2Globals_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzJbig2Globals::~FzJbig2Globals()
{
	ll_fz_drop_jbig2_globals(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzJbig2Globals_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzJbig2Globals::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzJbig2Globals::s_num_instances = 0;


/* Implementation of methods for FzKeyStorable (wrapper for fz_key_storable). */

#ifndef NDEBUG
static RefsCheck<::fz_key_storable, FzKeyStorable> s_FzKeyStorable_refs_check(offsetof(::fz_key_storable, storable.refs), 32);
#endif

/** Copy constructor using `fz_keep_key_storable()`. */
FZ_FUNCTION FzKeyStorable::FzKeyStorable(const FzKeyStorable& rhs)
: m_internal((::fz_key_storable*) ll_fz_keep_key_storable(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_key_storable(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzKeyStorable_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_key_storable()` and `fz_drop_key_storable()`. */
FZ_FUNCTION FzKeyStorable& FzKeyStorable::operator=(const FzKeyStorable& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_key_storable(this->m_internal)"
				<< " and ll_fz_keep_key_storable(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_key_storable(this->m_internal);
	ll_fz_keep_key_storable(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzKeyStorable_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = (::fz_key_storable*) rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzKeyStorable_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzKeyStorable::FzKeyStorable()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzKeyStorable_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzKeyStorable::FzKeyStorable(::fz_key_storable* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzKeyStorable_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzKeyStorable::~FzKeyStorable()
{
	ll_fz_drop_key_storable(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzKeyStorable_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzKeyStorable::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzKeyStorable::s_num_instances = 0;


/* Implementation of methods for FzLayoutBlock (wrapper for fz_layout_block). */

/* Constructor using `fz_new_layout()`. */
FZ_FUNCTION FzLayoutBlock::FzLayoutBlock()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_layout()\n";
	}
	#endif
	this->m_internal = ll_fz_new_layout();
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Class-aware wrapper for `::fz_add_layout_char()`.  */
FZ_FUNCTION void FzLayoutBlock::fz_add_layout_char(float x, float w, const char *p) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_add_layout_char()\n";
	}
	#endif
	mupdf::fz_add_layout_char(*this, x, w, p);
}

/* Class-aware wrapper for `::fz_add_layout_line()`.  */
FZ_FUNCTION void FzLayoutBlock::fz_add_layout_line(float x, float y, float h, const char *p) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_add_layout_line()\n";
	}
	#endif
	mupdf::fz_add_layout_line(*this, x, y, h, p);
}

FZ_FUNCTION FzLayoutBlock::FzLayoutBlock(::fz_layout_block* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzLayoutBlock::~FzLayoutBlock()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzLayoutBlock::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzLayoutBlock::s_num_instances = 0;


/* Implementation of methods for FzLayoutChar (wrapper for fz_layout_char). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzLayoutChar::FzLayoutChar()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzLayoutChar::FzLayoutChar(::fz_layout_char* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzLayoutChar::~FzLayoutChar()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzLayoutChar::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzLayoutChar::s_num_instances = 0;


/* Implementation of methods for FzLayoutLine (wrapper for fz_layout_line). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzLayoutLine::FzLayoutLine()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzLayoutLine::FzLayoutLine(::fz_layout_line* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzLayoutLine::~FzLayoutLine()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzLayoutLine::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzLayoutLine::s_num_instances = 0;


/* Implementation of methods for FzLink (wrapper for fz_link). */

#ifndef NDEBUG
static RefsCheck<::fz_link, FzLink> s_FzLink_refs_check(offsetof(::fz_link, refs), 32);
#endif

/* Constructor using `fz_new_link_of_size()`. */
FZ_FUNCTION FzLink::FzLink(int size, const FzRect& rect, const char *uri)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_link_of_size()\n";
	}
	#endif
	this->m_internal = ll_fz_new_link_of_size(size, * rect.internal(), uri);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzLink_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_link()`. */
FZ_FUNCTION FzLink::FzLink(const PdfPage& page, const FzRect& rect, const char *uri, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_link()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_link(page.m_internal, * rect.internal(), uri, obj.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzLink_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION FzLink::FzLink(FzRect& rect, const char *uri)
{
	m_internal = ll_fz_new_link_of_size( sizeof(fz_link), *rect.internal(), uri);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzLink_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_link()`. */
FZ_FUNCTION FzLink::FzLink(const FzLink& rhs)
: m_internal(ll_fz_keep_link(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_link(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzLink_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_link()` and `fz_drop_link()`. */
FZ_FUNCTION FzLink& FzLink::operator=(const FzLink& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_link(this->m_internal)"
				<< " and ll_fz_keep_link(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_link(this->m_internal);
	ll_fz_keep_link(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzLink_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzLink_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/* Class-aware wrapper for `::fz_set_link_rect()`.  */
FZ_FUNCTION void FzLink::fz_set_link_rect(const FzRect& rect) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_link_rect()\n";
	}
	#endif
	mupdf::fz_set_link_rect(*this, rect);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzLink_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_set_link_uri()`.  */
FZ_FUNCTION void FzLink::fz_set_link_uri(const char *uri) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_link_uri()\n";
	}
	#endif
	mupdf::fz_set_link_uri(*this, uri);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzLink_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/** Custom method. */
FZ_FUNCTION FzLinkIterator FzLink::begin()
{
	auto ret = FzLinkIterator(*this);
	#ifndef NDEBUG
	#if 1
	if (s_check_refs)
	{
		s_FzLink_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#endif
	return ret;
}

/** Custom method. */
FZ_FUNCTION FzLinkIterator FzLink::end()
{
	auto ret = FzLinkIterator(NULL);
	#ifndef NDEBUG
	#if 1
	if (s_check_refs)
	{
		s_FzLink_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#endif
	return ret;
}

FZ_FUNCTION FzLink::FzLink(::fz_link* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzLink_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION int FzLink::refs()
{
	return m_internal->refs;
}

FZ_FUNCTION FzLink FzLink::next()
{
	ll_fz_keep_link(m_internal->next);
	return m_internal->next;
}

FZ_FUNCTION ::fz_rect FzLink::rect()
{
	return m_internal->rect;
}

FZ_FUNCTION const char *FzLink::uri()
{
	return m_internal->uri;
}

FZ_FUNCTION FzLink::~FzLink()
{
	ll_fz_drop_link(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzLink_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzLink::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzLink::s_num_instances = 0;

/* .extra_cpp for fz_link. */

FZ_FUNCTION FzLinkIterator::FzLinkIterator(const FzLink& item)
: m_item( item)
{
}
FZ_FUNCTION FzLinkIterator& FzLinkIterator::operator++()
{
	ll_fz_keep_link(m_item.m_internal->next);
	m_item = FzLink(m_item.m_internal->next);
	return *this;
}
FZ_FUNCTION bool FzLinkIterator::operator==( const FzLinkIterator& rhs)
{
	return m_item.m_internal == rhs.m_item.m_internal;
}
FZ_FUNCTION bool FzLinkIterator::operator!=( const FzLinkIterator& rhs)
{
	return m_item.m_internal != rhs.m_item.m_internal;
}
FZ_FUNCTION FzLink FzLinkIterator::operator*()
{
	return m_item;
}
FZ_FUNCTION FzLink* FzLinkIterator::operator->()
{
	return &m_item;
}


/* Implementation of methods for FzLinkDest (wrapper for fz_link_dest). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzLinkDest::FzLinkDest()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::pdf_new_uri_from_explicit_dest()`.  */
FZ_FUNCTION char *FzLinkDest::pdf_new_uri_from_explicit_dest() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_uri_from_explicit_dest()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_uri_from_explicit_dest(*this);
	return ret;
}

FZ_FUNCTION FzLinkDest::FzLinkDest(::fz_link_dest* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzLinkDest::~FzLinkDest()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzLinkDest::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzLinkDest::s_num_instances = 0;


/* Implementation of methods for FzLocation (wrapper for fz_location). */

/* Constructor using `fz_make_location()`. */
FZ_FUNCTION FzLocation::FzLocation(int chapter, int page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_make_location()\n";
	}
	#endif
	*(::fz_location*) &this->chapter = ll_fz_make_location(chapter, page);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets each member to default value. */
FZ_FUNCTION FzLocation::FzLocation()
{
	this->chapter = {};
	this->page = {};
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzLocation::FzLocation(const ::fz_location* internal)
{
	assert( internal);
	this->chapter = internal->chapter;
	this->page = internal->page;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzLocation::FzLocation(const ::fz_location internal)
{
	this->chapter = internal.chapter;
	this->page = internal.page;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::fz_location`. */
FZ_FUNCTION ::fz_location* FzLocation::internal()
{
	auto ret = (::fz_location*) &this->chapter;
	return ret;
}

/** Constructor using raw copy of pre-existing `::fz_location`. */
FZ_FUNCTION const ::fz_location* FzLocation::internal() const
{
	auto ret = (const ::fz_location*) &this->chapter;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION FzLocation::~FzLocation()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzLocation::s_num_instances = 0;

FZ_FUNCTION std::string FzLocation::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool FzLocation::operator==(const FzLocation& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool FzLocation::operator!=(const FzLocation& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for FzLocksContext (wrapper for fz_locks_context). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzLocksContext::FzLocksContext()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzLocksContext::FzLocksContext(::fz_locks_context* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzLocksContext::~FzLocksContext()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzLocksContext::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzLocksContext::s_num_instances = 0;


/* Implementation of methods for FzMatrix (wrapper for fz_matrix). */

/* Constructor using `fz_make_matrix()`. */
FZ_FUNCTION FzMatrix::FzMatrix(float a, float b, float c, float d, float e, float f)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_make_matrix()\n";
	}
	#endif
	*(::fz_matrix*) &this->a = ll_fz_make_matrix(a, b, c, d, e, f);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION FzMatrix::FzMatrix()
: a(1), b(0), c(0), d(1), e(0), f(0)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Class-aware wrapper for `::fz_concat()`.  */
FZ_FUNCTION FzMatrix FzMatrix::fz_concat(const FzMatrix& left, const FzMatrix& right)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_concat()\n";
	}
	#endif
	auto ret = mupdf::fz_concat(left, right);
	return ret;
}

/* Class-aware wrapper for `::fz_scale()`.  */
FZ_FUNCTION FzMatrix FzMatrix::fz_scale(float sx, float sy)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_scale()\n";
	}
	#endif
	auto ret = mupdf::fz_scale(sx, sy);
	return ret;
}

/* Class-aware wrapper for `::fz_shear()`.  */
FZ_FUNCTION FzMatrix FzMatrix::fz_shear(float sx, float sy)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_shear()\n";
	}
	#endif
	auto ret = mupdf::fz_shear(sx, sy);
	return ret;
}

/* Class-aware wrapper for `::fz_rotate()`.  */
FZ_FUNCTION FzMatrix FzMatrix::fz_rotate(float degrees)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_rotate()\n";
	}
	#endif
	auto ret = mupdf::fz_rotate(degrees);
	return ret;
}

/* Class-aware wrapper for `::fz_translate()`.  */
FZ_FUNCTION FzMatrix FzMatrix::fz_translate(float tx, float ty)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_translate()\n";
	}
	#endif
	auto ret = mupdf::fz_translate(tx, ty);
	return ret;
}

/* Class-aware wrapper for `::fz_transform_page()`.  */
FZ_FUNCTION FzMatrix FzMatrix::fz_transform_page(const FzRect& mediabox, float resolution, float rotate)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_transform_page()\n";
	}
	#endif
	auto ret = mupdf::fz_transform_page(mediabox, resolution, rotate);
	return ret;
}

/* Class-aware wrapper for `::fz_concat()`.  */
FZ_FUNCTION FzMatrix FzMatrix::fz_concat(const FzMatrix& right)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_concat()\n";
	}
	#endif
	auto ret = mupdf::fz_concat(*this, right);
	return ret;
}

/* Class-aware wrapper for `::fz_invert_matrix()`.  */
FZ_FUNCTION FzMatrix FzMatrix::fz_invert_matrix()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_invert_matrix()\n";
	}
	#endif
	auto ret = mupdf::fz_invert_matrix(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_is_identity()`.  */
FZ_FUNCTION int FzMatrix::fz_is_identity()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_identity()\n";
	}
	#endif
	auto ret = mupdf::fz_is_identity(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_is_rectilinear()`.  */
FZ_FUNCTION int FzMatrix::fz_is_rectilinear()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_rectilinear()\n";
	}
	#endif
	auto ret = mupdf::fz_is_rectilinear(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_matrix_expansion()`.  */
FZ_FUNCTION float FzMatrix::fz_matrix_expansion()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_matrix_expansion()\n";
	}
	#endif
	auto ret = mupdf::fz_matrix_expansion(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_matrix_max_expansion()`.  */
FZ_FUNCTION float FzMatrix::fz_matrix_max_expansion()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_matrix_max_expansion()\n";
	}
	#endif
	auto ret = mupdf::fz_matrix_max_expansion(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_post_scale()`.  */
FZ_FUNCTION FzMatrix FzMatrix::fz_post_scale(float sx, float sy)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_post_scale()\n";
	}
	#endif
	auto ret = mupdf::fz_post_scale(*this, sx, sy);
	return ret;
}

/* Class-aware wrapper for `::fz_pre_rotate()`.  */
FZ_FUNCTION FzMatrix FzMatrix::fz_pre_rotate(float degrees)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pre_rotate()\n";
	}
	#endif
	auto ret = mupdf::fz_pre_rotate(*this, degrees);
	return ret;
}

/* Class-aware wrapper for `::fz_pre_scale()`.  */
FZ_FUNCTION FzMatrix FzMatrix::fz_pre_scale(float sx, float sy)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pre_scale()\n";
	}
	#endif
	auto ret = mupdf::fz_pre_scale(*this, sx, sy);
	return ret;
}

/* Class-aware wrapper for `::fz_pre_shear()`.  */
FZ_FUNCTION FzMatrix FzMatrix::fz_pre_shear(float sx, float sy)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pre_shear()\n";
	}
	#endif
	auto ret = mupdf::fz_pre_shear(*this, sx, sy);
	return ret;
}

/* Class-aware wrapper for `::fz_pre_translate()`.  */
FZ_FUNCTION FzMatrix FzMatrix::fz_pre_translate(float tx, float ty)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pre_translate()\n";
	}
	#endif
	auto ret = mupdf::fz_pre_translate(*this, tx, ty);
	return ret;
}

/* Class-aware wrapper for `::fz_subpixel_adjust()`.  */
FZ_FUNCTION float FzMatrix::fz_subpixel_adjust(FzMatrix& subpix_ctm, unsigned char *qe, unsigned char *qf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_subpixel_adjust()\n";
	}
	#endif
	auto ret = mupdf::fz_subpixel_adjust(*this, subpix_ctm, qe, qf);
	return ret;
}

/* Class-aware wrapper for `::fz_try_invert_matrix()`.  */
FZ_FUNCTION int FzMatrix::fz_try_invert_matrix(const FzMatrix& src)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_try_invert_matrix()\n";
	}
	#endif
	auto ret = mupdf::fz_try_invert_matrix(*this, src);
	return ret;
}

FZ_FUNCTION FzMatrix::FzMatrix(const ::fz_matrix* internal)
{
	assert( internal);
	this->a = internal->a;
	this->b = internal->b;
	this->c = internal->c;
	this->d = internal->d;
	this->e = internal->e;
	this->f = internal->f;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzMatrix::FzMatrix(const ::fz_matrix internal)
{
	this->a = internal.a;
	this->b = internal.b;
	this->c = internal.c;
	this->d = internal.d;
	this->e = internal.e;
	this->f = internal.f;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::fz_matrix`. */
FZ_FUNCTION ::fz_matrix* FzMatrix::internal()
{
	auto ret = (::fz_matrix*) &this->a;
	return ret;
}

/** Constructor using raw copy of pre-existing `::fz_matrix`. */
FZ_FUNCTION const ::fz_matrix* FzMatrix::internal() const
{
	auto ret = (const ::fz_matrix*) &this->a;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION FzMatrix::~FzMatrix()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzMatrix::s_num_instances = 0;

FZ_FUNCTION std::string FzMatrix::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool FzMatrix::operator==(const FzMatrix& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool FzMatrix::operator!=(const FzMatrix& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for FzMd5 (wrapper for fz_md5). */

/** Custom constructor. */
FZ_FUNCTION FzMd5::FzMd5()
{
	ll_fz_md5_init( &m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Class-aware wrapper for `::fz_md5_final()`.  */
FZ_FUNCTION void FzMd5::fz_md5_final(unsigned char digest[16])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_md5_final()\n";
	}
	#endif
	mupdf::fz_md5_final(*this, digest);
}

/* Class-aware wrapper for `::fz_md5_final2()`.  */
FZ_FUNCTION std::vector<unsigned char> FzMd5::fz_md5_final2()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_md5_final2()\n";
	}
	#endif
	auto ret = mupdf::fz_md5_final2(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_md5_init()`.  */
FZ_FUNCTION void FzMd5::fz_md5_init()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_md5_init()\n";
	}
	#endif
	mupdf::fz_md5_init(*this);
}

/* Class-aware wrapper for `::fz_md5_update()`.  */
FZ_FUNCTION void FzMd5::fz_md5_update(const unsigned char *input, size_t inlen)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_md5_update()\n";
	}
	#endif
	mupdf::fz_md5_update(*this, input, inlen);
}

/* Class-aware wrapper for `::fz_md5_update_int64()`.  */
FZ_FUNCTION void FzMd5::fz_md5_update_int64(int64_t i)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_md5_update_int64()\n";
	}
	#endif
	mupdf::fz_md5_update_int64(*this, i);
}

FZ_FUNCTION FzMd5::FzMd5(const ::fz_md5* internal)
: m_internal(*internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION uint32_t FzMd5::lo()
{
	return m_internal.lo;
}

FZ_FUNCTION uint32_t FzMd5::hi()
{
	return m_internal.hi;
}

FZ_FUNCTION uint32_t FzMd5::a()
{
	return m_internal.a;
}

FZ_FUNCTION uint32_t FzMd5::b()
{
	return m_internal.b;
}

FZ_FUNCTION uint32_t FzMd5::c()
{
	return m_internal.c;
}

FZ_FUNCTION uint32_t FzMd5::d()
{
	return m_internal.d;
}

FZ_FUNCTION unsigned char * FzMd5::buffer()
{
	return m_internal.buffer;
}

#ifndef NDEBUG
FZ_FUNCTION FzMd5::~FzMd5()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzMd5::s_num_instances = 0;

FZ_FUNCTION std::string FzMd5::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool FzMd5::operator==(const FzMd5& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool FzMd5::operator!=(const FzMd5& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for FzOutline (wrapper for fz_outline). */

#ifndef NDEBUG
static RefsCheck<::fz_outline, FzOutline> s_FzOutline_refs_check(offsetof(::fz_outline, refs), 32);
#endif

/* Constructor using `fz_load_outline()`. */
FZ_FUNCTION FzOutline::FzOutline(const FzDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_outline()\n";
	}
	#endif
	this->m_internal = ll_fz_load_outline(doc.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzOutline_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_load_outline_from_iterator()`. */
FZ_FUNCTION FzOutline::FzOutline(const FzOutlineIterator& iter)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_outline_from_iterator()\n";
	}
	#endif
	this->m_internal = ll_fz_load_outline_from_iterator(iter.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzOutline_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_outline()`. */
FZ_FUNCTION FzOutline::FzOutline()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_outline()\n";
	}
	#endif
	this->m_internal = ll_fz_new_outline();
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzOutline_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_outline()`. */
FZ_FUNCTION FzOutline::FzOutline(const FzOutline& rhs)
: m_internal(ll_fz_keep_outline(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_outline(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzOutline_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_outline()` and `fz_drop_outline()`. */
FZ_FUNCTION FzOutline& FzOutline::operator=(const FzOutline& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_outline(this->m_internal)"
				<< " and ll_fz_keep_outline(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_outline(this->m_internal);
	ll_fz_keep_outline(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzOutline_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzOutline_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

FZ_FUNCTION FzOutline::FzOutline(::fz_outline* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzOutline_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION int FzOutline::refs()
{
	return m_internal->refs;
}

FZ_FUNCTION const char *FzOutline::title()
{
	return m_internal->title;
}

FZ_FUNCTION const char *FzOutline::uri()
{
	return m_internal->uri;
}

FZ_FUNCTION ::fz_location FzOutline::page()
{
	return m_internal->page;
}

FZ_FUNCTION float FzOutline::x()
{
	return m_internal->x;
}

FZ_FUNCTION float FzOutline::y()
{
	return m_internal->y;
}

FZ_FUNCTION FzOutline FzOutline::next()
{
	ll_fz_keep_outline(m_internal->next);
	return m_internal->next;
}

FZ_FUNCTION FzOutline FzOutline::down()
{
	ll_fz_keep_outline(m_internal->down);
	return m_internal->down;
}

FZ_FUNCTION int FzOutline::is_open()
{
	return m_internal->is_open;
}

FZ_FUNCTION FzOutline::~FzOutline()
{
	ll_fz_drop_outline(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzOutline_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzOutline::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzOutline::s_num_instances = 0;


/* Implementation of methods for FzOutlineItem (wrapper for fz_outline_item). */

/** Default constructor, sets each member to default value. */
FZ_FUNCTION FzOutlineItem::FzOutlineItem()
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
#ifndef NDEBUG
FZ_FUNCTION FzOutlineItem::~FzOutlineItem()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzOutlineItem::s_num_instances = 0;

/* .extra_cpp for fz_outline_item. */

FZ_FUNCTION FzOutlineItem::FzOutlineItem(const ::fz_outline_item* item)
{
	if (item)
	{
		m_valid = true;
		m_title = item->title;
		m_uri = item->uri;
		m_is_open = item->is_open;
	}
	else
	{
		m_valid = false;
	}
}
FZ_FUNCTION bool FzOutlineItem::valid() const
{
	return m_valid;
}
FZ_FUNCTION const std::string& FzOutlineItem::title() const
{
	if (!m_valid) throw FzErrorGeneric("fz_outline_item is invalid");
	return m_title;
}
FZ_FUNCTION const std::string& FzOutlineItem::uri() const
{
	if (!m_valid) throw FzErrorGeneric("fz_outline_item is invalid");
	return m_uri;
}
FZ_FUNCTION int FzOutlineItem::is_open() const
{
	if (!m_valid) throw FzErrorGeneric("fz_outline_item is invalid");
	return m_is_open;
}

/* Implementation of methods for FzOutlineIterator (wrapper for fz_outline_iterator). */

/* Constructor using `fz_new_outline_iterator()`. */
FZ_FUNCTION FzOutlineIterator::FzOutlineIterator(const FzDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_outline_iterator()\n";
	}
	#endif
	this->m_internal = ll_fz_new_outline_iterator(doc.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_outline_iterator_of_size()`. */
FZ_FUNCTION FzOutlineIterator::FzOutlineIterator(size_t size, const FzDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_outline_iterator_of_size()\n";
	}
	#endif
	this->m_internal = ll_fz_new_outline_iterator_of_size(size, doc.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_outline_iterator()`. */
FZ_FUNCTION FzOutlineIterator::FzOutlineIterator(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_outline_iterator()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_outline_iterator(doc.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzOutlineIterator::FzOutlineIterator()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_load_outline_from_iterator()`.  */
FZ_FUNCTION FzOutline FzOutlineIterator::fz_load_outline_from_iterator() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_outline_from_iterator()\n";
	}
	#endif
	auto ret = mupdf::fz_load_outline_from_iterator(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_outline_iterator_delete()`.  */
FZ_FUNCTION int FzOutlineIterator::fz_outline_iterator_delete() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_outline_iterator_delete()\n";
	}
	#endif
	auto ret = mupdf::fz_outline_iterator_delete(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_outline_iterator_down()`.  */
FZ_FUNCTION int FzOutlineIterator::fz_outline_iterator_down() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_outline_iterator_down()\n";
	}
	#endif
	auto ret = mupdf::fz_outline_iterator_down(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_outline_iterator_item()`.  */
FZ_FUNCTION FzOutlineItem FzOutlineIterator::fz_outline_iterator_item() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_outline_iterator_item()\n";
	}
	#endif
	auto ret = mupdf::fz_outline_iterator_item(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_outline_iterator_next()`.  */
FZ_FUNCTION int FzOutlineIterator::fz_outline_iterator_next() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_outline_iterator_next()\n";
	}
	#endif
	auto ret = mupdf::fz_outline_iterator_next(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_outline_iterator_prev()`.  */
FZ_FUNCTION int FzOutlineIterator::fz_outline_iterator_prev() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_outline_iterator_prev()\n";
	}
	#endif
	auto ret = mupdf::fz_outline_iterator_prev(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_outline_iterator_up()`.  */
FZ_FUNCTION int FzOutlineIterator::fz_outline_iterator_up() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_outline_iterator_up()\n";
	}
	#endif
	auto ret = mupdf::fz_outline_iterator_up(*this);
	return ret;
}

/** Custom method. */
FZ_FUNCTION int FzOutlineIterator::fz_outline_iterator_insert(FzOutlineItem& item)
{
	/* Create a temporary fz_outline_item. */
	::fz_outline_item item2;
	item2.title = (char*) item.title().c_str();
	item2.uri = (char*) item.uri().c_str();
	item2.is_open = item.is_open();
	return ll_fz_outline_iterator_insert(m_internal, &item2);
}

/** Custom method. */
FZ_FUNCTION void FzOutlineIterator::fz_outline_iterator_update(FzOutlineItem& item)
{
	/* Create a temporary fz_outline_item. */
	::fz_outline_item item2;
	item2.title = (char*) item.title().c_str();
	item2.uri = (char*) item.uri().c_str();
	item2.is_open = item.is_open();
	return ll_fz_outline_iterator_update(m_internal, &item2);
}

FZ_FUNCTION FzOutlineIterator::FzOutlineIterator(::fz_outline_iterator* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzOutlineIterator::~FzOutlineIterator()
{
	ll_fz_drop_outline_iterator(m_internal);
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzOutlineIterator::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzOutlineIterator::s_num_instances = 0;


/* Implementation of methods for FzOutput (wrapper for fz_output). */

/* Constructor using `fz_new_arc4_output()`. */
FZ_FUNCTION FzOutput::FzOutput(const FzOutput& chain, unsigned char *key, size_t keylen)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_arc4_output()\n";
	}
	#endif
	this->m_internal = ll_fz_new_arc4_output(chain.m_internal, key, keylen);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_deflate_output()`. */
FZ_FUNCTION FzOutput::FzOutput(const FzOutput& chain, int effort, int raw)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_deflate_output()\n";
	}
	#endif
	this->m_internal = ll_fz_new_deflate_output(chain.m_internal, effort, raw);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_log_for_module()`. */
FZ_FUNCTION FzOutput::FzOutput(const char *module)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_log_for_module()\n";
	}
	#endif
	this->m_internal = ll_fz_new_log_for_module(module);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_output()`. */
FZ_FUNCTION FzOutput::FzOutput(int bufsiz, void *state, ::fz_output_write_fn *write, ::fz_output_close_fn *close, ::fz_output_drop_fn *drop)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_output()\n";
	}
	#endif
	this->m_internal = ll_fz_new_output(bufsiz, state, write, close, drop);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_output_with_buffer()`. */
FZ_FUNCTION FzOutput::FzOutput(const FzBuffer& buf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_output_with_buffer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_output_with_buffer(buf.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_output_with_path()`. */
FZ_FUNCTION FzOutput::FzOutput(const char *filename, int append)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_output_with_path()\n";
	}
	#endif
	this->m_internal = ll_fz_new_output_with_path(filename, append);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION FzOutput::FzOutput(Fixed out)
{
	if (0)  {}
	else if (out == Fixed_STDOUT) {
		m_internal = ll_fz_stdout();
	}
	else if (out == Fixed_STDERR) {
		m_internal = ll_fz_stderr();
	}
	else {
		throw FzErrorAbort("Unrecognised Fixed value");
	}
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION FzOutput::FzOutput(const FzOutput& chain, Filter filter)
{
	if (0)  {}
	else if (filter == Filter_HEX) {
		m_internal = ll_fz_new_asciihex_output(chain.m_internal);
	}
	else if (filter == Filter_85) {
		m_internal = ll_fz_new_ascii85_output(chain.m_internal);
	}
	else if (filter == Filter_RLE) {
		m_internal = ll_fz_new_rle_output(chain.m_internal);
	}
	else {
		throw FzErrorAbort("Unrecognised Filter value");
	}
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Class-aware wrapper for `::fz_close_output()`.  */
FZ_FUNCTION void FzOutput::fz_close_output() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_close_output()\n";
	}
	#endif
	mupdf::fz_close_output(*this);
}

/* Class-aware wrapper for `::fz_debug_store()`.  */
FZ_FUNCTION void FzOutput::fz_debug_store() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_debug_store()\n";
	}
	#endif
	mupdf::fz_debug_store(*this);
}

/* Class-aware wrapper for `::fz_dump_glyph_cache_stats()`.  */
FZ_FUNCTION void FzOutput::fz_dump_glyph_cache_stats() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dump_glyph_cache_stats()\n";
	}
	#endif
	mupdf::fz_dump_glyph_cache_stats(*this);
}

/* Class-aware wrapper for `::fz_flush_output()`.  */
FZ_FUNCTION void FzOutput::fz_flush_output() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_flush_output()\n";
	}
	#endif
	mupdf::fz_flush_output(*this);
}

/* Class-aware wrapper for `::fz_new_svg_device()`.  */
FZ_FUNCTION FzDevice FzOutput::fz_new_svg_device(float page_width, float page_height, int text_format, int reuse_images) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_svg_device()\n";
	}
	#endif
	auto ret = mupdf::fz_new_svg_device(*this, page_width, page_height, text_format, reuse_images);
	return ret;
}

/* Class-aware wrapper for `::fz_new_svg_device_with_id()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_new_svg_device_with_id(float page_width, float page_height, int text_format, int reuse_images)` => `(fz_device *, int id)`
	 */
FZ_FUNCTION FzDevice FzOutput::fz_new_svg_device_with_id(float page_width, float page_height, int text_format, int reuse_images, int *id) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_svg_device_with_id()\n";
	}
	#endif
	auto ret = mupdf::fz_new_svg_device_with_id(*this, page_width, page_height, text_format, reuse_images, id);
	return ret;
}

/* Class-aware wrapper for `::fz_new_trace_device()`.  */
FZ_FUNCTION FzDevice FzOutput::fz_new_trace_device() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_trace_device()\n";
	}
	#endif
	auto ret = mupdf::fz_new_trace_device(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_new_xmltext_device()`.  */
FZ_FUNCTION FzDevice FzOutput::fz_new_xmltext_device() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_xmltext_device()\n";
	}
	#endif
	auto ret = mupdf::fz_new_xmltext_device(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_output_supports_stream()`.  */
FZ_FUNCTION int FzOutput::fz_output_supports_stream() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_output_supports_stream()\n";
	}
	#endif
	auto ret = mupdf::fz_output_supports_stream(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_output_xml()`.  */
FZ_FUNCTION void FzOutput::fz_output_xml(const FzXml& item, int level) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_output_xml()\n";
	}
	#endif
	mupdf::fz_output_xml(*this, item, level);
}

/* Class-aware wrapper for `::fz_print_stext_header_as_html()`.  */
FZ_FUNCTION void FzOutput::fz_print_stext_header_as_html() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_print_stext_header_as_html()\n";
	}
	#endif
	mupdf::fz_print_stext_header_as_html(*this);
}

/* Class-aware wrapper for `::fz_print_stext_header_as_xhtml()`.  */
FZ_FUNCTION void FzOutput::fz_print_stext_header_as_xhtml() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_print_stext_header_as_xhtml()\n";
	}
	#endif
	mupdf::fz_print_stext_header_as_xhtml(*this);
}

/* Class-aware wrapper for `::fz_print_stext_page_as_html()`.  */
FZ_FUNCTION void FzOutput::fz_print_stext_page_as_html(const FzStextPage& page, int id) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_print_stext_page_as_html()\n";
	}
	#endif
	mupdf::fz_print_stext_page_as_html(*this, page, id);
}

/* Class-aware wrapper for `::fz_print_stext_page_as_json()`.  */
FZ_FUNCTION void FzOutput::fz_print_stext_page_as_json(const FzStextPage& page, float scale) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_print_stext_page_as_json()\n";
	}
	#endif
	mupdf::fz_print_stext_page_as_json(*this, page, scale);
}

/* Class-aware wrapper for `::fz_print_stext_page_as_text()`.  */
FZ_FUNCTION void FzOutput::fz_print_stext_page_as_text(const FzStextPage& page) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_print_stext_page_as_text()\n";
	}
	#endif
	mupdf::fz_print_stext_page_as_text(*this, page);
}

/* Class-aware wrapper for `::fz_print_stext_page_as_xhtml()`.  */
FZ_FUNCTION void FzOutput::fz_print_stext_page_as_xhtml(const FzStextPage& page, int id) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_print_stext_page_as_xhtml()\n";
	}
	#endif
	mupdf::fz_print_stext_page_as_xhtml(*this, page, id);
}

/* Class-aware wrapper for `::fz_print_stext_page_as_xml()`.  */
FZ_FUNCTION void FzOutput::fz_print_stext_page_as_xml(const FzStextPage& page, int id) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_print_stext_page_as_xml()\n";
	}
	#endif
	mupdf::fz_print_stext_page_as_xml(*this, page, id);
}

/* Class-aware wrapper for `::fz_print_stext_trailer_as_html()`.  */
FZ_FUNCTION void FzOutput::fz_print_stext_trailer_as_html() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_print_stext_trailer_as_html()\n";
	}
	#endif
	mupdf::fz_print_stext_trailer_as_html(*this);
}

/* Class-aware wrapper for `::fz_print_stext_trailer_as_xhtml()`.  */
FZ_FUNCTION void FzOutput::fz_print_stext_trailer_as_xhtml() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_print_stext_trailer_as_xhtml()\n";
	}
	#endif
	mupdf::fz_print_stext_trailer_as_xhtml(*this);
}

/* Class-aware wrapper for `::fz_reset_output()`.  */
FZ_FUNCTION void FzOutput::fz_reset_output() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_reset_output()\n";
	}
	#endif
	mupdf::fz_reset_output(*this);
}

/* Class-aware wrapper for `::fz_seek_output()`.  */
FZ_FUNCTION void FzOutput::fz_seek_output(int64_t off, int whence) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_seek_output()\n";
	}
	#endif
	mupdf::fz_seek_output(*this, off, whence);
}

/* Class-aware wrapper for `::fz_set_stddbg()`.  */
FZ_FUNCTION void FzOutput::fz_set_stddbg() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_stddbg()\n";
	}
	#endif
	mupdf::fz_set_stddbg(*this);
}

/* Class-aware wrapper for `::fz_stream_from_output()`.  */
FZ_FUNCTION FzStream FzOutput::fz_stream_from_output() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_stream_from_output()\n";
	}
	#endif
	auto ret = mupdf::fz_stream_from_output(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_tell_output()`.  */
FZ_FUNCTION int64_t FzOutput::fz_tell_output() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_tell_output()\n";
	}
	#endif
	auto ret = mupdf::fz_tell_output(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_truncate_output()`.  */
FZ_FUNCTION void FzOutput::fz_truncate_output() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_truncate_output()\n";
	}
	#endif
	mupdf::fz_truncate_output(*this);
}

/* Class-aware wrapper for `::fz_write_base64()`.  */
FZ_FUNCTION void FzOutput::fz_write_base64(const unsigned char *data, size_t size, int newline) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_base64()\n";
	}
	#endif
	mupdf::fz_write_base64(*this, data, size, newline);
}

/* Class-aware wrapper for `::fz_write_base64_buffer()`.  */
FZ_FUNCTION void FzOutput::fz_write_base64_buffer(const FzBuffer& data, int newline) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_base64_buffer()\n";
	}
	#endif
	mupdf::fz_write_base64_buffer(*this, data, newline);
}

/* Class-aware wrapper for `::fz_write_bitmap_as_pbm()`.  */
FZ_FUNCTION void FzOutput::fz_write_bitmap_as_pbm(const FzBitmap& bitmap) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_bitmap_as_pbm()\n";
	}
	#endif
	mupdf::fz_write_bitmap_as_pbm(*this, bitmap);
}

/* Class-aware wrapper for `::fz_write_bitmap_as_pcl()`.  */
FZ_FUNCTION void FzOutput::fz_write_bitmap_as_pcl(const FzBitmap& bitmap, const FzPclOptions& pcl) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_bitmap_as_pcl()\n";
	}
	#endif
	mupdf::fz_write_bitmap_as_pcl(*this, bitmap, pcl);
}

/* Class-aware wrapper for `::fz_write_bitmap_as_pkm()`.  */
FZ_FUNCTION void FzOutput::fz_write_bitmap_as_pkm(const FzBitmap& bitmap) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_bitmap_as_pkm()\n";
	}
	#endif
	mupdf::fz_write_bitmap_as_pkm(*this, bitmap);
}

/* Class-aware wrapper for `::fz_write_bitmap_as_pwg()`.  */
FZ_FUNCTION void FzOutput::fz_write_bitmap_as_pwg(const FzBitmap& bitmap, FzPwgOptions& pwg) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_bitmap_as_pwg()\n";
	}
	#endif
	mupdf::fz_write_bitmap_as_pwg(*this, bitmap, pwg);
}

/* Class-aware wrapper for `::fz_write_bitmap_as_pwg_page()`.  */
FZ_FUNCTION void FzOutput::fz_write_bitmap_as_pwg_page(const FzBitmap& bitmap, FzPwgOptions& pwg) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_bitmap_as_pwg_page()\n";
	}
	#endif
	mupdf::fz_write_bitmap_as_pwg_page(*this, bitmap, pwg);
}

/* Class-aware wrapper for `::fz_write_bits()`.  */
FZ_FUNCTION void FzOutput::fz_write_bits(unsigned int data, int num_bits) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_bits()\n";
	}
	#endif
	mupdf::fz_write_bits(*this, data, num_bits);
}

/* Class-aware wrapper for `::fz_write_bits_sync()`.  */
FZ_FUNCTION void FzOutput::fz_write_bits_sync() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_bits_sync()\n";
	}
	#endif
	mupdf::fz_write_bits_sync(*this);
}

/* Class-aware wrapper for `::fz_write_buffer()`.  */
FZ_FUNCTION void FzOutput::fz_write_buffer(const FzBuffer& data) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_buffer()\n";
	}
	#endif
	mupdf::fz_write_buffer(*this, data);
}

/* Class-aware wrapper for `::fz_write_byte()`.  */
FZ_FUNCTION void FzOutput::fz_write_byte(unsigned char x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_byte()\n";
	}
	#endif
	mupdf::fz_write_byte(*this, x);
}

/* Class-aware wrapper for `::fz_write_char()`.  */
FZ_FUNCTION void FzOutput::fz_write_char(char x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_char()\n";
	}
	#endif
	mupdf::fz_write_char(*this, x);
}

/* Class-aware wrapper for `::fz_write_data()`.  */
FZ_FUNCTION void FzOutput::fz_write_data(const void *data, size_t size) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_data()\n";
	}
	#endif
	mupdf::fz_write_data(*this, data, size);
}

/* Class-aware wrapper for `::fz_write_float_be()`.  */
FZ_FUNCTION void FzOutput::fz_write_float_be(float f) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_float_be()\n";
	}
	#endif
	mupdf::fz_write_float_be(*this, f);
}

/* Class-aware wrapper for `::fz_write_float_le()`.  */
FZ_FUNCTION void FzOutput::fz_write_float_le(float f) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_float_le()\n";
	}
	#endif
	mupdf::fz_write_float_le(*this, f);
}

/* Class-aware wrapper for `::fz_write_image_as_data_uri()`.  */
FZ_FUNCTION void FzOutput::fz_write_image_as_data_uri(const FzImage& image) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_image_as_data_uri()\n";
	}
	#endif
	mupdf::fz_write_image_as_data_uri(*this, image);
}

/* Class-aware wrapper for `::fz_write_int16_be()`.  */
FZ_FUNCTION void FzOutput::fz_write_int16_be(int x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_int16_be()\n";
	}
	#endif
	mupdf::fz_write_int16_be(*this, x);
}

/* Class-aware wrapper for `::fz_write_int16_le()`.  */
FZ_FUNCTION void FzOutput::fz_write_int16_le(int x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_int16_le()\n";
	}
	#endif
	mupdf::fz_write_int16_le(*this, x);
}

/* Class-aware wrapper for `::fz_write_int32_be()`.  */
FZ_FUNCTION void FzOutput::fz_write_int32_be(int x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_int32_be()\n";
	}
	#endif
	mupdf::fz_write_int32_be(*this, x);
}

/* Class-aware wrapper for `::fz_write_int32_le()`.  */
FZ_FUNCTION void FzOutput::fz_write_int32_le(int x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_int32_le()\n";
	}
	#endif
	mupdf::fz_write_int32_le(*this, x);
}

/* Class-aware wrapper for `::fz_write_pixmap_as_data_uri()`.  */
FZ_FUNCTION void FzOutput::fz_write_pixmap_as_data_uri(const FzPixmap& pixmap) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_data_uri()\n";
	}
	#endif
	mupdf::fz_write_pixmap_as_data_uri(*this, pixmap);
}

/* Class-aware wrapper for `::fz_write_pixmap_as_jpeg()`.  */
FZ_FUNCTION void FzOutput::fz_write_pixmap_as_jpeg(const FzPixmap& pix, int quality, int invert_cmyk) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_jpeg()\n";
	}
	#endif
	mupdf::fz_write_pixmap_as_jpeg(*this, pix, quality, invert_cmyk);
}

/* Class-aware wrapper for `::fz_write_pixmap_as_jpx()`.  */
FZ_FUNCTION void FzOutput::fz_write_pixmap_as_jpx(const FzPixmap& pix, int quality) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_jpx()\n";
	}
	#endif
	mupdf::fz_write_pixmap_as_jpx(*this, pix, quality);
}

/* Class-aware wrapper for `::fz_write_pixmap_as_pam()`.  */
FZ_FUNCTION void FzOutput::fz_write_pixmap_as_pam(const FzPixmap& pixmap) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_pam()\n";
	}
	#endif
	mupdf::fz_write_pixmap_as_pam(*this, pixmap);
}

/* Class-aware wrapper for `::fz_write_pixmap_as_pcl()`.  */
FZ_FUNCTION void FzOutput::fz_write_pixmap_as_pcl(const FzPixmap& pixmap, const FzPclOptions& pcl) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_pcl()\n";
	}
	#endif
	mupdf::fz_write_pixmap_as_pcl(*this, pixmap, pcl);
}

/* Class-aware wrapper for `::fz_write_pixmap_as_pclm()`.  */
FZ_FUNCTION void FzOutput::fz_write_pixmap_as_pclm(const FzPixmap& pixmap, const FzPclmOptions& options) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_pclm()\n";
	}
	#endif
	mupdf::fz_write_pixmap_as_pclm(*this, pixmap, options);
}

/* Class-aware wrapper for `::fz_write_pixmap_as_pdfocr()`.  */
FZ_FUNCTION void FzOutput::fz_write_pixmap_as_pdfocr(const FzPixmap& pixmap, FzPdfocrOptions& options) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_pdfocr()\n";
	}
	#endif
	mupdf::fz_write_pixmap_as_pdfocr(*this, pixmap, options);
}

/* Class-aware wrapper for `::fz_write_pixmap_as_png()`.  */
FZ_FUNCTION void FzOutput::fz_write_pixmap_as_png(const FzPixmap& pixmap) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_png()\n";
	}
	#endif
	mupdf::fz_write_pixmap_as_png(*this, pixmap);
}

/* Class-aware wrapper for `::fz_write_pixmap_as_pnm()`.  */
FZ_FUNCTION void FzOutput::fz_write_pixmap_as_pnm(const FzPixmap& pixmap) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_pnm()\n";
	}
	#endif
	mupdf::fz_write_pixmap_as_pnm(*this, pixmap);
}

/* Class-aware wrapper for `::fz_write_pixmap_as_ps()`.  */
FZ_FUNCTION void FzOutput::fz_write_pixmap_as_ps(const FzPixmap& pixmap) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_ps()\n";
	}
	#endif
	mupdf::fz_write_pixmap_as_ps(*this, pixmap);
}

/* Class-aware wrapper for `::fz_write_pixmap_as_psd()`.  */
FZ_FUNCTION void FzOutput::fz_write_pixmap_as_psd(const FzPixmap& pixmap) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_psd()\n";
	}
	#endif
	mupdf::fz_write_pixmap_as_psd(*this, pixmap);
}

/* Class-aware wrapper for `::fz_write_pixmap_as_pwg()`.  */
FZ_FUNCTION void FzOutput::fz_write_pixmap_as_pwg(const FzPixmap& pixmap, FzPwgOptions& pwg) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_pwg()\n";
	}
	#endif
	mupdf::fz_write_pixmap_as_pwg(*this, pixmap, pwg);
}

/* Class-aware wrapper for `::fz_write_pixmap_as_pwg_page()`.  */
FZ_FUNCTION void FzOutput::fz_write_pixmap_as_pwg_page(const FzPixmap& pixmap, FzPwgOptions& pwg) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_pwg_page()\n";
	}
	#endif
	mupdf::fz_write_pixmap_as_pwg_page(*this, pixmap, pwg);
}

/* Class-aware wrapper for `::fz_write_ps_file_header()`.  */
FZ_FUNCTION void FzOutput::fz_write_ps_file_header() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_ps_file_header()\n";
	}
	#endif
	mupdf::fz_write_ps_file_header(*this);
}

/* Class-aware wrapper for `::fz_write_ps_file_trailer()`.  */
FZ_FUNCTION void FzOutput::fz_write_ps_file_trailer(int pages) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_ps_file_trailer()\n";
	}
	#endif
	mupdf::fz_write_ps_file_trailer(*this, pages);
}

/* Class-aware wrapper for `::fz_write_pwg_file_header()`.  */
FZ_FUNCTION void FzOutput::fz_write_pwg_file_header() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pwg_file_header()\n";
	}
	#endif
	mupdf::fz_write_pwg_file_header(*this);
}

/* Class-aware wrapper for `::fz_write_rune()`.  */
FZ_FUNCTION void FzOutput::fz_write_rune(int rune) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_rune()\n";
	}
	#endif
	mupdf::fz_write_rune(*this, rune);
}

/* Class-aware wrapper for `::fz_write_string()`.  */
FZ_FUNCTION void FzOutput::fz_write_string(const char *s) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_string()\n";
	}
	#endif
	mupdf::fz_write_string(*this, s);
}

/* Class-aware wrapper for `::fz_write_uint16_be()`.  */
FZ_FUNCTION void FzOutput::fz_write_uint16_be(unsigned int x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_uint16_be()\n";
	}
	#endif
	mupdf::fz_write_uint16_be(*this, x);
}

/* Class-aware wrapper for `::fz_write_uint16_le()`.  */
FZ_FUNCTION void FzOutput::fz_write_uint16_le(unsigned int x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_uint16_le()\n";
	}
	#endif
	mupdf::fz_write_uint16_le(*this, x);
}

/* Class-aware wrapper for `::fz_write_uint32_be()`.  */
FZ_FUNCTION void FzOutput::fz_write_uint32_be(unsigned int x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_uint32_be()\n";
	}
	#endif
	mupdf::fz_write_uint32_be(*this, x);
}

/* Class-aware wrapper for `::fz_write_uint32_le()`.  */
FZ_FUNCTION void FzOutput::fz_write_uint32_le(unsigned int x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_uint32_le()\n";
	}
	#endif
	mupdf::fz_write_uint32_le(*this, x);
}

/* Class-aware wrapper for `::fz_write_vprintf()`.  */
FZ_FUNCTION void FzOutput::fz_write_vprintf(const char *fmt, va_list ap) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_vprintf()\n";
	}
	#endif
	mupdf::fz_write_vprintf(*this, fmt, ap);
}

/* Class-aware wrapper for `::pdf_new_output_processor()`.  */
FZ_FUNCTION PdfProcessor FzOutput::pdf_new_output_processor(int ahxencode, int newlines) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_output_processor()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_output_processor(*this, ahxencode, newlines);
	return ret;
}

/* Class-aware wrapper for `::pdf_print_crypt()`.  */
FZ_FUNCTION void FzOutput::pdf_print_crypt(const PdfCrypt& crypt) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_print_crypt()\n";
	}
	#endif
	mupdf::pdf_print_crypt(*this, crypt);
}

/* Class-aware wrapper for `::pdf_print_encrypted_obj()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_print_encrypted_obj(::pdf_obj *obj, int tight, int ascii, ::pdf_crypt *crypt, int num, int gen)` => int sep
	 */
FZ_FUNCTION void FzOutput::pdf_print_encrypted_obj(const PdfObj& obj, int tight, int ascii, const PdfCrypt& crypt, int num, int gen, int *sep) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_print_encrypted_obj()\n";
	}
	#endif
	mupdf::pdf_print_encrypted_obj(*this, obj, tight, ascii, crypt, num, gen, sep);
}

/* Class-aware wrapper for `::pdf_print_font()`.  */
FZ_FUNCTION void FzOutput::pdf_print_font(const PdfFontDesc& fontdesc) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_print_font()\n";
	}
	#endif
	mupdf::pdf_print_font(*this, fontdesc);
}

/* Class-aware wrapper for `::pdf_print_obj()`.  */
FZ_FUNCTION void FzOutput::pdf_print_obj(const PdfObj& obj, int tight, int ascii) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_print_obj()\n";
	}
	#endif
	mupdf::pdf_print_obj(*this, obj, tight, ascii);
}

/* Class-aware wrapper for `::pdf_write_digest()`.  */
FZ_FUNCTION void FzOutput::pdf_write_digest(const PdfObj& byte_range, const PdfObj& field, size_t digest_offset, size_t digest_length, const PdfPkcs7Signer& signer) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_write_digest()\n";
	}
	#endif
	mupdf::pdf_write_digest(*this, byte_range, field, digest_offset, digest_length, signer);
}

FZ_FUNCTION FzOutput::FzOutput(::fz_output* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzOutput::~FzOutput()
{
	ll_fz_drop_output(m_internal);
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzOutput::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzOutput::s_num_instances = 0;

/* Implementation of methods for `FzOutput2`, virtual_fnptrs wrapper for `fz_output`). */


FZ_FUNCTION FzOutput2::FzOutput2()
{

	m_internal = ll_fz_new_output(0 /*bufsize*/, this /*state*/, nullptr /*write*/, nullptr /*close*/, nullptr /*drop*/);
	
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2::FzOutput2(): this=" << this << "\n";
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2::FzOutput2(): m_internal=" << m_internal << "\n";
		FzOutput2* self = (FzOutput2*) m_internal;
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2::FzOutput2(): self=" << self << "\n";
	}
	#endif
}
/* Static callback, calls self->write(). */
static void FzOutput2_s_write(::fz_context *arg_0, void *arg_1, const void *arg_2, size_t arg_3)
{
	FzOutput2* self = (FzOutput2*) arg_1;
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2_s_write(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->write(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2_s_write(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->seek(). */
static void FzOutput2_s_seek(::fz_context *arg_0, void *arg_1, int64_t arg_2, int arg_3)
{
	FzOutput2* self = (FzOutput2*) arg_1;
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2_s_seek(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->seek(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2_s_seek(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->tell(). */
static int64_t FzOutput2_s_tell(::fz_context *arg_0, void *arg_1)
{
	FzOutput2* self = (FzOutput2*) arg_1;
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2_s_tell(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->tell(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2_s_tell(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->close(). */
static void FzOutput2_s_close(::fz_context *arg_0, void *arg_1)
{
	FzOutput2* self = (FzOutput2*) arg_1;
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2_s_close(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->close(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2_s_close(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->drop(). */
static void FzOutput2_s_drop(::fz_context *arg_0, void *arg_1)
{
	FzOutput2* self = (FzOutput2*) arg_1;
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2_s_drop(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->drop(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2_s_drop(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->reset(). */
static void FzOutput2_s_reset(::fz_context *arg_0, void *arg_1)
{
	FzOutput2* self = (FzOutput2*) arg_1;
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2_s_reset(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->reset(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2_s_reset(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->as_stream(). */
static ::fz_stream * FzOutput2_s_as_stream(::fz_context *arg_0, void *arg_1)
{
	FzOutput2* self = (FzOutput2*) arg_1;
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2_s_as_stream(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->as_stream(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2_s_as_stream(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->truncate(). */
static void FzOutput2_s_truncate(::fz_context *arg_0, void *arg_1)
{
	FzOutput2* self = (FzOutput2*) arg_1;
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2_s_truncate(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->truncate(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2_s_truncate(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
FZ_FUNCTION void FzOutput2::use_virtual_write( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2::use_virtual_write(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->write = (use) ? FzOutput2_s_write : nullptr;
}
FZ_FUNCTION void FzOutput2::use_virtual_seek( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2::use_virtual_seek(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->seek = (use) ? FzOutput2_s_seek : nullptr;
}
FZ_FUNCTION void FzOutput2::use_virtual_tell( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2::use_virtual_tell(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->tell = (use) ? FzOutput2_s_tell : nullptr;
}
FZ_FUNCTION void FzOutput2::use_virtual_close( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2::use_virtual_close(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->close = (use) ? FzOutput2_s_close : nullptr;
}
FZ_FUNCTION void FzOutput2::use_virtual_drop( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2::use_virtual_drop(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->drop = (use) ? FzOutput2_s_drop : nullptr;
}
FZ_FUNCTION void FzOutput2::use_virtual_reset( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2::use_virtual_reset(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->reset = (use) ? FzOutput2_s_reset : nullptr;
}
FZ_FUNCTION void FzOutput2::use_virtual_as_stream( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2::use_virtual_as_stream(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->as_stream = (use) ? FzOutput2_s_as_stream : nullptr;
}
FZ_FUNCTION void FzOutput2::use_virtual_truncate( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzOutput2::use_virtual_truncate(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->truncate = (use) ? FzOutput2_s_truncate : nullptr;
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzOutput2::write(::fz_context *arg_0, const void *arg_2, unsigned long arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzOutput2::write(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzOutput2::write()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzOutput2::seek(::fz_context *arg_0, long arg_2, int arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzOutput2::seek(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzOutput2::seek()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION long FzOutput2::tell(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzOutput2::tell(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzOutput2::tell()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzOutput2::close(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzOutput2::close(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzOutput2::close()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzOutput2::drop(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzOutput2::drop(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzOutput2::drop()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzOutput2::reset(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzOutput2::reset(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzOutput2::reset()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION ::fz_stream * FzOutput2::as_stream(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzOutput2::as_stream(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzOutput2::as_stream()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzOutput2::truncate(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzOutput2::truncate(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzOutput2::truncate()");
}

/* Implementation of methods for FzOverprint (wrapper for fz_overprint). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzOverprint::FzOverprint()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzOverprint::FzOverprint(::fz_overprint* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzOverprint::~FzOverprint()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzOverprint::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzOverprint::s_num_instances = 0;


/* Implementation of methods for FzPage (wrapper for fz_page). */

#ifndef NDEBUG
static RefsCheck<::fz_page, FzPage> s_FzPage_refs_check(offsetof(::fz_page, refs), 32);
#endif

/* Constructor using `fz_load_chapter_page()`. */
FZ_FUNCTION FzPage::FzPage(const FzDocument& doc, int chapter, int page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_chapter_page()\n";
	}
	#endif
	this->m_internal = ll_fz_load_chapter_page(doc.m_internal, chapter, page);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_load_page()`. */
FZ_FUNCTION FzPage::FzPage(const FzDocument& doc, int number)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_page()\n";
	}
	#endif
	this->m_internal = ll_fz_load_page(doc.m_internal, number);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_page_of_size()`. */
FZ_FUNCTION FzPage::FzPage(int size, const FzDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_page_of_size()\n";
	}
	#endif
	this->m_internal = ll_fz_new_page_of_size(size, doc.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION FzPage::FzPage(PdfPage& pdfpage)
{
	m_internal = ll_fz_keep_page(&pdfpage.m_internal->super);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_page()`. */
FZ_FUNCTION FzPage::FzPage(const FzPage& rhs)
: m_internal(ll_fz_keep_page(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_page(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_page()` and `fz_drop_page()`. */
FZ_FUNCTION FzPage& FzPage::operator=(const FzPage& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_page(this->m_internal)"
				<< " and ll_fz_keep_page(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_page(this->m_internal);
	ll_fz_keep_page(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzPage::FzPage()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_bound_page()`.  */
FZ_FUNCTION FzRect FzPage::fz_bound_page() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_bound_page()\n";
	}
	#endif
	auto ret = mupdf::fz_bound_page(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_bound_page_box()`.  */
FZ_FUNCTION FzRect FzPage::fz_bound_page_box(::fz_box_type box) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_bound_page_box()\n";
	}
	#endif
	auto ret = mupdf::fz_bound_page_box(*this, box);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_create_link()`.  */
FZ_FUNCTION FzLink FzPage::fz_create_link(const FzRect& bbox, const char *uri) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_create_link()\n";
	}
	#endif
	auto ret = mupdf::fz_create_link(*this, bbox, uri);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_delete_link()`.  */
FZ_FUNCTION void FzPage::fz_delete_link(const FzLink& link) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_delete_link()\n";
	}
	#endif
	mupdf::fz_delete_link(*this, link);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_load_links()`.  */
FZ_FUNCTION FzLink FzPage::fz_load_links() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_links()\n";
	}
	#endif
	auto ret = mupdf::fz_load_links(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_page()`.  */
FZ_FUNCTION FzBuffer FzPage::fz_new_buffer_from_page(FzStextOptions& options) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_page()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_page(*this, options);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_page_with_format()`.  */
FZ_FUNCTION FzBuffer FzPage::fz_new_buffer_from_page_with_format(const char *format, const char *options, const FzMatrix& transform, FzCookie& cookie) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_page_with_format()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_page_with_format(*this, format, options, transform, cookie);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_display_list_from_page()`.  */
FZ_FUNCTION FzDisplayList FzPage::fz_new_display_list_from_page() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_display_list_from_page()\n";
	}
	#endif
	auto ret = mupdf::fz_new_display_list_from_page(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_display_list_from_page_contents()`.  */
FZ_FUNCTION FzDisplayList FzPage::fz_new_display_list_from_page_contents() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_display_list_from_page_contents()\n";
	}
	#endif
	auto ret = mupdf::fz_new_display_list_from_page_contents(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_pixmap_from_page()`.  */
FZ_FUNCTION FzPixmap FzPage::fz_new_pixmap_from_page(const FzMatrix& ctm, const FzColorspace& cs, int alpha) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_page()\n";
	}
	#endif
	auto ret = mupdf::fz_new_pixmap_from_page(*this, ctm, cs, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_pixmap_from_page_contents()`.  */
FZ_FUNCTION FzPixmap FzPage::fz_new_pixmap_from_page_contents(const FzMatrix& ctm, const FzColorspace& cs, int alpha) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_page_contents()\n";
	}
	#endif
	auto ret = mupdf::fz_new_pixmap_from_page_contents(*this, ctm, cs, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_pixmap_from_page_contents_with_separations()`.  */
FZ_FUNCTION FzPixmap FzPage::fz_new_pixmap_from_page_contents_with_separations(const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_page_contents_with_separations()\n";
	}
	#endif
	auto ret = mupdf::fz_new_pixmap_from_page_contents_with_separations(*this, ctm, cs, seps, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_pixmap_from_page_with_separations()`.  */
FZ_FUNCTION FzPixmap FzPage::fz_new_pixmap_from_page_with_separations(const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_page_with_separations()\n";
	}
	#endif
	auto ret = mupdf::fz_new_pixmap_from_page_with_separations(*this, ctm, cs, seps, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_page_label()`.  */
FZ_FUNCTION const char *FzPage::fz_page_label(char *buf, int size) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_page_label()\n";
	}
	#endif
	auto ret = mupdf::fz_page_label(*this, buf, size);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_page_presentation()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_page_presentation(::fz_transition *transition)` => `(fz_transition *, float duration)`
	 */
FZ_FUNCTION FzTransition FzPage::fz_page_presentation(FzTransition& transition, float *duration) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_page_presentation()\n";
	}
	#endif
	auto ret = mupdf::fz_page_presentation(*this, transition, duration);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_page_separations()`.  */
FZ_FUNCTION FzSeparations FzPage::fz_page_separations() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_page_separations()\n";
	}
	#endif
	auto ret = mupdf::fz_page_separations(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_page_uses_overprint()`.  */
FZ_FUNCTION int FzPage::fz_page_uses_overprint() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_page_uses_overprint()\n";
	}
	#endif
	auto ret = mupdf::fz_page_uses_overprint(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_run_page()`.  */
FZ_FUNCTION void FzPage::fz_run_page(const FzDevice& dev, const FzMatrix& transform, FzCookie& cookie) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_run_page()\n";
	}
	#endif
	mupdf::fz_run_page(*this, dev, transform, cookie);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_run_page_annots()`.  */
FZ_FUNCTION void FzPage::fz_run_page_annots(const FzDevice& dev, const FzMatrix& transform, FzCookie& cookie) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_run_page_annots()\n";
	}
	#endif
	mupdf::fz_run_page_annots(*this, dev, transform, cookie);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_run_page_contents()`.  */
FZ_FUNCTION void FzPage::fz_run_page_contents(const FzDevice& dev, const FzMatrix& transform, FzCookie& cookie) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_run_page_contents()\n";
	}
	#endif
	mupdf::fz_run_page_contents(*this, dev, transform, cookie);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_run_page_widgets()`.  */
FZ_FUNCTION void FzPage::fz_run_page_widgets(const FzDevice& dev, const FzMatrix& transform, FzCookie& cookie) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_run_page_widgets()\n";
	}
	#endif
	mupdf::fz_run_page_widgets(*this, dev, transform, cookie);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_search_page()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_search_page(const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
	 */
FZ_FUNCTION int FzPage::fz_search_page(const char *needle, int *hit_mark, FzQuad& hit_bbox, int hit_max) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_search_page()\n";
	}
	#endif
	auto ret = mupdf::fz_search_page(*this, needle, hit_mark, hit_bbox, hit_max);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_page_from_fz_page()`.  */
FZ_FUNCTION PdfPage FzPage::pdf_page_from_fz_page() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_from_fz_page()\n";
	}
	#endif
	auto ret = mupdf::pdf_page_from_fz_page(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/** Custom method. */
FZ_FUNCTION FzDocument FzPage::doc()
{
	return FzDocument( ll_fz_keep_document( m_internal->doc));
}

FZ_FUNCTION FzPage::FzPage(::fz_page* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzPage::~FzPage()
{
	ll_fz_drop_page(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPage_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzPage::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzPage::s_num_instances = 0;


/* Implementation of methods for FzPath (wrapper for fz_path). */

#ifndef NDEBUG
static RefsCheck<::fz_path, FzPath> s_FzPath_refs_check(0, 8);
#endif

/* Constructor using `fz_new_path()`. */
FZ_FUNCTION FzPath::FzPath()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_path()\n";
	}
	#endif
	this->m_internal = ll_fz_new_path();
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_path()`. */
FZ_FUNCTION FzPath::FzPath(const FzPath& rhs)
: m_internal(ll_fz_keep_path(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_path(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_path()` and `fz_drop_path()`. */
FZ_FUNCTION FzPath& FzPath::operator=(const FzPath& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_path(this->m_internal)"
				<< " and ll_fz_keep_path(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_path(this->m_internal);
	ll_fz_keep_path(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/* Class-aware wrapper for `::fz_bound_path()`.  */
FZ_FUNCTION FzRect FzPath::fz_bound_path(const FzStrokeState& stroke, const FzMatrix& ctm) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_bound_path()\n";
	}
	#endif
	auto ret = mupdf::fz_bound_path(*this, stroke, ctm);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_clone_path()`.  */
FZ_FUNCTION FzPath FzPath::fz_clone_path() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clone_path()\n";
	}
	#endif
	auto ret = mupdf::fz_clone_path(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_closepath()`.  */
FZ_FUNCTION void FzPath::fz_closepath() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_closepath()\n";
	}
	#endif
	mupdf::fz_closepath(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_currentpoint()`.  */
FZ_FUNCTION FzPoint FzPath::fz_currentpoint() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_currentpoint()\n";
	}
	#endif
	auto ret = mupdf::fz_currentpoint(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_curveto()`.  */
FZ_FUNCTION void FzPath::fz_curveto(float x0, float y0, float x1, float y1, float x2, float y2) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_curveto()\n";
	}
	#endif
	mupdf::fz_curveto(*this, x0, y0, x1, y1, x2, y2);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_curvetov()`.  */
FZ_FUNCTION void FzPath::fz_curvetov(float x1, float y1, float x2, float y2) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_curvetov()\n";
	}
	#endif
	mupdf::fz_curvetov(*this, x1, y1, x2, y2);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_curvetoy()`.  */
FZ_FUNCTION void FzPath::fz_curvetoy(float x0, float y0, float x2, float y2) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_curvetoy()\n";
	}
	#endif
	mupdf::fz_curvetoy(*this, x0, y0, x2, y2);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_lineto()`.  */
FZ_FUNCTION void FzPath::fz_lineto(float x, float y) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lineto()\n";
	}
	#endif
	mupdf::fz_lineto(*this, x, y);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_moveto()`.  */
FZ_FUNCTION void FzPath::fz_moveto(float x, float y) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_moveto()\n";
	}
	#endif
	mupdf::fz_moveto(*this, x, y);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_packed_path_size()`.  */
FZ_FUNCTION int FzPath::fz_packed_path_size() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_packed_path_size()\n";
	}
	#endif
	auto ret = mupdf::fz_packed_path_size(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_quadto()`.  */
FZ_FUNCTION void FzPath::fz_quadto(float x0, float y0, float x1, float y1) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_quadto()\n";
	}
	#endif
	mupdf::fz_quadto(*this, x0, y0, x1, y1);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_rectto()`.  */
FZ_FUNCTION void FzPath::fz_rectto(float x0, float y0, float x1, float y1) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_rectto()\n";
	}
	#endif
	mupdf::fz_rectto(*this, x0, y0, x1, y1);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_transform_path()`.  */
FZ_FUNCTION void FzPath::fz_transform_path(const FzMatrix& transform) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_transform_path()\n";
	}
	#endif
	mupdf::fz_transform_path(*this, transform);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_trim_path()`.  */
FZ_FUNCTION void FzPath::fz_trim_path() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_trim_path()\n";
	}
	#endif
	mupdf::fz_trim_path(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_walk_path()`.  */
FZ_FUNCTION void FzPath::fz_walk_path(const FzPathWalker& walker, void *arg) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_walk_path()\n";
	}
	#endif
	mupdf::fz_walk_path(*this, walker, arg);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

FZ_FUNCTION FzPath::FzPath(::fz_path* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzPath::~FzPath()
{
	ll_fz_drop_path(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPath_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzPath::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzPath::s_num_instances = 0;


/* Implementation of methods for FzPathWalker (wrapper for fz_path_walker). */

FZ_FUNCTION FzPathWalker::FzPathWalker(::fz_path_walker* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzPathWalker::~FzPathWalker()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzPathWalker::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzPathWalker::s_num_instances = 0;

/* Implementation of methods for `FzPathWalker2`, virtual_fnptrs wrapper for `fz_path_walker`). */


FZ_FUNCTION FzPathWalker2::FzPathWalker2()
{

	
	m_internal = (::fz_path_walker*) ll_fz_calloc(
			1,
			sizeof(*m_internal) + sizeof(FzPathWalker2*)
			);
	*(FzPathWalker2**) (m_internal + 1) = this;
	
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2::FzPathWalker2(): this=" << this << "\n";
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2::FzPathWalker2(): m_internal=" << m_internal << "\n";
		FzPathWalker2* self = *(FzPathWalker2**) ((fz_path_walker*) m_internal + 1);
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2::FzPathWalker2(): self=" << self << "\n";
	}
	#endif
}

FZ_FUNCTION FzPathWalker2::~FzPathWalker2()
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": ~FzPathWalker2(): this=" << this << "\n";
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": ~FzPathWalker2(): m_internal=" << m_internal << "\n";
	}
	#endif
	ll_fz_free(m_internal);

}
/* Static callback, calls self->moveto(). */
static void FzPathWalker2_s_moveto(::fz_context *arg_0, void *arg_1, float arg_2, float arg_3)
{
	FzPathWalker2* self = *(FzPathWalker2**) ((fz_path_walker*) arg_1 + 1);
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2_s_moveto(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->moveto(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2_s_moveto(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->lineto(). */
static void FzPathWalker2_s_lineto(::fz_context *arg_0, void *arg_1, float arg_2, float arg_3)
{
	FzPathWalker2* self = *(FzPathWalker2**) ((fz_path_walker*) arg_1 + 1);
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2_s_lineto(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->lineto(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2_s_lineto(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->curveto(). */
static void FzPathWalker2_s_curveto(::fz_context *arg_0, void *arg_1, float arg_2, float arg_3, float arg_4, float arg_5, float arg_6, float arg_7)
{
	FzPathWalker2* self = *(FzPathWalker2**) ((fz_path_walker*) arg_1 + 1);
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2_s_curveto(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->curveto(arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2_s_curveto(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->closepath(). */
static void FzPathWalker2_s_closepath(::fz_context *arg_0, void *arg_1)
{
	FzPathWalker2* self = *(FzPathWalker2**) ((fz_path_walker*) arg_1 + 1);
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2_s_closepath(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->closepath(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2_s_closepath(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->quadto(). */
static void FzPathWalker2_s_quadto(::fz_context *arg_0, void *arg_1, float arg_2, float arg_3, float arg_4, float arg_5)
{
	FzPathWalker2* self = *(FzPathWalker2**) ((fz_path_walker*) arg_1 + 1);
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2_s_quadto(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->quadto(arg_0, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2_s_quadto(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->curvetov(). */
static void FzPathWalker2_s_curvetov(::fz_context *arg_0, void *arg_1, float arg_2, float arg_3, float arg_4, float arg_5)
{
	FzPathWalker2* self = *(FzPathWalker2**) ((fz_path_walker*) arg_1 + 1);
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2_s_curvetov(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->curvetov(arg_0, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2_s_curvetov(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->curvetoy(). */
static void FzPathWalker2_s_curvetoy(::fz_context *arg_0, void *arg_1, float arg_2, float arg_3, float arg_4, float arg_5)
{
	FzPathWalker2* self = *(FzPathWalker2**) ((fz_path_walker*) arg_1 + 1);
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2_s_curvetoy(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->curvetoy(arg_0, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2_s_curvetoy(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->rectto(). */
static void FzPathWalker2_s_rectto(::fz_context *arg_0, void *arg_1, float arg_2, float arg_3, float arg_4, float arg_5)
{
	FzPathWalker2* self = *(FzPathWalker2**) ((fz_path_walker*) arg_1 + 1);
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2_s_rectto(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->rectto(arg_0, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2_s_rectto(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
FZ_FUNCTION void FzPathWalker2::use_virtual_moveto( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2::use_virtual_moveto(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->moveto = (use) ? FzPathWalker2_s_moveto : nullptr;
}
FZ_FUNCTION void FzPathWalker2::use_virtual_lineto( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2::use_virtual_lineto(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->lineto = (use) ? FzPathWalker2_s_lineto : nullptr;
}
FZ_FUNCTION void FzPathWalker2::use_virtual_curveto( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2::use_virtual_curveto(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->curveto = (use) ? FzPathWalker2_s_curveto : nullptr;
}
FZ_FUNCTION void FzPathWalker2::use_virtual_closepath( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2::use_virtual_closepath(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->closepath = (use) ? FzPathWalker2_s_closepath : nullptr;
}
FZ_FUNCTION void FzPathWalker2::use_virtual_quadto( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2::use_virtual_quadto(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->quadto = (use) ? FzPathWalker2_s_quadto : nullptr;
}
FZ_FUNCTION void FzPathWalker2::use_virtual_curvetov( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2::use_virtual_curvetov(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->curvetov = (use) ? FzPathWalker2_s_curvetov : nullptr;
}
FZ_FUNCTION void FzPathWalker2::use_virtual_curvetoy( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2::use_virtual_curvetoy(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->curvetoy = (use) ? FzPathWalker2_s_curvetoy : nullptr;
}
FZ_FUNCTION void FzPathWalker2::use_virtual_rectto( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": FzPathWalker2::use_virtual_rectto(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->rectto = (use) ? FzPathWalker2_s_rectto : nullptr;
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzPathWalker2::moveto(::fz_context *arg_0, float arg_2, float arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzPathWalker2::moveto(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzPathWalker2::moveto()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzPathWalker2::lineto(::fz_context *arg_0, float arg_2, float arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzPathWalker2::lineto(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzPathWalker2::lineto()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzPathWalker2::curveto(::fz_context *arg_0, float arg_2, float arg_3, float arg_4, float arg_5, float arg_6, float arg_7)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzPathWalker2::curveto(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzPathWalker2::curveto()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzPathWalker2::closepath(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzPathWalker2::closepath(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzPathWalker2::closepath()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzPathWalker2::quadto(::fz_context *arg_0, float arg_2, float arg_3, float arg_4, float arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzPathWalker2::quadto(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzPathWalker2::quadto()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzPathWalker2::curvetov(::fz_context *arg_0, float arg_2, float arg_3, float arg_4, float arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzPathWalker2::curvetov(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzPathWalker2::curvetov()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzPathWalker2::curvetoy(::fz_context *arg_0, float arg_2, float arg_3, float arg_4, float arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzPathWalker2::curvetoy(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzPathWalker2::curvetoy()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void FzPathWalker2::rectto(::fz_context *arg_0, float arg_2, float arg_3, float arg_4, float arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn FzPathWalker2::rectto(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn FzPathWalker2::rectto()");
}

/* Implementation of methods for FzPclOptions (wrapper for fz_pcl_options). */

/* Constructor using `fz_parse_pcl_options()`. */
FZ_FUNCTION FzPclOptions::FzPclOptions(const FzPclOptions& opts, const char *args)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_parse_pcl_options()\n";
	}
	#endif
	this->m_internal = ll_fz_parse_pcl_options(opts.m_internal, args);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzPclOptions::FzPclOptions()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_pcl_preset()`.  */
FZ_FUNCTION void FzPclOptions::fz_pcl_preset(const char *preset) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pcl_preset()\n";
	}
	#endif
	mupdf::fz_pcl_preset(*this, preset);
}

FZ_FUNCTION FzPclOptions::FzPclOptions(::fz_pcl_options* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzPclOptions::~FzPclOptions()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzPclOptions::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzPclOptions::s_num_instances = 0;


/* Implementation of methods for FzPclmOptions (wrapper for fz_pclm_options). */

/* Constructor using `fz_parse_pclm_options()`. */
FZ_FUNCTION FzPclmOptions::FzPclmOptions(const FzPclmOptions& opts, const char *args)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_parse_pclm_options()\n";
	}
	#endif
	this->m_internal = ll_fz_parse_pclm_options(opts.m_internal, args);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION FzPclmOptions::FzPclmOptions(const char *args)
{
	ll_fz_parse_pclm_options(m_internal, args);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzPclmOptions::FzPclmOptions()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzPclmOptions::FzPclmOptions(::fz_pclm_options* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzPclmOptions::~FzPclmOptions()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzPclmOptions::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzPclmOptions::s_num_instances = 0;


/* Implementation of methods for FzPdfocrOptions (wrapper for fz_pdfocr_options). */

/** Default constructor, sets each member to default value. */
FZ_FUNCTION FzPdfocrOptions::FzPdfocrOptions()
{
	this->compress = {};
	this->strip_height = {};
	memset(&this->language, 0, sizeof(this->language));
	memset(&this->datadir, 0, sizeof(this->datadir));
	this->page_count = {};
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_parse_pdfocr_options()`.  */
FZ_FUNCTION FzPdfocrOptions FzPdfocrOptions::fz_parse_pdfocr_options(const char *args)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_parse_pdfocr_options()\n";
	}
	#endif
	auto ret = mupdf::fz_parse_pdfocr_options(*this, args);
	return ret;
}

/** Custom method. */
FZ_FUNCTION void FzPdfocrOptions::language_set2(const char* language)
{
	fz_strlcpy(this->language, language, sizeof(this->language));
}

/** Custom method. */
FZ_FUNCTION void FzPdfocrOptions::datadir_set2(const char* datadir)
{
	fz_strlcpy(this->datadir, datadir, sizeof(this->datadir));
}

FZ_FUNCTION FzPdfocrOptions::FzPdfocrOptions(const ::fz_pdfocr_options* internal)
{
	assert( internal);
	this->compress = internal->compress;
	this->strip_height = internal->strip_height;
	memcpy(this->language, internal->language, sizeof(this->language));
	memcpy(this->datadir, internal->datadir, sizeof(this->datadir));
	this->page_count = internal->page_count;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzPdfocrOptions::FzPdfocrOptions(const ::fz_pdfocr_options internal)
{
	this->compress = internal.compress;
	this->strip_height = internal.strip_height;
	memcpy(this->language, &internal.language, sizeof(this->language));
	memcpy(this->datadir, &internal.datadir, sizeof(this->datadir));
	this->page_count = internal.page_count;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::fz_pdfocr_options`. */
FZ_FUNCTION ::fz_pdfocr_options* FzPdfocrOptions::internal()
{
	auto ret = (::fz_pdfocr_options*) &this->compress;
	return ret;
}

/** Constructor using raw copy of pre-existing `::fz_pdfocr_options`. */
FZ_FUNCTION const ::fz_pdfocr_options* FzPdfocrOptions::internal() const
{
	auto ret = (const ::fz_pdfocr_options*) &this->compress;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION FzPdfocrOptions::~FzPdfocrOptions()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzPdfocrOptions::s_num_instances = 0;

FZ_FUNCTION std::string FzPdfocrOptions::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool FzPdfocrOptions::operator==(const FzPdfocrOptions& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool FzPdfocrOptions::operator!=(const FzPdfocrOptions& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for FzPixmap (wrapper for fz_pixmap). */

#ifndef NDEBUG
static RefsCheck<::fz_pixmap, FzPixmap> s_FzPixmap_refs_check(offsetof(::fz_pixmap, storable.refs), 32);
#endif

/* Constructor using `fz_new_pixmap()`. */
FZ_FUNCTION FzPixmap::FzPixmap(const FzColorspace& cs, int w, int h, const FzSeparations& seps, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pixmap(cs.m_internal, w, h, seps.m_internal, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_pixmap_from_color_and_mask()`. */
FZ_FUNCTION FzPixmap::FzPixmap(const FzPixmap& color, const FzPixmap& mask)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_color_and_mask()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pixmap_from_color_and_mask(color.m_internal, mask.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_pixmap_from_display_list()`. */
FZ_FUNCTION FzPixmap::FzPixmap(const FzDisplayList& list, const FzMatrix& ctm, const FzColorspace& cs, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_display_list()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pixmap_from_display_list(list.m_internal, * ctm.internal(), cs.m_internal, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_pixmap_from_display_list_with_separations()`. */
FZ_FUNCTION FzPixmap::FzPixmap(const FzDisplayList& list, const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_display_list_with_separations()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pixmap_from_display_list_with_separations(list.m_internal, * ctm.internal(), cs.m_internal, seps.m_internal, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_pixmap_from_page()`. */
FZ_FUNCTION FzPixmap::FzPixmap(const FzPage& page, const FzMatrix& ctm, const FzColorspace& cs, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_page()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pixmap_from_page(page.m_internal, * ctm.internal(), cs.m_internal, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_pixmap_from_page_number()`. */
FZ_FUNCTION FzPixmap::FzPixmap(const FzDocument& doc, int number, const FzMatrix& ctm, const FzColorspace& cs, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_page_number()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pixmap_from_page_number(doc.m_internal, number, * ctm.internal(), cs.m_internal, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_pixmap_from_page_number_with_separations()`. */
FZ_FUNCTION FzPixmap::FzPixmap(const FzDocument& doc, int number, const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_page_number_with_separations()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pixmap_from_page_number_with_separations(doc.m_internal, number, * ctm.internal(), cs.m_internal, seps.m_internal, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_pixmap_from_page_with_separations()`. */
FZ_FUNCTION FzPixmap::FzPixmap(const FzPage& page, const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_page_with_separations()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pixmap_from_page_with_separations(page.m_internal, * ctm.internal(), cs.m_internal, seps.m_internal, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_pixmap_from_pixmap()`. */
FZ_FUNCTION FzPixmap::FzPixmap(const FzPixmap& pixmap, FzIrect& rect)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_pixmap()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pixmap_from_pixmap(pixmap.m_internal,  rect.internal());
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_pixmap_with_bbox()`. */
FZ_FUNCTION FzPixmap::FzPixmap(const FzColorspace& colorspace, const FzIrect& bbox, const FzSeparations& seps, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_with_bbox()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pixmap_with_bbox(colorspace.m_internal, * bbox.internal(), seps.m_internal, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_pixmap_with_bbox_and_data()`. */
FZ_FUNCTION FzPixmap::FzPixmap(const FzColorspace& colorspace, const FzIrect& rect, const FzSeparations& seps, int alpha, unsigned char *samples)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_with_bbox_and_data()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pixmap_with_bbox_and_data(colorspace.m_internal, * rect.internal(), seps.m_internal, alpha, samples);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_pixmap_with_data()`. */
FZ_FUNCTION FzPixmap::FzPixmap(const FzColorspace& colorspace, int w, int h, const FzSeparations& seps, int alpha, int stride, unsigned char *samples)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_with_data()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pixmap_with_data(colorspace.m_internal, w, h, seps.m_internal, alpha, stride, samples);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_pixmap_from_annot()`. */
FZ_FUNCTION FzPixmap::FzPixmap(const PdfAnnot& annot, const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_pixmap_from_annot()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_pixmap_from_annot(annot.m_internal, * ctm.internal(), cs.m_internal, seps.m_internal, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_pixmap_from_page_contents_with_separations_and_usage()`. */
FZ_FUNCTION FzPixmap::FzPixmap(const PdfPage& page, const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha, const char *usage, ::fz_box_type box)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_pixmap_from_page_contents_with_separations_and_usage()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_pixmap_from_page_contents_with_separations_and_usage(page.m_internal, * ctm.internal(), cs.m_internal, seps.m_internal, alpha, usage, box);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_pixmap_from_page_contents_with_usage()`. */
FZ_FUNCTION FzPixmap::FzPixmap(const PdfPage& page, const FzMatrix& ctm, const FzColorspace& cs, int alpha, const char *usage, ::fz_box_type box)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_pixmap_from_page_contents_with_usage()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_pixmap_from_page_contents_with_usage(page.m_internal, * ctm.internal(), cs.m_internal, alpha, usage, box);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_pixmap()`. */
FZ_FUNCTION FzPixmap::FzPixmap(const FzPixmap& rhs)
: m_internal(ll_fz_keep_pixmap(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_pixmap(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_pixmap()` and `fz_drop_pixmap()`. */
FZ_FUNCTION FzPixmap& FzPixmap::operator=(const FzPixmap& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_pixmap(this->m_internal)"
				<< " and ll_fz_keep_pixmap(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_pixmap(this->m_internal);
	ll_fz_keep_pixmap(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzPixmap::FzPixmap()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::pdf_new_pixmap_from_page_with_usage()`.  */
FZ_FUNCTION FzPixmap FzPixmap::pdf_new_pixmap_from_page_with_usage(const PdfPage& page, const FzMatrix& ctm, const FzColorspace& cs, int alpha, const char *usage, ::fz_box_type box)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_pixmap_from_page_with_usage()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_pixmap_from_page_with_usage(page, ctm, cs, alpha, usage, box);
	return ret;
}

/* Class-aware wrapper for `::pdf_new_pixmap_from_page_with_separations_and_usage()`.  */
FZ_FUNCTION FzPixmap FzPixmap::pdf_new_pixmap_from_page_with_separations_and_usage(const PdfPage& page, const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha, const char *usage, ::fz_box_type box)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_pixmap_from_page_with_separations_and_usage()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_pixmap_from_page_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box);
	return ret;
}

/* Class-aware wrapper for `::fz_new_pixmap_from_page_contents()`.  */
FZ_FUNCTION FzPixmap FzPixmap::fz_new_pixmap_from_page_contents(const FzPage& page, const FzMatrix& ctm, const FzColorspace& cs, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_page_contents()\n";
	}
	#endif
	auto ret = mupdf::fz_new_pixmap_from_page_contents(page, ctm, cs, alpha);
	return ret;
}

/* Class-aware wrapper for `::fz_new_pixmap_from_page_contents_with_separations()`.  */
FZ_FUNCTION FzPixmap FzPixmap::fz_new_pixmap_from_page_contents_with_separations(const FzPage& page, const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_page_contents_with_separations()\n";
	}
	#endif
	auto ret = mupdf::fz_new_pixmap_from_page_contents_with_separations(page, ctm, cs, seps, alpha);
	return ret;
}

/* Class-aware wrapper for `::fz_alpha_from_gray()`.  */
FZ_FUNCTION FzPixmap FzPixmap::fz_alpha_from_gray() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_alpha_from_gray()\n";
	}
	#endif
	auto ret = mupdf::fz_alpha_from_gray(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_clear_pixmap()`.  */
FZ_FUNCTION void FzPixmap::fz_clear_pixmap() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clear_pixmap()\n";
	}
	#endif
	mupdf::fz_clear_pixmap(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_clear_pixmap_rect_with_value()`.  */
FZ_FUNCTION void FzPixmap::fz_clear_pixmap_rect_with_value(int value, const FzIrect& r) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clear_pixmap_rect_with_value()\n";
	}
	#endif
	mupdf::fz_clear_pixmap_rect_with_value(*this, value, r);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_clear_pixmap_with_value()`.  */
FZ_FUNCTION void FzPixmap::fz_clear_pixmap_with_value(int value) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clear_pixmap_with_value()\n";
	}
	#endif
	mupdf::fz_clear_pixmap_with_value(*this, value);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_clone_pixmap()`.  */
FZ_FUNCTION FzPixmap FzPixmap::fz_clone_pixmap() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clone_pixmap()\n";
	}
	#endif
	auto ret = mupdf::fz_clone_pixmap(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_clone_pixmap_area_with_different_seps()`.  */
FZ_FUNCTION FzPixmap FzPixmap::fz_clone_pixmap_area_with_different_seps(FzIrect& bbox, const FzColorspace& dcs, const FzSeparations& seps, const FzColorParams& color_params, const FzDefaultColorspaces& default_cs) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clone_pixmap_area_with_different_seps()\n";
	}
	#endif
	auto ret = mupdf::fz_clone_pixmap_area_with_different_seps(*this, bbox, dcs, seps, color_params, default_cs);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_convert_indexed_pixmap_to_base()`.  */
FZ_FUNCTION FzPixmap FzPixmap::fz_convert_indexed_pixmap_to_base() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_convert_indexed_pixmap_to_base()\n";
	}
	#endif
	auto ret = mupdf::fz_convert_indexed_pixmap_to_base(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_convert_pixmap()`.  */
FZ_FUNCTION FzPixmap FzPixmap::fz_convert_pixmap(const FzColorspace& cs_des, const FzColorspace& prf, const FzDefaultColorspaces& default_cs, const FzColorParams& color_params, int keep_alpha) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_convert_pixmap()\n";
	}
	#endif
	auto ret = mupdf::fz_convert_pixmap(*this, cs_des, prf, default_cs, color_params, keep_alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_convert_separation_pixmap_to_base()`.  */
FZ_FUNCTION FzPixmap FzPixmap::fz_convert_separation_pixmap_to_base() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_convert_separation_pixmap_to_base()\n";
	}
	#endif
	auto ret = mupdf::fz_convert_separation_pixmap_to_base(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_copy_pixmap_rect()`.  */
FZ_FUNCTION void FzPixmap::fz_copy_pixmap_rect(const FzPixmap& src, const FzIrect& r, const FzDefaultColorspaces& default_cs) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_copy_pixmap_rect()\n";
	}
	#endif
	mupdf::fz_copy_pixmap_rect(*this, src, r, default_cs);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_decode_tile()`.  */
FZ_FUNCTION void FzPixmap::fz_decode_tile(const float *decode) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_decode_tile()\n";
	}
	#endif
	mupdf::fz_decode_tile(*this, decode);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_fill_pixmap_with_color()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_fill_pixmap_with_color(::fz_colorspace *colorspace, ::fz_color_params color_params)` => float color
	 */
FZ_FUNCTION void FzPixmap::fz_fill_pixmap_with_color(const FzColorspace& colorspace, float *color, const FzColorParams& color_params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_fill_pixmap_with_color()\n";
	}
	#endif
	mupdf::fz_fill_pixmap_with_color(*this, colorspace, color, color_params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_gamma_pixmap()`.  */
FZ_FUNCTION void FzPixmap::fz_gamma_pixmap(float gamma) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_gamma_pixmap()\n";
	}
	#endif
	mupdf::fz_gamma_pixmap(*this, gamma);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_generate_transition()`.  */
FZ_FUNCTION int FzPixmap::fz_generate_transition(const FzPixmap& opix, const FzPixmap& npix, int time, FzTransition& trans) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_generate_transition()\n";
	}
	#endif
	auto ret = mupdf::fz_generate_transition(*this, opix, npix, time, trans);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_invert_pixmap()`.  */
FZ_FUNCTION void FzPixmap::fz_invert_pixmap() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_invert_pixmap()\n";
	}
	#endif
	mupdf::fz_invert_pixmap(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_invert_pixmap_alpha()`.  */
FZ_FUNCTION void FzPixmap::fz_invert_pixmap_alpha() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_invert_pixmap_alpha()\n";
	}
	#endif
	mupdf::fz_invert_pixmap_alpha(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_invert_pixmap_luminance()`.  */
FZ_FUNCTION void FzPixmap::fz_invert_pixmap_luminance() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_invert_pixmap_luminance()\n";
	}
	#endif
	mupdf::fz_invert_pixmap_luminance(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_invert_pixmap_raw()`.  */
FZ_FUNCTION void FzPixmap::fz_invert_pixmap_raw() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_invert_pixmap_raw()\n";
	}
	#endif
	mupdf::fz_invert_pixmap_raw(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_invert_pixmap_rect()`.  */
FZ_FUNCTION void FzPixmap::fz_invert_pixmap_rect(const FzIrect& rect) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_invert_pixmap_rect()\n";
	}
	#endif
	mupdf::fz_invert_pixmap_rect(*this, rect);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_is_pixmap_monochrome()`.  */
FZ_FUNCTION int FzPixmap::fz_is_pixmap_monochrome() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_pixmap_monochrome()\n";
	}
	#endif
	auto ret = mupdf::fz_is_pixmap_monochrome(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_md5_pixmap()`.  */
FZ_FUNCTION void FzPixmap::fz_md5_pixmap(unsigned char digest[16]) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_md5_pixmap()\n";
	}
	#endif
	mupdf::fz_md5_pixmap(*this, digest);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_md5_pixmap2()`.  */
FZ_FUNCTION std::vector<unsigned char> FzPixmap::fz_md5_pixmap2() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_md5_pixmap2()\n";
	}
	#endif
	auto ret = mupdf::fz_md5_pixmap2(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_bitmap_from_pixmap()`.  */
FZ_FUNCTION FzBitmap FzPixmap::fz_new_bitmap_from_pixmap(const FzHalftone& ht) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_bitmap_from_pixmap()\n";
	}
	#endif
	auto ret = mupdf::fz_new_bitmap_from_pixmap(*this, ht);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_bitmap_from_pixmap_band()`.  */
FZ_FUNCTION FzBitmap FzPixmap::fz_new_bitmap_from_pixmap_band(const FzHalftone& ht, int band_start) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_bitmap_from_pixmap_band()\n";
	}
	#endif
	auto ret = mupdf::fz_new_bitmap_from_pixmap_band(*this, ht, band_start);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_jpeg()`.  */
FZ_FUNCTION FzBuffer FzPixmap::fz_new_buffer_from_pixmap_as_jpeg(const FzColorParams& color_params, int quality, int invert_cmyk) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_pixmap_as_jpeg()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_pixmap_as_jpeg(*this, color_params, quality, invert_cmyk);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_jpx()`.  */
FZ_FUNCTION FzBuffer FzPixmap::fz_new_buffer_from_pixmap_as_jpx(const FzColorParams& color_params, int quality) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_pixmap_as_jpx()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_pixmap_as_jpx(*this, color_params, quality);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pam()`.  */
FZ_FUNCTION FzBuffer FzPixmap::fz_new_buffer_from_pixmap_as_pam(const FzColorParams& color_params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_pixmap_as_pam()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_pixmap_as_pam(*this, color_params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_png()`.  */
FZ_FUNCTION FzBuffer FzPixmap::fz_new_buffer_from_pixmap_as_png(const FzColorParams& color_params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_pixmap_as_png()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_pixmap_as_png(*this, color_params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pnm()`.  */
FZ_FUNCTION FzBuffer FzPixmap::fz_new_buffer_from_pixmap_as_pnm(const FzColorParams& color_params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_pixmap_as_pnm()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_pixmap_as_pnm(*this, color_params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_psd()`.  */
FZ_FUNCTION FzBuffer FzPixmap::fz_new_buffer_from_pixmap_as_psd(const FzColorParams& color_params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_pixmap_as_psd()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_pixmap_as_psd(*this, color_params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_image_from_pixmap()`.  */
FZ_FUNCTION FzImage FzPixmap::fz_new_image_from_pixmap(const FzImage& mask) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_from_pixmap()\n";
	}
	#endif
	auto ret = mupdf::fz_new_image_from_pixmap(*this, mask);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_pixmap_from_alpha_channel()`.  */
FZ_FUNCTION FzPixmap FzPixmap::fz_new_pixmap_from_alpha_channel() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_alpha_channel()\n";
	}
	#endif
	auto ret = mupdf::fz_new_pixmap_from_alpha_channel(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_pixmap_from_color_and_mask()`.  */
FZ_FUNCTION FzPixmap FzPixmap::fz_new_pixmap_from_color_and_mask(const FzPixmap& mask) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_color_and_mask()\n";
	}
	#endif
	auto ret = mupdf::fz_new_pixmap_from_color_and_mask(*this, mask);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_pixmap_from_pixmap()`.  */
FZ_FUNCTION FzPixmap FzPixmap::fz_new_pixmap_from_pixmap(FzIrect& rect) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_pixmap()\n";
	}
	#endif
	auto ret = mupdf::fz_new_pixmap_from_pixmap(*this, rect);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_pixmap_alpha()`.  */
FZ_FUNCTION int FzPixmap::fz_pixmap_alpha() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_alpha()\n";
	}
	#endif
	auto ret = mupdf::fz_pixmap_alpha(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_pixmap_bbox()`.  */
FZ_FUNCTION FzIrect FzPixmap::fz_pixmap_bbox() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_bbox()\n";
	}
	#endif
	auto ret = mupdf::fz_pixmap_bbox(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_pixmap_colorants()`.  */
FZ_FUNCTION int FzPixmap::fz_pixmap_colorants() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_colorants()\n";
	}
	#endif
	auto ret = mupdf::fz_pixmap_colorants(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_pixmap_colorspace()`.  */
FZ_FUNCTION FzColorspace FzPixmap::fz_pixmap_colorspace() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_colorspace()\n";
	}
	#endif
	auto ret = mupdf::fz_pixmap_colorspace(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_pixmap_components()`.  */
FZ_FUNCTION int FzPixmap::fz_pixmap_components() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_components()\n";
	}
	#endif
	auto ret = mupdf::fz_pixmap_components(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_pixmap_height()`.  */
FZ_FUNCTION int FzPixmap::fz_pixmap_height() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_height()\n";
	}
	#endif
	auto ret = mupdf::fz_pixmap_height(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_pixmap_samples()`.  */
FZ_FUNCTION unsigned char *FzPixmap::fz_pixmap_samples() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_samples()\n";
	}
	#endif
	auto ret = mupdf::fz_pixmap_samples(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_pixmap_samples_int()`.  */
FZ_FUNCTION long long FzPixmap::fz_pixmap_samples_int() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_samples_int()\n";
	}
	#endif
	auto ret = mupdf::fz_pixmap_samples_int(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_pixmap_size()`.  */
FZ_FUNCTION size_t FzPixmap::fz_pixmap_size() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_size()\n";
	}
	#endif
	auto ret = mupdf::fz_pixmap_size(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_pixmap_spots()`.  */
FZ_FUNCTION int FzPixmap::fz_pixmap_spots() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_spots()\n";
	}
	#endif
	auto ret = mupdf::fz_pixmap_spots(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_pixmap_stride()`.  */
FZ_FUNCTION int FzPixmap::fz_pixmap_stride() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_stride()\n";
	}
	#endif
	auto ret = mupdf::fz_pixmap_stride(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_pixmap_width()`.  */
FZ_FUNCTION int FzPixmap::fz_pixmap_width() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_width()\n";
	}
	#endif
	auto ret = mupdf::fz_pixmap_width(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_pixmap_x()`.  */
FZ_FUNCTION int FzPixmap::fz_pixmap_x() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_x()\n";
	}
	#endif
	auto ret = mupdf::fz_pixmap_x(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_pixmap_y()`.  */
FZ_FUNCTION int FzPixmap::fz_pixmap_y() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_y()\n";
	}
	#endif
	auto ret = mupdf::fz_pixmap_y(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_samples_get()`.  */
FZ_FUNCTION int FzPixmap::fz_samples_get(int offset) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_samples_get()\n";
	}
	#endif
	auto ret = mupdf::fz_samples_get(*this, offset);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_samples_set()`.  */
FZ_FUNCTION void FzPixmap::fz_samples_set(int offset, int value) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_samples_set()\n";
	}
	#endif
	mupdf::fz_samples_set(*this, offset, value);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_save_pixmap_as_jpeg()`.  */
FZ_FUNCTION void FzPixmap::fz_save_pixmap_as_jpeg(const char *filename, int quality) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_jpeg()\n";
	}
	#endif
	mupdf::fz_save_pixmap_as_jpeg(*this, filename, quality);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_save_pixmap_as_jpx()`.  */
FZ_FUNCTION void FzPixmap::fz_save_pixmap_as_jpx(const char *filename, int q) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_jpx()\n";
	}
	#endif
	mupdf::fz_save_pixmap_as_jpx(*this, filename, q);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_save_pixmap_as_pam()`.  */
FZ_FUNCTION void FzPixmap::fz_save_pixmap_as_pam(const char *filename) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_pam()\n";
	}
	#endif
	mupdf::fz_save_pixmap_as_pam(*this, filename);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_save_pixmap_as_pbm()`.  */
FZ_FUNCTION void FzPixmap::fz_save_pixmap_as_pbm(const char *filename) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_pbm()\n";
	}
	#endif
	mupdf::fz_save_pixmap_as_pbm(*this, filename);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_save_pixmap_as_pcl()`.  */
FZ_FUNCTION void FzPixmap::fz_save_pixmap_as_pcl(char *filename, int append, const FzPclOptions& pcl) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_pcl()\n";
	}
	#endif
	mupdf::fz_save_pixmap_as_pcl(*this, filename, append, pcl);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_save_pixmap_as_pclm()`.  */
FZ_FUNCTION void FzPixmap::fz_save_pixmap_as_pclm(char *filename, int append, const FzPclmOptions& options) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_pclm()\n";
	}
	#endif
	mupdf::fz_save_pixmap_as_pclm(*this, filename, append, options);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_save_pixmap_as_pdfocr()`.  */
FZ_FUNCTION void FzPixmap::fz_save_pixmap_as_pdfocr(char *filename, int append, FzPdfocrOptions& options) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_pdfocr()\n";
	}
	#endif
	mupdf::fz_save_pixmap_as_pdfocr(*this, filename, append, options);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_save_pixmap_as_pkm()`.  */
FZ_FUNCTION void FzPixmap::fz_save_pixmap_as_pkm(const char *filename) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_pkm()\n";
	}
	#endif
	mupdf::fz_save_pixmap_as_pkm(*this, filename);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_save_pixmap_as_png()`.  */
FZ_FUNCTION void FzPixmap::fz_save_pixmap_as_png(const char *filename) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_png()\n";
	}
	#endif
	mupdf::fz_save_pixmap_as_png(*this, filename);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_save_pixmap_as_pnm()`.  */
FZ_FUNCTION void FzPixmap::fz_save_pixmap_as_pnm(const char *filename) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_pnm()\n";
	}
	#endif
	mupdf::fz_save_pixmap_as_pnm(*this, filename);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_save_pixmap_as_ps()`.  */
FZ_FUNCTION void FzPixmap::fz_save_pixmap_as_ps(char *filename, int append) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_ps()\n";
	}
	#endif
	mupdf::fz_save_pixmap_as_ps(*this, filename, append);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_save_pixmap_as_psd()`.  */
FZ_FUNCTION void FzPixmap::fz_save_pixmap_as_psd(const char *filename) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_psd()\n";
	}
	#endif
	mupdf::fz_save_pixmap_as_psd(*this, filename);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_save_pixmap_as_pwg()`.  */
FZ_FUNCTION void FzPixmap::fz_save_pixmap_as_pwg(char *filename, int append, FzPwgOptions& pwg) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_pwg()\n";
	}
	#endif
	mupdf::fz_save_pixmap_as_pwg(*this, filename, append, pwg);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_scale_pixmap()`.  */
FZ_FUNCTION FzPixmap FzPixmap::fz_scale_pixmap(float x, float y, float w, float h, FzIrect& clip) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_scale_pixmap()\n";
	}
	#endif
	auto ret = mupdf::fz_scale_pixmap(*this, x, y, w, h, clip);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_set_pixmap_resolution()`.  */
FZ_FUNCTION void FzPixmap::fz_set_pixmap_resolution(int xres, int yres) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_pixmap_resolution()\n";
	}
	#endif
	mupdf::fz_set_pixmap_resolution(*this, xres, yres);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_subsample_pixmap()`.  */
FZ_FUNCTION void FzPixmap::fz_subsample_pixmap(int factor) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_subsample_pixmap()\n";
	}
	#endif
	mupdf::fz_subsample_pixmap(*this, factor);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_tint_pixmap()`.  */
FZ_FUNCTION void FzPixmap::fz_tint_pixmap(int black, int white) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_tint_pixmap()\n";
	}
	#endif
	mupdf::fz_tint_pixmap(*this, black, white);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

FZ_FUNCTION FzPixmap::FzPixmap(::fz_pixmap* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION ::fz_storable FzPixmap::storable()
{
	return m_internal->storable;
}

FZ_FUNCTION int FzPixmap::x()
{
	return m_internal->x;
}

FZ_FUNCTION int FzPixmap::y()
{
	return m_internal->y;
}

FZ_FUNCTION int FzPixmap::w()
{
	return m_internal->w;
}

FZ_FUNCTION int FzPixmap::h()
{
	return m_internal->h;
}

FZ_FUNCTION unsigned char FzPixmap::n()
{
	return m_internal->n;
}

FZ_FUNCTION unsigned char FzPixmap::s()
{
	return m_internal->s;
}

FZ_FUNCTION unsigned char FzPixmap::alpha()
{
	return m_internal->alpha;
}

FZ_FUNCTION unsigned char FzPixmap::flags()
{
	return m_internal->flags;
}

FZ_FUNCTION int FzPixmap::stride()
{
	return m_internal->stride;
}

FZ_FUNCTION FzSeparations FzPixmap::seps()
{
	ll_fz_keep_separations(m_internal->seps);
	return m_internal->seps;
}

FZ_FUNCTION int FzPixmap::xres()
{
	return m_internal->xres;
}

FZ_FUNCTION int FzPixmap::yres()
{
	return m_internal->yres;
}

FZ_FUNCTION FzColorspace FzPixmap::colorspace()
{
	ll_fz_keep_colorspace(m_internal->colorspace);
	return m_internal->colorspace;
}

FZ_FUNCTION const unsigned char *FzPixmap::samples()
{
	return m_internal->samples;
}

FZ_FUNCTION FzPixmap FzPixmap::underlying()
{
	ll_fz_keep_pixmap(m_internal->underlying);
	return m_internal->underlying;
}

FZ_FUNCTION FzPixmap::~FzPixmap()
{
	ll_fz_drop_pixmap(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzPixmap_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzPixmap::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzPixmap::s_num_instances = 0;


/* Implementation of methods for FzPixmapImage (wrapper for fz_pixmap_image). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzPixmapImage::FzPixmapImage()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_pixmap_image_tile()`.  */
FZ_FUNCTION FzPixmap FzPixmapImage::fz_pixmap_image_tile() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_image_tile()\n";
	}
	#endif
	auto ret = mupdf::fz_pixmap_image_tile(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_set_pixmap_image_tile()`.  */
FZ_FUNCTION void FzPixmapImage::fz_set_pixmap_image_tile(const FzPixmap& pix) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_pixmap_image_tile()\n";
	}
	#endif
	mupdf::fz_set_pixmap_image_tile(*this, pix);
}

FZ_FUNCTION FzPixmapImage::FzPixmapImage(::fz_pixmap_image* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzPixmapImage::~FzPixmapImage()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzPixmapImage::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzPixmapImage::s_num_instances = 0;


/* Implementation of methods for FzPoint (wrapper for fz_point). */

/** Custom constructor. */
FZ_FUNCTION FzPoint::FzPoint(float x, float y)
: x(x), y(y)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets each member to default value. */
FZ_FUNCTION FzPoint::FzPoint()
{
	this->x = {};
	this->y = {};
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_transform_point()`.  */
FZ_FUNCTION FzPoint FzPoint::fz_transform_point(const FzPoint& point, const FzMatrix& m)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_transform_point()\n";
	}
	#endif
	auto ret = mupdf::fz_transform_point(point, m);
	return ret;
}

/* Class-aware wrapper for `::fz_transform_point_xy()`.  */
FZ_FUNCTION FzPoint FzPoint::fz_transform_point_xy(float x, float y, const FzMatrix& m)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_transform_point_xy()\n";
	}
	#endif
	auto ret = mupdf::fz_transform_point_xy(x, y, m);
	return ret;
}

/* Class-aware wrapper for `::fz_transform_vector()`.  */
FZ_FUNCTION FzPoint FzPoint::fz_transform_vector(const FzPoint& vector, const FzMatrix& m)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_transform_vector()\n";
	}
	#endif
	auto ret = mupdf::fz_transform_vector(vector, m);
	return ret;
}

/* Class-aware wrapper for `::fz_is_point_inside_quad()`.  */
FZ_FUNCTION int FzPoint::fz_is_point_inside_quad(const FzQuad& q)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_point_inside_quad()\n";
	}
	#endif
	auto ret = mupdf::fz_is_point_inside_quad(*this, q);
	return ret;
}

/* Class-aware wrapper for `::fz_is_point_inside_rect()`.  */
FZ_FUNCTION int FzPoint::fz_is_point_inside_rect(const FzRect& r)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_point_inside_rect()\n";
	}
	#endif
	auto ret = mupdf::fz_is_point_inside_rect(*this, r);
	return ret;
}

/* Class-aware wrapper for `::fz_normalize_vector()`.  */
FZ_FUNCTION FzPoint FzPoint::fz_normalize_vector()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_normalize_vector()\n";
	}
	#endif
	auto ret = mupdf::fz_normalize_vector(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_transform_point()`.  */
FZ_FUNCTION FzPoint FzPoint::fz_transform_point(const FzMatrix& m)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_transform_point()\n";
	}
	#endif
	auto ret = mupdf::fz_transform_point(*this, m);
	return ret;
}

/* Class-aware wrapper for `::fz_transform_vector()`.  */
FZ_FUNCTION FzPoint FzPoint::fz_transform_vector(const FzMatrix& m)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_transform_vector()\n";
	}
	#endif
	auto ret = mupdf::fz_transform_vector(*this, m);
	return ret;
}

/** Custom method. */
FZ_FUNCTION FzPoint& FzPoint::transform(const FzMatrix& m)
{
	double  old_x = x;
	x = old_x * m.a + y * m.c + m.e;
	y = old_x * m.b + y * m.d + m.f;
	return *this;
}

FZ_FUNCTION FzPoint::FzPoint(const ::fz_point* internal)
{
	assert( internal);
	this->x = internal->x;
	this->y = internal->y;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzPoint::FzPoint(const ::fz_point internal)
{
	this->x = internal.x;
	this->y = internal.y;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::fz_point`. */
FZ_FUNCTION ::fz_point* FzPoint::internal()
{
	auto ret = (::fz_point*) &this->x;
	return ret;
}

/** Constructor using raw copy of pre-existing `::fz_point`. */
FZ_FUNCTION const ::fz_point* FzPoint::internal() const
{
	auto ret = (const ::fz_point*) &this->x;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION FzPoint::~FzPoint()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzPoint::s_num_instances = 0;

FZ_FUNCTION std::string FzPoint::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool FzPoint::operator==(const FzPoint& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool FzPoint::operator!=(const FzPoint& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for FzPool (wrapper for fz_pool). */

/* Constructor using `fz_new_pool()`. */
FZ_FUNCTION FzPool::FzPool()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pool()\n";
	}
	#endif
	this->m_internal = ll_fz_new_pool();
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Class-aware wrapper for `::fz_pool_alloc()`.  */
FZ_FUNCTION void *FzPool::fz_pool_alloc(size_t size) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pool_alloc()\n";
	}
	#endif
	auto ret = mupdf::fz_pool_alloc(*this, size);
	return ret;
}

/* Class-aware wrapper for `::fz_pool_size()`.  */
FZ_FUNCTION size_t FzPool::fz_pool_size() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pool_size()\n";
	}
	#endif
	auto ret = mupdf::fz_pool_size(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_pool_strdup()`.  */
FZ_FUNCTION char *FzPool::fz_pool_strdup(const char *s) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pool_strdup()\n";
	}
	#endif
	auto ret = mupdf::fz_pool_strdup(*this, s);
	return ret;
}

/* Class-aware wrapper for `::fz_xml_add_att()`.  */
FZ_FUNCTION void FzPool::fz_xml_add_att(const FzXml& node, const char *key, const char *val) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_add_att()\n";
	}
	#endif
	mupdf::fz_xml_add_att(*this, node, key, val);
}

FZ_FUNCTION FzPool::FzPool(::fz_pool* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzPool::~FzPool()
{
	ll_fz_drop_pool(m_internal);
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzPool::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzPool::s_num_instances = 0;


/* Implementation of methods for FzPtrHeap (wrapper for fz_ptr_heap). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzPtrHeap::FzPtrHeap()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_ptr_heap_insert()`.  */
FZ_FUNCTION void FzPtrHeap::fz_ptr_heap_insert(void *v, int (*HEAP_CMP)(void **, void **)) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_ptr_heap_insert()\n";
	}
	#endif
	mupdf::fz_ptr_heap_insert(*this, v, HEAP_CMP);
}

/* Class-aware wrapper for `::fz_ptr_heap_sort()`.  */
FZ_FUNCTION void FzPtrHeap::fz_ptr_heap_sort(int (*HEAP_CMP)(void **, void **)) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_ptr_heap_sort()\n";
	}
	#endif
	mupdf::fz_ptr_heap_sort(*this, HEAP_CMP);
}

/* Class-aware wrapper for `::fz_ptr_heap_uniq()`.  */
FZ_FUNCTION void FzPtrHeap::fz_ptr_heap_uniq(int (*HEAP_CMP)(void **, void **)) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_ptr_heap_uniq()\n";
	}
	#endif
	mupdf::fz_ptr_heap_uniq(*this, HEAP_CMP);
}

FZ_FUNCTION FzPtrHeap::FzPtrHeap(::fz_ptr_heap* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzPtrHeap::~FzPtrHeap()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzPtrHeap::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzPtrHeap::s_num_instances = 0;


/* Implementation of methods for FzPwgOptions (wrapper for fz_pwg_options). */

/** Default constructor, sets each member to default value. */
FZ_FUNCTION FzPwgOptions::FzPwgOptions()
{
	memset(&this->m_internal.media_class, 0, sizeof(this->m_internal.media_class));
	memset(&this->m_internal.media_color, 0, sizeof(this->m_internal.media_color));
	memset(&this->m_internal.media_type, 0, sizeof(this->m_internal.media_type));
	memset(&this->m_internal.output_type, 0, sizeof(this->m_internal.output_type));
	this->m_internal.advance_distance = {};
	this->m_internal.advance_media = {};
	this->m_internal.collate = {};
	this->m_internal.cut_media = {};
	this->m_internal.duplex = {};
	this->m_internal.insert_sheet = {};
	this->m_internal.jog = {};
	this->m_internal.leading_edge = {};
	this->m_internal.manual_feed = {};
	this->m_internal.media_position = {};
	this->m_internal.media_weight = {};
	this->m_internal.mirror_print = {};
	this->m_internal.negative_print = {};
	this->m_internal.num_copies = {};
	this->m_internal.orientation = {};
	this->m_internal.output_face_up = {};
	memset(&this->m_internal.PageSize, 0, sizeof(this->m_internal.PageSize));
	this->m_internal.separations = {};
	this->m_internal.tray_switch = {};
	this->m_internal.tumble = {};
	this->m_internal.media_type_num = {};
	this->m_internal.compression = {};
	this->m_internal.row_count = {};
	this->m_internal.row_feed = {};
	this->m_internal.row_step = {};
	memset(&this->m_internal.rendering_intent, 0, sizeof(this->m_internal.rendering_intent));
	memset(&this->m_internal.page_size_name, 0, sizeof(this->m_internal.page_size_name));
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzPwgOptions::FzPwgOptions(const ::fz_pwg_options* internal)
: m_internal(*internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION char * FzPwgOptions::media_class()
{
	return m_internal.media_class;
}

FZ_FUNCTION char * FzPwgOptions::media_color()
{
	return m_internal.media_color;
}

FZ_FUNCTION char * FzPwgOptions::media_type()
{
	return m_internal.media_type;
}

FZ_FUNCTION char * FzPwgOptions::output_type()
{
	return m_internal.output_type;
}

FZ_FUNCTION unsigned int FzPwgOptions::advance_distance()
{
	return m_internal.advance_distance;
}

FZ_FUNCTION int FzPwgOptions::advance_media()
{
	return m_internal.advance_media;
}

FZ_FUNCTION int FzPwgOptions::collate()
{
	return m_internal.collate;
}

FZ_FUNCTION int FzPwgOptions::cut_media()
{
	return m_internal.cut_media;
}

FZ_FUNCTION int FzPwgOptions::duplex()
{
	return m_internal.duplex;
}

FZ_FUNCTION int FzPwgOptions::insert_sheet()
{
	return m_internal.insert_sheet;
}

FZ_FUNCTION int FzPwgOptions::jog()
{
	return m_internal.jog;
}

FZ_FUNCTION int FzPwgOptions::leading_edge()
{
	return m_internal.leading_edge;
}

FZ_FUNCTION int FzPwgOptions::manual_feed()
{
	return m_internal.manual_feed;
}

FZ_FUNCTION unsigned int FzPwgOptions::media_position()
{
	return m_internal.media_position;
}

FZ_FUNCTION unsigned int FzPwgOptions::media_weight()
{
	return m_internal.media_weight;
}

FZ_FUNCTION int FzPwgOptions::mirror_print()
{
	return m_internal.mirror_print;
}

FZ_FUNCTION int FzPwgOptions::negative_print()
{
	return m_internal.negative_print;
}

FZ_FUNCTION unsigned int FzPwgOptions::num_copies()
{
	return m_internal.num_copies;
}

FZ_FUNCTION int FzPwgOptions::orientation()
{
	return m_internal.orientation;
}

FZ_FUNCTION int FzPwgOptions::output_face_up()
{
	return m_internal.output_face_up;
}

FZ_FUNCTION unsigned int * FzPwgOptions::PageSize()
{
	return m_internal.PageSize;
}

FZ_FUNCTION int FzPwgOptions::separations()
{
	return m_internal.separations;
}

FZ_FUNCTION int FzPwgOptions::tray_switch()
{
	return m_internal.tray_switch;
}

FZ_FUNCTION int FzPwgOptions::tumble()
{
	return m_internal.tumble;
}

FZ_FUNCTION int FzPwgOptions::media_type_num()
{
	return m_internal.media_type_num;
}

FZ_FUNCTION int FzPwgOptions::compression()
{
	return m_internal.compression;
}

FZ_FUNCTION unsigned int FzPwgOptions::row_count()
{
	return m_internal.row_count;
}

FZ_FUNCTION unsigned int FzPwgOptions::row_feed()
{
	return m_internal.row_feed;
}

FZ_FUNCTION unsigned int FzPwgOptions::row_step()
{
	return m_internal.row_step;
}

FZ_FUNCTION char * FzPwgOptions::rendering_intent()
{
	return m_internal.rendering_intent;
}

FZ_FUNCTION char * FzPwgOptions::page_size_name()
{
	return m_internal.page_size_name;
}

#ifndef NDEBUG
FZ_FUNCTION FzPwgOptions::~FzPwgOptions()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzPwgOptions::s_num_instances = 0;

FZ_FUNCTION std::string FzPwgOptions::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool FzPwgOptions::operator==(const FzPwgOptions& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool FzPwgOptions::operator!=(const FzPwgOptions& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for FzQuad (wrapper for fz_quad). */

/* Constructor using `fz_quad_from_rect()`. */
FZ_FUNCTION FzQuad::FzQuad(const FzRect& r)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_quad_from_rect()\n";
	}
	#endif
	*(::fz_quad*) &this->ul = ll_fz_quad_from_rect(* r.internal());
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_transform_quad()`. */
FZ_FUNCTION FzQuad::FzQuad(const FzQuad& q, const FzMatrix& m)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_transform_quad()\n";
	}
	#endif
	*(::fz_quad*) &this->ul = ll_fz_transform_quad(* q.internal(), * m.internal());
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets each member to default value. */
FZ_FUNCTION FzQuad::FzQuad()
{
	this->ul = {};
	this->ur = {};
	this->ll = {};
	this->lr = {};
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_is_quad_inside_quad()`.  */
FZ_FUNCTION int FzQuad::fz_is_quad_inside_quad(const FzQuad& haystack)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_quad_inside_quad()\n";
	}
	#endif
	auto ret = mupdf::fz_is_quad_inside_quad(*this, haystack);
	return ret;
}

/* Class-aware wrapper for `::fz_is_quad_intersecting_quad()`.  */
FZ_FUNCTION int FzQuad::fz_is_quad_intersecting_quad(const FzQuad& b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_quad_intersecting_quad()\n";
	}
	#endif
	auto ret = mupdf::fz_is_quad_intersecting_quad(*this, b);
	return ret;
}

/* Class-aware wrapper for `::fz_rect_from_quad()`.  */
FZ_FUNCTION FzRect FzQuad::fz_rect_from_quad()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_rect_from_quad()\n";
	}
	#endif
	auto ret = mupdf::fz_rect_from_quad(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_transform_quad()`.  */
FZ_FUNCTION FzQuad FzQuad::fz_transform_quad(const FzMatrix& m)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_transform_quad()\n";
	}
	#endif
	auto ret = mupdf::fz_transform_quad(*this, m);
	return ret;
}

FZ_FUNCTION FzQuad::FzQuad(const ::fz_quad* internal)
{
	assert( internal);
	this->ul = internal->ul;
	this->ur = internal->ur;
	this->ll = internal->ll;
	this->lr = internal->lr;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzQuad::FzQuad(const ::fz_quad internal)
{
	this->ul = internal.ul;
	this->ur = internal.ur;
	this->ll = internal.ll;
	this->lr = internal.lr;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::fz_quad`. */
FZ_FUNCTION ::fz_quad* FzQuad::internal()
{
	auto ret = (::fz_quad*) &this->ul;
	return ret;
}

/** Constructor using raw copy of pre-existing `::fz_quad`. */
FZ_FUNCTION const ::fz_quad* FzQuad::internal() const
{
	auto ret = (const ::fz_quad*) &this->ul;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION FzQuad::~FzQuad()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzQuad::s_num_instances = 0;

FZ_FUNCTION std::string FzQuad::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool FzQuad::operator==(const FzQuad& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool FzQuad::operator!=(const FzQuad& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for FzRange (wrapper for fz_range). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzRange::FzRange()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzRange::FzRange(::fz_range* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzRange::~FzRange()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzRange::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzRange::s_num_instances = 0;


/* Implementation of methods for FzRect (wrapper for fz_rect). */

/* Constructor using `fz_bound_display_list()`. */
FZ_FUNCTION FzRect::FzRect(const FzDisplayList& list)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_bound_display_list()\n";
	}
	#endif
	*(::fz_rect*) &this->x0 = ll_fz_bound_display_list(list.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_rect_from_irect()`. */
FZ_FUNCTION FzRect::FzRect(const FzIrect& bbox)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_rect_from_irect()\n";
	}
	#endif
	*(::fz_rect*) &this->x0 = ll_fz_rect_from_irect(* bbox.internal());
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_rect_from_quad()`. */
FZ_FUNCTION FzRect::FzRect(const FzQuad& q)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_rect_from_quad()\n";
	}
	#endif
	*(::fz_rect*) &this->x0 = ll_fz_rect_from_quad(* q.internal());
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_transform_rect()`. */
FZ_FUNCTION FzRect::FzRect(const FzRect& rect, const FzMatrix& m)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_transform_rect()\n";
	}
	#endif
	*(::fz_rect*) &this->x0 = ll_fz_transform_rect(* rect.internal(), * m.internal());
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION FzRect::FzRect(double x0, double y0, double x1, double y1)
:
x0(x0),
x1(x1),
y0(y0),
y1(y1)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION FzRect::FzRect(const FzRect& rhs)
:
x0(rhs.x0),
y0(rhs.y0),
x1(rhs.x1),
y1(rhs.y1)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION FzRect::FzRect(Fixed fixed)
{
	if (0)  {}
	else if (fixed == Fixed_UNIT)       *this->internal() = ::fz_unit_rect;
	else if (fixed == Fixed_EMPTY)      *this->internal() = ::fz_empty_rect;
	else if (fixed == Fixed_INFINITE)   *this->internal() = ::fz_infinite_rect;
	else throw FzErrorAbort( "Unrecognised From value");
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets each member to default value. */
FZ_FUNCTION FzRect::FzRect()
{
	this->x0 = {};
	this->y0 = {};
	this->x1 = {};
	this->y1 = {};
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_intersect_rect()`.  */
FZ_FUNCTION FzRect FzRect::fz_intersect_rect(const FzRect& a, const FzRect& b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_intersect_rect()\n";
	}
	#endif
	auto ret = mupdf::fz_intersect_rect(a, b);
	return ret;
}

/* Class-aware wrapper for `::fz_union_rect()`.  */
FZ_FUNCTION FzRect FzRect::fz_union_rect(const FzRect& a, const FzRect& b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_union_rect()\n";
	}
	#endif
	auto ret = mupdf::fz_union_rect(a, b);
	return ret;
}

/* Class-aware wrapper for `::fz_adjust_rect_for_stroke()`.  */
FZ_FUNCTION FzRect FzRect::fz_adjust_rect_for_stroke(const FzStrokeState& stroke, const FzMatrix& ctm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_adjust_rect_for_stroke()\n";
	}
	#endif
	auto ret = mupdf::fz_adjust_rect_for_stroke(*this, stroke, ctm);
	return ret;
}

/* Class-aware wrapper for `::fz_contains_rect()`.  */
FZ_FUNCTION int FzRect::fz_contains_rect(const FzRect& b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_contains_rect()\n";
	}
	#endif
	auto ret = mupdf::fz_contains_rect(*this, b);
	return ret;
}

/* Class-aware wrapper for `::fz_expand_rect()`.  */
FZ_FUNCTION FzRect FzRect::fz_expand_rect(float expand)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_expand_rect()\n";
	}
	#endif
	auto ret = mupdf::fz_expand_rect(*this, expand);
	return ret;
}

/* Class-aware wrapper for `::fz_include_point_in_rect()`.  */
FZ_FUNCTION FzRect FzRect::fz_include_point_in_rect(const FzPoint& p)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_include_point_in_rect()\n";
	}
	#endif
	auto ret = mupdf::fz_include_point_in_rect(*this, p);
	return ret;
}

/* Class-aware wrapper for `::fz_intersect_rect()`.  */
FZ_FUNCTION FzRect FzRect::fz_intersect_rect(const FzRect& b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_intersect_rect()\n";
	}
	#endif
	auto ret = mupdf::fz_intersect_rect(*this, b);
	return ret;
}

/* Class-aware wrapper for `::fz_irect_from_rect()`.  */
FZ_FUNCTION FzIrect FzRect::fz_irect_from_rect()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_irect_from_rect()\n";
	}
	#endif
	auto ret = mupdf::fz_irect_from_rect(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_is_empty_rect()`.  */
FZ_FUNCTION int FzRect::fz_is_empty_rect()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_empty_rect()\n";
	}
	#endif
	auto ret = mupdf::fz_is_empty_rect(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_is_infinite_rect()`.  */
FZ_FUNCTION int FzRect::fz_is_infinite_rect()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_infinite_rect()\n";
	}
	#endif
	auto ret = mupdf::fz_is_infinite_rect(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_is_valid_rect()`.  */
FZ_FUNCTION int FzRect::fz_is_valid_rect()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_valid_rect()\n";
	}
	#endif
	auto ret = mupdf::fz_is_valid_rect(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_new_bbox_device()`.  */
FZ_FUNCTION FzDevice FzRect::fz_new_bbox_device()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_bbox_device()\n";
	}
	#endif
	auto ret = mupdf::fz_new_bbox_device(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_new_display_list()`.  */
FZ_FUNCTION FzDisplayList FzRect::fz_new_display_list()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_display_list()\n";
	}
	#endif
	auto ret = mupdf::fz_new_display_list(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_quad_from_rect()`.  */
FZ_FUNCTION FzQuad FzRect::fz_quad_from_rect()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_quad_from_rect()\n";
	}
	#endif
	auto ret = mupdf::fz_quad_from_rect(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_round_rect()`.  */
FZ_FUNCTION FzIrect FzRect::fz_round_rect()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_round_rect()\n";
	}
	#endif
	auto ret = mupdf::fz_round_rect(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_transform_page()`.  */
FZ_FUNCTION FzMatrix FzRect::fz_transform_page(float resolution, float rotate)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_transform_page()\n";
	}
	#endif
	auto ret = mupdf::fz_transform_page(*this, resolution, rotate);
	return ret;
}

/* Class-aware wrapper for `::fz_transform_rect()`.  */
FZ_FUNCTION FzRect FzRect::fz_transform_rect(const FzMatrix& m)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_transform_rect()\n";
	}
	#endif
	auto ret = mupdf::fz_transform_rect(*this, m);
	return ret;
}

/* Class-aware wrapper for `::fz_translate_rect()`.  */
FZ_FUNCTION FzRect FzRect::fz_translate_rect(float xoff, float yoff)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_translate_rect()\n";
	}
	#endif
	auto ret = mupdf::fz_translate_rect(*this, xoff, yoff);
	return ret;
}

/* Class-aware wrapper for `::fz_union_rect()`.  */
FZ_FUNCTION FzRect FzRect::fz_union_rect(const FzRect& b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_union_rect()\n";
	}
	#endif
	auto ret = mupdf::fz_union_rect(*this, b);
	return ret;
}

/* Class-aware wrapper for `::pdf_signature_appearance_signed()`.  */
FZ_FUNCTION FzDisplayList FzRect::pdf_signature_appearance_signed(::fz_text_language lang, const FzImage& img, const char *left_text, const char *right_text, int include_logo)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_appearance_signed()\n";
	}
	#endif
	auto ret = mupdf::pdf_signature_appearance_signed(*this, lang, img, left_text, right_text, include_logo);
	return ret;
}

/* Class-aware wrapper for `::pdf_signature_appearance_unsigned()`.  */
FZ_FUNCTION FzDisplayList FzRect::pdf_signature_appearance_unsigned(::fz_text_language lang)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_appearance_unsigned()\n";
	}
	#endif
	auto ret = mupdf::pdf_signature_appearance_unsigned(*this, lang);
	return ret;
}

/** Custom method. */
FZ_FUNCTION void FzRect::transform(const FzMatrix& m)
{
	*(::fz_rect*) &this->x0 = ::fz_transform_rect(*(::fz_rect*) &this->x0, *(::fz_matrix*) &m.a);
}

/** Custom method. */
FZ_FUNCTION bool FzRect::contains(double x, double y)
{
	if (is_empty()) {
		return false;
	}
	return true
			&& x >= x0
			&& x < x1
			&& y >= y0
			&& y < y1
			;
}

/** Custom method. */
FZ_FUNCTION bool FzRect::contains(FzRect& rhs)
{
	return ::fz_contains_rect(*(::fz_rect*) &x0, *(::fz_rect*) &rhs.x0);
}

/** Custom method. */
FZ_FUNCTION bool FzRect::is_empty()
{
	return ::fz_is_empty_rect(*(::fz_rect*) &x0);
}

/** Custom method. */
FZ_FUNCTION void FzRect::union_(FzRect& rhs)
{
	*(::fz_rect*) &x0 = ::fz_union_rect(*(::fz_rect*) &x0, *(::fz_rect*) &rhs.x0);
}

FZ_FUNCTION FzRect::FzRect(const ::fz_rect* internal)
{
	assert( internal);
	this->x0 = internal->x0;
	this->y0 = internal->y0;
	this->x1 = internal->x1;
	this->y1 = internal->y1;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzRect::FzRect(const ::fz_rect internal)
{
	this->x0 = internal.x0;
	this->y0 = internal.y0;
	this->x1 = internal.x1;
	this->y1 = internal.y1;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::fz_rect`. */
FZ_FUNCTION ::fz_rect* FzRect::internal()
{
	auto ret = (::fz_rect*) &this->x0;
	return ret;
}

/** Constructor using raw copy of pre-existing `::fz_rect`. */
FZ_FUNCTION const ::fz_rect* FzRect::internal() const
{
	auto ret = (const ::fz_rect*) &this->x0;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION FzRect::~FzRect()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzRect::s_num_instances = 0;

FZ_FUNCTION std::string FzRect::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool FzRect::operator==(const FzRect& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool FzRect::operator!=(const FzRect& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for FzSeparations (wrapper for fz_separations). */

#ifndef NDEBUG
static RefsCheck<::fz_separations, FzSeparations> s_FzSeparations_refs_check(0, 32);
#endif

/* Constructor using `fz_new_separations()`. */
FZ_FUNCTION FzSeparations::FzSeparations(int controllable)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_separations()\n";
	}
	#endif
	this->m_internal = ll_fz_new_separations(controllable);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzSeparations_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_separations()`. */
FZ_FUNCTION FzSeparations::FzSeparations(const FzSeparations& rhs)
: m_internal(ll_fz_keep_separations(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_separations(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzSeparations_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_separations()` and `fz_drop_separations()`. */
FZ_FUNCTION FzSeparations& FzSeparations::operator=(const FzSeparations& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_separations(this->m_internal)"
				<< " and ll_fz_keep_separations(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_separations(this->m_internal);
	ll_fz_keep_separations(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzSeparations_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzSeparations_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/* Class-aware wrapper for `::fz_add_separation()`.  */
FZ_FUNCTION void FzSeparations::fz_add_separation(const char *name, const FzColorspace& cs, int cs_channel) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_add_separation()\n";
	}
	#endif
	mupdf::fz_add_separation(*this, name, cs, cs_channel);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzSeparations_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_add_separation_equivalents()`.  */
FZ_FUNCTION void FzSeparations::fz_add_separation_equivalents(uint32_t rgba, uint32_t cmyk, const char *name) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_add_separation_equivalents()\n";
	}
	#endif
	mupdf::fz_add_separation_equivalents(*this, rgba, cmyk, name);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzSeparations_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_clone_separations_for_overprint()`.  */
FZ_FUNCTION FzSeparations FzSeparations::fz_clone_separations_for_overprint() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clone_separations_for_overprint()\n";
	}
	#endif
	auto ret = mupdf::fz_clone_separations_for_overprint(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzSeparations_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_compare_separations()`.  */
FZ_FUNCTION int FzSeparations::fz_compare_separations(const FzSeparations& sep2) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_compare_separations()\n";
	}
	#endif
	auto ret = mupdf::fz_compare_separations(*this, sep2);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzSeparations_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_count_active_separations()`.  */
FZ_FUNCTION int FzSeparations::fz_count_active_separations() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_count_active_separations()\n";
	}
	#endif
	auto ret = mupdf::fz_count_active_separations(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzSeparations_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_count_separations()`.  */
FZ_FUNCTION int FzSeparations::fz_count_separations() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_count_separations()\n";
	}
	#endif
	auto ret = mupdf::fz_count_separations(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzSeparations_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_separation_equivalent()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_separation_equivalent(int idx, ::fz_colorspace *dst_cs, ::fz_colorspace *prf, ::fz_color_params color_params)` => float dst_color
	 */
FZ_FUNCTION void FzSeparations::fz_separation_equivalent(int idx, const FzColorspace& dst_cs, float *dst_color, const FzColorspace& prf, const FzColorParams& color_params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_separation_equivalent()\n";
	}
	#endif
	mupdf::fz_separation_equivalent(*this, idx, dst_cs, dst_color, prf, color_params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzSeparations_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_separation_name()`.  */
FZ_FUNCTION const char *FzSeparations::fz_separation_name(int separation) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_separation_name()\n";
	}
	#endif
	auto ret = mupdf::fz_separation_name(*this, separation);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzSeparations_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_set_separation_behavior()`.  */
FZ_FUNCTION void FzSeparations::fz_set_separation_behavior(int separation, ::fz_separation_behavior behavior) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_separation_behavior()\n";
	}
	#endif
	mupdf::fz_set_separation_behavior(*this, separation, behavior);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzSeparations_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

FZ_FUNCTION FzSeparations::FzSeparations(::fz_separations* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzSeparations_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzSeparations::~FzSeparations()
{
	ll_fz_drop_separations(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzSeparations_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzSeparations::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzSeparations::s_num_instances = 0;


/* Implementation of methods for FzSha256 (wrapper for fz_sha256). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzSha256::FzSha256()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_sha256_final()`.  */
FZ_FUNCTION void FzSha256::fz_sha256_final(unsigned char digest[32]) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_sha256_final()\n";
	}
	#endif
	mupdf::fz_sha256_final(*this, digest);
}

/* Class-aware wrapper for `::fz_sha256_init()`.  */
FZ_FUNCTION void FzSha256::fz_sha256_init() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_sha256_init()\n";
	}
	#endif
	mupdf::fz_sha256_init(*this);
}

/* Class-aware wrapper for `::fz_sha256_update()`.  */
FZ_FUNCTION void FzSha256::fz_sha256_update(const unsigned char *input, size_t inlen) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_sha256_update()\n";
	}
	#endif
	mupdf::fz_sha256_update(*this, input, inlen);
}

FZ_FUNCTION FzSha256::FzSha256(::fz_sha256* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzSha256::~FzSha256()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzSha256::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzSha256::s_num_instances = 0;


/* Implementation of methods for FzSha384 (wrapper for fz_sha384). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzSha384::FzSha384()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzSha384::FzSha384(::fz_sha384* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzSha384::~FzSha384()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzSha384::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzSha384::s_num_instances = 0;


/* Implementation of methods for FzSha512 (wrapper for fz_sha512). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzSha512::FzSha512()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_sha384_final()`.  */
FZ_FUNCTION void FzSha512::fz_sha384_final(unsigned char digest[64]) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_sha384_final()\n";
	}
	#endif
	mupdf::fz_sha384_final(*this, digest);
}

/* Class-aware wrapper for `::fz_sha384_init()`.  */
FZ_FUNCTION void FzSha512::fz_sha384_init() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_sha384_init()\n";
	}
	#endif
	mupdf::fz_sha384_init(*this);
}

/* Class-aware wrapper for `::fz_sha384_update()`.  */
FZ_FUNCTION void FzSha512::fz_sha384_update(const unsigned char *input, size_t inlen) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_sha384_update()\n";
	}
	#endif
	mupdf::fz_sha384_update(*this, input, inlen);
}

/* Class-aware wrapper for `::fz_sha512_final()`.  */
FZ_FUNCTION void FzSha512::fz_sha512_final(unsigned char digest[64]) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_sha512_final()\n";
	}
	#endif
	mupdf::fz_sha512_final(*this, digest);
}

/* Class-aware wrapper for `::fz_sha512_init()`.  */
FZ_FUNCTION void FzSha512::fz_sha512_init() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_sha512_init()\n";
	}
	#endif
	mupdf::fz_sha512_init(*this);
}

/* Class-aware wrapper for `::fz_sha512_update()`.  */
FZ_FUNCTION void FzSha512::fz_sha512_update(const unsigned char *input, size_t inlen) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_sha512_update()\n";
	}
	#endif
	mupdf::fz_sha512_update(*this, input, inlen);
}

FZ_FUNCTION FzSha512::FzSha512(::fz_sha512* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzSha512::~FzSha512()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzSha512::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzSha512::s_num_instances = 0;


/* Implementation of methods for FzShade (wrapper for fz_shade). */

#ifndef NDEBUG
static RefsCheck<::fz_shade, FzShade> s_FzShade_refs_check(offsetof(::fz_shade, storable.refs), 32);
#endif

/** Copy constructor using `fz_keep_shade()`. */
FZ_FUNCTION FzShade::FzShade(const FzShade& rhs)
: m_internal(ll_fz_keep_shade(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_shade(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzShade_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_shade()` and `fz_drop_shade()`. */
FZ_FUNCTION FzShade& FzShade::operator=(const FzShade& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_shade(this->m_internal)"
				<< " and ll_fz_keep_shade(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_shade(this->m_internal);
	ll_fz_keep_shade(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzShade_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzShade_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzShade::FzShade()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzShade_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_bound_shade()`.  */
FZ_FUNCTION FzRect FzShade::fz_bound_shade(const FzMatrix& ctm) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_bound_shade()\n";
	}
	#endif
	auto ret = mupdf::fz_bound_shade(*this, ctm);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzShade_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_paint_shade()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_paint_shade(::fz_colorspace *override_cs, ::fz_matrix ctm, ::fz_pixmap *dest, ::fz_color_params color_params, ::fz_irect bbox, const ::fz_overprint *eop, ::fz_shade_color_cache **cache)` => 
	 */
FZ_FUNCTION void FzShade::fz_paint_shade(const FzColorspace& override_cs, const FzMatrix& ctm, const FzPixmap& dest, const FzColorParams& color_params, const FzIrect& bbox, const FzOverprint& eop, FzShadeColorCache& cache) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_paint_shade()\n";
	}
	#endif
	mupdf::fz_paint_shade(*this, override_cs, ctm, dest, color_params, bbox, eop, cache);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzShade_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_process_shade()`.  */
FZ_FUNCTION void FzShade::fz_process_shade(const FzMatrix& ctm, const FzRect& scissor, ::fz_shade_prepare_fn *prepare, ::fz_shade_process_fn *process, void *process_arg) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_process_shade()\n";
	}
	#endif
	mupdf::fz_process_shade(*this, ctm, scissor, prepare, process, process_arg);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzShade_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/** Custom method. */
FZ_FUNCTION void FzShade::fz_paint_shade_no_cache( const FzColorspace& override_cs, FzMatrix& ctm, const FzPixmap& dest, FzColorParams& color_params, FzIrect& bbox, const FzOverprint& eop)
{
	return ll_fz_paint_shade(
			this->m_internal,
			override_cs.m_internal,
			*(::fz_matrix*) &ctm.a,
			dest.m_internal,
			*(::fz_color_params*) &color_params.ri,
			*(::fz_irect*) &bbox.x0,
			eop.m_internal,
			NULL /*cache*/
			);
}

FZ_FUNCTION FzShade::FzShade(::fz_shade* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzShade_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzShade::~FzShade()
{
	ll_fz_drop_shade(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzShade_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzShade::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzShade::s_num_instances = 0;


/* Implementation of methods for FzShadeColorCache (wrapper for fz_shade_color_cache). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzShadeColorCache::FzShadeColorCache()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzShadeColorCache::FzShadeColorCache(::fz_shade_color_cache* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzShadeColorCache::~FzShadeColorCache()
{
	ll_fz_drop_shade_color_cache(m_internal);
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzShadeColorCache::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzShadeColorCache::s_num_instances = 0;


/* Implementation of methods for FzShaperDataT (wrapper for fz_shaper_data_t). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzShaperDataT::FzShaperDataT()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzShaperDataT::FzShaperDataT(::fz_shaper_data_t* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzShaperDataT::~FzShaperDataT()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzShaperDataT::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzShaperDataT::s_num_instances = 0;


/* Implementation of methods for FzStextBlock (wrapper for fz_stext_block). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzStextBlock::FzStextBlock()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/** Custom method. */
FZ_FUNCTION FzMatrix FzStextBlock::i_transform()
{
	if (m_internal->type != FZ_STEXT_BLOCK_IMAGE) {
		throw std::runtime_error("Not an image");
	}
	return m_internal->u.i.transform;
}

/** Custom method. */
FZ_FUNCTION FzImage FzStextBlock::i_image()
{
	if (m_internal->type != FZ_STEXT_BLOCK_IMAGE) {
		throw std::runtime_error("Not an image");
	}
	return ll_fz_keep_image(m_internal->u.i.image);
}

/** Custom method. */
FZ_FUNCTION FzStextBlockIterator FzStextBlock::begin()
{
	auto ret = FzStextBlockIterator(m_internal->u.t.first_line);
	#ifndef NDEBUG
	#if 0
	if (s_check_refs)
	{
		s_FzStextBlock_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#endif
	return ret;
}

/** Custom method. */
FZ_FUNCTION FzStextBlockIterator FzStextBlock::end()
{
	auto ret = FzStextBlockIterator(NULL);
	#ifndef NDEBUG
	#if 0
	if (s_check_refs)
	{
		s_FzStextBlock_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#endif
	return ret;
}

FZ_FUNCTION FzStextBlock::FzStextBlock(::fz_stext_block* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzStextBlock::~FzStextBlock()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzStextBlock::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzStextBlock::s_num_instances = 0;

/* .extra_cpp for fz_stext_block. */

FZ_FUNCTION FzStextBlockIterator::FzStextBlockIterator(const FzStextLine& item)
: m_item( item)
{
}
FZ_FUNCTION FzStextBlockIterator& FzStextBlockIterator::operator++()
{

	m_item = FzStextLine(m_item.m_internal->next);
	return *this;
}
FZ_FUNCTION bool FzStextBlockIterator::operator==( const FzStextBlockIterator& rhs)
{
	return m_item.m_internal == rhs.m_item.m_internal;
}
FZ_FUNCTION bool FzStextBlockIterator::operator!=( const FzStextBlockIterator& rhs)
{
	return m_item.m_internal != rhs.m_item.m_internal;
}
FZ_FUNCTION FzStextLine FzStextBlockIterator::operator*()
{
	return m_item;
}
FZ_FUNCTION FzStextLine* FzStextBlockIterator::operator->()
{
	return &m_item;
}


/* Implementation of methods for FzStextChar (wrapper for fz_stext_char). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzStextChar::FzStextChar()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzStextChar::FzStextChar(::fz_stext_char* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzStextChar::~FzStextChar()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzStextChar::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzStextChar::s_num_instances = 0;


/* Implementation of methods for FzStextLine (wrapper for fz_stext_line). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzStextLine::FzStextLine()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/** Custom method. */
FZ_FUNCTION FzStextLineIterator FzStextLine::begin()
{
	auto ret = FzStextLineIterator(m_internal->first_char);
	#ifndef NDEBUG
	#if 0
	if (s_check_refs)
	{
		s_FzStextLine_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#endif
	return ret;
}

/** Custom method. */
FZ_FUNCTION FzStextLineIterator FzStextLine::end()
{
	auto ret = FzStextLineIterator(NULL);
	#ifndef NDEBUG
	#if 0
	if (s_check_refs)
	{
		s_FzStextLine_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#endif
	return ret;
}

FZ_FUNCTION FzStextLine::FzStextLine(::fz_stext_line* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzStextLine::~FzStextLine()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzStextLine::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzStextLine::s_num_instances = 0;

/* .extra_cpp for fz_stext_line. */

FZ_FUNCTION FzStextLineIterator::FzStextLineIterator(const FzStextChar& item)
: m_item( item)
{
}
FZ_FUNCTION FzStextLineIterator& FzStextLineIterator::operator++()
{

	m_item = FzStextChar(m_item.m_internal->next);
	return *this;
}
FZ_FUNCTION bool FzStextLineIterator::operator==( const FzStextLineIterator& rhs)
{
	return m_item.m_internal == rhs.m_item.m_internal;
}
FZ_FUNCTION bool FzStextLineIterator::operator!=( const FzStextLineIterator& rhs)
{
	return m_item.m_internal != rhs.m_item.m_internal;
}
FZ_FUNCTION FzStextChar FzStextLineIterator::operator*()
{
	return m_item;
}
FZ_FUNCTION FzStextChar* FzStextLineIterator::operator->()
{
	return &m_item;
}


/* Implementation of methods for FzStextOptions (wrapper for fz_stext_options). */

/** Custom constructor. */
FZ_FUNCTION FzStextOptions::FzStextOptions(int flags)
: flags( flags)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets each member to default value. */
FZ_FUNCTION FzStextOptions::FzStextOptions()
{
	this->flags = {};
	this->scale = {};
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_parse_stext_options()`.  */
FZ_FUNCTION FzStextOptions FzStextOptions::fz_parse_stext_options(const char *string)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_parse_stext_options()\n";
	}
	#endif
	auto ret = mupdf::fz_parse_stext_options(*this, string);
	return ret;
}

FZ_FUNCTION FzStextOptions::FzStextOptions(const ::fz_stext_options* internal)
{
	assert( internal);
	this->flags = internal->flags;
	this->scale = internal->scale;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzStextOptions::FzStextOptions(const ::fz_stext_options internal)
{
	this->flags = internal.flags;
	this->scale = internal.scale;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::fz_stext_options`. */
FZ_FUNCTION ::fz_stext_options* FzStextOptions::internal()
{
	auto ret = (::fz_stext_options*) &this->flags;
	return ret;
}

/** Constructor using raw copy of pre-existing `::fz_stext_options`. */
FZ_FUNCTION const ::fz_stext_options* FzStextOptions::internal() const
{
	auto ret = (const ::fz_stext_options*) &this->flags;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION FzStextOptions::~FzStextOptions()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzStextOptions::s_num_instances = 0;

FZ_FUNCTION std::string FzStextOptions::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool FzStextOptions::operator==(const FzStextOptions& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool FzStextOptions::operator!=(const FzStextOptions& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for FzStextPage (wrapper for fz_stext_page). */

/* Constructor using `fz_new_stext_page()`. */
FZ_FUNCTION FzStextPage::FzStextPage(const FzRect& mediabox)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_stext_page()\n";
	}
	#endif
	this->m_internal = ll_fz_new_stext_page(* mediabox.internal());
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_stext_page_from_chapter_page_number()`. */
FZ_FUNCTION FzStextPage::FzStextPage(const FzDocument& doc, int chapter, int number, FzStextOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_stext_page_from_chapter_page_number()\n";
	}
	#endif
	this->m_internal = ll_fz_new_stext_page_from_chapter_page_number(doc.m_internal, chapter, number,  options.internal());
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_stext_page_from_display_list()`. */
FZ_FUNCTION FzStextPage::FzStextPage(const FzDisplayList& list, FzStextOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_stext_page_from_display_list()\n";
	}
	#endif
	this->m_internal = ll_fz_new_stext_page_from_display_list(list.m_internal,  options.internal());
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_stext_page_from_page()`. */
FZ_FUNCTION FzStextPage::FzStextPage(const FzPage& page, FzStextOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_stext_page_from_page()\n";
	}
	#endif
	this->m_internal = ll_fz_new_stext_page_from_page(page.m_internal,  options.internal());
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_stext_page_from_page_number()`. */
FZ_FUNCTION FzStextPage::FzStextPage(const FzDocument& doc, int number, FzStextOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_stext_page_from_page_number()\n";
	}
	#endif
	this->m_internal = ll_fz_new_stext_page_from_page_number(doc.m_internal, number,  options.internal());
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_stext_page_from_annot()`. */
FZ_FUNCTION FzStextPage::FzStextPage(const PdfAnnot& annot, FzStextOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_stext_page_from_annot()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_stext_page_from_annot(annot.m_internal,  options.internal());
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzStextPage::FzStextPage()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_highlight_selection()`.  */
FZ_FUNCTION int FzStextPage::fz_highlight_selection(const FzPoint& a, const FzPoint& b, FzQuad& quads, int max_quads) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_highlight_selection()\n";
	}
	#endif
	auto ret = mupdf::fz_highlight_selection(*this, a, b, quads, max_quads);
	return ret;
}

/* Class-aware wrapper for `::fz_highlight_selection2()`.  */
FZ_FUNCTION std::vector<fz_quad> FzStextPage::fz_highlight_selection2(const FzPoint& a, const FzPoint& b, int max_quads) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_highlight_selection2()\n";
	}
	#endif
	auto ret = mupdf::fz_highlight_selection2(*this, a, b, max_quads);
	return ret;
}

/* Class-aware wrapper for `::fz_new_buffer_from_stext_page()`.  */
FZ_FUNCTION FzBuffer FzStextPage::fz_new_buffer_from_stext_page() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_stext_page()\n";
	}
	#endif
	auto ret = mupdf::fz_new_buffer_from_stext_page(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_new_stext_device()`.  */
FZ_FUNCTION FzDevice FzStextPage::fz_new_stext_device(FzStextOptions& options) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_stext_device()\n";
	}
	#endif
	auto ret = mupdf::fz_new_stext_device(*this, options);
	return ret;
}

/* Class-aware wrapper for `::fz_search_stext_page()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_search_stext_page(const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
	 */
FZ_FUNCTION int FzStextPage::fz_search_stext_page(const char *needle, int *hit_mark, FzQuad& hit_bbox, int hit_max) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_search_stext_page()\n";
	}
	#endif
	auto ret = mupdf::fz_search_stext_page(*this, needle, hit_mark, hit_bbox, hit_max);
	return ret;
}

/* Class-aware wrapper for `::fz_snap_selection()`.  */
FZ_FUNCTION FzQuad FzStextPage::fz_snap_selection(FzPoint& ap, FzPoint& bp, int mode) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_snap_selection()\n";
	}
	#endif
	auto ret = mupdf::fz_snap_selection(*this, ap, bp, mode);
	return ret;
}

/** Custom method. */
FZ_FUNCTION std::string FzStextPage::fz_copy_selection(FzPoint& a, FzPoint& b, int crlf)
{
	char* text = ll_fz_copy_selection(m_internal, *(::fz_point *) &a.x, *(::fz_point *) &b.x, crlf);
	std::string ret(text);
	ll_fz_free(text);
	return ret;
}

/** Custom method. */
FZ_FUNCTION std::string FzStextPage::fz_copy_rectangle(FzRect& area, int crlf)
{
	char* text = ll_fz_copy_rectangle(m_internal, *(::fz_rect*) &area.x0, crlf);
	std::string ret(text);
	ll_fz_free(text);
	return ret;
}

/** Custom method. */
FZ_FUNCTION std::vector<FzQuad> FzStextPage::search_stext_page(const char* needle, int *hit_mark, int max_quads)
{
	std::vector<FzQuad> ret(max_quads);
	int n = ll_fz_search_stext_page(m_internal, needle, hit_mark, ret[0].internal(), max_quads);
	ret.resize(n);
	return ret;
}

/** Custom method. */
FZ_FUNCTION FzStextPageIterator FzStextPage::begin()
{
	auto ret = FzStextPageIterator(m_internal->first_block);
	#ifndef NDEBUG
	#if 0
	if (s_check_refs)
	{
		s_FzStextPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#endif
	return ret;
}

/** Custom method. */
FZ_FUNCTION FzStextPageIterator FzStextPage::end()
{
	auto ret = FzStextPageIterator(NULL);
	#ifndef NDEBUG
	#if 0
	if (s_check_refs)
	{
		s_FzStextPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#endif
	return ret;
}

FZ_FUNCTION FzStextPage::FzStextPage(::fz_stext_page* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzStextPage::~FzStextPage()
{
	ll_fz_drop_stext_page(m_internal);
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzStextPage::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzStextPage::s_num_instances = 0;

/* .extra_cpp for fz_stext_page. */

FZ_FUNCTION FzStextPageIterator::FzStextPageIterator(const FzStextBlock& item)
: m_item( item)
{
}
FZ_FUNCTION FzStextPageIterator& FzStextPageIterator::operator++()
{

	m_item = FzStextBlock(m_item.m_internal->next);
	return *this;
}
FZ_FUNCTION bool FzStextPageIterator::operator==( const FzStextPageIterator& rhs)
{
	return m_item.m_internal == rhs.m_item.m_internal;
}
FZ_FUNCTION bool FzStextPageIterator::operator!=( const FzStextPageIterator& rhs)
{
	return m_item.m_internal != rhs.m_item.m_internal;
}
FZ_FUNCTION FzStextBlock FzStextPageIterator::operator*()
{
	return m_item;
}
FZ_FUNCTION FzStextBlock* FzStextPageIterator::operator->()
{
	return &m_item;
}


/* Implementation of methods for FzStorable (wrapper for fz_storable). */

#ifndef NDEBUG
static RefsCheck<::fz_storable, FzStorable> s_FzStorable_refs_check(offsetof(::fz_storable, refs), 32);
#endif

/** Copy constructor using `fz_keep_storable()`. */
FZ_FUNCTION FzStorable::FzStorable(const FzStorable& rhs)
: m_internal((::fz_storable*) ll_fz_keep_storable(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_storable(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStorable_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_storable()` and `fz_drop_storable()`. */
FZ_FUNCTION FzStorable& FzStorable::operator=(const FzStorable& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_storable(this->m_internal)"
				<< " and ll_fz_keep_storable(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_storable(this->m_internal);
	ll_fz_keep_storable(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStorable_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = (::fz_storable*) rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStorable_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzStorable::FzStorable()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStorable_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzStorable::FzStorable(::fz_storable* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStorable_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzStorable::~FzStorable()
{
	ll_fz_drop_storable(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStorable_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzStorable::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzStorable::s_num_instances = 0;


/* Implementation of methods for FzStore (wrapper for fz_store). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzStore::FzStore()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzStore::FzStore(::fz_store* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzStore::~FzStore()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzStore::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzStore::s_num_instances = 0;


/* Implementation of methods for FzStoreHash (wrapper for fz_store_hash). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzStoreHash::FzStoreHash()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzStoreHash::FzStoreHash(::fz_store_hash* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzStoreHash::~FzStoreHash()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzStoreHash::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzStoreHash::s_num_instances = 0;


/* Implementation of methods for FzStoreType (wrapper for fz_store_type). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzStoreType::FzStoreType()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzStoreType::FzStoreType(::fz_store_type* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzStoreType::~FzStoreType()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzStoreType::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzStoreType::s_num_instances = 0;


/* Implementation of methods for FzStory (wrapper for fz_story). */

/* Constructor using `fz_new_story()`. */
FZ_FUNCTION FzStory::FzStory(const FzBuffer& buf, const char *user_css, float em, const FzArchive& dir)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_story()\n";
	}
	#endif
	this->m_internal = ll_fz_new_story(buf.m_internal, user_css, em, dir.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzStory::FzStory()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_draw_story()`.  */
FZ_FUNCTION void FzStory::fz_draw_story(const FzDevice& dev, const FzMatrix& ctm) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_draw_story()\n";
	}
	#endif
	mupdf::fz_draw_story(*this, dev, ctm);
}

/* Class-aware wrapper for `::fz_place_story()`.  */
FZ_FUNCTION int FzStory::fz_place_story(const FzRect& where, FzRect& filled) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_place_story()\n";
	}
	#endif
	auto ret = mupdf::fz_place_story(*this, where, filled);
	return ret;
}

/* Class-aware wrapper for `::fz_place_story_flags()`.  */
FZ_FUNCTION int FzStory::fz_place_story_flags(const FzRect& where, FzRect& filled, int flags) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_place_story_flags()\n";
	}
	#endif
	auto ret = mupdf::fz_place_story_flags(*this, where, filled, flags);
	return ret;
}

/* Class-aware wrapper for `::fz_reset_story()`.  */
FZ_FUNCTION void FzStory::fz_reset_story() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_reset_story()\n";
	}
	#endif
	mupdf::fz_reset_story(*this);
}

/* Class-aware wrapper for `::fz_story_document()`.  */
FZ_FUNCTION FzXml FzStory::fz_story_document() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_story_document()\n";
	}
	#endif
	auto ret = mupdf::fz_story_document(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_story_positions()`.  */
FZ_FUNCTION void FzStory::fz_story_positions(::fz_story_position_callback *cb, void *arg) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_story_positions()\n";
	}
	#endif
	mupdf::fz_story_positions(*this, cb, arg);
}

/* Class-aware wrapper for `::fz_story_warnings()`.  */
FZ_FUNCTION const char *FzStory::fz_story_warnings() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_story_warnings()\n";
	}
	#endif
	auto ret = mupdf::fz_story_warnings(*this);
	return ret;
}

FZ_FUNCTION FzStory::FzStory(::fz_story* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzStory::~FzStory()
{
	ll_fz_drop_story(m_internal);
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzStory::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzStory::s_num_instances = 0;


/* Implementation of methods for FzStoryElementPosition (wrapper for fz_story_element_position). */

/** Default constructor, sets each member to default value. */
FZ_FUNCTION FzStoryElementPosition::FzStoryElementPosition()
{
	this->depth = {};
	this->heading = {};
	this->id = {};
	this->href = {};
	this->rect = {};
	this->text = {};
	this->open_close = {};
	this->rectangle_num = {};
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzStoryElementPosition::FzStoryElementPosition(const ::fz_story_element_position* internal)
{
	assert( internal);
	this->depth = internal->depth;
	this->heading = internal->heading;
	this->id = internal->id;
	this->href = internal->href;
	this->rect = internal->rect;
	this->text = internal->text;
	this->open_close = internal->open_close;
	this->rectangle_num = internal->rectangle_num;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzStoryElementPosition::FzStoryElementPosition(const ::fz_story_element_position internal)
{
	this->depth = internal.depth;
	this->heading = internal.heading;
	this->id = internal.id;
	this->href = internal.href;
	this->rect = internal.rect;
	this->text = internal.text;
	this->open_close = internal.open_close;
	this->rectangle_num = internal.rectangle_num;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::fz_story_element_position`. */
FZ_FUNCTION ::fz_story_element_position* FzStoryElementPosition::internal()
{
	auto ret = (::fz_story_element_position*) &this->depth;
	return ret;
}

/** Constructor using raw copy of pre-existing `::fz_story_element_position`. */
FZ_FUNCTION const ::fz_story_element_position* FzStoryElementPosition::internal() const
{
	auto ret = (const ::fz_story_element_position*) &this->depth;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION FzStoryElementPosition::~FzStoryElementPosition()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzStoryElementPosition::s_num_instances = 0;

FZ_FUNCTION std::string FzStoryElementPosition::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool FzStoryElementPosition::operator==(const FzStoryElementPosition& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool FzStoryElementPosition::operator!=(const FzStoryElementPosition& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for FzStream (wrapper for fz_stream). */

#ifndef NDEBUG
static RefsCheck<::fz_stream, FzStream> s_FzStream_refs_check(offsetof(::fz_stream, refs), 32);
#endif

/* Constructor using `fz_new_stream()`. */
FZ_FUNCTION FzStream::FzStream(void *state, ::fz_stream_next_fn *next, ::fz_stream_drop_fn *drop)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_stream()\n";
	}
	#endif
	this->m_internal = ll_fz_new_stream(state, next, drop);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_open_file()`. */
FZ_FUNCTION FzStream::FzStream(const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_file()\n";
	}
	#endif
	this->m_internal = ll_fz_open_file(filename);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_open_file_ptr_no_close()`. */
FZ_FUNCTION FzStream::FzStream(FILE *file)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_file_ptr_no_close()\n";
	}
	#endif
	this->m_internal = ll_fz_open_file_ptr_no_close(file);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_open_memory()`. */
FZ_FUNCTION FzStream::FzStream(const unsigned char *data, size_t len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_memory()\n";
	}
	#endif
	this->m_internal = ll_fz_open_memory(data, len);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION FzStream::FzStream(const std::string& filename)
: m_internal(ll_fz_open_file(filename.c_str()))
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_stream()`. */
FZ_FUNCTION FzStream::FzStream(const FzStream& rhs)
: m_internal(ll_fz_keep_stream(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_stream(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_stream()` and `fz_drop_stream()`. */
FZ_FUNCTION FzStream& FzStream::operator=(const FzStream& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_stream(this->m_internal)"
				<< " and ll_fz_keep_stream(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_stream(this->m_internal);
	ll_fz_keep_stream(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzStream::FzStream()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_available()`.  */
FZ_FUNCTION size_t FzStream::fz_available(size_t max) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_available()\n";
	}
	#endif
	auto ret = mupdf::fz_available(*this, max);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_decomp_image_from_stream()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_decomp_image_from_stream(::fz_compressed_image *image, ::fz_irect *subarea, int indexed, int l2factor)` => `(fz_pixmap *, int l2extra)`
	 */
FZ_FUNCTION FzPixmap FzStream::fz_decomp_image_from_stream(const FzCompressedImage& image, FzIrect& subarea, int indexed, int l2factor, int *l2extra) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_decomp_image_from_stream()\n";
	}
	#endif
	auto ret = mupdf::fz_decomp_image_from_stream(*this, image, subarea, indexed, l2factor, l2extra);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_is_cfb_archive()`.  */
FZ_FUNCTION int FzStream::fz_is_cfb_archive() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_cfb_archive()\n";
	}
	#endif
	auto ret = mupdf::fz_is_cfb_archive(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_is_eof()`.  */
FZ_FUNCTION int FzStream::fz_is_eof() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_eof()\n";
	}
	#endif
	auto ret = mupdf::fz_is_eof(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_is_eof_bits()`.  */
FZ_FUNCTION int FzStream::fz_is_eof_bits() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_eof_bits()\n";
	}
	#endif
	auto ret = mupdf::fz_is_eof_bits(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_is_libarchive_archive()`.  */
FZ_FUNCTION int FzStream::fz_is_libarchive_archive() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_libarchive_archive()\n";
	}
	#endif
	auto ret = mupdf::fz_is_libarchive_archive(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_is_tar_archive()`.  */
FZ_FUNCTION int FzStream::fz_is_tar_archive() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_tar_archive()\n";
	}
	#endif
	auto ret = mupdf::fz_is_tar_archive(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_is_zip_archive()`.  */
FZ_FUNCTION int FzStream::fz_is_zip_archive() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_zip_archive()\n";
	}
	#endif
	auto ret = mupdf::fz_is_zip_archive(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_archive_of_size()`.  */
FZ_FUNCTION FzArchive FzStream::fz_new_archive_of_size(int size) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_archive_of_size()\n";
	}
	#endif
	auto ret = mupdf::fz_new_archive_of_size(*this, size);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_a85d()`.  */
FZ_FUNCTION FzStream FzStream::fz_open_a85d() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_a85d()\n";
	}
	#endif
	auto ret = mupdf::fz_open_a85d(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_aesd()`.  */
FZ_FUNCTION FzStream FzStream::fz_open_aesd(unsigned char *key, unsigned int keylen) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_aesd()\n";
	}
	#endif
	auto ret = mupdf::fz_open_aesd(*this, key, keylen);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_ahxd()`.  */
FZ_FUNCTION FzStream FzStream::fz_open_ahxd() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_ahxd()\n";
	}
	#endif
	auto ret = mupdf::fz_open_ahxd(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_arc4()`.  */
FZ_FUNCTION FzStream FzStream::fz_open_arc4(unsigned char *key, unsigned int keylen) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_arc4()\n";
	}
	#endif
	auto ret = mupdf::fz_open_arc4(*this, key, keylen);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_archive_with_stream()`.  */
FZ_FUNCTION FzArchive FzStream::fz_open_archive_with_stream() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_archive_with_stream()\n";
	}
	#endif
	auto ret = mupdf::fz_open_archive_with_stream(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_cfb_archive_with_stream()`.  */
FZ_FUNCTION FzArchive FzStream::fz_open_cfb_archive_with_stream() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_cfb_archive_with_stream()\n";
	}
	#endif
	auto ret = mupdf::fz_open_cfb_archive_with_stream(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_dctd()`.  */
FZ_FUNCTION FzStream FzStream::fz_open_dctd(int color_transform, int invert_cmyk, int l2factor, const FzStream& jpegtables) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_dctd()\n";
	}
	#endif
	auto ret = mupdf::fz_open_dctd(*this, color_transform, invert_cmyk, l2factor, jpegtables);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_endstream_filter()`.  */
FZ_FUNCTION FzStream FzStream::fz_open_endstream_filter(uint64_t len, int64_t offset) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_endstream_filter()\n";
	}
	#endif
	auto ret = mupdf::fz_open_endstream_filter(*this, len, offset);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_faxd()`.  */
FZ_FUNCTION FzStream FzStream::fz_open_faxd(int k, int end_of_line, int encoded_byte_align, int columns, int rows, int end_of_block, int black_is_1) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_faxd()\n";
	}
	#endif
	auto ret = mupdf::fz_open_faxd(*this, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_flated()`.  */
FZ_FUNCTION FzStream FzStream::fz_open_flated(int window_bits) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_flated()\n";
	}
	#endif
	auto ret = mupdf::fz_open_flated(*this, window_bits);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_image_decomp_stream()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_open_image_decomp_stream(::fz_compression_params *arg_1)` => `(fz_stream *, int l2factor)`
	 */
FZ_FUNCTION FzStream FzStream::fz_open_image_decomp_stream(const FzCompressionParams& arg_1, int *l2factor) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_image_decomp_stream()\n";
	}
	#endif
	auto ret = mupdf::fz_open_image_decomp_stream(*this, arg_1, l2factor);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_jbig2d()`.  */
FZ_FUNCTION FzStream FzStream::fz_open_jbig2d(const FzJbig2Globals& globals, int embedded) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_jbig2d()\n";
	}
	#endif
	auto ret = mupdf::fz_open_jbig2d(*this, globals, embedded);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_leecher()`.  */
FZ_FUNCTION FzStream FzStream::fz_open_leecher(const FzBuffer& buf) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_leecher()\n";
	}
	#endif
	auto ret = mupdf::fz_open_leecher(*this, buf);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_libarchive_archive_with_stream()`.  */
FZ_FUNCTION FzArchive FzStream::fz_open_libarchive_archive_with_stream() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_libarchive_archive_with_stream()\n";
	}
	#endif
	auto ret = mupdf::fz_open_libarchive_archive_with_stream(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_libarchived()`.  */
FZ_FUNCTION FzStream FzStream::fz_open_libarchived() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_libarchived()\n";
	}
	#endif
	auto ret = mupdf::fz_open_libarchived(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_lzwd()`.  */
FZ_FUNCTION FzStream FzStream::fz_open_lzwd(int early_change, int min_bits, int reverse_bits, int old_tiff) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_lzwd()\n";
	}
	#endif
	auto ret = mupdf::fz_open_lzwd(*this, early_change, min_bits, reverse_bits, old_tiff);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_null_filter()`.  */
FZ_FUNCTION FzStream FzStream::fz_open_null_filter(uint64_t len, int64_t offset) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_null_filter()\n";
	}
	#endif
	auto ret = mupdf::fz_open_null_filter(*this, len, offset);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_predict()`.  */
FZ_FUNCTION FzStream FzStream::fz_open_predict(int predictor, int columns, int colors, int bpc) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_predict()\n";
	}
	#endif
	auto ret = mupdf::fz_open_predict(*this, predictor, columns, colors, bpc);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_range_filter()`.  */
FZ_FUNCTION FzStream FzStream::fz_open_range_filter(const FzRange& ranges, int nranges) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_range_filter()\n";
	}
	#endif
	auto ret = mupdf::fz_open_range_filter(*this, ranges, nranges);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_rld()`.  */
FZ_FUNCTION FzStream FzStream::fz_open_rld() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_rld()\n";
	}
	#endif
	auto ret = mupdf::fz_open_rld(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_sgilog16()`.  */
FZ_FUNCTION FzStream FzStream::fz_open_sgilog16(int w) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_sgilog16()\n";
	}
	#endif
	auto ret = mupdf::fz_open_sgilog16(*this, w);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_sgilog24()`.  */
FZ_FUNCTION FzStream FzStream::fz_open_sgilog24(int w) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_sgilog24()\n";
	}
	#endif
	auto ret = mupdf::fz_open_sgilog24(*this, w);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_sgilog32()`.  */
FZ_FUNCTION FzStream FzStream::fz_open_sgilog32(int w) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_sgilog32()\n";
	}
	#endif
	auto ret = mupdf::fz_open_sgilog32(*this, w);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_tar_archive_with_stream()`.  */
FZ_FUNCTION FzArchive FzStream::fz_open_tar_archive_with_stream() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_tar_archive_with_stream()\n";
	}
	#endif
	auto ret = mupdf::fz_open_tar_archive_with_stream(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_thunder()`.  */
FZ_FUNCTION FzStream FzStream::fz_open_thunder(int w) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_thunder()\n";
	}
	#endif
	auto ret = mupdf::fz_open_thunder(*this, w);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_open_zip_archive_with_stream()`.  */
FZ_FUNCTION FzArchive FzStream::fz_open_zip_archive_with_stream() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_zip_archive_with_stream()\n";
	}
	#endif
	auto ret = mupdf::fz_open_zip_archive_with_stream(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_parse_xml_stream()`.  */
FZ_FUNCTION FzXml FzStream::fz_parse_xml_stream(int preserve_white) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_parse_xml_stream()\n";
	}
	#endif
	auto ret = mupdf::fz_parse_xml_stream(*this, preserve_white);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_peek_byte()`.  */
FZ_FUNCTION int FzStream::fz_peek_byte() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_peek_byte()\n";
	}
	#endif
	auto ret = mupdf::fz_peek_byte(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read()`.  */
FZ_FUNCTION size_t FzStream::fz_read(unsigned char *data, size_t len) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read()\n";
	}
	#endif
	auto ret = mupdf::fz_read(*this, data, len);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_all()`.  */
FZ_FUNCTION FzBuffer FzStream::fz_read_all(size_t initial) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_all()\n";
	}
	#endif
	auto ret = mupdf::fz_read_all(*this, initial);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_best()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_read_best(size_t initial, size_t worst_case)` => `(fz_buffer *, int truncated)`
	 */
FZ_FUNCTION FzBuffer FzStream::fz_read_best(size_t initial, int *truncated, size_t worst_case) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_best()\n";
	}
	#endif
	auto ret = mupdf::fz_read_best(*this, initial, truncated, worst_case);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_bits()`.  */
FZ_FUNCTION unsigned int FzStream::fz_read_bits(int n) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_bits()\n";
	}
	#endif
	auto ret = mupdf::fz_read_bits(*this, n);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_byte()`.  */
FZ_FUNCTION int FzStream::fz_read_byte() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_byte()\n";
	}
	#endif
	auto ret = mupdf::fz_read_byte(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_float()`.  */
FZ_FUNCTION float FzStream::fz_read_float() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_float()\n";
	}
	#endif
	auto ret = mupdf::fz_read_float(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_float_le()`.  */
FZ_FUNCTION float FzStream::fz_read_float_le() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_float_le()\n";
	}
	#endif
	auto ret = mupdf::fz_read_float_le(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_int16()`.  */
FZ_FUNCTION int16_t FzStream::fz_read_int16() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_int16()\n";
	}
	#endif
	auto ret = mupdf::fz_read_int16(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_int16_le()`.  */
FZ_FUNCTION int16_t FzStream::fz_read_int16_le() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_int16_le()\n";
	}
	#endif
	auto ret = mupdf::fz_read_int16_le(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_int32()`.  */
FZ_FUNCTION int32_t FzStream::fz_read_int32() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_int32()\n";
	}
	#endif
	auto ret = mupdf::fz_read_int32(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_int32_le()`.  */
FZ_FUNCTION int32_t FzStream::fz_read_int32_le() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_int32_le()\n";
	}
	#endif
	auto ret = mupdf::fz_read_int32_le(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_int64()`.  */
FZ_FUNCTION int64_t FzStream::fz_read_int64() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_int64()\n";
	}
	#endif
	auto ret = mupdf::fz_read_int64(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_int64_le()`.  */
FZ_FUNCTION int64_t FzStream::fz_read_int64_le() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_int64_le()\n";
	}
	#endif
	auto ret = mupdf::fz_read_int64_le(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_line()`.  */
FZ_FUNCTION char *FzStream::fz_read_line(char *buf, size_t max) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_line()\n";
	}
	#endif
	auto ret = mupdf::fz_read_line(*this, buf, max);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_rbits()`.  */
FZ_FUNCTION unsigned int FzStream::fz_read_rbits(int n) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_rbits()\n";
	}
	#endif
	auto ret = mupdf::fz_read_rbits(*this, n);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_rune()`.  */
FZ_FUNCTION int FzStream::fz_read_rune() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_rune()\n";
	}
	#endif
	auto ret = mupdf::fz_read_rune(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_string()`.  */
FZ_FUNCTION void FzStream::fz_read_string(char *buffer, int len) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_string()\n";
	}
	#endif
	mupdf::fz_read_string(*this, buffer, len);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_read_uint16()`.  */
FZ_FUNCTION uint16_t FzStream::fz_read_uint16() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_uint16()\n";
	}
	#endif
	auto ret = mupdf::fz_read_uint16(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_uint16_le()`.  */
FZ_FUNCTION uint16_t FzStream::fz_read_uint16_le() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_uint16_le()\n";
	}
	#endif
	auto ret = mupdf::fz_read_uint16_le(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_uint24()`.  */
FZ_FUNCTION uint32_t FzStream::fz_read_uint24() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_uint24()\n";
	}
	#endif
	auto ret = mupdf::fz_read_uint24(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_uint24_le()`.  */
FZ_FUNCTION uint32_t FzStream::fz_read_uint24_le() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_uint24_le()\n";
	}
	#endif
	auto ret = mupdf::fz_read_uint24_le(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_uint32()`.  */
FZ_FUNCTION uint32_t FzStream::fz_read_uint32() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_uint32()\n";
	}
	#endif
	auto ret = mupdf::fz_read_uint32(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_uint32_le()`.  */
FZ_FUNCTION uint32_t FzStream::fz_read_uint32_le() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_uint32_le()\n";
	}
	#endif
	auto ret = mupdf::fz_read_uint32_le(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_uint64()`.  */
FZ_FUNCTION uint64_t FzStream::fz_read_uint64() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_uint64()\n";
	}
	#endif
	auto ret = mupdf::fz_read_uint64(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_uint64_le()`.  */
FZ_FUNCTION uint64_t FzStream::fz_read_uint64_le() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_uint64_le()\n";
	}
	#endif
	auto ret = mupdf::fz_read_uint64_le(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_utf16_be()`.  */
FZ_FUNCTION int FzStream::fz_read_utf16_be() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_utf16_be()\n";
	}
	#endif
	auto ret = mupdf::fz_read_utf16_be(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_read_utf16_le()`.  */
FZ_FUNCTION int FzStream::fz_read_utf16_le() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_utf16_le()\n";
	}
	#endif
	auto ret = mupdf::fz_read_utf16_le(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_seek()`.  */
FZ_FUNCTION void FzStream::fz_seek(int64_t offset, int whence) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_seek()\n";
	}
	#endif
	mupdf::fz_seek(*this, offset, whence);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_skip()`.  */
FZ_FUNCTION size_t FzStream::fz_skip(size_t len) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_skip()\n";
	}
	#endif
	auto ret = mupdf::fz_skip(*this, len);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_skip_space()`.  */
FZ_FUNCTION void FzStream::fz_skip_space() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_skip_space()\n";
	}
	#endif
	mupdf::fz_skip_space(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_skip_string()`.  */
FZ_FUNCTION int FzStream::fz_skip_string(const char *str) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_skip_string()\n";
	}
	#endif
	auto ret = mupdf::fz_skip_string(*this, str);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_sync_bits()`.  */
FZ_FUNCTION void FzStream::fz_sync_bits() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_sync_bits()\n";
	}
	#endif
	mupdf::fz_sync_bits(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_tell()`.  */
FZ_FUNCTION int64_t FzStream::fz_tell() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_tell()\n";
	}
	#endif
	auto ret = mupdf::fz_tell(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_try_open_archive_with_stream()`.  */
FZ_FUNCTION FzArchive FzStream::fz_try_open_archive_with_stream() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_try_open_archive_with_stream()\n";
	}
	#endif
	auto ret = mupdf::fz_try_open_archive_with_stream(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_unpack_stream()`.  */
FZ_FUNCTION FzStream FzStream::fz_unpack_stream(int depth, int w, int h, int n, int indexed, int pad, int skip) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_unpack_stream()\n";
	}
	#endif
	auto ret = mupdf::fz_unpack_stream(*this, depth, w, h, n, indexed, pad, skip);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_unread_byte()`.  */
FZ_FUNCTION void FzStream::fz_unread_byte() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_unread_byte()\n";
	}
	#endif
	mupdf::fz_unread_byte(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_load_cmap()`.  */
FZ_FUNCTION PdfCmap FzStream::pdf_load_cmap() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_cmap()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_cmap(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_open_crypt()`.  */
FZ_FUNCTION FzStream FzStream::pdf_open_crypt(const PdfCrypt& crypt, int num, int gen) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_crypt()\n";
	}
	#endif
	auto ret = mupdf::pdf_open_crypt(*this, crypt, num, gen);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_open_crypt_with_filter()`.  */
FZ_FUNCTION FzStream FzStream::pdf_open_crypt_with_filter(const PdfCrypt& crypt, const PdfObj& name, int num, int gen) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_crypt_with_filter()\n";
	}
	#endif
	auto ret = mupdf::pdf_open_crypt_with_filter(*this, crypt, name, num, gen);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_open_document_with_stream()`.  */
FZ_FUNCTION PdfDocument FzStream::pdf_open_document_with_stream() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_document_with_stream()\n";
	}
	#endif
	auto ret = mupdf::pdf_open_document_with_stream(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

FZ_FUNCTION FzStream::FzStream(::fz_stream* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzStream::~FzStream()
{
	ll_fz_drop_stream(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStream_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzStream::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzStream::s_num_instances = 0;


/* Implementation of methods for FzString (wrapper for fz_string). */

#ifndef NDEBUG
static RefsCheck<::fz_string, FzString> s_FzString_refs_check(offsetof(::fz_string, refs), 32);
#endif

/* Constructor using `fz_new_string()`. */
FZ_FUNCTION FzString::FzString(const char *str)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_string()\n";
	}
	#endif
	this->m_internal = ll_fz_new_string(str);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzString_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_string()`. */
FZ_FUNCTION FzString::FzString(const FzString& rhs)
: m_internal(ll_fz_keep_string(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_string(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzString_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_string()` and `fz_drop_string()`. */
FZ_FUNCTION FzString& FzString::operator=(const FzString& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_string(this->m_internal)"
				<< " and ll_fz_keep_string(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_string(this->m_internal);
	ll_fz_keep_string(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzString_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzString_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzString::FzString()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzString_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzString::FzString(::fz_string* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzString_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzString::~FzString()
{
	ll_fz_drop_string(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzString_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzString::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzString::s_num_instances = 0;


/* Implementation of methods for FzStrokeState (wrapper for fz_stroke_state). */

#ifndef NDEBUG
static RefsCheck<::fz_stroke_state, FzStrokeState> s_FzStrokeState_refs_check(offsetof(::fz_stroke_state, refs), 32);
#endif

/* Constructor using `fz_new_stroke_state()`. */
FZ_FUNCTION FzStrokeState::FzStrokeState()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_stroke_state()\n";
	}
	#endif
	this->m_internal = ll_fz_new_stroke_state();
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStrokeState_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_stroke_state_with_dash_len()`. */
FZ_FUNCTION FzStrokeState::FzStrokeState(int len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_stroke_state_with_dash_len()\n";
	}
	#endif
	this->m_internal = ll_fz_new_stroke_state_with_dash_len(len);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStrokeState_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_stroke_state()`. */
FZ_FUNCTION FzStrokeState::FzStrokeState(const FzStrokeState& rhs)
: m_internal(ll_fz_keep_stroke_state(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_stroke_state(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStrokeState_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_stroke_state()` and `fz_drop_stroke_state()`. */
FZ_FUNCTION FzStrokeState& FzStrokeState::operator=(const FzStrokeState& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_stroke_state(this->m_internal)"
				<< " and ll_fz_keep_stroke_state(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_stroke_state(this->m_internal);
	ll_fz_keep_stroke_state(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStrokeState_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStrokeState_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/* Class-aware wrapper for `::fz_clone_stroke_state()`.  */
FZ_FUNCTION FzStrokeState FzStrokeState::fz_clone_stroke_state() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clone_stroke_state()\n";
	}
	#endif
	auto ret = mupdf::fz_clone_stroke_state(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStrokeState_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_unshare_stroke_state()`.  */
FZ_FUNCTION FzStrokeState FzStrokeState::fz_unshare_stroke_state() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_unshare_stroke_state()\n";
	}
	#endif
	auto ret = mupdf::fz_unshare_stroke_state(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStrokeState_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_unshare_stroke_state_with_dash_len()`.  */
FZ_FUNCTION FzStrokeState FzStrokeState::fz_unshare_stroke_state_with_dash_len(int len) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_unshare_stroke_state_with_dash_len()\n";
	}
	#endif
	auto ret = mupdf::fz_unshare_stroke_state_with_dash_len(*this, len);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStrokeState_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

FZ_FUNCTION FzStrokeState::FzStrokeState(::fz_stroke_state* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStrokeState_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzStrokeState::~FzStrokeState()
{
	ll_fz_drop_stroke_state(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzStrokeState_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzStrokeState::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzStrokeState::s_num_instances = 0;


/* Implementation of methods for FzStyleContext (wrapper for fz_style_context). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzStyleContext::FzStyleContext()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzStyleContext::FzStyleContext(::fz_style_context* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzStyleContext::~FzStyleContext()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzStyleContext::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzStyleContext::s_num_instances = 0;


/* Implementation of methods for FzText (wrapper for fz_text). */

#ifndef NDEBUG
static RefsCheck<::fz_text, FzText> s_FzText_refs_check(offsetof(::fz_text, refs), 32);
#endif

/* Constructor using `fz_new_text()`. */
FZ_FUNCTION FzText::FzText()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_text()\n";
	}
	#endif
	this->m_internal = ll_fz_new_text();
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzText_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `fz_keep_text()`. */
FZ_FUNCTION FzText::FzText(const FzText& rhs)
: m_internal(ll_fz_keep_text(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_text(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzText_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_text()` and `fz_drop_text()`. */
FZ_FUNCTION FzText& FzText::operator=(const FzText& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_text(this->m_internal)"
				<< " and ll_fz_keep_text(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_text(this->m_internal);
	ll_fz_keep_text(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzText_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzText_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/* Class-aware wrapper for `::fz_bound_text()`.  */
FZ_FUNCTION FzRect FzText::fz_bound_text(const FzStrokeState& stroke, const FzMatrix& ctm) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_bound_text()\n";
	}
	#endif
	auto ret = mupdf::fz_bound_text(*this, stroke, ctm);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzText_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_show_glyph()`.  */
FZ_FUNCTION void FzText::fz_show_glyph(const FzFont& font, const FzMatrix& trm, int glyph, int unicode, int wmode, int bidi_level, ::fz_bidi_direction markup_dir, ::fz_text_language language) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_show_glyph()\n";
	}
	#endif
	mupdf::fz_show_glyph(*this, font, trm, glyph, unicode, wmode, bidi_level, markup_dir, language);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzText_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_show_glyph_aux()`.  */
FZ_FUNCTION void FzText::fz_show_glyph_aux(const FzFont& font, const FzMatrix& trm, int glyph, int unicode, int cid, int wmode, int bidi_level, ::fz_bidi_direction markup_dir, ::fz_text_language lang) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_show_glyph_aux()\n";
	}
	#endif
	mupdf::fz_show_glyph_aux(*this, font, trm, glyph, unicode, cid, wmode, bidi_level, markup_dir, lang);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzText_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_show_string()`.  */
FZ_FUNCTION FzMatrix FzText::fz_show_string(const FzFont& font, const FzMatrix& trm, const char *s, int wmode, int bidi_level, ::fz_bidi_direction markup_dir, ::fz_text_language language) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_show_string()\n";
	}
	#endif
	auto ret = mupdf::fz_show_string(*this, font, trm, s, wmode, bidi_level, markup_dir, language);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzText_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

FZ_FUNCTION FzText::FzText(::fz_text* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzText_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzText::~FzText()
{
	ll_fz_drop_text(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzText_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzText::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzText::s_num_instances = 0;


/* Implementation of methods for FzTextDecoder (wrapper for fz_text_decoder). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzTextDecoder::FzTextDecoder()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_init_text_decoder()`.  */
FZ_FUNCTION void FzTextDecoder::fz_init_text_decoder(const char *encoding) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_init_text_decoder()\n";
	}
	#endif
	mupdf::fz_init_text_decoder(*this, encoding);
}

FZ_FUNCTION FzTextDecoder::FzTextDecoder(::fz_text_decoder* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzTextDecoder::~FzTextDecoder()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzTextDecoder::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzTextDecoder::s_num_instances = 0;


/* Implementation of methods for FzTextItem (wrapper for fz_text_item). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzTextItem::FzTextItem()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzTextItem::FzTextItem(::fz_text_item* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzTextItem::~FzTextItem()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzTextItem::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzTextItem::s_num_instances = 0;


/* Implementation of methods for FzTextSpan (wrapper for fz_text_span). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzTextSpan::FzTextSpan()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/** Custom method. */
FZ_FUNCTION FzFont FzTextSpan::font()
{
	return FzFont( ll_fz_keep_font( m_internal->font));
}

/** Custom method. */
FZ_FUNCTION FzMatrix FzTextSpan::trm()
{
	return FzMatrix( m_internal->trm);
}

/** Custom method. */
FZ_FUNCTION fz_text_item& FzTextSpan::items( int i)
{
	assert( i < m_internal->len);
	return m_internal->items[i];
}

FZ_FUNCTION FzTextSpan::FzTextSpan(::fz_text_span* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzTextSpan::~FzTextSpan()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzTextSpan::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzTextSpan::s_num_instances = 0;


/* Implementation of methods for FzTransition (wrapper for fz_transition). */

/** Default constructor, sets each member to default value. */
FZ_FUNCTION FzTransition::FzTransition()
{
	this->type = {};
	this->duration = {};
	this->vertical = {};
	this->outwards = {};
	this->direction = {};
	this->state0 = {};
	this->state1 = {};
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzTransition::FzTransition(const ::fz_transition* internal)
{
	assert( internal);
	this->type = internal->type;
	this->duration = internal->duration;
	this->vertical = internal->vertical;
	this->outwards = internal->outwards;
	this->direction = internal->direction;
	this->state0 = internal->state0;
	this->state1 = internal->state1;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzTransition::FzTransition(const ::fz_transition internal)
{
	this->type = internal.type;
	this->duration = internal.duration;
	this->vertical = internal.vertical;
	this->outwards = internal.outwards;
	this->direction = internal.direction;
	this->state0 = internal.state0;
	this->state1 = internal.state1;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::fz_transition`. */
FZ_FUNCTION ::fz_transition* FzTransition::internal()
{
	auto ret = (::fz_transition*) &this->type;
	return ret;
}

/** Constructor using raw copy of pre-existing `::fz_transition`. */
FZ_FUNCTION const ::fz_transition* FzTransition::internal() const
{
	auto ret = (const ::fz_transition*) &this->type;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION FzTransition::~FzTransition()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzTransition::s_num_instances = 0;

FZ_FUNCTION std::string FzTransition::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool FzTransition::operator==(const FzTransition& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool FzTransition::operator!=(const FzTransition& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for FzTree (wrapper for fz_tree). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzTree::FzTree()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_new_tree_archive()`.  */
FZ_FUNCTION FzArchive FzTree::fz_new_tree_archive() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_tree_archive()\n";
	}
	#endif
	auto ret = mupdf::fz_new_tree_archive(*this);
	return ret;
}

/* Class-aware wrapper for `::fz_tree_lookup()`.  */
FZ_FUNCTION void *FzTree::fz_tree_lookup(const char *key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_tree_lookup()\n";
	}
	#endif
	auto ret = mupdf::fz_tree_lookup(*this, key);
	return ret;
}

FZ_FUNCTION FzTree::FzTree(::fz_tree* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzTree::~FzTree()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzTree::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzTree::s_num_instances = 0;


/* Implementation of methods for FzTuningContext (wrapper for fz_tuning_context). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzTuningContext::FzTuningContext()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzTuningContext::FzTuningContext(::fz_tuning_context* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzTuningContext::~FzTuningContext()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzTuningContext::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzTuningContext::s_num_instances = 0;


/* Implementation of methods for FzVertex (wrapper for fz_vertex). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzVertex::FzVertex()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzVertex::FzVertex(::fz_vertex* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzVertex::~FzVertex()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzVertex::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzVertex::s_num_instances = 0;


/* Implementation of methods for FzWarnContext (wrapper for fz_warn_context). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzWarnContext::FzWarnContext()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzWarnContext::FzWarnContext(::fz_warn_context* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzWarnContext::~FzWarnContext()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzWarnContext::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzWarnContext::s_num_instances = 0;


/* Implementation of methods for FzWriteStoryPosition (wrapper for fz_write_story_position). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzWriteStoryPosition::FzWriteStoryPosition()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzWriteStoryPosition::FzWriteStoryPosition(::fz_write_story_position* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzWriteStoryPosition::~FzWriteStoryPosition()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzWriteStoryPosition::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzWriteStoryPosition::s_num_instances = 0;


/* Implementation of methods for FzWriteStoryPositions (wrapper for fz_write_story_positions). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzWriteStoryPositions::FzWriteStoryPositions()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzWriteStoryPositions::FzWriteStoryPositions(::fz_write_story_positions* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzWriteStoryPositions::~FzWriteStoryPositions()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzWriteStoryPositions::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzWriteStoryPositions::s_num_instances = 0;


/* Implementation of methods for FzXml (wrapper for fz_xml). */

#ifndef NDEBUG
static RefsCheck<::fz_xml, FzXml> s_FzXml_refs_check(0, -1);
#endif

/** Copy constructor using `fz_keep_xml()`. */
FZ_FUNCTION FzXml::FzXml(const FzXml& rhs)
: m_internal(ll_fz_keep_xml(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_fz_keep_xml(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `fz_keep_xml()` and `fz_drop_xml()`. */
FZ_FUNCTION FzXml& FzXml::operator=(const FzXml& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_fz_drop_xml(this->m_internal)"
				<< " and ll_fz_keep_xml(rhs.m_internal)\n"
				;
	}
	#endif
	ll_fz_drop_xml(this->m_internal);
	ll_fz_keep_xml(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzXml::FzXml()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_debug_xml()`.  */
FZ_FUNCTION void FzXml::fz_debug_xml(int level) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_debug_xml()\n";
	}
	#endif
	mupdf::fz_debug_xml(*this, level);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_detach_xml()`.  */
FZ_FUNCTION void FzXml::fz_detach_xml() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_detach_xml()\n";
	}
	#endif
	mupdf::fz_detach_xml(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_dom_add_attribute()`.  */
FZ_FUNCTION void FzXml::fz_dom_add_attribute(const char *att, const char *value) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_add_attribute()\n";
	}
	#endif
	mupdf::fz_dom_add_attribute(*this, att, value);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_dom_append_child()`.  */
FZ_FUNCTION void FzXml::fz_dom_append_child(const FzXml& child) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_append_child()\n";
	}
	#endif
	mupdf::fz_dom_append_child(*this, child);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_dom_attribute()`.  */
FZ_FUNCTION const char *FzXml::fz_dom_attribute(const char *att) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_attribute()\n";
	}
	#endif
	auto ret = mupdf::fz_dom_attribute(*this, att);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_dom_body()`.  */
FZ_FUNCTION FzXml FzXml::fz_dom_body() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_body()\n";
	}
	#endif
	auto ret = mupdf::fz_dom_body(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_dom_clone()`.  */
FZ_FUNCTION FzXml FzXml::fz_dom_clone() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_clone()\n";
	}
	#endif
	auto ret = mupdf::fz_dom_clone(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_dom_create_element()`.  */
FZ_FUNCTION FzXml FzXml::fz_dom_create_element(const char *tag) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_create_element()\n";
	}
	#endif
	auto ret = mupdf::fz_dom_create_element(*this, tag);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_dom_create_text_node()`.  */
FZ_FUNCTION FzXml FzXml::fz_dom_create_text_node(const char *text) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_create_text_node()\n";
	}
	#endif
	auto ret = mupdf::fz_dom_create_text_node(*this, text);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_dom_document_element()`.  */
FZ_FUNCTION FzXml FzXml::fz_dom_document_element() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_document_element()\n";
	}
	#endif
	auto ret = mupdf::fz_dom_document_element(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_dom_find()`.  */
FZ_FUNCTION FzXml FzXml::fz_dom_find(const char *tag, const char *att, const char *match) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_find()\n";
	}
	#endif
	auto ret = mupdf::fz_dom_find(*this, tag, att, match);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_dom_find_next()`.  */
FZ_FUNCTION FzXml FzXml::fz_dom_find_next(const char *tag, const char *att, const char *match) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_find_next()\n";
	}
	#endif
	auto ret = mupdf::fz_dom_find_next(*this, tag, att, match);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_dom_first_child()`.  */
FZ_FUNCTION FzXml FzXml::fz_dom_first_child() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_first_child()\n";
	}
	#endif
	auto ret = mupdf::fz_dom_first_child(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_dom_get_attribute()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_dom_get_attribute(int i)` => `(const char *, const char *att)`
	 */
FZ_FUNCTION const char *FzXml::fz_dom_get_attribute(int i, const char **att) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_get_attribute()\n";
	}
	#endif
	auto ret = mupdf::fz_dom_get_attribute(*this, i, att);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_dom_insert_after()`.  */
FZ_FUNCTION void FzXml::fz_dom_insert_after(const FzXml& new_elt) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_insert_after()\n";
	}
	#endif
	mupdf::fz_dom_insert_after(*this, new_elt);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_dom_insert_before()`.  */
FZ_FUNCTION void FzXml::fz_dom_insert_before(const FzXml& new_elt) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_insert_before()\n";
	}
	#endif
	mupdf::fz_dom_insert_before(*this, new_elt);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_dom_next()`.  */
FZ_FUNCTION FzXml FzXml::fz_dom_next() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_next()\n";
	}
	#endif
	auto ret = mupdf::fz_dom_next(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_dom_parent()`.  */
FZ_FUNCTION FzXml FzXml::fz_dom_parent() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_parent()\n";
	}
	#endif
	auto ret = mupdf::fz_dom_parent(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_dom_previous()`.  */
FZ_FUNCTION FzXml FzXml::fz_dom_previous() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_previous()\n";
	}
	#endif
	auto ret = mupdf::fz_dom_previous(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_dom_remove()`.  */
FZ_FUNCTION void FzXml::fz_dom_remove() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_remove()\n";
	}
	#endif
	mupdf::fz_dom_remove(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_dom_remove_attribute()`.  */
FZ_FUNCTION void FzXml::fz_dom_remove_attribute(const char *att) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_remove_attribute()\n";
	}
	#endif
	mupdf::fz_dom_remove_attribute(*this, att);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::fz_new_display_list_from_svg_xml()`.
	
	This method has out-params. Python/C# wrappers look like:
		`fz_new_display_list_from_svg_xml(::fz_xml *xml, const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`
	 */
FZ_FUNCTION FzDisplayList FzXml::fz_new_display_list_from_svg_xml(const FzXml& xml, const char *base_uri, const FzArchive& dir, float *w, float *h) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_display_list_from_svg_xml()\n";
	}
	#endif
	auto ret = mupdf::fz_new_display_list_from_svg_xml(*this, xml, base_uri, dir, w, h);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_new_image_from_svg_xml()`.  */
FZ_FUNCTION FzImage FzXml::fz_new_image_from_svg_xml(const FzXml& xml, const char *base_uri, const FzArchive& dir) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_from_svg_xml()\n";
	}
	#endif
	auto ret = mupdf::fz_new_image_from_svg_xml(*this, xml, base_uri, dir);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_att()`.  */
FZ_FUNCTION char *FzXml::fz_xml_att(const char *att) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_att()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_att(*this, att);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_att_alt()`.  */
FZ_FUNCTION char *FzXml::fz_xml_att_alt(const char *one, const char *two) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_att_alt()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_att_alt(*this, one, two);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_att_eq()`.  */
FZ_FUNCTION int FzXml::fz_xml_att_eq(const char *name, const char *match) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_att_eq()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_att_eq(*this, name, match);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_down()`.  */
FZ_FUNCTION FzXml FzXml::fz_xml_down() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_down()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_down(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_find()`.  */
FZ_FUNCTION FzXml FzXml::fz_xml_find(const char *tag) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_find()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_find(*this, tag);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_find_dfs()`.  */
FZ_FUNCTION FzXml FzXml::fz_xml_find_dfs(const char *tag, const char *att, const char *match) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_find_dfs()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_find_dfs(*this, tag, att, match);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_find_dfs_top()`.  */
FZ_FUNCTION FzXml FzXml::fz_xml_find_dfs_top(const char *tag, const char *att, const char *match, const FzXml& top) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_find_dfs_top()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_find_dfs_top(*this, tag, att, match, top);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_find_down()`.  */
FZ_FUNCTION FzXml FzXml::fz_xml_find_down(const char *tag) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_find_down()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_find_down(*this, tag);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_find_down_match()`.  */
FZ_FUNCTION FzXml FzXml::fz_xml_find_down_match(const char *tag, const char *att, const char *match) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_find_down_match()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_find_down_match(*this, tag, att, match);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_find_match()`.  */
FZ_FUNCTION FzXml FzXml::fz_xml_find_match(const char *tag, const char *att, const char *match) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_find_match()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_find_match(*this, tag, att, match);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_find_next()`.  */
FZ_FUNCTION FzXml FzXml::fz_xml_find_next(const char *tag) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_find_next()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_find_next(*this, tag);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_find_next_dfs()`.  */
FZ_FUNCTION FzXml FzXml::fz_xml_find_next_dfs(const char *tag, const char *att, const char *match) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_find_next_dfs()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_find_next_dfs(*this, tag, att, match);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_find_next_dfs_top()`.  */
FZ_FUNCTION FzXml FzXml::fz_xml_find_next_dfs_top(const char *tag, const char *att, const char *match, const FzXml& top) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_find_next_dfs_top()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_find_next_dfs_top(*this, tag, att, match, top);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_find_next_match()`.  */
FZ_FUNCTION FzXml FzXml::fz_xml_find_next_match(const char *tag, const char *att, const char *match) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_find_next_match()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_find_next_match(*this, tag, att, match);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_is_tag()`.  */
FZ_FUNCTION int FzXml::fz_xml_is_tag(const char *name) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_is_tag()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_is_tag(*this, name);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_next()`.  */
FZ_FUNCTION FzXml FzXml::fz_xml_next() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_next()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_next(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_prev()`.  */
FZ_FUNCTION FzXml FzXml::fz_xml_prev() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_prev()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_prev(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_root()`.  */
FZ_FUNCTION FzXml FzXml::fz_xml_root() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_root()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_root(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_tag()`.  */
FZ_FUNCTION char *FzXml::fz_xml_tag() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_tag()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_tag(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_text()`.  */
FZ_FUNCTION char *FzXml::fz_xml_text() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_text()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_text(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::fz_xml_up()`.  */
FZ_FUNCTION FzXml FzXml::fz_xml_up() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_up()\n";
	}
	#endif
	auto ret = mupdf::fz_xml_up(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

FZ_FUNCTION FzXml::FzXml(::fz_xml* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzXml::~FzXml()
{
	ll_fz_drop_xml(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXml_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzXml::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzXml::s_num_instances = 0;


/* Implementation of methods for FzXmlDoc (wrapper for fz_xml_doc). */

#ifndef NDEBUG
static RefsCheck<::fz_xml_doc, FzXmlDoc> s_FzXmlDoc_refs_check(0, -1);
#endif

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzXmlDoc::FzXmlDoc()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXmlDoc_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION FzXmlDoc::FzXmlDoc(::fz_xml_doc* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_FzXmlDoc_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION FzXmlDoc::~FzXmlDoc()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long FzXmlDoc::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzXmlDoc::s_num_instances = 0;


/* Implementation of methods for FzZipWriter (wrapper for fz_zip_writer). */

/* Constructor using `fz_new_zip_writer()`. */
FZ_FUNCTION FzZipWriter::FzZipWriter(const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_zip_writer()\n";
	}
	#endif
	this->m_internal = ll_fz_new_zip_writer(filename);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `fz_new_zip_writer_with_output()`. */
FZ_FUNCTION FzZipWriter::FzZipWriter(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_zip_writer_with_output()\n";
	}
	#endif
	this->m_internal = ll_fz_new_zip_writer_with_output(out.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION FzZipWriter::FzZipWriter()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::fz_close_zip_writer()`.  */
FZ_FUNCTION void FzZipWriter::fz_close_zip_writer() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_close_zip_writer()\n";
	}
	#endif
	mupdf::fz_close_zip_writer(*this);
}

/* Class-aware wrapper for `::fz_write_zip_entry()`.  */
FZ_FUNCTION void FzZipWriter::fz_write_zip_entry(const char *name, const FzBuffer& buf, int compress) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_zip_entry()\n";
	}
	#endif
	mupdf::fz_write_zip_entry(*this, name, buf, compress);
}

FZ_FUNCTION FzZipWriter::FzZipWriter(::fz_zip_writer* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION FzZipWriter::~FzZipWriter()
{
	ll_fz_drop_zip_writer(m_internal);
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long FzZipWriter::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int FzZipWriter::s_num_instances = 0;


/* Implementation of methods for PdfAlertEvent (wrapper for pdf_alert_event). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfAlertEvent::PdfAlertEvent()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfAlertEvent::PdfAlertEvent(::pdf_alert_event* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfAlertEvent::~PdfAlertEvent()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfAlertEvent::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfAlertEvent::s_num_instances = 0;


/* Implementation of methods for PdfAnnot (wrapper for pdf_annot). */

#ifndef NDEBUG
static RefsCheck<::pdf_annot, PdfAnnot> s_PdfAnnot_refs_check(0, 32);
#endif

/** Copy constructor using `pdf_keep_annot()`. */
FZ_FUNCTION PdfAnnot::PdfAnnot(const PdfAnnot& rhs)
: m_internal(ll_pdf_keep_annot(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_pdf_keep_annot(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `pdf_keep_annot()` and `pdf_drop_annot()`. */
FZ_FUNCTION PdfAnnot& PdfAnnot::operator=(const PdfAnnot& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_pdf_drop_annot(this->m_internal)"
				<< " and ll_pdf_keep_annot(rhs.m_internal)\n"
				;
	}
	#endif
	ll_pdf_drop_annot(this->m_internal);
	ll_pdf_keep_annot(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/* Class-aware wrapper for `::pdf_add_annot_border_dash_item()`.  */
FZ_FUNCTION void PdfAnnot::pdf_add_annot_border_dash_item(float length) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_annot_border_dash_item()\n";
	}
	#endif
	mupdf::pdf_add_annot_border_dash_item(*this, length);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_add_annot_ink_list_stroke()`.  */
FZ_FUNCTION void PdfAnnot::pdf_add_annot_ink_list_stroke() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_annot_ink_list_stroke()\n";
	}
	#endif
	mupdf::pdf_add_annot_ink_list_stroke(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_add_annot_ink_list_stroke_vertex()`.  */
FZ_FUNCTION void PdfAnnot::pdf_add_annot_ink_list_stroke_vertex(const FzPoint& p) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_annot_ink_list_stroke_vertex()\n";
	}
	#endif
	mupdf::pdf_add_annot_ink_list_stroke_vertex(*this, p);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_add_annot_quad_point()`.  */
FZ_FUNCTION void PdfAnnot::pdf_add_annot_quad_point(const FzQuad& quad) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_annot_quad_point()\n";
	}
	#endif
	mupdf::pdf_add_annot_quad_point(*this, quad);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_add_annot_vertex()`.  */
FZ_FUNCTION void PdfAnnot::pdf_add_annot_vertex(const FzPoint& p) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_annot_vertex()\n";
	}
	#endif
	mupdf::pdf_add_annot_vertex(*this, p);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_MK_BC()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_annot_MK_BC(float color[4])` => int n
	 */
FZ_FUNCTION void PdfAnnot::pdf_annot_MK_BC(int *n, float color[4]) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_MK_BC()\n";
	}
	#endif
	mupdf::pdf_annot_MK_BC(*this, n, color);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_MK_BC_rgb()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_MK_BC_rgb(float rgb[3]) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_MK_BC_rgb()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_MK_BC_rgb(*this, rgb);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_MK_BG()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_annot_MK_BG(float color[4])` => int n
	 */
FZ_FUNCTION void PdfAnnot::pdf_annot_MK_BG(int *n, float color[4]) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_MK_BG()\n";
	}
	#endif
	mupdf::pdf_annot_MK_BG(*this, n, color);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_MK_BG_rgb()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_MK_BG_rgb(float rgb[3]) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_MK_BG_rgb()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_MK_BG_rgb(*this, rgb);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_active()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_active() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_active()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_active(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_ap()`.  */
FZ_FUNCTION PdfObj PdfAnnot::pdf_annot_ap() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_ap()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_ap(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_author()`.  */
FZ_FUNCTION const char *PdfAnnot::pdf_annot_author() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_author()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_author(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_border()`.  */
FZ_FUNCTION float PdfAnnot::pdf_annot_border() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_border()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_border(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_border_dash_count()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_border_dash_count() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_border_dash_count()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_border_dash_count(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_border_dash_item()`.  */
FZ_FUNCTION float PdfAnnot::pdf_annot_border_dash_item(int i) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_border_dash_item()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_border_dash_item(*this, i);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_border_effect()`.  */
FZ_FUNCTION enum pdf_border_effect PdfAnnot::pdf_annot_border_effect() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_border_effect()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_border_effect(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_border_effect_intensity()`.  */
FZ_FUNCTION float PdfAnnot::pdf_annot_border_effect_intensity() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_border_effect_intensity()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_border_effect_intensity(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_border_style()`.  */
FZ_FUNCTION enum pdf_border_style PdfAnnot::pdf_annot_border_style() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_border_style()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_border_style(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_border_width()`.  */
FZ_FUNCTION float PdfAnnot::pdf_annot_border_width() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_border_width()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_border_width(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_color()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_annot_color(float color[4])` => int n
	 */
FZ_FUNCTION void PdfAnnot::pdf_annot_color(int *n, float color[4]) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_color()\n";
	}
	#endif
	mupdf::pdf_annot_color(*this, n, color);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_contents()`.  */
FZ_FUNCTION const char *PdfAnnot::pdf_annot_contents() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_contents()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_contents(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_creation_date()`.  */
FZ_FUNCTION int64_t PdfAnnot::pdf_annot_creation_date() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_creation_date()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_creation_date(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_default_appearance()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_annot_default_appearance(float color[4])` => `(const char *font, float size, int n)`
	 */
FZ_FUNCTION void PdfAnnot::pdf_annot_default_appearance(const char **font, float *size, int *n, float color[4]) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_default_appearance()\n";
	}
	#endif
	mupdf::pdf_annot_default_appearance(*this, font, size, n, color);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_ensure_local_xref()`.  */
FZ_FUNCTION void PdfAnnot::pdf_annot_ensure_local_xref() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_ensure_local_xref()\n";
	}
	#endif
	mupdf::pdf_annot_ensure_local_xref(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_event_blur()`.  */
FZ_FUNCTION void PdfAnnot::pdf_annot_event_blur() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_event_blur()\n";
	}
	#endif
	mupdf::pdf_annot_event_blur(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_event_down()`.  */
FZ_FUNCTION void PdfAnnot::pdf_annot_event_down() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_event_down()\n";
	}
	#endif
	mupdf::pdf_annot_event_down(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_event_enter()`.  */
FZ_FUNCTION void PdfAnnot::pdf_annot_event_enter() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_event_enter()\n";
	}
	#endif
	mupdf::pdf_annot_event_enter(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_event_exit()`.  */
FZ_FUNCTION void PdfAnnot::pdf_annot_event_exit() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_event_exit()\n";
	}
	#endif
	mupdf::pdf_annot_event_exit(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_event_focus()`.  */
FZ_FUNCTION void PdfAnnot::pdf_annot_event_focus() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_event_focus()\n";
	}
	#endif
	mupdf::pdf_annot_event_focus(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_event_page_close()`.  */
FZ_FUNCTION void PdfAnnot::pdf_annot_event_page_close() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_event_page_close()\n";
	}
	#endif
	mupdf::pdf_annot_event_page_close(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_event_page_invisible()`.  */
FZ_FUNCTION void PdfAnnot::pdf_annot_event_page_invisible() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_event_page_invisible()\n";
	}
	#endif
	mupdf::pdf_annot_event_page_invisible(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_event_page_open()`.  */
FZ_FUNCTION void PdfAnnot::pdf_annot_event_page_open() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_event_page_open()\n";
	}
	#endif
	mupdf::pdf_annot_event_page_open(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_event_page_visible()`.  */
FZ_FUNCTION void PdfAnnot::pdf_annot_event_page_visible() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_event_page_visible()\n";
	}
	#endif
	mupdf::pdf_annot_event_page_visible(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_event_up()`.  */
FZ_FUNCTION void PdfAnnot::pdf_annot_event_up() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_event_up()\n";
	}
	#endif
	mupdf::pdf_annot_event_up(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_field_flags()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_field_flags() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_field_flags()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_field_flags(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_field_label()`.  */
FZ_FUNCTION const char *PdfAnnot::pdf_annot_field_label() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_field_label()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_field_label(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_field_value()`.  */
FZ_FUNCTION const char *PdfAnnot::pdf_annot_field_value() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_field_value()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_field_value(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_filespec()`.  */
FZ_FUNCTION PdfObj PdfAnnot::pdf_annot_filespec() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_filespec()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_filespec(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_flags()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_flags() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_flags()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_flags(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_has_author()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_has_author() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_author()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_has_author(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_has_border()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_has_border() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_border()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_has_border(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_has_border_effect()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_has_border_effect() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_border_effect()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_has_border_effect(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_has_filespec()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_has_filespec() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_filespec()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_has_filespec(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_has_icon_name()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_has_icon_name() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_icon_name()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_has_icon_name(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_has_ink_list()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_has_ink_list() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_ink_list()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_has_ink_list(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_has_intent()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_has_intent() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_intent()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_has_intent(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_has_interior_color()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_has_interior_color() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_interior_color()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_has_interior_color(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_has_line()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_has_line() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_line()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_has_line(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_has_line_ending_styles()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_has_line_ending_styles() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_line_ending_styles()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_has_line_ending_styles(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_has_open()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_has_open() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_open()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_has_open(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_has_quad_points()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_has_quad_points() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_quad_points()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_has_quad_points(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_has_quadding()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_has_quadding() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_quadding()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_has_quadding(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_has_rect()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_has_rect() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_rect()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_has_rect(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_has_vertices()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_has_vertices() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_vertices()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_has_vertices(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_hidden_for_editing()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_hidden_for_editing() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_hidden_for_editing()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_hidden_for_editing(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_hot()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_hot() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_hot()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_hot(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_icon_name()`.  */
FZ_FUNCTION const char *PdfAnnot::pdf_annot_icon_name() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_icon_name()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_icon_name(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_ink_list_count()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_ink_list_count() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_ink_list_count()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_ink_list_count(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_ink_list_stroke_count()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_ink_list_stroke_count(int i) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_ink_list_stroke_count()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_ink_list_stroke_count(*this, i);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_ink_list_stroke_vertex()`.  */
FZ_FUNCTION FzPoint PdfAnnot::pdf_annot_ink_list_stroke_vertex(int i, int k) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_ink_list_stroke_vertex()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_ink_list_stroke_vertex(*this, i, k);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_intent()`.  */
FZ_FUNCTION enum pdf_intent PdfAnnot::pdf_annot_intent() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_intent()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_intent(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_interior_color()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_annot_interior_color(float color[4])` => int n
	 */
FZ_FUNCTION void PdfAnnot::pdf_annot_interior_color(int *n, float color[4]) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_interior_color()\n";
	}
	#endif
	mupdf::pdf_annot_interior_color(*this, n, color);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_is_open()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_is_open() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_is_open()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_is_open(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_is_standard_stamp()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_is_standard_stamp() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_is_standard_stamp()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_is_standard_stamp(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_line()`.  */
FZ_FUNCTION void PdfAnnot::pdf_annot_line(FzPoint& a, FzPoint& b) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_line()\n";
	}
	#endif
	mupdf::pdf_annot_line(*this, a, b);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_line_end_style()`.  */
FZ_FUNCTION enum pdf_line_ending PdfAnnot::pdf_annot_line_end_style() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_line_end_style()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_line_end_style(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_line_ending_styles()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_annot_line_ending_styles()` => `(enum pdf_line_ending start_style, enum pdf_line_ending end_style)`
	 */
FZ_FUNCTION void PdfAnnot::pdf_annot_line_ending_styles(enum pdf_line_ending *start_style, enum pdf_line_ending *end_style) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_line_ending_styles()\n";
	}
	#endif
	mupdf::pdf_annot_line_ending_styles(*this, start_style, end_style);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_line_start_style()`.  */
FZ_FUNCTION enum pdf_line_ending PdfAnnot::pdf_annot_line_start_style() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_line_start_style()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_line_start_style(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_modification_date()`.  */
FZ_FUNCTION int64_t PdfAnnot::pdf_annot_modification_date() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_modification_date()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_modification_date(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_needs_resynthesis()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_needs_resynthesis() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_needs_resynthesis()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_needs_resynthesis(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_obj()`.  */
FZ_FUNCTION PdfObj PdfAnnot::pdf_annot_obj() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_obj()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_obj(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_opacity()`.  */
FZ_FUNCTION float PdfAnnot::pdf_annot_opacity() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_opacity()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_opacity(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_page()`.  */
FZ_FUNCTION PdfPage PdfAnnot::pdf_annot_page() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_page()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_page(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_pop_and_discard_local_xref()`.  */
FZ_FUNCTION void PdfAnnot::pdf_annot_pop_and_discard_local_xref() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_pop_and_discard_local_xref()\n";
	}
	#endif
	mupdf::pdf_annot_pop_and_discard_local_xref(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_pop_local_xref()`.  */
FZ_FUNCTION void PdfAnnot::pdf_annot_pop_local_xref() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_pop_local_xref()\n";
	}
	#endif
	mupdf::pdf_annot_pop_local_xref(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_popup()`.  */
FZ_FUNCTION FzRect PdfAnnot::pdf_annot_popup() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_popup()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_popup(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_push_local_xref()`.  */
FZ_FUNCTION void PdfAnnot::pdf_annot_push_local_xref() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_push_local_xref()\n";
	}
	#endif
	mupdf::pdf_annot_push_local_xref(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_quad_point()`.  */
FZ_FUNCTION FzQuad PdfAnnot::pdf_annot_quad_point(int i) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_quad_point()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_quad_point(*this, i);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_quad_point_count()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_quad_point_count() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_quad_point_count()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_quad_point_count(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_quadding()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_quadding() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_quadding()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_quadding(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_rect()`.  */
FZ_FUNCTION FzRect PdfAnnot::pdf_annot_rect() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_rect()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_rect(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_request_resynthesis()`.  */
FZ_FUNCTION void PdfAnnot::pdf_annot_request_resynthesis() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_request_resynthesis()\n";
	}
	#endif
	mupdf::pdf_annot_request_resynthesis(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_request_synthesis()`.  */
FZ_FUNCTION void PdfAnnot::pdf_annot_request_synthesis() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_request_synthesis()\n";
	}
	#endif
	mupdf::pdf_annot_request_synthesis(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_annot_transform()`.  */
FZ_FUNCTION FzMatrix PdfAnnot::pdf_annot_transform() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_transform()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_transform(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_type()`.  */
FZ_FUNCTION enum pdf_annot_type PdfAnnot::pdf_annot_type() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_type()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_type(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_vertex()`.  */
FZ_FUNCTION FzPoint PdfAnnot::pdf_annot_vertex(int i) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_vertex()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_vertex(*this, i);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_vertex_count()`.  */
FZ_FUNCTION int PdfAnnot::pdf_annot_vertex_count() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_vertex_count()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_vertex_count(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_apply_redaction()`.  */
FZ_FUNCTION int PdfAnnot::pdf_apply_redaction(PdfRedactOptions& opts) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_apply_redaction()\n";
	}
	#endif
	auto ret = mupdf::pdf_apply_redaction(*this, opts);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_bound_annot()`.  */
FZ_FUNCTION FzRect PdfAnnot::pdf_bound_annot() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_bound_annot()\n";
	}
	#endif
	auto ret = mupdf::pdf_bound_annot(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_bound_widget()`.  */
FZ_FUNCTION FzRect PdfAnnot::pdf_bound_widget() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_bound_widget()\n";
	}
	#endif
	auto ret = mupdf::pdf_bound_widget(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_choice_widget_is_multiselect()`.  */
FZ_FUNCTION int PdfAnnot::pdf_choice_widget_is_multiselect() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_choice_widget_is_multiselect()\n";
	}
	#endif
	auto ret = mupdf::pdf_choice_widget_is_multiselect(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_choice_widget_options()`.  */
FZ_FUNCTION int PdfAnnot::pdf_choice_widget_options(int exportval, const char *opts[]) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_choice_widget_options()\n";
	}
	#endif
	auto ret = mupdf::pdf_choice_widget_options(*this, exportval, opts);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_choice_widget_options2()`.  */
FZ_FUNCTION std::vector<std::string> PdfAnnot::pdf_choice_widget_options2(int exportval) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_choice_widget_options2()\n";
	}
	#endif
	auto ret = mupdf::pdf_choice_widget_options2(*this, exportval);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_choice_widget_set_value()`.  */
FZ_FUNCTION void PdfAnnot::pdf_choice_widget_set_value(int n, const char *opts[]) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_choice_widget_set_value()\n";
	}
	#endif
	mupdf::pdf_choice_widget_set_value(*this, n, opts);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_choice_widget_value()`.  */
FZ_FUNCTION int PdfAnnot::pdf_choice_widget_value(const char *opts[]) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_choice_widget_value()\n";
	}
	#endif
	auto ret = mupdf::pdf_choice_widget_value(*this, opts);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_clear_annot_border_dash()`.  */
FZ_FUNCTION void PdfAnnot::pdf_clear_annot_border_dash() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_clear_annot_border_dash()\n";
	}
	#endif
	mupdf::pdf_clear_annot_border_dash(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_clear_annot_ink_list()`.  */
FZ_FUNCTION void PdfAnnot::pdf_clear_annot_ink_list() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_clear_annot_ink_list()\n";
	}
	#endif
	mupdf::pdf_clear_annot_ink_list(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_clear_annot_quad_points()`.  */
FZ_FUNCTION void PdfAnnot::pdf_clear_annot_quad_points() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_clear_annot_quad_points()\n";
	}
	#endif
	mupdf::pdf_clear_annot_quad_points(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_clear_annot_vertices()`.  */
FZ_FUNCTION void PdfAnnot::pdf_clear_annot_vertices() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_clear_annot_vertices()\n";
	}
	#endif
	mupdf::pdf_clear_annot_vertices(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_clear_signature()`.  */
FZ_FUNCTION void PdfAnnot::pdf_clear_signature() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_clear_signature()\n";
	}
	#endif
	mupdf::pdf_clear_signature(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_dirty_annot()`.  */
FZ_FUNCTION void PdfAnnot::pdf_dirty_annot() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dirty_annot()\n";
	}
	#endif
	mupdf::pdf_dirty_annot(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_edit_text_field_value()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_edit_text_field_value(const char *value, const char *change)` => `(int, int selStart, int selEnd, char *newvalue)`
	 */
FZ_FUNCTION int PdfAnnot::pdf_edit_text_field_value(const char *value, const char *change, int *selStart, int *selEnd, char **newvalue) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_edit_text_field_value()\n";
	}
	#endif
	auto ret = mupdf::pdf_edit_text_field_value(*this, value, change, selStart, selEnd, newvalue);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_get_widget_editing_state()`.  */
FZ_FUNCTION int PdfAnnot::pdf_get_widget_editing_state() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_get_widget_editing_state()\n";
	}
	#endif
	auto ret = mupdf::pdf_get_widget_editing_state(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_display_list_from_annot()`.  */
FZ_FUNCTION FzDisplayList PdfAnnot::pdf_new_display_list_from_annot() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_display_list_from_annot()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_display_list_from_annot(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_pixmap_from_annot()`.  */
FZ_FUNCTION FzPixmap PdfAnnot::pdf_new_pixmap_from_annot(const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_pixmap_from_annot()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_pixmap_from_annot(*this, ctm, cs, seps, alpha);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_next_annot()`.  */
FZ_FUNCTION PdfAnnot PdfAnnot::pdf_next_annot() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_next_annot()\n";
	}
	#endif
	auto ret = mupdf::pdf_next_annot(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_next_widget()`.  */
FZ_FUNCTION PdfAnnot PdfAnnot::pdf_next_widget() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_next_widget()\n";
	}
	#endif
	auto ret = mupdf::pdf_next_widget(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_run_annot()`.  */
FZ_FUNCTION void PdfAnnot::pdf_run_annot(const FzDevice& dev, const FzMatrix& ctm, FzCookie& cookie) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_annot()\n";
	}
	#endif
	mupdf::pdf_run_annot(*this, dev, ctm, cookie);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_active()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_active(int active) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_active()\n";
	}
	#endif
	mupdf::pdf_set_annot_active(*this, active);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_appearance()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_appearance(const char *appearance, const char *state, const FzMatrix& ctm, const FzRect& bbox, const PdfObj& res, const FzBuffer& contents) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_appearance()\n";
	}
	#endif
	mupdf::pdf_set_annot_appearance(*this, appearance, state, ctm, bbox, res, contents);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_appearance_from_display_list()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_appearance_from_display_list(const char *appearance, const char *state, const FzMatrix& ctm, const FzDisplayList& list) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_appearance_from_display_list()\n";
	}
	#endif
	mupdf::pdf_set_annot_appearance_from_display_list(*this, appearance, state, ctm, list);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_author()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_author(const char *author) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_author()\n";
	}
	#endif
	mupdf::pdf_set_annot_author(*this, author);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_border()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_border(float width) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_border()\n";
	}
	#endif
	mupdf::pdf_set_annot_border(*this, width);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_border_effect()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_border_effect(enum pdf_border_effect effect) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_border_effect()\n";
	}
	#endif
	mupdf::pdf_set_annot_border_effect(*this, effect);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_border_effect_intensity()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_border_effect_intensity(float intensity) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_border_effect_intensity()\n";
	}
	#endif
	mupdf::pdf_set_annot_border_effect_intensity(*this, intensity);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_border_style()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_border_style(enum pdf_border_style style) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_border_style()\n";
	}
	#endif
	mupdf::pdf_set_annot_border_style(*this, style);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_border_width()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_border_width(float width) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_border_width()\n";
	}
	#endif
	mupdf::pdf_set_annot_border_width(*this, width);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_color()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_color(int n, const float *color) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_color()\n";
	}
	#endif
	mupdf::pdf_set_annot_color(*this, n, color);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_contents()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_contents(const char *text) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_contents()\n";
	}
	#endif
	mupdf::pdf_set_annot_contents(*this, text);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_creation_date()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_creation_date(int64_t time) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_creation_date()\n";
	}
	#endif
	mupdf::pdf_set_annot_creation_date(*this, time);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_default_appearance()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_default_appearance(const char *font, float size, int n, const float *color) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_default_appearance()\n";
	}
	#endif
	mupdf::pdf_set_annot_default_appearance(*this, font, size, n, color);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_filespec()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_filespec(const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_filespec()\n";
	}
	#endif
	mupdf::pdf_set_annot_filespec(*this, obj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_flags()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_flags(int flags) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_flags()\n";
	}
	#endif
	mupdf::pdf_set_annot_flags(*this, flags);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_hidden_for_editing()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_hidden_for_editing(int hidden) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_hidden_for_editing()\n";
	}
	#endif
	mupdf::pdf_set_annot_hidden_for_editing(*this, hidden);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_hot()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_hot(int hot) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_hot()\n";
	}
	#endif
	mupdf::pdf_set_annot_hot(*this, hot);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_icon_name()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_icon_name(const char *name) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_icon_name()\n";
	}
	#endif
	mupdf::pdf_set_annot_icon_name(*this, name);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_ink_list()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_ink_list(int n, const int *count, FzPoint& v) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_ink_list()\n";
	}
	#endif
	mupdf::pdf_set_annot_ink_list(*this, n, count, v);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_intent()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_intent(enum pdf_intent it) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_intent()\n";
	}
	#endif
	mupdf::pdf_set_annot_intent(*this, it);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_interior_color()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_interior_color(int n, const float *color) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_interior_color()\n";
	}
	#endif
	mupdf::pdf_set_annot_interior_color(*this, n, color);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_is_open()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_is_open(int is_open) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_is_open()\n";
	}
	#endif
	mupdf::pdf_set_annot_is_open(*this, is_open);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_language()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_language(::fz_text_language lang) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_language()\n";
	}
	#endif
	mupdf::pdf_set_annot_language(*this, lang);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_line()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_line(const FzPoint& a, const FzPoint& b) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_line()\n";
	}
	#endif
	mupdf::pdf_set_annot_line(*this, a, b);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_line_end_style()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_line_end_style(enum pdf_line_ending e) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_line_end_style()\n";
	}
	#endif
	mupdf::pdf_set_annot_line_end_style(*this, e);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_line_ending_styles()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_line_ending_styles(enum pdf_line_ending start_style, enum pdf_line_ending end_style) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_line_ending_styles()\n";
	}
	#endif
	mupdf::pdf_set_annot_line_ending_styles(*this, start_style, end_style);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_line_start_style()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_line_start_style(enum pdf_line_ending s) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_line_start_style()\n";
	}
	#endif
	mupdf::pdf_set_annot_line_start_style(*this, s);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_modification_date()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_modification_date(int64_t time) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_modification_date()\n";
	}
	#endif
	mupdf::pdf_set_annot_modification_date(*this, time);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_opacity()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_opacity(float opacity) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_opacity()\n";
	}
	#endif
	mupdf::pdf_set_annot_opacity(*this, opacity);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_popup()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_popup(const FzRect& rect) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_popup()\n";
	}
	#endif
	mupdf::pdf_set_annot_popup(*this, rect);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_quad_points()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_quad_points(int n, FzQuad& qv) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_quad_points()\n";
	}
	#endif
	mupdf::pdf_set_annot_quad_points(*this, n, qv);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_quadding()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_quadding(int q) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_quadding()\n";
	}
	#endif
	mupdf::pdf_set_annot_quadding(*this, q);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_rect()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_rect(const FzRect& rect) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_rect()\n";
	}
	#endif
	mupdf::pdf_set_annot_rect(*this, rect);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_resynthesised()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_resynthesised() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_resynthesised()\n";
	}
	#endif
	mupdf::pdf_set_annot_resynthesised(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_stamp_image()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_stamp_image(const FzImage& image) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_stamp_image()\n";
	}
	#endif
	mupdf::pdf_set_annot_stamp_image(*this, image);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_vertex()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_vertex(int i, const FzPoint& p) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_vertex()\n";
	}
	#endif
	mupdf::pdf_set_annot_vertex(*this, i, p);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_vertices()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_annot_vertices(int n, FzPoint& v) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_vertices()\n";
	}
	#endif
	mupdf::pdf_set_annot_vertices(*this, n, v);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_choice_field_value()`.  */
FZ_FUNCTION int PdfAnnot::pdf_set_choice_field_value(const char *value) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_choice_field_value()\n";
	}
	#endif
	auto ret = mupdf::pdf_set_choice_field_value(*this, value);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_set_text_field_value()`.  */
FZ_FUNCTION int PdfAnnot::pdf_set_text_field_value(const char *value) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_text_field_value()\n";
	}
	#endif
	auto ret = mupdf::pdf_set_text_field_value(*this, value);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_set_widget_editing_state()`.  */
FZ_FUNCTION void PdfAnnot::pdf_set_widget_editing_state(int editing) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_widget_editing_state()\n";
	}
	#endif
	mupdf::pdf_set_widget_editing_state(*this, editing);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_sign_signature()`.  */
FZ_FUNCTION void PdfAnnot::pdf_sign_signature(const PdfPkcs7Signer& signer, int appearance_flags, const FzImage& graphic, const char *reason, const char *location) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_sign_signature()\n";
	}
	#endif
	mupdf::pdf_sign_signature(*this, signer, appearance_flags, graphic, reason, location);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_sign_signature_with_appearance()`.  */
FZ_FUNCTION void PdfAnnot::pdf_sign_signature_with_appearance(const PdfPkcs7Signer& signer, int64_t date, const FzDisplayList& disp_list) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_sign_signature_with_appearance()\n";
	}
	#endif
	mupdf::pdf_sign_signature_with_appearance(*this, signer, date, disp_list);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_text_widget_format()`.  */
FZ_FUNCTION int PdfAnnot::pdf_text_widget_format() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_text_widget_format()\n";
	}
	#endif
	auto ret = mupdf::pdf_text_widget_format(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_text_widget_max_len()`.  */
FZ_FUNCTION int PdfAnnot::pdf_text_widget_max_len() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_text_widget_max_len()\n";
	}
	#endif
	auto ret = mupdf::pdf_text_widget_max_len(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_toggle_widget()`.  */
FZ_FUNCTION int PdfAnnot::pdf_toggle_widget() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_toggle_widget()\n";
	}
	#endif
	auto ret = mupdf::pdf_toggle_widget(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_update_annot()`.  */
FZ_FUNCTION int PdfAnnot::pdf_update_annot() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_update_annot()\n";
	}
	#endif
	auto ret = mupdf::pdf_update_annot(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_update_widget()`.  */
FZ_FUNCTION int PdfAnnot::pdf_update_widget() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_update_widget()\n";
	}
	#endif
	auto ret = mupdf::pdf_update_widget(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_validate_signature()`.  */
FZ_FUNCTION int PdfAnnot::pdf_validate_signature() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_validate_signature()\n";
	}
	#endif
	auto ret = mupdf::pdf_validate_signature(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_widget_is_readonly()`.  */
FZ_FUNCTION int PdfAnnot::pdf_widget_is_readonly() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_widget_is_readonly()\n";
	}
	#endif
	auto ret = mupdf::pdf_widget_is_readonly(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_widget_is_signed()`.  */
FZ_FUNCTION int PdfAnnot::pdf_widget_is_signed() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_widget_is_signed()\n";
	}
	#endif
	auto ret = mupdf::pdf_widget_is_signed(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_widget_type()`.  */
FZ_FUNCTION enum pdf_widget_type PdfAnnot::pdf_widget_type() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_widget_type()\n";
	}
	#endif
	auto ret = mupdf::pdf_widget_type(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

FZ_FUNCTION PdfAnnot::PdfAnnot(::pdf_annot* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfAnnot::~PdfAnnot()
{
	ll_pdf_drop_annot(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfAnnot_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long PdfAnnot::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfAnnot::s_num_instances = 0;


/* Implementation of methods for PdfCleanOptions (wrapper for pdf_clean_options). */

/** Custom constructor. */
FZ_FUNCTION PdfCleanOptions::PdfCleanOptions()
{
	/* Use memcpy() otherwise we get 'invalid array assignment' errors. */
	memcpy(&this->internal()->write, &pdf_default_write_options, sizeof(this->internal()->write));
	memset(&this->internal()->image, 0, sizeof(this->internal()->image));
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION PdfCleanOptions::PdfCleanOptions(const PdfCleanOptions& rhs)
{
	*this = rhs;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION PdfCleanOptions& PdfCleanOptions::operator=(const PdfCleanOptions& rhs)
{
	memcpy(this->internal(), rhs.internal(), sizeof(*this->internal()));
	return *this;
}

/** Custom method. */
FZ_FUNCTION void PdfCleanOptions::write_opwd_utf8_set(const std::string& text)
{
	size_t len = std::min(text.size(), sizeof(write.opwd_utf8) - 1);
	memcpy(write.opwd_utf8, text.c_str(), len);
	write.opwd_utf8[len] = 0;
}

/** Custom method. */
FZ_FUNCTION void PdfCleanOptions::write_upwd_utf8_set(const std::string& text)
{
	size_t len = std::min(text.size(), sizeof(write.upwd_utf8) - 1);
	memcpy(write.upwd_utf8, text.c_str(), len);
	write.upwd_utf8[len] = 0;
}

FZ_FUNCTION PdfCleanOptions::PdfCleanOptions(const ::pdf_clean_options* internal)
{
	assert( internal);
	this->write = internal->write;
	this->image = internal->image;
	this->subset_fonts = internal->subset_fonts;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfCleanOptions::PdfCleanOptions(const ::pdf_clean_options internal)
{
	this->write = internal.write;
	this->image = internal.image;
	this->subset_fonts = internal.subset_fonts;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::pdf_clean_options`. */
FZ_FUNCTION ::pdf_clean_options* PdfCleanOptions::internal()
{
	auto ret = (::pdf_clean_options*) &this->write;
	return ret;
}

/** Constructor using raw copy of pre-existing `::pdf_clean_options`. */
FZ_FUNCTION const ::pdf_clean_options* PdfCleanOptions::internal() const
{
	auto ret = (const ::pdf_clean_options*) &this->write;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION PdfCleanOptions::~PdfCleanOptions()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfCleanOptions::s_num_instances = 0;

FZ_FUNCTION std::string PdfCleanOptions::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool PdfCleanOptions::operator==(const PdfCleanOptions& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool PdfCleanOptions::operator!=(const PdfCleanOptions& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for PdfCmap (wrapper for pdf_cmap). */

#ifndef NDEBUG
static RefsCheck<::pdf_cmap, PdfCmap> s_PdfCmap_refs_check(offsetof(::pdf_cmap, storable.refs), 32);
#endif

/* Constructor using `pdf_new_cmap()`. */
FZ_FUNCTION PdfCmap::PdfCmap()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_cmap()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_cmap();
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfCmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_identity_cmap()`. */
FZ_FUNCTION PdfCmap::PdfCmap(int wmode, int bytes)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_identity_cmap()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_identity_cmap(wmode, bytes);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfCmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `pdf_keep_cmap()`. */
FZ_FUNCTION PdfCmap::PdfCmap(const PdfCmap& rhs)
: m_internal(ll_pdf_keep_cmap(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_pdf_keep_cmap(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfCmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `pdf_keep_cmap()` and `pdf_drop_cmap()`. */
FZ_FUNCTION PdfCmap& PdfCmap::operator=(const PdfCmap& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_pdf_drop_cmap(this->m_internal)"
				<< " and ll_pdf_keep_cmap(rhs.m_internal)\n"
				;
	}
	#endif
	ll_pdf_drop_cmap(this->m_internal);
	ll_pdf_keep_cmap(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfCmap_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfCmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/* Class-aware wrapper for `::pdf_add_codespace()`.  */
FZ_FUNCTION void PdfCmap::pdf_add_codespace(unsigned int low, unsigned int high, size_t n) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_codespace()\n";
	}
	#endif
	mupdf::pdf_add_codespace(*this, low, high, n);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfCmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_cmap_size()`.  */
FZ_FUNCTION size_t PdfCmap::pdf_cmap_size() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_cmap_size()\n";
	}
	#endif
	auto ret = mupdf::pdf_cmap_size(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfCmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_cmap_wmode()`.  */
FZ_FUNCTION int PdfCmap::pdf_cmap_wmode() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_cmap_wmode()\n";
	}
	#endif
	auto ret = mupdf::pdf_cmap_wmode(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfCmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_decode_cmap()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_decode_cmap(unsigned char *s, unsigned char *e)` => `(int, unsigned int cpt)`
	 */
FZ_FUNCTION int PdfCmap::pdf_decode_cmap(unsigned char *s, unsigned char *e, unsigned int *cpt) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_decode_cmap()\n";
	}
	#endif
	auto ret = mupdf::pdf_decode_cmap(*this, s, e, cpt);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfCmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_lookup_cmap()`.  */
FZ_FUNCTION int PdfCmap::pdf_lookup_cmap(unsigned int cpt) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_cmap()\n";
	}
	#endif
	auto ret = mupdf::pdf_lookup_cmap(*this, cpt);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfCmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_lookup_cmap_full()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_lookup_cmap_full(unsigned int cpt)` => `(int, int out)`
	 */
FZ_FUNCTION int PdfCmap::pdf_lookup_cmap_full(unsigned int cpt, int *out) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_cmap_full()\n";
	}
	#endif
	auto ret = mupdf::pdf_lookup_cmap_full(*this, cpt, out);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfCmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_map_one_to_many()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_map_one_to_many(unsigned int one, size_t len)` => int many
	 */
FZ_FUNCTION void PdfCmap::pdf_map_one_to_many(unsigned int one, int *many, size_t len) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_map_one_to_many()\n";
	}
	#endif
	mupdf::pdf_map_one_to_many(*this, one, many, len);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfCmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_map_range_to_range()`.  */
FZ_FUNCTION void PdfCmap::pdf_map_range_to_range(unsigned int srclo, unsigned int srchi, int dstlo) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_map_range_to_range()\n";
	}
	#endif
	mupdf::pdf_map_range_to_range(*this, srclo, srchi, dstlo);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfCmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_cmap_wmode()`.  */
FZ_FUNCTION void PdfCmap::pdf_set_cmap_wmode(int wmode) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_cmap_wmode()\n";
	}
	#endif
	mupdf::pdf_set_cmap_wmode(*this, wmode);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfCmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_usecmap()`.  */
FZ_FUNCTION void PdfCmap::pdf_set_usecmap(const PdfCmap& usecmap) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_usecmap()\n";
	}
	#endif
	mupdf::pdf_set_usecmap(*this, usecmap);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfCmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_sort_cmap()`.  */
FZ_FUNCTION void PdfCmap::pdf_sort_cmap() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_sort_cmap()\n";
	}
	#endif
	mupdf::pdf_sort_cmap(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfCmap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

FZ_FUNCTION PdfCmap::PdfCmap(::pdf_cmap* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfCmap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfCmap::~PdfCmap()
{
	ll_pdf_drop_cmap(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfCmap_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long PdfCmap::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfCmap::s_num_instances = 0;


/* Implementation of methods for PdfColorFilterOptions (wrapper for pdf_color_filter_options). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfColorFilterOptions::PdfColorFilterOptions()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfColorFilterOptions::PdfColorFilterOptions(::pdf_color_filter_options* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfColorFilterOptions::~PdfColorFilterOptions()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfColorFilterOptions::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfColorFilterOptions::s_num_instances = 0;


/* Implementation of methods for PdfCrypt (wrapper for pdf_crypt). */

/* Constructor using `pdf_new_crypt()`. */
FZ_FUNCTION PdfCrypt::PdfCrypt(const PdfObj& enc, const PdfObj& id)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_crypt()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_crypt(enc.m_internal, id.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_encrypt()`. */
FZ_FUNCTION PdfCrypt::PdfCrypt(const char *opwd_utf8, const char *upwd_utf8, const PdfObj& id, int permissions, int algorithm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_encrypt()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_encrypt(opwd_utf8, upwd_utf8, id.m_internal, permissions, algorithm);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfCrypt::PdfCrypt()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::pdf_crypt_encrypt_metadata()`.  */
FZ_FUNCTION int PdfCrypt::pdf_crypt_encrypt_metadata() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_encrypt_metadata()\n";
	}
	#endif
	auto ret = mupdf::pdf_crypt_encrypt_metadata(*this);
	return ret;
}

/* Class-aware wrapper for `::pdf_crypt_key()`.  */
FZ_FUNCTION unsigned char *PdfCrypt::pdf_crypt_key() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_key()\n";
	}
	#endif
	auto ret = mupdf::pdf_crypt_key(*this);
	return ret;
}

/* Class-aware wrapper for `::pdf_crypt_length()`.  */
FZ_FUNCTION int PdfCrypt::pdf_crypt_length() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_length()\n";
	}
	#endif
	auto ret = mupdf::pdf_crypt_length(*this);
	return ret;
}

/* Class-aware wrapper for `::pdf_crypt_method()`.  */
FZ_FUNCTION const char *PdfCrypt::pdf_crypt_method() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_method()\n";
	}
	#endif
	auto ret = mupdf::pdf_crypt_method(*this);
	return ret;
}

/* Class-aware wrapper for `::pdf_crypt_obj()`.  */
FZ_FUNCTION void PdfCrypt::pdf_crypt_obj(const PdfObj& obj, int num, int gen) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_obj()\n";
	}
	#endif
	mupdf::pdf_crypt_obj(*this, obj, num, gen);
}

/* Class-aware wrapper for `::pdf_crypt_owner_encryption()`.  */
FZ_FUNCTION unsigned char *PdfCrypt::pdf_crypt_owner_encryption() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_owner_encryption()\n";
	}
	#endif
	auto ret = mupdf::pdf_crypt_owner_encryption(*this);
	return ret;
}

/* Class-aware wrapper for `::pdf_crypt_owner_password()`.  */
FZ_FUNCTION unsigned char *PdfCrypt::pdf_crypt_owner_password() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_owner_password()\n";
	}
	#endif
	auto ret = mupdf::pdf_crypt_owner_password(*this);
	return ret;
}

/* Class-aware wrapper for `::pdf_crypt_permissions()`.  */
FZ_FUNCTION int PdfCrypt::pdf_crypt_permissions() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_permissions()\n";
	}
	#endif
	auto ret = mupdf::pdf_crypt_permissions(*this);
	return ret;
}

/* Class-aware wrapper for `::pdf_crypt_permissions_encryption()`.  */
FZ_FUNCTION unsigned char *PdfCrypt::pdf_crypt_permissions_encryption() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_permissions_encryption()\n";
	}
	#endif
	auto ret = mupdf::pdf_crypt_permissions_encryption(*this);
	return ret;
}

/* Class-aware wrapper for `::pdf_crypt_revision()`.  */
FZ_FUNCTION int PdfCrypt::pdf_crypt_revision() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_revision()\n";
	}
	#endif
	auto ret = mupdf::pdf_crypt_revision(*this);
	return ret;
}

/* Class-aware wrapper for `::pdf_crypt_stream_method()`.  */
FZ_FUNCTION const char *PdfCrypt::pdf_crypt_stream_method() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_stream_method()\n";
	}
	#endif
	auto ret = mupdf::pdf_crypt_stream_method(*this);
	return ret;
}

/* Class-aware wrapper for `::pdf_crypt_string_method()`.  */
FZ_FUNCTION const char *PdfCrypt::pdf_crypt_string_method() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_string_method()\n";
	}
	#endif
	auto ret = mupdf::pdf_crypt_string_method(*this);
	return ret;
}

/* Class-aware wrapper for `::pdf_crypt_user_encryption()`.  */
FZ_FUNCTION unsigned char *PdfCrypt::pdf_crypt_user_encryption() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_user_encryption()\n";
	}
	#endif
	auto ret = mupdf::pdf_crypt_user_encryption(*this);
	return ret;
}

/* Class-aware wrapper for `::pdf_crypt_user_password()`.  */
FZ_FUNCTION unsigned char *PdfCrypt::pdf_crypt_user_password() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_user_password()\n";
	}
	#endif
	auto ret = mupdf::pdf_crypt_user_password(*this);
	return ret;
}

/* Class-aware wrapper for `::pdf_crypt_version()`.  */
FZ_FUNCTION int PdfCrypt::pdf_crypt_version() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_version()\n";
	}
	#endif
	auto ret = mupdf::pdf_crypt_version(*this);
	return ret;
}

/* Class-aware wrapper for `::pdf_encrypt_data()`.  */
FZ_FUNCTION void PdfCrypt::pdf_encrypt_data(int num, int gen, void (*fmt_str_out)(::fz_context *, void *, const unsigned char *, size_t ), void *arg, const unsigned char *s, size_t n) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_encrypt_data()\n";
	}
	#endif
	mupdf::pdf_encrypt_data(*this, num, gen, fmt_str_out, arg, s, n);
}

/* Class-aware wrapper for `::pdf_encrypted_len()`.  */
FZ_FUNCTION size_t PdfCrypt::pdf_encrypted_len(int num, int gen, size_t len) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_encrypted_len()\n";
	}
	#endif
	auto ret = mupdf::pdf_encrypted_len(*this, num, gen, len);
	return ret;
}

FZ_FUNCTION PdfCrypt::PdfCrypt(::pdf_crypt* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfCrypt::~PdfCrypt()
{
	ll_pdf_drop_crypt(m_internal);
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long PdfCrypt::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfCrypt::s_num_instances = 0;


/* Implementation of methods for PdfCsi (wrapper for pdf_csi). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfCsi::PdfCsi()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfCsi::PdfCsi(::pdf_csi* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfCsi::~PdfCsi()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfCsi::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfCsi::s_num_instances = 0;


/* Implementation of methods for PdfCycleList (wrapper for pdf_cycle_list). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfCycleList::PdfCycleList()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::pdf_cycle()`.  */
FZ_FUNCTION int PdfCycleList::pdf_cycle(const PdfCycleList& prev, const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_cycle()\n";
	}
	#endif
	auto ret = mupdf::pdf_cycle(*this, prev, obj);
	return ret;
}

FZ_FUNCTION PdfCycleList::PdfCycleList(::pdf_cycle_list* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfCycleList::~PdfCycleList()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfCycleList::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfCycleList::s_num_instances = 0;


/* Implementation of methods for PdfDocEvent (wrapper for pdf_doc_event). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfDocEvent::PdfDocEvent()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::pdf_access_exec_menu_item_event()`.  */
FZ_FUNCTION const char *PdfDocEvent::pdf_access_exec_menu_item_event() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_access_exec_menu_item_event()\n";
	}
	#endif
	auto ret = mupdf::pdf_access_exec_menu_item_event(*this);
	return ret;
}

FZ_FUNCTION PdfDocEvent::PdfDocEvent(::pdf_doc_event* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfDocEvent::~PdfDocEvent()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfDocEvent::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfDocEvent::s_num_instances = 0;


/* Implementation of methods for PdfDocument (wrapper for pdf_document). */

#ifndef NDEBUG
static RefsCheck<::pdf_document, PdfDocument> s_PdfDocument_refs_check(offsetof(::pdf_document, super.refs), 32);
#endif

/* Constructor using `pdf_create_document()`. */
FZ_FUNCTION PdfDocument::PdfDocument()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_create_document()\n";
	}
	#endif
	this->m_internal = ll_pdf_create_document();
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_document_from_fz_document()`. */
FZ_FUNCTION PdfDocument::PdfDocument(const FzDocument& ptr)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_document_from_fz_document()\n";
	}
	#endif
	this->m_internal = ll_pdf_document_from_fz_document(ptr.m_internal);
	ll_pdf_keep_document(this->m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_open_document()`. */
FZ_FUNCTION PdfDocument::PdfDocument(const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_document()\n";
	}
	#endif
	this->m_internal = ll_pdf_open_document(filename);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_open_document_with_stream()`. */
FZ_FUNCTION PdfDocument::PdfDocument(const FzStream& file)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_document_with_stream()\n";
	}
	#endif
	this->m_internal = ll_pdf_open_document_with_stream(file.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `pdf_keep_document()`. */
FZ_FUNCTION PdfDocument::PdfDocument(const PdfDocument& rhs)
: m_internal(ll_pdf_keep_document(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_pdf_keep_document(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `pdf_keep_document()` and `pdf_drop_document()`. */
FZ_FUNCTION PdfDocument& PdfDocument::operator=(const PdfDocument& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_pdf_drop_document(this->m_internal)"
				<< " and ll_pdf_keep_document(rhs.m_internal)\n"
				;
	}
	#endif
	ll_pdf_drop_document(this->m_internal);
	ll_pdf_keep_document(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/* Class-aware wrapper for `::pdf_abandon_operation()`.  */
FZ_FUNCTION void PdfDocument::pdf_abandon_operation() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_abandon_operation()\n";
	}
	#endif
	mupdf::pdf_abandon_operation(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_add_cid_font()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_add_cid_font(const FzFont& font) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_cid_font()\n";
	}
	#endif
	auto ret = mupdf::pdf_add_cid_font(*this, font);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_add_cjk_font()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_add_cjk_font(const FzFont& font, int script, int wmode, int serif) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_cjk_font()\n";
	}
	#endif
	auto ret = mupdf::pdf_add_cjk_font(*this, font, script, wmode, serif);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_add_embedded_file()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_add_embedded_file(const char *filename, const char *mimetype, const FzBuffer& contents, int64_t created, int64_t modifed, int add_checksum) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_embedded_file()\n";
	}
	#endif
	auto ret = mupdf::pdf_add_embedded_file(*this, filename, mimetype, contents, created, modifed, add_checksum);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_add_image()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_add_image(const FzImage& image) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_image()\n";
	}
	#endif
	auto ret = mupdf::pdf_add_image(*this, image);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_add_journal_fragment()`.  */
FZ_FUNCTION void PdfDocument::pdf_add_journal_fragment(int parent, const PdfObj& copy, const FzBuffer& copy_stream, int newobj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_journal_fragment()\n";
	}
	#endif
	mupdf::pdf_add_journal_fragment(*this, parent, copy, copy_stream, newobj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_add_new_array()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_add_new_array(int initial) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_new_array()\n";
	}
	#endif
	auto ret = mupdf::pdf_add_new_array(*this, initial);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_add_new_dict()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_add_new_dict(int initial) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_new_dict()\n";
	}
	#endif
	auto ret = mupdf::pdf_add_new_dict(*this, initial);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_add_object()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_add_object(const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_object()\n";
	}
	#endif
	auto ret = mupdf::pdf_add_object(*this, obj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_add_page()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_add_page(const FzRect& mediabox, int rotate, const PdfObj& resources, const FzBuffer& contents) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_page()\n";
	}
	#endif
	auto ret = mupdf::pdf_add_page(*this, mediabox, rotate, resources, contents);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_add_simple_font()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_add_simple_font(const FzFont& font, int encoding) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_simple_font()\n";
	}
	#endif
	auto ret = mupdf::pdf_add_simple_font(*this, font, encoding);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_add_stream()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_add_stream(const FzBuffer& buf, const PdfObj& obj, int compressed) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_stream()\n";
	}
	#endif
	auto ret = mupdf::pdf_add_stream(*this, buf, obj, compressed);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_add_substitute_font()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_add_substitute_font(const FzFont& font) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_substitute_font()\n";
	}
	#endif
	auto ret = mupdf::pdf_add_substitute_font(*this, font);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_annot_field_event_keystroke()`.  */
FZ_FUNCTION int PdfDocument::pdf_annot_field_event_keystroke(const PdfAnnot& annot, const PdfKeystrokeEvent& evt) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_field_event_keystroke()\n";
	}
	#endif
	auto ret = mupdf::pdf_annot_field_event_keystroke(*this, annot, evt);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_authenticate_password()`.  */
FZ_FUNCTION int PdfDocument::pdf_authenticate_password(const char *pw) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_authenticate_password()\n";
	}
	#endif
	auto ret = mupdf::pdf_authenticate_password(*this, pw);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_bake_document()`.  */
FZ_FUNCTION void PdfDocument::pdf_bake_document(int bake_annots, int bake_widgets) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_bake_document()\n";
	}
	#endif
	mupdf::pdf_bake_document(*this, bake_annots, bake_widgets);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_begin_implicit_operation()`.  */
FZ_FUNCTION void PdfDocument::pdf_begin_implicit_operation() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_begin_implicit_operation()\n";
	}
	#endif
	mupdf::pdf_begin_implicit_operation(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_begin_operation()`.  */
FZ_FUNCTION void PdfDocument::pdf_begin_operation(const char *operation) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_begin_operation()\n";
	}
	#endif
	mupdf::pdf_begin_operation(*this, operation);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_calculate_form()`.  */
FZ_FUNCTION void PdfDocument::pdf_calculate_form() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_calculate_form()\n";
	}
	#endif
	mupdf::pdf_calculate_form(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_can_be_saved_incrementally()`.  */
FZ_FUNCTION int PdfDocument::pdf_can_be_saved_incrementally() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_can_be_saved_incrementally()\n";
	}
	#endif
	auto ret = mupdf::pdf_can_be_saved_incrementally(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_can_redo()`.  */
FZ_FUNCTION int PdfDocument::pdf_can_redo() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_can_redo()\n";
	}
	#endif
	auto ret = mupdf::pdf_can_redo(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_can_undo()`.  */
FZ_FUNCTION int PdfDocument::pdf_can_undo() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_can_undo()\n";
	}
	#endif
	auto ret = mupdf::pdf_can_undo(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_clear_xref()`.  */
FZ_FUNCTION void PdfDocument::pdf_clear_xref() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_clear_xref()\n";
	}
	#endif
	mupdf::pdf_clear_xref(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_clear_xref_to_mark()`.  */
FZ_FUNCTION void PdfDocument::pdf_clear_xref_to_mark() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_clear_xref_to_mark()\n";
	}
	#endif
	mupdf::pdf_clear_xref_to_mark(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_count_layer_config_ui()`.  */
FZ_FUNCTION int PdfDocument::pdf_count_layer_config_ui() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_count_layer_config_ui()\n";
	}
	#endif
	auto ret = mupdf::pdf_count_layer_config_ui(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_count_layer_configs()`.  */
FZ_FUNCTION int PdfDocument::pdf_count_layer_configs() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_count_layer_configs()\n";
	}
	#endif
	auto ret = mupdf::pdf_count_layer_configs(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_count_layers()`.  */
FZ_FUNCTION int PdfDocument::pdf_count_layers() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_count_layers()\n";
	}
	#endif
	auto ret = mupdf::pdf_count_layers(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_count_objects()`.  */
FZ_FUNCTION int PdfDocument::pdf_count_objects() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_count_objects()\n";
	}
	#endif
	auto ret = mupdf::pdf_count_objects(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_count_pages()`.  */
FZ_FUNCTION int PdfDocument::pdf_count_pages() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_count_pages()\n";
	}
	#endif
	auto ret = mupdf::pdf_count_pages(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_count_q_balance()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_count_q_balance(::pdf_obj *res, ::pdf_obj *stm)` => `(int prepend, int append)`
	 */
FZ_FUNCTION void PdfDocument::pdf_count_q_balance(const PdfObj& res, const PdfObj& stm, int *prepend, int *append) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_count_q_balance()\n";
	}
	#endif
	mupdf::pdf_count_q_balance(*this, res, stm, prepend, append);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_count_signatures()`.  */
FZ_FUNCTION int PdfDocument::pdf_count_signatures() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_count_signatures()\n";
	}
	#endif
	auto ret = mupdf::pdf_count_signatures(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_count_unsaved_versions()`.  */
FZ_FUNCTION int PdfDocument::pdf_count_unsaved_versions() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_count_unsaved_versions()\n";
	}
	#endif
	auto ret = mupdf::pdf_count_unsaved_versions(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_count_versions()`.  */
FZ_FUNCTION int PdfDocument::pdf_count_versions() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_count_versions()\n";
	}
	#endif
	auto ret = mupdf::pdf_count_versions(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_create_field_name()`.  */
FZ_FUNCTION void PdfDocument::pdf_create_field_name(const char *prefix, char *buf, size_t len) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_create_field_name()\n";
	}
	#endif
	mupdf::pdf_create_field_name(*this, prefix, buf, len);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_create_object()`.  */
FZ_FUNCTION int PdfDocument::pdf_create_object() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_create_object()\n";
	}
	#endif
	auto ret = mupdf::pdf_create_object(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_debug_doc_changes()`.  */
FZ_FUNCTION void PdfDocument::pdf_debug_doc_changes() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_debug_doc_changes()\n";
	}
	#endif
	mupdf::pdf_debug_doc_changes(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_delete_object()`.  */
FZ_FUNCTION void PdfDocument::pdf_delete_object(int num) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_delete_object()\n";
	}
	#endif
	mupdf::pdf_delete_object(*this, num);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_delete_page()`.  */
FZ_FUNCTION void PdfDocument::pdf_delete_page(int number) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_delete_page()\n";
	}
	#endif
	mupdf::pdf_delete_page(*this, number);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_delete_page_labels()`.  */
FZ_FUNCTION void PdfDocument::pdf_delete_page_labels(int index) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_delete_page_labels()\n";
	}
	#endif
	mupdf::pdf_delete_page_labels(*this, index);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_delete_page_range()`.  */
FZ_FUNCTION void PdfDocument::pdf_delete_page_range(int start, int end) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_delete_page_range()\n";
	}
	#endif
	mupdf::pdf_delete_page_range(*this, start, end);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_deselect_layer_config_ui()`.  */
FZ_FUNCTION void PdfDocument::pdf_deselect_layer_config_ui(int ui) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_deselect_layer_config_ui()\n";
	}
	#endif
	mupdf::pdf_deselect_layer_config_ui(*this, ui);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_deserialise_journal()`.  */
FZ_FUNCTION void PdfDocument::pdf_deserialise_journal(const FzStream& stm) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_deserialise_journal()\n";
	}
	#endif
	mupdf::pdf_deserialise_journal(*this, stm);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_disable_js()`.  */
FZ_FUNCTION void PdfDocument::pdf_disable_js() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_disable_js()\n";
	}
	#endif
	mupdf::pdf_disable_js(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_doc_was_linearized()`.  */
FZ_FUNCTION int PdfDocument::pdf_doc_was_linearized() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_doc_was_linearized()\n";
	}
	#endif
	auto ret = mupdf::pdf_doc_was_linearized(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_document_event_did_print()`.  */
FZ_FUNCTION void PdfDocument::pdf_document_event_did_print() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_document_event_did_print()\n";
	}
	#endif
	mupdf::pdf_document_event_did_print(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_document_event_did_save()`.  */
FZ_FUNCTION void PdfDocument::pdf_document_event_did_save() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_document_event_did_save()\n";
	}
	#endif
	mupdf::pdf_document_event_did_save(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_document_event_will_close()`.  */
FZ_FUNCTION void PdfDocument::pdf_document_event_will_close() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_document_event_will_close()\n";
	}
	#endif
	mupdf::pdf_document_event_will_close(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_document_event_will_print()`.  */
FZ_FUNCTION void PdfDocument::pdf_document_event_will_print() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_document_event_will_print()\n";
	}
	#endif
	mupdf::pdf_document_event_will_print(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_document_event_will_save()`.  */
FZ_FUNCTION void PdfDocument::pdf_document_event_will_save() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_document_event_will_save()\n";
	}
	#endif
	mupdf::pdf_document_event_will_save(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_document_output_intent()`.  */
FZ_FUNCTION FzColorspace PdfDocument::pdf_document_output_intent() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_document_output_intent()\n";
	}
	#endif
	auto ret = mupdf::pdf_document_output_intent(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_document_permissions()`.  */
FZ_FUNCTION int PdfDocument::pdf_document_permissions() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_document_permissions()\n";
	}
	#endif
	auto ret = mupdf::pdf_document_permissions(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_empty_store()`.  */
FZ_FUNCTION void PdfDocument::pdf_empty_store() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_empty_store()\n";
	}
	#endif
	mupdf::pdf_empty_store(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_enable_journal()`.  */
FZ_FUNCTION void PdfDocument::pdf_enable_journal() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_enable_journal()\n";
	}
	#endif
	mupdf::pdf_enable_journal(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_enable_js()`.  */
FZ_FUNCTION void PdfDocument::pdf_enable_js() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_enable_js()\n";
	}
	#endif
	mupdf::pdf_enable_js(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_enable_layer()`.  */
FZ_FUNCTION void PdfDocument::pdf_enable_layer(int layer, int enabled) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_enable_layer()\n";
	}
	#endif
	mupdf::pdf_enable_layer(*this, layer, enabled);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_end_operation()`.  */
FZ_FUNCTION void PdfDocument::pdf_end_operation() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_end_operation()\n";
	}
	#endif
	mupdf::pdf_end_operation(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_ensure_solid_xref()`.  */
FZ_FUNCTION void PdfDocument::pdf_ensure_solid_xref(int num) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_ensure_solid_xref()\n";
	}
	#endif
	mupdf::pdf_ensure_solid_xref(*this, num);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_event_issue_alert()`.  */
FZ_FUNCTION void PdfDocument::pdf_event_issue_alert(const PdfAlertEvent& evt) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_event_issue_alert()\n";
	}
	#endif
	mupdf::pdf_event_issue_alert(*this, evt);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_event_issue_exec_menu_item()`.  */
FZ_FUNCTION void PdfDocument::pdf_event_issue_exec_menu_item(const char *item) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_event_issue_exec_menu_item()\n";
	}
	#endif
	mupdf::pdf_event_issue_exec_menu_item(*this, item);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_event_issue_launch_url()`.  */
FZ_FUNCTION void PdfDocument::pdf_event_issue_launch_url(const char *url, int new_frame) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_event_issue_launch_url()\n";
	}
	#endif
	mupdf::pdf_event_issue_launch_url(*this, url, new_frame);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_event_issue_mail_doc()`.  */
FZ_FUNCTION void PdfDocument::pdf_event_issue_mail_doc(const PdfMailDocEvent& evt) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_event_issue_mail_doc()\n";
	}
	#endif
	mupdf::pdf_event_issue_mail_doc(*this, evt);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_event_issue_print()`.  */
FZ_FUNCTION void PdfDocument::pdf_event_issue_print() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_event_issue_print()\n";
	}
	#endif
	mupdf::pdf_event_issue_print(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_field_event_calculate()`.  */
FZ_FUNCTION void PdfDocument::pdf_field_event_calculate(const PdfObj& field) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_event_calculate()\n";
	}
	#endif
	mupdf::pdf_field_event_calculate(*this, field);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_field_event_format()`.  */
FZ_FUNCTION char *PdfDocument::pdf_field_event_format(const PdfObj& field) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_event_format()\n";
	}
	#endif
	auto ret = mupdf::pdf_field_event_format(*this, field);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_field_event_keystroke()`.  */
FZ_FUNCTION int PdfDocument::pdf_field_event_keystroke(const PdfObj& field, const PdfKeystrokeEvent& evt) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_event_keystroke()\n";
	}
	#endif
	auto ret = mupdf::pdf_field_event_keystroke(*this, field, evt);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_field_event_validate()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_field_event_validate(::pdf_obj *field, const char *value)` => `(int, char *newvalue)`
	 */
FZ_FUNCTION int PdfDocument::pdf_field_event_validate(const PdfObj& field, const char *value, char **newvalue) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_event_validate()\n";
	}
	#endif
	auto ret = mupdf::pdf_field_event_validate(*this, field, value, newvalue);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_field_reset()`.  */
FZ_FUNCTION void PdfDocument::pdf_field_reset(const PdfObj& field) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_reset()\n";
	}
	#endif
	mupdf::pdf_field_reset(*this, field);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_filter_annot_contents()`.  */
FZ_FUNCTION void PdfDocument::pdf_filter_annot_contents(const PdfAnnot& annot, PdfFilterOptions& options) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_filter_annot_contents()\n";
	}
	#endif
	mupdf::pdf_filter_annot_contents(*this, annot, options);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_filter_page_contents()`.  */
FZ_FUNCTION void PdfDocument::pdf_filter_page_contents(const PdfPage& page, PdfFilterOptions& options) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_filter_page_contents()\n";
	}
	#endif
	mupdf::pdf_filter_page_contents(*this, page, options);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_find_font_resource()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_find_font_resource(int type, int encoding, const FzFont& item, const PdfFontResourceKey& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_find_font_resource()\n";
	}
	#endif
	auto ret = mupdf::pdf_find_font_resource(*this, type, encoding, item, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_find_version_for_obj()`.  */
FZ_FUNCTION int PdfDocument::pdf_find_version_for_obj(const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_find_version_for_obj()\n";
	}
	#endif
	auto ret = mupdf::pdf_find_version_for_obj(*this, obj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_forget_xref()`.  */
FZ_FUNCTION void PdfDocument::pdf_forget_xref() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_forget_xref()\n";
	}
	#endif
	mupdf::pdf_forget_xref(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_get_doc_event_callback_data()`.  */
FZ_FUNCTION void *PdfDocument::pdf_get_doc_event_callback_data() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_get_doc_event_callback_data()\n";
	}
	#endif
	auto ret = mupdf::pdf_get_doc_event_callback_data(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_graft_object()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_graft_object(const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_graft_object()\n";
	}
	#endif
	auto ret = mupdf::pdf_graft_object(*this, obj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_graft_page()`.  */
FZ_FUNCTION void PdfDocument::pdf_graft_page(int page_to, const PdfDocument& src, int page_from) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_graft_page()\n";
	}
	#endif
	mupdf::pdf_graft_page(*this, page_to, src, page_from);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_has_permission()`.  */
FZ_FUNCTION int PdfDocument::pdf_has_permission(::fz_permission p) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_has_permission()\n";
	}
	#endif
	auto ret = mupdf::pdf_has_permission(*this, p);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_has_unsaved_changes()`.  */
FZ_FUNCTION int PdfDocument::pdf_has_unsaved_changes() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_has_unsaved_changes()\n";
	}
	#endif
	auto ret = mupdf::pdf_has_unsaved_changes(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_has_unsaved_sigs()`.  */
FZ_FUNCTION int PdfDocument::pdf_has_unsaved_sigs() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_has_unsaved_sigs()\n";
	}
	#endif
	auto ret = mupdf::pdf_has_unsaved_sigs(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_insert_font_resource()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_insert_font_resource(const PdfFontResourceKey& key, const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_insert_font_resource()\n";
	}
	#endif
	auto ret = mupdf::pdf_insert_font_resource(*this, key, obj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_insert_page()`.  */
FZ_FUNCTION void PdfDocument::pdf_insert_page(int at, const PdfObj& page) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_insert_page()\n";
	}
	#endif
	mupdf::pdf_insert_page(*this, at, page);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_invalidate_xfa()`.  */
FZ_FUNCTION void PdfDocument::pdf_invalidate_xfa() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_invalidate_xfa()\n";
	}
	#endif
	mupdf::pdf_invalidate_xfa(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_is_local_object()`.  */
FZ_FUNCTION int PdfDocument::pdf_is_local_object(const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_local_object()\n";
	}
	#endif
	auto ret = mupdf::pdf_is_local_object(*this, obj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_is_ocg_hidden()`.  */
FZ_FUNCTION int PdfDocument::pdf_is_ocg_hidden(const PdfObj& rdb, const char *usage, const PdfObj& ocg) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_ocg_hidden()\n";
	}
	#endif
	auto ret = mupdf::pdf_is_ocg_hidden(*this, rdb, usage, ocg);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_js_set_console()`.  */
FZ_FUNCTION void PdfDocument::pdf_js_set_console(const PdfJsConsole& console, void *user) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_js_set_console()\n";
	}
	#endif
	mupdf::pdf_js_set_console(*this, console, user);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_js_supported()`.  */
FZ_FUNCTION int PdfDocument::pdf_js_supported() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_js_supported()\n";
	}
	#endif
	auto ret = mupdf::pdf_js_supported(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_layer_config_info()`.  */
FZ_FUNCTION void PdfDocument::pdf_layer_config_info(int config_num, PdfLayerConfig& info) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_layer_config_info()\n";
	}
	#endif
	mupdf::pdf_layer_config_info(*this, config_num, info);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_layer_config_ui_info()`.  */
FZ_FUNCTION void PdfDocument::pdf_layer_config_ui_info(int ui, PdfLayerConfigUi& info) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_layer_config_ui_info()\n";
	}
	#endif
	mupdf::pdf_layer_config_ui_info(*this, ui, info);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_layer_is_enabled()`.  */
FZ_FUNCTION int PdfDocument::pdf_layer_is_enabled(int layer) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_layer_is_enabled()\n";
	}
	#endif
	auto ret = mupdf::pdf_layer_is_enabled(*this, layer);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_layer_name()`.  */
FZ_FUNCTION const char *PdfDocument::pdf_layer_name(int layer) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_layer_name()\n";
	}
	#endif
	auto ret = mupdf::pdf_layer_name(*this, layer);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_compressed_inline_image()`.  */
FZ_FUNCTION void PdfDocument::pdf_load_compressed_inline_image(const PdfObj& dict, int length, const FzStream& cstm, int indexed, const FzCompressedImage& image) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_compressed_inline_image()\n";
	}
	#endif
	mupdf::pdf_load_compressed_inline_image(*this, dict, length, cstm, indexed, image);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_load_compressed_stream()`.  */
FZ_FUNCTION FzCompressedBuffer PdfDocument::pdf_load_compressed_stream(int num, size_t worst_case) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_compressed_stream()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_compressed_stream(*this, num, worst_case);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_default_colorspaces()`.  */
FZ_FUNCTION FzDefaultColorspaces PdfDocument::pdf_load_default_colorspaces(const PdfPage& page) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_default_colorspaces()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_default_colorspaces(*this, page);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_embedded_cmap()`.  */
FZ_FUNCTION PdfCmap PdfDocument::pdf_load_embedded_cmap(const PdfObj& ref) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_embedded_cmap()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_embedded_cmap(*this, ref);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_image()`.  */
FZ_FUNCTION FzImage PdfDocument::pdf_load_image(const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_image()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_image(*this, obj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_inline_image()`.  */
FZ_FUNCTION FzImage PdfDocument::pdf_load_inline_image(const PdfObj& rdb, const PdfObj& dict, const FzStream& file) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_inline_image()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_inline_image(*this, rdb, dict, file);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_journal()`.  */
FZ_FUNCTION void PdfDocument::pdf_load_journal(const char *filename) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_journal()\n";
	}
	#endif
	mupdf::pdf_load_journal(*this, filename);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_load_link_annots()`.  */
FZ_FUNCTION FzLink PdfDocument::pdf_load_link_annots(const PdfPage& arg_1, const PdfObj& annots, int pagenum, const FzMatrix& page_ctm) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_link_annots()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_link_annots(*this, arg_1, annots, pagenum, page_ctm);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_name_tree()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_load_name_tree(const PdfObj& which) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_name_tree()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_name_tree(*this, which);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_object()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_load_object(int num) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_object()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_object(*this, num);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_outline()`.  */
FZ_FUNCTION FzOutline PdfDocument::pdf_load_outline() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_outline()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_outline(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_page()`.  */
FZ_FUNCTION PdfPage PdfDocument::pdf_load_page(int number) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_page()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_page(*this, number);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_page_tree()`.  */
FZ_FUNCTION void PdfDocument::pdf_load_page_tree() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_page_tree()\n";
	}
	#endif
	mupdf::pdf_load_page_tree(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_load_pattern()`.  */
FZ_FUNCTION PdfPattern PdfDocument::pdf_load_pattern(const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_pattern()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_pattern(*this, obj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_raw_stream_number()`.  */
FZ_FUNCTION FzBuffer PdfDocument::pdf_load_raw_stream_number(int num) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_raw_stream_number()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_raw_stream_number(*this, num);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_shading()`.  */
FZ_FUNCTION FzShade PdfDocument::pdf_load_shading(const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_shading()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_shading(*this, obj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_stream_number()`.  */
FZ_FUNCTION FzBuffer PdfDocument::pdf_load_stream_number(int num) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_stream_number()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_stream_number(*this, num);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_to_unicode()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_load_to_unicode(::pdf_font_desc *font, char *collection, ::pdf_obj *cmapstm)` => const char *strings
	 */
FZ_FUNCTION void PdfDocument::pdf_load_to_unicode(const PdfFontDesc& font, const char **strings, char *collection, const PdfObj& cmapstm) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_to_unicode()\n";
	}
	#endif
	mupdf::pdf_load_to_unicode(*this, font, strings, collection, cmapstm);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_load_type3_glyphs()`.  */
FZ_FUNCTION void PdfDocument::pdf_load_type3_glyphs(const PdfFontDesc& fontdesc) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_type3_glyphs()\n";
	}
	#endif
	mupdf::pdf_load_type3_glyphs(*this, fontdesc);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_load_unencrypted_object()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_load_unencrypted_object(int num) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_unencrypted_object()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_unencrypted_object(*this, num);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_lookup_dest()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_lookup_dest(const PdfObj& needle) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_dest()\n";
	}
	#endif
	auto ret = mupdf::pdf_lookup_dest(*this, needle);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_lookup_metadata()`.  */
FZ_FUNCTION int PdfDocument::pdf_lookup_metadata(const char *key, char *ptr, int size) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_metadata()\n";
	}
	#endif
	auto ret = mupdf::pdf_lookup_metadata(*this, key, ptr, size);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_lookup_metadata2()`.  */
FZ_FUNCTION std::string PdfDocument::pdf_lookup_metadata2(const char *key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_metadata2()\n";
	}
	#endif
	auto ret = mupdf::pdf_lookup_metadata2(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_lookup_name()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_lookup_name(const PdfObj& which, const PdfObj& needle) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_name()\n";
	}
	#endif
	auto ret = mupdf::pdf_lookup_name(*this, which, needle);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_lookup_page_loc()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_lookup_page_loc(int needle, ::pdf_obj **parentp)` => `(pdf_obj *, int indexp)`
	 */
FZ_FUNCTION PdfObj PdfDocument::pdf_lookup_page_loc(int needle, PdfObj& parentp, int *indexp) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_page_loc()\n";
	}
	#endif
	auto ret = mupdf::pdf_lookup_page_loc(*this, needle, parentp, indexp);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_lookup_page_number()`.  */
FZ_FUNCTION int PdfDocument::pdf_lookup_page_number(const PdfObj& pageobj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_page_number()\n";
	}
	#endif
	auto ret = mupdf::pdf_lookup_page_number(*this, pageobj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_lookup_page_obj()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_lookup_page_obj(int needle) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_page_obj()\n";
	}
	#endif
	auto ret = mupdf::pdf_lookup_page_obj(*this, needle);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_mark_xref()`.  */
FZ_FUNCTION void PdfDocument::pdf_mark_xref() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_mark_xref()\n";
	}
	#endif
	mupdf::pdf_mark_xref(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_metadata()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_metadata() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_metadata()\n";
	}
	#endif
	auto ret = mupdf::pdf_metadata(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_minimize_document()`.  */
FZ_FUNCTION void PdfDocument::pdf_minimize_document() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_minimize_document()\n";
	}
	#endif
	mupdf::pdf_minimize_document(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_needs_password()`.  */
FZ_FUNCTION int PdfDocument::pdf_needs_password() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_needs_password()\n";
	}
	#endif
	auto ret = mupdf::pdf_needs_password(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_action_from_link()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_new_action_from_link(const char *uri) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_action_from_link()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_action_from_link(*this, uri);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_array()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_new_array(int initialcap) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_array()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_array(*this, initialcap);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_color_filter()`.  */
FZ_FUNCTION PdfProcessor PdfDocument::pdf_new_color_filter(const PdfProcessor& chain, int struct_parents, const FzMatrix& transform, PdfFilterOptions& options, void *copts) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_color_filter()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_color_filter(*this, chain, struct_parents, transform, options, copts);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_date()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_new_date(int64_t time) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_date()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_date(*this, time);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_dest_from_link()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_new_dest_from_link(const char *uri, int is_remote) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_dest_from_link()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_dest_from_link(*this, uri, is_remote);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_dict()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_new_dict(int initialcap) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_dict()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_dict(*this, initialcap);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_graft_map()`.  */
FZ_FUNCTION PdfGraftMap PdfDocument::pdf_new_graft_map() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_graft_map()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_graft_map(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_indirect()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_new_indirect(int num, int gen) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_indirect()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_indirect(*this, num, gen);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_matrix()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_new_matrix(const FzMatrix& mtx) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_matrix()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_matrix(*this, mtx);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_pdf_device()`.  */
FZ_FUNCTION FzDevice PdfDocument::pdf_new_pdf_device(const FzMatrix& topctm, const PdfObj& resources, const FzBuffer& contents) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_pdf_device()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_pdf_device(*this, topctm, resources, contents);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_rect()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_new_rect(const FzRect& rect) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_rect()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_rect(*this, rect);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_run_processor()`.  */
FZ_FUNCTION PdfProcessor PdfDocument::pdf_new_run_processor(const FzDevice& dev, const FzMatrix& ctm, int struct_parent, const char *usage, const PdfGstate& gstate, const FzDefaultColorspaces& default_cs, FzCookie& cookie) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_run_processor()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_run_processor(*this, dev, ctm, struct_parent, usage, gstate, default_cs, cookie);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_sanitize_filter()`.  */
FZ_FUNCTION PdfProcessor PdfDocument::pdf_new_sanitize_filter(const PdfProcessor& chain, int struct_parents, const FzMatrix& transform, PdfFilterOptions& options, void *sopts) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_sanitize_filter()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_sanitize_filter(*this, chain, struct_parents, transform, options, sopts);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_xobject()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_new_xobject(const FzRect& bbox, const FzMatrix& matrix, const PdfObj& res, const FzBuffer& buffer) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_xobject()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_xobject(*this, bbox, matrix, res, buffer);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_obj_num_is_stream()`.  */
FZ_FUNCTION int PdfDocument::pdf_obj_num_is_stream(int num) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_obj_num_is_stream()\n";
	}
	#endif
	auto ret = mupdf::pdf_obj_num_is_stream(*this, num);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_open_contents_stream()`.  */
FZ_FUNCTION FzStream PdfDocument::pdf_open_contents_stream(const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_contents_stream()\n";
	}
	#endif
	auto ret = mupdf::pdf_open_contents_stream(*this, obj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_open_inline_stream()`.  */
FZ_FUNCTION FzStream PdfDocument::pdf_open_inline_stream(const PdfObj& stmobj, int length, const FzStream& chain, const FzCompressionParams& params) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_inline_stream()\n";
	}
	#endif
	auto ret = mupdf::pdf_open_inline_stream(*this, stmobj, length, chain, params);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_open_raw_stream_number()`.  */
FZ_FUNCTION FzStream PdfDocument::pdf_open_raw_stream_number(int num) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_raw_stream_number()\n";
	}
	#endif
	auto ret = mupdf::pdf_open_raw_stream_number(*this, num);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_open_stream_number()`.  */
FZ_FUNCTION FzStream PdfDocument::pdf_open_stream_number(int num) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_stream_number()\n";
	}
	#endif
	auto ret = mupdf::pdf_open_stream_number(*this, num);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_open_stream_with_offset()`.  */
FZ_FUNCTION FzStream PdfDocument::pdf_open_stream_with_offset(int num, const PdfObj& dict, int64_t stm_ofs) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_stream_with_offset()\n";
	}
	#endif
	auto ret = mupdf::pdf_open_stream_with_offset(*this, num, dict, stm_ofs);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_page_label()`.  */
FZ_FUNCTION void PdfDocument::pdf_page_label(int page, char *buf, size_t size) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_label()\n";
	}
	#endif
	mupdf::pdf_page_label(*this, page, buf, size);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_page_write()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_page_write(::fz_rect mediabox, ::pdf_obj **presources, ::fz_buffer **pcontents)` => `(fz_device *)`
	 */
FZ_FUNCTION FzDevice PdfDocument::pdf_page_write(const FzRect& mediabox, PdfObj& presources, FzBuffer& pcontents) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_write()\n";
	}
	#endif
	auto ret = mupdf::pdf_page_write(*this, mediabox, presources, pcontents);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_parse_array()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_parse_array(const FzStream& f, const PdfLexbuf& buf) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_parse_array()\n";
	}
	#endif
	auto ret = mupdf::pdf_parse_array(*this, f, buf);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_parse_dict()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_parse_dict(const FzStream& f, const PdfLexbuf& buf) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_parse_dict()\n";
	}
	#endif
	auto ret = mupdf::pdf_parse_dict(*this, f, buf);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_parse_ind_obj()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_parse_ind_obj(::fz_stream *f)` => `(pdf_obj *, int num, int gen, int64_t stm_ofs, int try_repair)`
	 */
FZ_FUNCTION PdfObj PdfDocument::pdf_parse_ind_obj(const FzStream& f, int *num, int *gen, int64_t *stm_ofs, int *try_repair) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_parse_ind_obj()\n";
	}
	#endif
	auto ret = mupdf::pdf_parse_ind_obj(*this, f, num, gen, stm_ofs, try_repair);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_parse_journal_obj()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_parse_journal_obj(::fz_stream *stm, ::fz_buffer **ostm)` => `(pdf_obj *, int onum, int newobj)`
	 */
FZ_FUNCTION PdfObj PdfDocument::pdf_parse_journal_obj(const FzStream& stm, int *onum, FzBuffer& ostm, int *newobj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_parse_journal_obj()\n";
	}
	#endif
	auto ret = mupdf::pdf_parse_journal_obj(*this, stm, onum, ostm, newobj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_parse_stm_obj()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_parse_stm_obj(const FzStream& f, const PdfLexbuf& buf) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_parse_stm_obj()\n";
	}
	#endif
	auto ret = mupdf::pdf_parse_stm_obj(*this, f, buf);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_progressive_advance()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_progressive_advance(int pagenum) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_progressive_advance()\n";
	}
	#endif
	auto ret = mupdf::pdf_progressive_advance(*this, pagenum);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_purge_local_font_resources()`.  */
FZ_FUNCTION void PdfDocument::pdf_purge_local_font_resources() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_purge_local_font_resources()\n";
	}
	#endif
	mupdf::pdf_purge_local_font_resources(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_purge_locals_from_store()`.  */
FZ_FUNCTION void PdfDocument::pdf_purge_locals_from_store() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_purge_locals_from_store()\n";
	}
	#endif
	mupdf::pdf_purge_locals_from_store(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_read_journal()`.  */
FZ_FUNCTION void PdfDocument::pdf_read_journal(const FzStream& stm) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_read_journal()\n";
	}
	#endif
	mupdf::pdf_read_journal(*this, stm);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_rearrange_pages()`.  */
FZ_FUNCTION void PdfDocument::pdf_rearrange_pages(int count, const int *pages) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_rearrange_pages()\n";
	}
	#endif
	mupdf::pdf_rearrange_pages(*this, count, pages);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_rearrange_pages2()`.  */
FZ_FUNCTION void PdfDocument::pdf_rearrange_pages2(const std::vector<int> &pages) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_rearrange_pages2()\n";
	}
	#endif
	mupdf::pdf_rearrange_pages2(*this, pages);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_redact_page()`.  */
FZ_FUNCTION int PdfDocument::pdf_redact_page(const PdfPage& page, PdfRedactOptions& opts) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_redact_page()\n";
	}
	#endif
	auto ret = mupdf::pdf_redact_page(*this, page, opts);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_redo()`.  */
FZ_FUNCTION void PdfDocument::pdf_redo() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_redo()\n";
	}
	#endif
	mupdf::pdf_redo(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_repair_obj()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_repair_obj(::pdf_lexbuf *buf, ::pdf_obj **encrypt, ::pdf_obj **id, ::pdf_obj **page, ::pdf_obj **root)` => `(int, int64_t stmofsp, int64_t stmlenp, int64_t tmpofs)`
	 */
FZ_FUNCTION int PdfDocument::pdf_repair_obj(const PdfLexbuf& buf, int64_t *stmofsp, int64_t *stmlenp, PdfObj& encrypt, PdfObj& id, PdfObj& page, int64_t *tmpofs, PdfObj& root) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_repair_obj()\n";
	}
	#endif
	auto ret = mupdf::pdf_repair_obj(*this, buf, stmofsp, stmlenp, encrypt, id, page, tmpofs, root);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_repair_obj_stms()`.  */
FZ_FUNCTION void PdfDocument::pdf_repair_obj_stms() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_repair_obj_stms()\n";
	}
	#endif
	mupdf::pdf_repair_obj_stms(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_repair_trailer()`.  */
FZ_FUNCTION void PdfDocument::pdf_repair_trailer() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_repair_trailer()\n";
	}
	#endif
	mupdf::pdf_repair_trailer(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_repair_xref()`.  */
FZ_FUNCTION void PdfDocument::pdf_repair_xref() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_repair_xref()\n";
	}
	#endif
	mupdf::pdf_repair_xref(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_replace_xref()`.  */
FZ_FUNCTION void PdfDocument::pdf_replace_xref(const PdfXrefEntry& entries, int n) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_replace_xref()\n";
	}
	#endif
	mupdf::pdf_replace_xref(*this, entries, n);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_reset_form()`.  */
FZ_FUNCTION void PdfDocument::pdf_reset_form(const PdfObj& fields, int exclude) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_reset_form()\n";
	}
	#endif
	mupdf::pdf_reset_form(*this, fields, exclude);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_resolve_link()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_resolve_link(const char *uri)` => `(int, float xp, float yp)`
	 */
FZ_FUNCTION int PdfDocument::pdf_resolve_link(const char *uri, float *xp, float *yp) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_resolve_link()\n";
	}
	#endif
	auto ret = mupdf::pdf_resolve_link(*this, uri, xp, yp);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_rewrite_images()`.  */
FZ_FUNCTION void PdfDocument::pdf_rewrite_images(PdfImageRewriterOptions& opts) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_rewrite_images()\n";
	}
	#endif
	mupdf::pdf_rewrite_images(*this, opts);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_run_document_structure()`.  */
FZ_FUNCTION void PdfDocument::pdf_run_document_structure(const FzDevice& dev, FzCookie& cookie) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_document_structure()\n";
	}
	#endif
	mupdf::pdf_run_document_structure(*this, dev, cookie);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_run_glyph()`.  */
FZ_FUNCTION void PdfDocument::pdf_run_glyph(const PdfObj& resources, const FzBuffer& contents, const FzDevice& dev, const FzMatrix& ctm, void *gstate, const FzDefaultColorspaces& default_cs) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_glyph()\n";
	}
	#endif
	mupdf::pdf_run_glyph(*this, resources, contents, dev, ctm, gstate, default_cs);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_save_document()`.  */
FZ_FUNCTION void PdfDocument::pdf_save_document(const char *filename, PdfWriteOptions& opts) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_save_document()\n";
	}
	#endif
	mupdf::pdf_save_document(*this, filename, opts);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_save_journal()`.  */
FZ_FUNCTION void PdfDocument::pdf_save_journal(const char *filename) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_save_journal()\n";
	}
	#endif
	mupdf::pdf_save_journal(*this, filename);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_save_snapshot()`.  */
FZ_FUNCTION void PdfDocument::pdf_save_snapshot(const char *filename) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_save_snapshot()\n";
	}
	#endif
	mupdf::pdf_save_snapshot(*this, filename);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_select_layer_config()`.  */
FZ_FUNCTION void PdfDocument::pdf_select_layer_config(int config_num) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_select_layer_config()\n";
	}
	#endif
	mupdf::pdf_select_layer_config(*this, config_num);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_select_layer_config_ui()`.  */
FZ_FUNCTION void PdfDocument::pdf_select_layer_config_ui(int ui) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_select_layer_config_ui()\n";
	}
	#endif
	mupdf::pdf_select_layer_config_ui(*this, ui);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_serialise_journal()`.  */
FZ_FUNCTION void PdfDocument::pdf_serialise_journal(const FzOutput& out) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_serialise_journal()\n";
	}
	#endif
	mupdf::pdf_serialise_journal(*this, out);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_annot_field_value()`.  */
FZ_FUNCTION int PdfDocument::pdf_set_annot_field_value(const PdfAnnot& widget, const char *text, int ignore_trigger_events) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_field_value()\n";
	}
	#endif
	auto ret = mupdf::pdf_set_annot_field_value(*this, widget, text, ignore_trigger_events);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_set_doc_event_callback()`.  */
FZ_FUNCTION void PdfDocument::pdf_set_doc_event_callback(::pdf_doc_event_cb *event_cb, ::pdf_free_doc_event_data_cb *free_event_data_cb, void *data) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_doc_event_callback()\n";
	}
	#endif
	mupdf::pdf_set_doc_event_callback(*this, event_cb, free_event_data_cb, data);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_document_language()`.  */
FZ_FUNCTION void PdfDocument::pdf_set_document_language(::fz_text_language lang) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_document_language()\n";
	}
	#endif
	mupdf::pdf_set_document_language(*this, lang);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_field_value()`.  */
FZ_FUNCTION int PdfDocument::pdf_set_field_value(const PdfObj& field, const char *text, int ignore_trigger_events) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_field_value()\n";
	}
	#endif
	auto ret = mupdf::pdf_set_field_value(*this, field, text, ignore_trigger_events);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_set_layer_config_as_default()`.  */
FZ_FUNCTION void PdfDocument::pdf_set_layer_config_as_default() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_layer_config_as_default()\n";
	}
	#endif
	mupdf::pdf_set_layer_config_as_default(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_page_labels()`.  */
FZ_FUNCTION void PdfDocument::pdf_set_page_labels(int index, ::pdf_page_label_style style, const char *prefix, int start) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_page_labels()\n";
	}
	#endif
	mupdf::pdf_set_page_labels(*this, index, style, prefix, start);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_populating_xref_trailer()`.  */
FZ_FUNCTION void PdfDocument::pdf_set_populating_xref_trailer(const PdfObj& trailer) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_populating_xref_trailer()\n";
	}
	#endif
	mupdf::pdf_set_populating_xref_trailer(*this, trailer);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_signature_byte_range()`.  */
FZ_FUNCTION int PdfDocument::pdf_signature_byte_range(const PdfObj& signature, const FzRange& byte_range) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_byte_range()\n";
	}
	#endif
	auto ret = mupdf::pdf_signature_byte_range(*this, signature, byte_range);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_signature_contents()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_signature_contents(::pdf_obj *signature)` => `(size_t, char *contents)`
	 */
FZ_FUNCTION size_t PdfDocument::pdf_signature_contents(const PdfObj& signature, char **contents) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_contents()\n";
	}
	#endif
	auto ret = mupdf::pdf_signature_contents(*this, signature, contents);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_signature_hash_bytes()`.  */
FZ_FUNCTION FzStream PdfDocument::pdf_signature_hash_bytes(const PdfObj& signature) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_hash_bytes()\n";
	}
	#endif
	auto ret = mupdf::pdf_signature_hash_bytes(*this, signature);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_signature_incremental_change_since_signing()`.  */
FZ_FUNCTION int PdfDocument::pdf_signature_incremental_change_since_signing(const PdfObj& signature) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_incremental_change_since_signing()\n";
	}
	#endif
	auto ret = mupdf::pdf_signature_incremental_change_since_signing(*this, signature);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_signature_is_signed()`.  */
FZ_FUNCTION int PdfDocument::pdf_signature_is_signed(const PdfObj& field) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_is_signed()\n";
	}
	#endif
	auto ret = mupdf::pdf_signature_is_signed(*this, field);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_signature_set_value()`.  */
FZ_FUNCTION void PdfDocument::pdf_signature_set_value(const PdfObj& field, const PdfPkcs7Signer& signer, int64_t stime) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_set_value()\n";
	}
	#endif
	mupdf::pdf_signature_set_value(*this, field, signer, stime);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_subset_fonts()`.  */
FZ_FUNCTION void PdfDocument::pdf_subset_fonts(int pages_len, const int *pages) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_subset_fonts()\n";
	}
	#endif
	mupdf::pdf_subset_fonts(*this, pages_len, pages);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_subset_fonts2()`.  */
FZ_FUNCTION void PdfDocument::pdf_subset_fonts2(const std::vector<int> &pages) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_subset_fonts2()\n";
	}
	#endif
	mupdf::pdf_subset_fonts2(*this, pages);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_toggle_layer_config_ui()`.  */
FZ_FUNCTION void PdfDocument::pdf_toggle_layer_config_ui(int ui) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_toggle_layer_config_ui()\n";
	}
	#endif
	mupdf::pdf_toggle_layer_config_ui(*this, ui);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_trailer()`.  */
FZ_FUNCTION PdfObj PdfDocument::pdf_trailer() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_trailer()\n";
	}
	#endif
	auto ret = mupdf::pdf_trailer(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_undo()`.  */
FZ_FUNCTION void PdfDocument::pdf_undo() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_undo()\n";
	}
	#endif
	mupdf::pdf_undo(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_undoredo_state()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_undoredo_state()` => `(int, int steps)`
	 */
FZ_FUNCTION int PdfDocument::pdf_undoredo_state(int *steps) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_undoredo_state()\n";
	}
	#endif
	auto ret = mupdf::pdf_undoredo_state(*this, steps);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_undoredo_step()`.  */
FZ_FUNCTION const char *PdfDocument::pdf_undoredo_step(int step) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_undoredo_step()\n";
	}
	#endif
	auto ret = mupdf::pdf_undoredo_step(*this, step);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_update_object()`.  */
FZ_FUNCTION void PdfDocument::pdf_update_object(int num, const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_update_object()\n";
	}
	#endif
	mupdf::pdf_update_object(*this, num, obj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_update_stream()`.  */
FZ_FUNCTION void PdfDocument::pdf_update_stream(const PdfObj& ref, const FzBuffer& buf, int compressed) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_update_stream()\n";
	}
	#endif
	mupdf::pdf_update_stream(*this, ref, buf, compressed);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_update_xobject()`.  */
FZ_FUNCTION void PdfDocument::pdf_update_xobject(const PdfObj& xobj, const FzRect& bbox, const FzMatrix& mat, const PdfObj& res, const FzBuffer& buffer) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_update_xobject()\n";
	}
	#endif
	mupdf::pdf_update_xobject(*this, xobj, bbox, mat, res, buffer);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_validate_change_history()`.  */
FZ_FUNCTION int PdfDocument::pdf_validate_change_history() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_validate_change_history()\n";
	}
	#endif
	auto ret = mupdf::pdf_validate_change_history(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_validate_changes()`.  */
FZ_FUNCTION int PdfDocument::pdf_validate_changes(int version) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_validate_changes()\n";
	}
	#endif
	auto ret = mupdf::pdf_validate_changes(*this, version);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_version()`.  */
FZ_FUNCTION int PdfDocument::pdf_version() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_version()\n";
	}
	#endif
	auto ret = mupdf::pdf_version(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_was_pure_xfa()`.  */
FZ_FUNCTION int PdfDocument::pdf_was_pure_xfa() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_was_pure_xfa()\n";
	}
	#endif
	auto ret = mupdf::pdf_was_pure_xfa(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_was_repaired()`.  */
FZ_FUNCTION int PdfDocument::pdf_was_repaired() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_was_repaired()\n";
	}
	#endif
	auto ret = mupdf::pdf_was_repaired(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_write_document()`.  */
FZ_FUNCTION void PdfDocument::pdf_write_document(const FzOutput& out, PdfWriteOptions& opts) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_write_document()\n";
	}
	#endif
	mupdf::pdf_write_document(*this, out, opts);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_write_journal()`.  */
FZ_FUNCTION void PdfDocument::pdf_write_journal(const FzOutput& out) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_write_journal()\n";
	}
	#endif
	mupdf::pdf_write_journal(*this, out);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_write_snapshot()`.  */
FZ_FUNCTION void PdfDocument::pdf_write_snapshot(const FzOutput& out) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_write_snapshot()\n";
	}
	#endif
	mupdf::pdf_write_snapshot(*this, out);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_xref_ensure_incremental_object()`.  */
FZ_FUNCTION int PdfDocument::pdf_xref_ensure_incremental_object(int num) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xref_ensure_incremental_object()\n";
	}
	#endif
	auto ret = mupdf::pdf_xref_ensure_incremental_object(*this, num);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_xref_ensure_local_object()`.  */
FZ_FUNCTION void PdfDocument::pdf_xref_ensure_local_object(int num) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xref_ensure_local_object()\n";
	}
	#endif
	mupdf::pdf_xref_ensure_local_object(*this, num);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_xref_entry_map()`.  */
FZ_FUNCTION void PdfDocument::pdf_xref_entry_map(void (*fn)(::fz_context *, ::pdf_xref_entry *, int , ::pdf_document *, void *), void *arg) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xref_entry_map()\n";
	}
	#endif
	mupdf::pdf_xref_entry_map(*this, fn, arg);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_xref_is_incremental()`.  */
FZ_FUNCTION int PdfDocument::pdf_xref_is_incremental(int num) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xref_is_incremental()\n";
	}
	#endif
	auto ret = mupdf::pdf_xref_is_incremental(*this, num);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_xref_len()`.  */
FZ_FUNCTION int PdfDocument::pdf_xref_len() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xref_len()\n";
	}
	#endif
	auto ret = mupdf::pdf_xref_len(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_xref_obj_is_unsaved_signature()`.  */
FZ_FUNCTION int PdfDocument::pdf_xref_obj_is_unsaved_signature(const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xref_obj_is_unsaved_signature()\n";
	}
	#endif
	auto ret = mupdf::pdf_xref_obj_is_unsaved_signature(*this, obj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_xref_remove_unsaved_signature()`.  */
FZ_FUNCTION void PdfDocument::pdf_xref_remove_unsaved_signature(const PdfObj& field) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xref_remove_unsaved_signature()\n";
	}
	#endif
	mupdf::pdf_xref_remove_unsaved_signature(*this, field);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_xref_store_unsaved_signature()`.  */
FZ_FUNCTION void PdfDocument::pdf_xref_store_unsaved_signature(const PdfObj& field, const PdfPkcs7Signer& signer) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xref_store_unsaved_signature()\n";
	}
	#endif
	mupdf::pdf_xref_store_unsaved_signature(*this, field, signer);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/** Custom method. */
FZ_FUNCTION FzDocument PdfDocument::super()
{
	return FzDocument( ll_fz_keep_document( &m_internal->super));
}

FZ_FUNCTION PdfDocument::PdfDocument(::pdf_document* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfDocument::~PdfDocument()
{
	ll_pdf_drop_document(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfDocument_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long PdfDocument::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfDocument::s_num_instances = 0;


/* Implementation of methods for PdfEmbeddedFileParams (wrapper for pdf_embedded_file_params). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfEmbeddedFileParams::PdfEmbeddedFileParams()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfEmbeddedFileParams::PdfEmbeddedFileParams(::pdf_embedded_file_params* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfEmbeddedFileParams::~PdfEmbeddedFileParams()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfEmbeddedFileParams::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfEmbeddedFileParams::s_num_instances = 0;


/* Implementation of methods for PdfFilterFactory (wrapper for pdf_filter_factory). */

/** Default constructor, sets each member to default value. */
FZ_FUNCTION PdfFilterFactory::PdfFilterFactory()
{
	this->filter = {};
	this->options = {};
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfFilterFactory::PdfFilterFactory(const ::pdf_filter_factory* internal)
{
	assert( internal);
	this->filter = internal->filter;
	this->options = internal->options;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfFilterFactory::PdfFilterFactory(const ::pdf_filter_factory internal)
{
	this->filter = internal.filter;
	this->options = internal.options;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::pdf_filter_factory`. */
FZ_FUNCTION ::pdf_filter_factory* PdfFilterFactory::internal()
{
	auto ret = (::pdf_filter_factory*) &this->filter;
	return ret;
}

/** Constructor using raw copy of pre-existing `::pdf_filter_factory`. */
FZ_FUNCTION const ::pdf_filter_factory* PdfFilterFactory::internal() const
{
	auto ret = (const ::pdf_filter_factory*) &this->filter;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION PdfFilterFactory::~PdfFilterFactory()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfFilterFactory::s_num_instances = 0;

FZ_FUNCTION std::string PdfFilterFactory::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool PdfFilterFactory::operator==(const PdfFilterFactory& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool PdfFilterFactory::operator!=(const PdfFilterFactory& rhs)
{
	return ::operator!=( *this, rhs);
}

/* Implementation of methods for `PdfFilterFactory2`, virtual_fnptrs wrapper for `pdf_filter_factory`). */


FZ_FUNCTION PdfFilterFactory2::PdfFilterFactory2()
{

	this->options = this;
	
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfFilterFactory2::PdfFilterFactory2(): this=" << this << "\n";
	}
	#endif
}
/* Static callback, calls self->filter(). */
static ::pdf_processor * PdfFilterFactory2_s_filter(::fz_context *arg_0, ::pdf_document *arg_1, ::pdf_processor *arg_2, int arg_3, ::fz_matrix arg_4, ::pdf_filter_options *arg_5, void *arg_6)
{
	PdfFilterFactory2* self = (PdfFilterFactory2*) arg_6;
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfFilterFactory2_s_filter(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->filter(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfFilterFactory2_s_filter(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
FZ_FUNCTION void PdfFilterFactory2::use_virtual_filter( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfFilterFactory2::use_virtual_filter(): this=" << this << " use=" << use << "\n";
	}
	#endif
	PdfFilterFactory::filter = (use) ? PdfFilterFactory2_s_filter : nullptr;
}
/* Default implementation of virtual method. */
FZ_FUNCTION ::pdf_processor * PdfFilterFactory2::filter(::fz_context *arg_0, ::pdf_document *arg_1, ::pdf_processor *arg_2, int arg_3, ::fz_matrix arg_4, ::pdf_filter_options *arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfFilterFactory2::filter(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfFilterFactory2::filter()");
}

/* Implementation of methods for PdfFilterOptions (wrapper for pdf_filter_options). */

/** Custom constructor. */
FZ_FUNCTION PdfFilterOptions::PdfFilterOptions()
{
	this->recurse = 0;
	this->instance_forms = 0;
	this->ascii = 0;
	this->opaque = nullptr;
	this->complete = nullptr;
	this->filters = nullptr;
	pdf_filter_factory eof = { nullptr, nullptr};
	m_filters.push_back( eof);
	this->newlines = 0;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION void PdfFilterOptions::add_factory( const pdf_filter_factory& factory)
{
	this->m_filters.back() = factory;
	pdf_filter_factory eof = { nullptr, nullptr};
	this->m_filters.push_back( eof);
	this->filters = &this->m_filters[0];
}

FZ_FUNCTION PdfFilterOptions::PdfFilterOptions(const ::pdf_filter_options* internal)
{
	assert( internal);
	this->recurse = internal->recurse;
	this->instance_forms = internal->instance_forms;
	this->ascii = internal->ascii;
	this->no_update = internal->no_update;
	this->opaque = internal->opaque;
	this->complete = internal->complete;
	this->filters = internal->filters;
	this->newlines = internal->newlines;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfFilterOptions::PdfFilterOptions(const ::pdf_filter_options internal)
{
	this->recurse = internal.recurse;
	this->instance_forms = internal.instance_forms;
	this->ascii = internal.ascii;
	this->no_update = internal.no_update;
	this->opaque = internal.opaque;
	this->complete = internal.complete;
	this->filters = internal.filters;
	this->newlines = internal.newlines;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::pdf_filter_options`. */
FZ_FUNCTION ::pdf_filter_options* PdfFilterOptions::internal()
{
	auto ret = (::pdf_filter_options*) &this->recurse;
	return ret;
}

/** Constructor using raw copy of pre-existing `::pdf_filter_options`. */
FZ_FUNCTION const ::pdf_filter_options* PdfFilterOptions::internal() const
{
	auto ret = (const ::pdf_filter_options*) &this->recurse;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION PdfFilterOptions::~PdfFilterOptions()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfFilterOptions::s_num_instances = 0;

FZ_FUNCTION std::string PdfFilterOptions::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool PdfFilterOptions::operator==(const PdfFilterOptions& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool PdfFilterOptions::operator!=(const PdfFilterOptions& rhs)
{
	return ::operator!=( *this, rhs);
}

/* Implementation of methods for `PdfFilterOptions2`, virtual_fnptrs wrapper for `pdf_filter_options`). */


FZ_FUNCTION PdfFilterOptions2::PdfFilterOptions2()
{

	this->opaque = this;
	
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfFilterOptions2::PdfFilterOptions2(): this=" << this << "\n";
	}
	#endif
}
/* Static callback, calls self->complete(). */
static void PdfFilterOptions2_s_complete(::fz_context *arg_0, ::fz_buffer *arg_1, void *arg_2)
{
	PdfFilterOptions2* self = (PdfFilterOptions2*) arg_2;
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfFilterOptions2_s_complete(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->complete(arg_0, arg_1);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfFilterOptions2_s_complete(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
FZ_FUNCTION void PdfFilterOptions2::use_virtual_complete( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfFilterOptions2::use_virtual_complete(): this=" << this << " use=" << use << "\n";
	}
	#endif
	PdfFilterOptions::complete = (use) ? PdfFilterOptions2_s_complete : nullptr;
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfFilterOptions2::complete(::fz_context *arg_0, ::fz_buffer *arg_1)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfFilterOptions2::complete(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfFilterOptions2::complete()");
}

/* Implementation of methods for PdfFontDesc (wrapper for pdf_font_desc). */

/* Constructor using `pdf_new_font_desc()`. */
FZ_FUNCTION PdfFontDesc::PdfFontDesc()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_font_desc()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_font_desc();
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Class-aware wrapper for `::pdf_add_hmtx()`.  */
FZ_FUNCTION void PdfFontDesc::pdf_add_hmtx(int lo, int hi, int w) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_hmtx()\n";
	}
	#endif
	mupdf::pdf_add_hmtx(*this, lo, hi, w);
}

/* Class-aware wrapper for `::pdf_add_vmtx()`.  */
FZ_FUNCTION void PdfFontDesc::pdf_add_vmtx(int lo, int hi, int x, int y, int w) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_vmtx()\n";
	}
	#endif
	mupdf::pdf_add_vmtx(*this, lo, hi, x, y, w);
}

/* Class-aware wrapper for `::pdf_end_hmtx()`.  */
FZ_FUNCTION void PdfFontDesc::pdf_end_hmtx() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_end_hmtx()\n";
	}
	#endif
	mupdf::pdf_end_hmtx(*this);
}

/* Class-aware wrapper for `::pdf_end_vmtx()`.  */
FZ_FUNCTION void PdfFontDesc::pdf_end_vmtx() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_end_vmtx()\n";
	}
	#endif
	mupdf::pdf_end_vmtx(*this);
}

/* Class-aware wrapper for `::pdf_font_cid_to_gid()`.  */
FZ_FUNCTION int PdfFontDesc::pdf_font_cid_to_gid(int cid) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_font_cid_to_gid()\n";
	}
	#endif
	auto ret = mupdf::pdf_font_cid_to_gid(*this, cid);
	return ret;
}

/* Class-aware wrapper for `::pdf_set_default_hmtx()`.  */
FZ_FUNCTION void PdfFontDesc::pdf_set_default_hmtx(int w) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_default_hmtx()\n";
	}
	#endif
	mupdf::pdf_set_default_hmtx(*this, w);
}

/* Class-aware wrapper for `::pdf_set_default_vmtx()`.  */
FZ_FUNCTION void PdfFontDesc::pdf_set_default_vmtx(int y, int w) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_default_vmtx()\n";
	}
	#endif
	mupdf::pdf_set_default_vmtx(*this, y, w);
}

/* Class-aware wrapper for `::pdf_set_font_wmode()`.  */
FZ_FUNCTION void PdfFontDesc::pdf_set_font_wmode(int wmode) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_font_wmode()\n";
	}
	#endif
	mupdf::pdf_set_font_wmode(*this, wmode);
}

FZ_FUNCTION PdfFontDesc::PdfFontDesc(::pdf_font_desc* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfFontDesc::~PdfFontDesc()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfFontDesc::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfFontDesc::s_num_instances = 0;


/* Implementation of methods for PdfFontResourceKey (wrapper for pdf_font_resource_key). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfFontResourceKey::PdfFontResourceKey()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfFontResourceKey::PdfFontResourceKey(::pdf_font_resource_key* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfFontResourceKey::~PdfFontResourceKey()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfFontResourceKey::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfFontResourceKey::s_num_instances = 0;


/* Implementation of methods for PdfFunction (wrapper for pdf_function). */

#ifndef NDEBUG
static RefsCheck<::pdf_function, PdfFunction> s_PdfFunction_refs_check(0, 32);
#endif

/** Copy constructor using `pdf_keep_function()`. */
FZ_FUNCTION PdfFunction::PdfFunction(const PdfFunction& rhs)
: m_internal(ll_pdf_keep_function(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_pdf_keep_function(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfFunction_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `pdf_keep_function()` and `pdf_drop_function()`. */
FZ_FUNCTION PdfFunction& PdfFunction::operator=(const PdfFunction& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_pdf_drop_function(this->m_internal)"
				<< " and ll_pdf_keep_function(rhs.m_internal)\n"
				;
	}
	#endif
	ll_pdf_drop_function(this->m_internal);
	ll_pdf_keep_function(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfFunction_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfFunction_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfFunction::PdfFunction()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfFunction_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::pdf_eval_function()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_eval_function(const float *in, int inlen, int outlen)` => float out
	 */
FZ_FUNCTION void PdfFunction::pdf_eval_function(const float *in, int inlen, float *out, int outlen) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_eval_function()\n";
	}
	#endif
	mupdf::pdf_eval_function(*this, in, inlen, out, outlen);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfFunction_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_function_size()`.  */
FZ_FUNCTION size_t PdfFunction::pdf_function_size() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_function_size()\n";
	}
	#endif
	auto ret = mupdf::pdf_function_size(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfFunction_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

FZ_FUNCTION PdfFunction::PdfFunction(::pdf_function* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfFunction_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfFunction::~PdfFunction()
{
	ll_pdf_drop_function(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfFunction_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long PdfFunction::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfFunction::s_num_instances = 0;


/* Implementation of methods for PdfGraftMap (wrapper for pdf_graft_map). */

#ifndef NDEBUG
static RefsCheck<::pdf_graft_map, PdfGraftMap> s_PdfGraftMap_refs_check(0, 32);
#endif

/* Constructor using `pdf_new_graft_map()`. */
FZ_FUNCTION PdfGraftMap::PdfGraftMap(const PdfDocument& dst)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_graft_map()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_graft_map(dst.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfGraftMap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `pdf_keep_graft_map()`. */
FZ_FUNCTION PdfGraftMap::PdfGraftMap(const PdfGraftMap& rhs)
: m_internal(ll_pdf_keep_graft_map(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_pdf_keep_graft_map(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfGraftMap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `pdf_keep_graft_map()` and `pdf_drop_graft_map()`. */
FZ_FUNCTION PdfGraftMap& PdfGraftMap::operator=(const PdfGraftMap& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_pdf_drop_graft_map(this->m_internal)"
				<< " and ll_pdf_keep_graft_map(rhs.m_internal)\n"
				;
	}
	#endif
	ll_pdf_drop_graft_map(this->m_internal);
	ll_pdf_keep_graft_map(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfGraftMap_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfGraftMap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfGraftMap::PdfGraftMap()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfGraftMap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::pdf_graft_mapped_object()`.  */
FZ_FUNCTION PdfObj PdfGraftMap::pdf_graft_mapped_object(const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_graft_mapped_object()\n";
	}
	#endif
	auto ret = mupdf::pdf_graft_mapped_object(*this, obj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfGraftMap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_graft_mapped_page()`.  */
FZ_FUNCTION void PdfGraftMap::pdf_graft_mapped_page(int page_to, const PdfDocument& src, int page_from) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_graft_mapped_page()\n";
	}
	#endif
	mupdf::pdf_graft_mapped_page(*this, page_to, src, page_from);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfGraftMap_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

FZ_FUNCTION PdfGraftMap::PdfGraftMap(::pdf_graft_map* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfGraftMap_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfGraftMap::~PdfGraftMap()
{
	ll_pdf_drop_graft_map(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfGraftMap_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long PdfGraftMap::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfGraftMap::s_num_instances = 0;


/* Implementation of methods for PdfGstate (wrapper for pdf_gstate). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfGstate::PdfGstate()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfGstate::PdfGstate(::pdf_gstate* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfGstate::~PdfGstate()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfGstate::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfGstate::s_num_instances = 0;


/* Implementation of methods for PdfHintPage (wrapper for pdf_hint_page). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfHintPage::PdfHintPage()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfHintPage::PdfHintPage(::pdf_hint_page* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfHintPage::~PdfHintPage()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfHintPage::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfHintPage::s_num_instances = 0;


/* Implementation of methods for PdfHintShared (wrapper for pdf_hint_shared). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfHintShared::PdfHintShared()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfHintShared::PdfHintShared(::pdf_hint_shared* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfHintShared::~PdfHintShared()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfHintShared::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfHintShared::s_num_instances = 0;


/* Implementation of methods for PdfHmtx (wrapper for pdf_hmtx). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfHmtx::PdfHmtx()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfHmtx::PdfHmtx(::pdf_hmtx* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfHmtx::~PdfHmtx()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfHmtx::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfHmtx::s_num_instances = 0;


/* Implementation of methods for PdfImageRewriterOptions (wrapper for pdf_image_rewriter_options). */

/** Default constructor, sets each member to default value. */
FZ_FUNCTION PdfImageRewriterOptions::PdfImageRewriterOptions()
{
	this->color_lossless_image_subsample_method = {};
	this->color_lossy_image_subsample_method = {};
	this->color_lossless_image_subsample_threshold = {};
	this->color_lossless_image_subsample_to = {};
	this->color_lossy_image_subsample_threshold = {};
	this->color_lossy_image_subsample_to = {};
	this->color_lossless_image_recompress_method = {};
	this->color_lossy_image_recompress_method = {};
	this->color_lossy_image_recompress_quality = {};
	this->color_lossless_image_recompress_quality = {};
	this->gray_lossless_image_subsample_method = {};
	this->gray_lossy_image_subsample_method = {};
	this->gray_lossless_image_subsample_threshold = {};
	this->gray_lossless_image_subsample_to = {};
	this->gray_lossy_image_subsample_threshold = {};
	this->gray_lossy_image_subsample_to = {};
	this->gray_lossless_image_recompress_method = {};
	this->gray_lossy_image_recompress_method = {};
	this->gray_lossy_image_recompress_quality = {};
	this->gray_lossless_image_recompress_quality = {};
	this->bitonal_image_subsample_method = {};
	this->bitonal_image_subsample_threshold = {};
	this->bitonal_image_subsample_to = {};
	this->bitonal_image_recompress_method = {};
	this->bitonal_image_recompress_quality = {};
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfImageRewriterOptions::PdfImageRewriterOptions(const ::pdf_image_rewriter_options* internal)
{
	assert( internal);
	this->color_lossless_image_subsample_method = internal->color_lossless_image_subsample_method;
	this->color_lossy_image_subsample_method = internal->color_lossy_image_subsample_method;
	this->color_lossless_image_subsample_threshold = internal->color_lossless_image_subsample_threshold;
	this->color_lossless_image_subsample_to = internal->color_lossless_image_subsample_to;
	this->color_lossy_image_subsample_threshold = internal->color_lossy_image_subsample_threshold;
	this->color_lossy_image_subsample_to = internal->color_lossy_image_subsample_to;
	this->color_lossless_image_recompress_method = internal->color_lossless_image_recompress_method;
	this->color_lossy_image_recompress_method = internal->color_lossy_image_recompress_method;
	this->color_lossy_image_recompress_quality = internal->color_lossy_image_recompress_quality;
	this->color_lossless_image_recompress_quality = internal->color_lossless_image_recompress_quality;
	this->gray_lossless_image_subsample_method = internal->gray_lossless_image_subsample_method;
	this->gray_lossy_image_subsample_method = internal->gray_lossy_image_subsample_method;
	this->gray_lossless_image_subsample_threshold = internal->gray_lossless_image_subsample_threshold;
	this->gray_lossless_image_subsample_to = internal->gray_lossless_image_subsample_to;
	this->gray_lossy_image_subsample_threshold = internal->gray_lossy_image_subsample_threshold;
	this->gray_lossy_image_subsample_to = internal->gray_lossy_image_subsample_to;
	this->gray_lossless_image_recompress_method = internal->gray_lossless_image_recompress_method;
	this->gray_lossy_image_recompress_method = internal->gray_lossy_image_recompress_method;
	this->gray_lossy_image_recompress_quality = internal->gray_lossy_image_recompress_quality;
	this->gray_lossless_image_recompress_quality = internal->gray_lossless_image_recompress_quality;
	this->bitonal_image_subsample_method = internal->bitonal_image_subsample_method;
	this->bitonal_image_subsample_threshold = internal->bitonal_image_subsample_threshold;
	this->bitonal_image_subsample_to = internal->bitonal_image_subsample_to;
	this->bitonal_image_recompress_method = internal->bitonal_image_recompress_method;
	this->bitonal_image_recompress_quality = internal->bitonal_image_recompress_quality;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfImageRewriterOptions::PdfImageRewriterOptions(const ::pdf_image_rewriter_options internal)
{
	this->color_lossless_image_subsample_method = internal.color_lossless_image_subsample_method;
	this->color_lossy_image_subsample_method = internal.color_lossy_image_subsample_method;
	this->color_lossless_image_subsample_threshold = internal.color_lossless_image_subsample_threshold;
	this->color_lossless_image_subsample_to = internal.color_lossless_image_subsample_to;
	this->color_lossy_image_subsample_threshold = internal.color_lossy_image_subsample_threshold;
	this->color_lossy_image_subsample_to = internal.color_lossy_image_subsample_to;
	this->color_lossless_image_recompress_method = internal.color_lossless_image_recompress_method;
	this->color_lossy_image_recompress_method = internal.color_lossy_image_recompress_method;
	this->color_lossy_image_recompress_quality = internal.color_lossy_image_recompress_quality;
	this->color_lossless_image_recompress_quality = internal.color_lossless_image_recompress_quality;
	this->gray_lossless_image_subsample_method = internal.gray_lossless_image_subsample_method;
	this->gray_lossy_image_subsample_method = internal.gray_lossy_image_subsample_method;
	this->gray_lossless_image_subsample_threshold = internal.gray_lossless_image_subsample_threshold;
	this->gray_lossless_image_subsample_to = internal.gray_lossless_image_subsample_to;
	this->gray_lossy_image_subsample_threshold = internal.gray_lossy_image_subsample_threshold;
	this->gray_lossy_image_subsample_to = internal.gray_lossy_image_subsample_to;
	this->gray_lossless_image_recompress_method = internal.gray_lossless_image_recompress_method;
	this->gray_lossy_image_recompress_method = internal.gray_lossy_image_recompress_method;
	this->gray_lossy_image_recompress_quality = internal.gray_lossy_image_recompress_quality;
	this->gray_lossless_image_recompress_quality = internal.gray_lossless_image_recompress_quality;
	this->bitonal_image_subsample_method = internal.bitonal_image_subsample_method;
	this->bitonal_image_subsample_threshold = internal.bitonal_image_subsample_threshold;
	this->bitonal_image_subsample_to = internal.bitonal_image_subsample_to;
	this->bitonal_image_recompress_method = internal.bitonal_image_recompress_method;
	this->bitonal_image_recompress_quality = internal.bitonal_image_recompress_quality;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::pdf_image_rewriter_options`. */
FZ_FUNCTION ::pdf_image_rewriter_options* PdfImageRewriterOptions::internal()
{
	auto ret = (::pdf_image_rewriter_options*) &this->color_lossless_image_subsample_method;
	return ret;
}

/** Constructor using raw copy of pre-existing `::pdf_image_rewriter_options`. */
FZ_FUNCTION const ::pdf_image_rewriter_options* PdfImageRewriterOptions::internal() const
{
	auto ret = (const ::pdf_image_rewriter_options*) &this->color_lossless_image_subsample_method;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION PdfImageRewriterOptions::~PdfImageRewriterOptions()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfImageRewriterOptions::s_num_instances = 0;

FZ_FUNCTION std::string PdfImageRewriterOptions::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool PdfImageRewriterOptions::operator==(const PdfImageRewriterOptions& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool PdfImageRewriterOptions::operator!=(const PdfImageRewriterOptions& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for PdfJournal (wrapper for pdf_journal). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfJournal::PdfJournal()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::pdf_discard_journal()`.  */
FZ_FUNCTION void PdfJournal::pdf_discard_journal() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_discard_journal()\n";
	}
	#endif
	mupdf::pdf_discard_journal(*this);
}

FZ_FUNCTION PdfJournal::PdfJournal(::pdf_journal* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfJournal::~PdfJournal()
{
	ll_pdf_drop_journal(m_internal);
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long PdfJournal::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfJournal::s_num_instances = 0;


/* Implementation of methods for PdfJs (wrapper for pdf_js). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfJs::PdfJs()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::pdf_js_event_init()`.  */
FZ_FUNCTION void PdfJs::pdf_js_event_init(const PdfObj& target, const char *value, int willCommit) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_js_event_init()\n";
	}
	#endif
	mupdf::pdf_js_event_init(*this, target, value, willCommit);
}

/* Class-aware wrapper for `::pdf_js_event_init_keystroke()`.  */
FZ_FUNCTION void PdfJs::pdf_js_event_init_keystroke(const PdfObj& target, const PdfKeystrokeEvent& evt) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_js_event_init_keystroke()\n";
	}
	#endif
	mupdf::pdf_js_event_init_keystroke(*this, target, evt);
}

/* Class-aware wrapper for `::pdf_js_event_result()`.  */
FZ_FUNCTION int PdfJs::pdf_js_event_result() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_js_event_result()\n";
	}
	#endif
	auto ret = mupdf::pdf_js_event_result(*this);
	return ret;
}

/* Class-aware wrapper for `::pdf_js_event_result_keystroke()`.  */
FZ_FUNCTION int PdfJs::pdf_js_event_result_keystroke(const PdfKeystrokeEvent& evt) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_js_event_result_keystroke()\n";
	}
	#endif
	auto ret = mupdf::pdf_js_event_result_keystroke(*this, evt);
	return ret;
}

/* Class-aware wrapper for `::pdf_js_event_result_validate()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_js_event_result_validate()` => `(int, char *newvalue)`
	 */
FZ_FUNCTION int PdfJs::pdf_js_event_result_validate(char **newvalue) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_js_event_result_validate()\n";
	}
	#endif
	auto ret = mupdf::pdf_js_event_result_validate(*this, newvalue);
	return ret;
}

/* Class-aware wrapper for `::pdf_js_event_value()`.  */
FZ_FUNCTION char *PdfJs::pdf_js_event_value() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_js_event_value()\n";
	}
	#endif
	auto ret = mupdf::pdf_js_event_value(*this);
	return ret;
}

/* Class-aware wrapper for `::pdf_js_execute()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_js_execute(const char *name, const char *code)` => char *result
	 */
FZ_FUNCTION void PdfJs::pdf_js_execute(const char *name, const char *code, char **result) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_js_execute()\n";
	}
	#endif
	mupdf::pdf_js_execute(*this, name, code, result);
}

FZ_FUNCTION PdfJs::PdfJs(::pdf_js* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfJs::~PdfJs()
{
	ll_pdf_drop_js(m_internal);
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long PdfJs::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfJs::s_num_instances = 0;


/* Implementation of methods for PdfJsConsole (wrapper for pdf_js_console). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfJsConsole::PdfJsConsole()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfJsConsole::PdfJsConsole(::pdf_js_console* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfJsConsole::~PdfJsConsole()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfJsConsole::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfJsConsole::s_num_instances = 0;


/* Implementation of methods for PdfKeystrokeEvent (wrapper for pdf_keystroke_event). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfKeystrokeEvent::PdfKeystrokeEvent()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfKeystrokeEvent::PdfKeystrokeEvent(::pdf_keystroke_event* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfKeystrokeEvent::~PdfKeystrokeEvent()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfKeystrokeEvent::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfKeystrokeEvent::s_num_instances = 0;


/* Implementation of methods for PdfLaunchUrlEvent (wrapper for pdf_launch_url_event). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfLaunchUrlEvent::PdfLaunchUrlEvent()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfLaunchUrlEvent::PdfLaunchUrlEvent(::pdf_launch_url_event* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfLaunchUrlEvent::~PdfLaunchUrlEvent()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfLaunchUrlEvent::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfLaunchUrlEvent::s_num_instances = 0;


/* Implementation of methods for PdfLayerConfig (wrapper for pdf_layer_config). */

/** Default constructor, sets each member to default value. */
FZ_FUNCTION PdfLayerConfig::PdfLayerConfig()
{
	this->name = {};
	this->creator = {};
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfLayerConfig::PdfLayerConfig(const ::pdf_layer_config* internal)
{
	assert( internal);
	this->name = internal->name;
	this->creator = internal->creator;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfLayerConfig::PdfLayerConfig(const ::pdf_layer_config internal)
{
	this->name = internal.name;
	this->creator = internal.creator;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::pdf_layer_config`. */
FZ_FUNCTION ::pdf_layer_config* PdfLayerConfig::internal()
{
	auto ret = (::pdf_layer_config*) &this->name;
	return ret;
}

/** Constructor using raw copy of pre-existing `::pdf_layer_config`. */
FZ_FUNCTION const ::pdf_layer_config* PdfLayerConfig::internal() const
{
	auto ret = (const ::pdf_layer_config*) &this->name;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION PdfLayerConfig::~PdfLayerConfig()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfLayerConfig::s_num_instances = 0;

FZ_FUNCTION std::string PdfLayerConfig::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool PdfLayerConfig::operator==(const PdfLayerConfig& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool PdfLayerConfig::operator!=(const PdfLayerConfig& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for PdfLayerConfigUi (wrapper for pdf_layer_config_ui). */

/** Custom constructor. */
FZ_FUNCTION PdfLayerConfigUi::PdfLayerConfigUi()
{
	this->text = nullptr;
	this->depth = 0;
	this->type = PDF_LAYER_UI_LABEL;
	this->selected = 0;
	this->locked = 0;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfLayerConfigUi::PdfLayerConfigUi(const ::pdf_layer_config_ui* internal)
{
	assert( internal);
	this->text = internal->text;
	this->depth = internal->depth;
	this->type = internal->type;
	this->selected = internal->selected;
	this->locked = internal->locked;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfLayerConfigUi::PdfLayerConfigUi(const ::pdf_layer_config_ui internal)
{
	this->text = internal.text;
	this->depth = internal.depth;
	this->type = internal.type;
	this->selected = internal.selected;
	this->locked = internal.locked;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::pdf_layer_config_ui`. */
FZ_FUNCTION ::pdf_layer_config_ui* PdfLayerConfigUi::internal()
{
	auto ret = (::pdf_layer_config_ui*) &this->text;
	return ret;
}

/** Constructor using raw copy of pre-existing `::pdf_layer_config_ui`. */
FZ_FUNCTION const ::pdf_layer_config_ui* PdfLayerConfigUi::internal() const
{
	auto ret = (const ::pdf_layer_config_ui*) &this->text;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION PdfLayerConfigUi::~PdfLayerConfigUi()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfLayerConfigUi::s_num_instances = 0;

FZ_FUNCTION std::string PdfLayerConfigUi::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool PdfLayerConfigUi::operator==(const PdfLayerConfigUi& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool PdfLayerConfigUi::operator!=(const PdfLayerConfigUi& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for PdfLexbuf (wrapper for pdf_lexbuf). */

/** Custom constructor. */
FZ_FUNCTION PdfLexbuf::PdfLexbuf(int size)
{
	m_internal = new ::pdf_lexbuf;
	ll_pdf_lexbuf_init(m_internal, size);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfLexbuf::PdfLexbuf()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::pdf_lexbuf_fin()`.  */
FZ_FUNCTION void PdfLexbuf::pdf_lexbuf_fin() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lexbuf_fin()\n";
	}
	#endif
	mupdf::pdf_lexbuf_fin(*this);
}

/* Class-aware wrapper for `::pdf_lexbuf_grow()`.  */
FZ_FUNCTION int PdfLexbuf::pdf_lexbuf_grow() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lexbuf_grow()\n";
	}
	#endif
	auto ret = mupdf::pdf_lexbuf_grow(*this);
	return ret;
}

/* Class-aware wrapper for `::pdf_lexbuf_init()`.  */
FZ_FUNCTION void PdfLexbuf::pdf_lexbuf_init(int size) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lexbuf_init()\n";
	}
	#endif
	mupdf::pdf_lexbuf_init(*this, size);
}

/** Custom destructor. */
FZ_FUNCTION PdfLexbuf::~PdfLexbuf()
{
	ll_pdf_lexbuf_fin(m_internal);
	delete m_internal;
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

FZ_FUNCTION PdfLexbuf::PdfLexbuf(::pdf_lexbuf* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long PdfLexbuf::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfLexbuf::s_num_instances = 0;


/* Implementation of methods for PdfLexbufLarge (wrapper for pdf_lexbuf_large). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfLexbufLarge::PdfLexbufLarge()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfLexbufLarge::PdfLexbufLarge(::pdf_lexbuf_large* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfLexbufLarge::~PdfLexbufLarge()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfLexbufLarge::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfLexbufLarge::s_num_instances = 0;


/* Implementation of methods for PdfLockedFields (wrapper for pdf_locked_fields). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfLockedFields::PdfLockedFields()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::pdf_is_field_locked()`.  */
FZ_FUNCTION int PdfLockedFields::pdf_is_field_locked(const char *name) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_field_locked()\n";
	}
	#endif
	auto ret = mupdf::pdf_is_field_locked(*this, name);
	return ret;
}

FZ_FUNCTION PdfLockedFields::PdfLockedFields(::pdf_locked_fields* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfLockedFields::~PdfLockedFields()
{
	ll_pdf_drop_locked_fields(m_internal);
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long PdfLockedFields::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfLockedFields::s_num_instances = 0;


/* Implementation of methods for PdfMailDocEvent (wrapper for pdf_mail_doc_event). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfMailDocEvent::PdfMailDocEvent()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfMailDocEvent::PdfMailDocEvent(::pdf_mail_doc_event* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfMailDocEvent::~PdfMailDocEvent()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfMailDocEvent::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfMailDocEvent::s_num_instances = 0;


/* Implementation of methods for PdfMarkBits (wrapper for pdf_mark_bits). */

/* Constructor using `pdf_new_mark_bits()`. */
FZ_FUNCTION PdfMarkBits::PdfMarkBits(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_mark_bits()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_mark_bits(doc.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfMarkBits::PdfMarkBits()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::pdf_mark_bits_reset()`.  */
FZ_FUNCTION void PdfMarkBits::pdf_mark_bits_reset() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_mark_bits_reset()\n";
	}
	#endif
	mupdf::pdf_mark_bits_reset(*this);
}

/* Class-aware wrapper for `::pdf_mark_bits_set()`.  */
FZ_FUNCTION int PdfMarkBits::pdf_mark_bits_set(const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_mark_bits_set()\n";
	}
	#endif
	auto ret = mupdf::pdf_mark_bits_set(*this, obj);
	return ret;
}

FZ_FUNCTION PdfMarkBits::PdfMarkBits(::pdf_mark_bits* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfMarkBits::~PdfMarkBits()
{
	ll_pdf_drop_mark_bits(m_internal);
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long PdfMarkBits::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfMarkBits::s_num_instances = 0;


/* Implementation of methods for PdfMarkList (wrapper for pdf_mark_list). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfMarkList::PdfMarkList()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::pdf_mark_list_check()`.  */
FZ_FUNCTION int PdfMarkList::pdf_mark_list_check(const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_mark_list_check()\n";
	}
	#endif
	auto ret = mupdf::pdf_mark_list_check(*this, obj);
	return ret;
}

/* Class-aware wrapper for `::pdf_mark_list_free()`.  */
FZ_FUNCTION void PdfMarkList::pdf_mark_list_free() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_mark_list_free()\n";
	}
	#endif
	mupdf::pdf_mark_list_free(*this);
}

/* Class-aware wrapper for `::pdf_mark_list_init()`.  */
FZ_FUNCTION void PdfMarkList::pdf_mark_list_init() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_mark_list_init()\n";
	}
	#endif
	mupdf::pdf_mark_list_init(*this);
}

/* Class-aware wrapper for `::pdf_mark_list_pop()`.  */
FZ_FUNCTION void PdfMarkList::pdf_mark_list_pop() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_mark_list_pop()\n";
	}
	#endif
	mupdf::pdf_mark_list_pop(*this);
}

/* Class-aware wrapper for `::pdf_mark_list_push()`.  */
FZ_FUNCTION int PdfMarkList::pdf_mark_list_push(const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_mark_list_push()\n";
	}
	#endif
	auto ret = mupdf::pdf_mark_list_push(*this, obj);
	return ret;
}

FZ_FUNCTION PdfMarkList::PdfMarkList(::pdf_mark_list* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfMarkList::~PdfMarkList()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfMarkList::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfMarkList::s_num_instances = 0;


/* Implementation of methods for PdfMrange (wrapper for pdf_mrange). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfMrange::PdfMrange()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfMrange::PdfMrange(::pdf_mrange* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfMrange::~PdfMrange()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfMrange::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfMrange::s_num_instances = 0;


/* Implementation of methods for PdfObj (wrapper for pdf_obj). */

#ifndef NDEBUG
static RefsCheck<::pdf_obj, PdfObj, true /*allow_int_this*/> s_PdfObj_refs_check(0, 16);
#endif

/* Constructor using `pdf_new_action_from_link()`. */
FZ_FUNCTION PdfObj::PdfObj(const PdfDocument& doc, const char *uri)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_action_from_link()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_action_from_link(doc.m_internal, uri);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_array()`. */
FZ_FUNCTION PdfObj::PdfObj(const PdfDocument& doc, int initialcap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_array()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_array(doc.m_internal, initialcap);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_date()`. */
FZ_FUNCTION PdfObj::PdfObj(const PdfDocument& doc, int64_t time)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_date()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_date(doc.m_internal, time);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_dest_from_link()`. */
FZ_FUNCTION PdfObj::PdfObj(const PdfDocument& doc, const char *uri, int is_remote)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_dest_from_link()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_dest_from_link(doc.m_internal, uri, is_remote);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_indirect()`. */
FZ_FUNCTION PdfObj::PdfObj(const PdfDocument& doc, int num, int gen)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_indirect()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_indirect(doc.m_internal, num, gen);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_int()`. */
FZ_FUNCTION PdfObj::PdfObj(int64_t i)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_int()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_int(i);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_matrix()`. */
FZ_FUNCTION PdfObj::PdfObj(const PdfDocument& doc, const FzMatrix& mtx)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_matrix()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_matrix(doc.m_internal, * mtx.internal());
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_name()`. */
FZ_FUNCTION PdfObj::PdfObj(const char *str)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_name()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_name(str);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_real()`. */
FZ_FUNCTION PdfObj::PdfObj(float f)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_real()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_real(f);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_rect()`. */
FZ_FUNCTION PdfObj::PdfObj(const PdfDocument& doc, const FzRect& rect)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_rect()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_rect(doc.m_internal, * rect.internal());
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_string()`. */
FZ_FUNCTION PdfObj::PdfObj(const char *str, size_t len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_string()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_string(str, len);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_xobject()`. */
FZ_FUNCTION PdfObj::PdfObj(const PdfDocument& doc, const FzRect& bbox, const FzMatrix& matrix, const PdfObj& res, const FzBuffer& buffer)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_xobject()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_xobject(doc.m_internal, * bbox.internal(), * matrix.internal(), res.m_internal, buffer.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `pdf_keep_obj()`. */
FZ_FUNCTION PdfObj::PdfObj(const PdfObj& rhs)
: m_internal(ll_pdf_keep_obj(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_pdf_keep_obj(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `pdf_keep_obj()` and `pdf_drop_obj()`. */
FZ_FUNCTION PdfObj& PdfObj::operator=(const PdfObj& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_pdf_drop_obj(this->m_internal)"
				<< " and ll_pdf_keep_obj(rhs.m_internal)\n"
				;
	}
	#endif
	ll_pdf_drop_obj(this->m_internal);
	ll_pdf_keep_obj(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/* Class-aware wrapper for `::pdf_new_text_string()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_new_text_string(const char *s)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_text_string()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_text_string(s);
	return ret;
}

/* Class-aware wrapper for `::pdf_new_dict()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_new_dict(const PdfDocument& doc, int initialcap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_dict()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_dict(doc, initialcap);
	return ret;
}

/* Class-aware wrapper for `::pdf_array_contains()`.  */
FZ_FUNCTION int PdfObj::pdf_array_contains(const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_contains()\n";
	}
	#endif
	auto ret = mupdf::pdf_array_contains(*this, obj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_array_delete()`.  */
FZ_FUNCTION void PdfObj::pdf_array_delete(int index) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_delete()\n";
	}
	#endif
	mupdf::pdf_array_delete(*this, index);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_array_find()`.  */
FZ_FUNCTION int PdfObj::pdf_array_find(const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_find()\n";
	}
	#endif
	auto ret = mupdf::pdf_array_find(*this, obj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_array_get()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_array_get(int i) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_get()\n";
	}
	#endif
	auto ret = mupdf::pdf_array_get(*this, i);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_array_get_bool()`.  */
FZ_FUNCTION int PdfObj::pdf_array_get_bool(int index) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_get_bool()\n";
	}
	#endif
	auto ret = mupdf::pdf_array_get_bool(*this, index);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_array_get_int()`.  */
FZ_FUNCTION int PdfObj::pdf_array_get_int(int index) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_get_int()\n";
	}
	#endif
	auto ret = mupdf::pdf_array_get_int(*this, index);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_array_get_matrix()`.  */
FZ_FUNCTION FzMatrix PdfObj::pdf_array_get_matrix(int index) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_get_matrix()\n";
	}
	#endif
	auto ret = mupdf::pdf_array_get_matrix(*this, index);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_array_get_name()`.  */
FZ_FUNCTION const char *PdfObj::pdf_array_get_name(int index) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_get_name()\n";
	}
	#endif
	auto ret = mupdf::pdf_array_get_name(*this, index);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_array_get_real()`.  */
FZ_FUNCTION float PdfObj::pdf_array_get_real(int index) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_get_real()\n";
	}
	#endif
	auto ret = mupdf::pdf_array_get_real(*this, index);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_array_get_rect()`.  */
FZ_FUNCTION FzRect PdfObj::pdf_array_get_rect(int index) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_get_rect()\n";
	}
	#endif
	auto ret = mupdf::pdf_array_get_rect(*this, index);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_array_get_string()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_array_get_string(int index)` => `(const char *, size_t sizep)`
	 */
FZ_FUNCTION const char *PdfObj::pdf_array_get_string(int index, size_t *sizep) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_get_string()\n";
	}
	#endif
	auto ret = mupdf::pdf_array_get_string(*this, index, sizep);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_array_get_text_string()`.  */
FZ_FUNCTION const char *PdfObj::pdf_array_get_text_string(int index) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_get_text_string()\n";
	}
	#endif
	auto ret = mupdf::pdf_array_get_text_string(*this, index);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_array_insert()`.  */
FZ_FUNCTION void PdfObj::pdf_array_insert(const PdfObj& obj, int index) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_insert()\n";
	}
	#endif
	mupdf::pdf_array_insert(*this, obj, index);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_array_len()`.  */
FZ_FUNCTION int PdfObj::pdf_array_len() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_len()\n";
	}
	#endif
	auto ret = mupdf::pdf_array_len(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_array_push()`.  */
FZ_FUNCTION void PdfObj::pdf_array_push(const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_push()\n";
	}
	#endif
	mupdf::pdf_array_push(*this, obj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_array_push_array()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_array_push_array(int initial) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_push_array()\n";
	}
	#endif
	auto ret = mupdf::pdf_array_push_array(*this, initial);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_array_push_bool()`.  */
FZ_FUNCTION void PdfObj::pdf_array_push_bool(int x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_push_bool()\n";
	}
	#endif
	mupdf::pdf_array_push_bool(*this, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_array_push_dict()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_array_push_dict(int initial) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_push_dict()\n";
	}
	#endif
	auto ret = mupdf::pdf_array_push_dict(*this, initial);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_array_push_int()`.  */
FZ_FUNCTION void PdfObj::pdf_array_push_int(int64_t x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_push_int()\n";
	}
	#endif
	mupdf::pdf_array_push_int(*this, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_array_push_name()`.  */
FZ_FUNCTION void PdfObj::pdf_array_push_name(const char *x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_push_name()\n";
	}
	#endif
	mupdf::pdf_array_push_name(*this, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_array_push_real()`.  */
FZ_FUNCTION void PdfObj::pdf_array_push_real(double x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_push_real()\n";
	}
	#endif
	mupdf::pdf_array_push_real(*this, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_array_push_string()`.  */
FZ_FUNCTION void PdfObj::pdf_array_push_string(const char *x, size_t n) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_push_string()\n";
	}
	#endif
	mupdf::pdf_array_push_string(*this, x, n);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_array_push_text_string()`.  */
FZ_FUNCTION void PdfObj::pdf_array_push_text_string(const char *x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_push_text_string()\n";
	}
	#endif
	mupdf::pdf_array_push_text_string(*this, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_array_put()`.  */
FZ_FUNCTION void PdfObj::pdf_array_put(int i, const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_put()\n";
	}
	#endif
	mupdf::pdf_array_put(*this, i, obj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_array_put_array()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_array_put_array(int i, int initial) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_put_array()\n";
	}
	#endif
	auto ret = mupdf::pdf_array_put_array(*this, i, initial);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_array_put_bool()`.  */
FZ_FUNCTION void PdfObj::pdf_array_put_bool(int i, int x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_put_bool()\n";
	}
	#endif
	mupdf::pdf_array_put_bool(*this, i, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_array_put_dict()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_array_put_dict(int i, int initial) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_put_dict()\n";
	}
	#endif
	auto ret = mupdf::pdf_array_put_dict(*this, i, initial);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_array_put_int()`.  */
FZ_FUNCTION void PdfObj::pdf_array_put_int(int i, int64_t x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_put_int()\n";
	}
	#endif
	mupdf::pdf_array_put_int(*this, i, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_array_put_name()`.  */
FZ_FUNCTION void PdfObj::pdf_array_put_name(int i, const char *x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_put_name()\n";
	}
	#endif
	mupdf::pdf_array_put_name(*this, i, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_array_put_real()`.  */
FZ_FUNCTION void PdfObj::pdf_array_put_real(int i, double x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_put_real()\n";
	}
	#endif
	mupdf::pdf_array_put_real(*this, i, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_array_put_string()`.  */
FZ_FUNCTION void PdfObj::pdf_array_put_string(int i, const char *x, size_t n) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_put_string()\n";
	}
	#endif
	mupdf::pdf_array_put_string(*this, i, x, n);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_array_put_text_string()`.  */
FZ_FUNCTION void PdfObj::pdf_array_put_text_string(int i, const char *x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_put_text_string()\n";
	}
	#endif
	mupdf::pdf_array_put_text_string(*this, i, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_button_field_on_state()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_button_field_on_state() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_button_field_on_state()\n";
	}
	#endif
	auto ret = mupdf::pdf_button_field_on_state(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_choice_field_option()`.  */
FZ_FUNCTION const char *PdfObj::pdf_choice_field_option(int exportval, int i) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_choice_field_option()\n";
	}
	#endif
	auto ret = mupdf::pdf_choice_field_option(*this, exportval, i);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_choice_field_option_count()`.  */
FZ_FUNCTION int PdfObj::pdf_choice_field_option_count() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_choice_field_option_count()\n";
	}
	#endif
	auto ret = mupdf::pdf_choice_field_option_count(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_clean_obj()`.  */
FZ_FUNCTION void PdfObj::pdf_clean_obj() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_clean_obj()\n";
	}
	#endif
	mupdf::pdf_clean_obj(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_copy_array()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_copy_array() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_copy_array()\n";
	}
	#endif
	auto ret = mupdf::pdf_copy_array(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_copy_dict()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_copy_dict() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_copy_dict()\n";
	}
	#endif
	auto ret = mupdf::pdf_copy_dict(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_debug_obj()`.  */
FZ_FUNCTION void PdfObj::pdf_debug_obj() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_debug_obj()\n";
	}
	#endif
	mupdf::pdf_debug_obj(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_debug_ref()`.  */
FZ_FUNCTION void PdfObj::pdf_debug_ref() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_debug_ref()\n";
	}
	#endif
	mupdf::pdf_debug_ref(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_deep_copy_obj()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_deep_copy_obj() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_deep_copy_obj()\n";
	}
	#endif
	auto ret = mupdf::pdf_deep_copy_obj(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_del()`.  */
FZ_FUNCTION void PdfObj::pdf_dict_del(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_del()\n";
	}
	#endif
	mupdf::pdf_dict_del(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_dict_dels()`.  */
FZ_FUNCTION void PdfObj::pdf_dict_dels(const char *key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_dels()\n";
	}
	#endif
	mupdf::pdf_dict_dels(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_dict_get()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_dict_get(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_bool()`.  */
FZ_FUNCTION int PdfObj::pdf_dict_get_bool(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_bool()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_bool(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_bool_default()`.  */
FZ_FUNCTION int PdfObj::pdf_dict_get_bool_default(const PdfObj& key, int def) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_bool_default()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_bool_default(*this, key, def);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_date()`.  */
FZ_FUNCTION int64_t PdfObj::pdf_dict_get_date(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_date()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_date(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_inheritable()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_dict_get_inheritable(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_inheritable(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_inheritable_bool()`.  */
FZ_FUNCTION int PdfObj::pdf_dict_get_inheritable_bool(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable_bool()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_inheritable_bool(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_inheritable_date()`.  */
FZ_FUNCTION int64_t PdfObj::pdf_dict_get_inheritable_date(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable_date()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_inheritable_date(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_inheritable_int()`.  */
FZ_FUNCTION int PdfObj::pdf_dict_get_inheritable_int(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable_int()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_inheritable_int(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_inheritable_int64()`.  */
FZ_FUNCTION int64_t PdfObj::pdf_dict_get_inheritable_int64(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable_int64()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_inheritable_int64(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_inheritable_matrix()`.  */
FZ_FUNCTION FzMatrix PdfObj::pdf_dict_get_inheritable_matrix(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable_matrix()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_inheritable_matrix(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_inheritable_name()`.  */
FZ_FUNCTION const char *PdfObj::pdf_dict_get_inheritable_name(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable_name()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_inheritable_name(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_inheritable_real()`.  */
FZ_FUNCTION float PdfObj::pdf_dict_get_inheritable_real(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable_real()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_inheritable_real(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_inheritable_rect()`.  */
FZ_FUNCTION FzRect PdfObj::pdf_dict_get_inheritable_rect(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable_rect()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_inheritable_rect(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_inheritable_string()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_dict_get_inheritable_string(::pdf_obj *key)` => `(const char *, size_t sizep)`
	 */
FZ_FUNCTION const char *PdfObj::pdf_dict_get_inheritable_string(const PdfObj& key, size_t *sizep) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable_string()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_inheritable_string(*this, key, sizep);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_inheritable_text_string()`.  */
FZ_FUNCTION const char *PdfObj::pdf_dict_get_inheritable_text_string(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable_text_string()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_inheritable_text_string(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_int()`.  */
FZ_FUNCTION int PdfObj::pdf_dict_get_int(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_int()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_int(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_int64()`.  */
FZ_FUNCTION int64_t PdfObj::pdf_dict_get_int64(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_int64()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_int64(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_int_default()`.  */
FZ_FUNCTION int PdfObj::pdf_dict_get_int_default(const PdfObj& key, int def) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_int_default()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_int_default(*this, key, def);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_key()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_dict_get_key(int idx) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_key()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_key(*this, idx);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_matrix()`.  */
FZ_FUNCTION FzMatrix PdfObj::pdf_dict_get_matrix(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_matrix()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_matrix(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_name()`.  */
FZ_FUNCTION const char *PdfObj::pdf_dict_get_name(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_name()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_name(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_real()`.  */
FZ_FUNCTION float PdfObj::pdf_dict_get_real(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_real()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_real(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_real_default()`.  */
FZ_FUNCTION float PdfObj::pdf_dict_get_real_default(const PdfObj& key, float def) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_real_default()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_real_default(*this, key, def);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_rect()`.  */
FZ_FUNCTION FzRect PdfObj::pdf_dict_get_rect(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_rect()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_rect(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_string()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_dict_get_string(::pdf_obj *key)` => `(const char *, size_t sizep)`
	 */
FZ_FUNCTION const char *PdfObj::pdf_dict_get_string(const PdfObj& key, size_t *sizep) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_string()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_string(*this, key, sizep);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_text_string()`.  */
FZ_FUNCTION const char *PdfObj::pdf_dict_get_text_string(const PdfObj& key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_text_string()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_text_string(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_get_val()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_dict_get_val(int idx) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_val()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_get_val(*this, idx);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_geta()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_dict_geta(const PdfObj& key, const PdfObj& abbrev) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_geta()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_geta(*this, key, abbrev);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_getp()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_dict_getp(const char *path) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_getp()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_getp(*this, path);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_getp_inheritable()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_dict_getp_inheritable(const char *path) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_getp_inheritable()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_getp_inheritable(*this, path);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_gets()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_dict_gets(const char *key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_gets()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_gets(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_gets_inheritable()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_dict_gets_inheritable(const char *key) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_gets_inheritable()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_gets_inheritable(*this, key);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_getsa()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_dict_getsa(const char *key, const char *abbrev) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_getsa()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_getsa(*this, key, abbrev);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_len()`.  */
FZ_FUNCTION int PdfObj::pdf_dict_len() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_len()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_len(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_put()`.  */
FZ_FUNCTION void PdfObj::pdf_dict_put(const PdfObj& key, const PdfObj& val) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put()\n";
	}
	#endif
	mupdf::pdf_dict_put(*this, key, val);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_dict_put_array()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_dict_put_array(const PdfObj& key, int initial) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_array()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_put_array(*this, key, initial);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_put_bool()`.  */
FZ_FUNCTION void PdfObj::pdf_dict_put_bool(const PdfObj& key, int x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_bool()\n";
	}
	#endif
	mupdf::pdf_dict_put_bool(*this, key, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_dict_put_date()`.  */
FZ_FUNCTION void PdfObj::pdf_dict_put_date(const PdfObj& key, int64_t time) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_date()\n";
	}
	#endif
	mupdf::pdf_dict_put_date(*this, key, time);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_dict_put_dict()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_dict_put_dict(const PdfObj& key, int initial) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_dict()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_put_dict(*this, key, initial);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dict_put_int()`.  */
FZ_FUNCTION void PdfObj::pdf_dict_put_int(const PdfObj& key, int64_t x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_int()\n";
	}
	#endif
	mupdf::pdf_dict_put_int(*this, key, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_dict_put_matrix()`.  */
FZ_FUNCTION void PdfObj::pdf_dict_put_matrix(const PdfObj& key, const FzMatrix& x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_matrix()\n";
	}
	#endif
	mupdf::pdf_dict_put_matrix(*this, key, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_dict_put_name()`.  */
FZ_FUNCTION void PdfObj::pdf_dict_put_name(const PdfObj& key, const char *x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_name()\n";
	}
	#endif
	mupdf::pdf_dict_put_name(*this, key, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_dict_put_real()`.  */
FZ_FUNCTION void PdfObj::pdf_dict_put_real(const PdfObj& key, double x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_real()\n";
	}
	#endif
	mupdf::pdf_dict_put_real(*this, key, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_dict_put_rect()`.  */
FZ_FUNCTION void PdfObj::pdf_dict_put_rect(const PdfObj& key, const FzRect& x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_rect()\n";
	}
	#endif
	mupdf::pdf_dict_put_rect(*this, key, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_dict_put_string()`.  */
FZ_FUNCTION void PdfObj::pdf_dict_put_string(const PdfObj& key, const char *x, size_t n) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_string()\n";
	}
	#endif
	mupdf::pdf_dict_put_string(*this, key, x, n);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_dict_put_text_string()`.  */
FZ_FUNCTION void PdfObj::pdf_dict_put_text_string(const PdfObj& key, const char *x) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_text_string()\n";
	}
	#endif
	mupdf::pdf_dict_put_text_string(*this, key, x);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_dict_put_val_null()`.  */
FZ_FUNCTION void PdfObj::pdf_dict_put_val_null(int idx) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_val_null()\n";
	}
	#endif
	mupdf::pdf_dict_put_val_null(*this, idx);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_dict_putp()`.  */
FZ_FUNCTION void PdfObj::pdf_dict_putp(const char *path, const PdfObj& val) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_putp()\n";
	}
	#endif
	mupdf::pdf_dict_putp(*this, path, val);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_dict_puts()`.  */
FZ_FUNCTION void PdfObj::pdf_dict_puts(const char *key, const PdfObj& val) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_puts()\n";
	}
	#endif
	mupdf::pdf_dict_puts(*this, key, val);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_dict_puts_dict()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_dict_puts_dict(const char *key, int initial) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_puts_dict()\n";
	}
	#endif
	auto ret = mupdf::pdf_dict_puts_dict(*this, key, initial);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_dirty_obj()`.  */
FZ_FUNCTION void PdfObj::pdf_dirty_obj() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dirty_obj()\n";
	}
	#endif
	mupdf::pdf_dirty_obj(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_field_border_style()`.  */
FZ_FUNCTION char *PdfObj::pdf_field_border_style() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_border_style()\n";
	}
	#endif
	auto ret = mupdf::pdf_field_border_style(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_field_display()`.  */
FZ_FUNCTION int PdfObj::pdf_field_display() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_display()\n";
	}
	#endif
	auto ret = mupdf::pdf_field_display(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_field_flags()`.  */
FZ_FUNCTION int PdfObj::pdf_field_flags() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_flags()\n";
	}
	#endif
	auto ret = mupdf::pdf_field_flags(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_field_label()`.  */
FZ_FUNCTION const char *PdfObj::pdf_field_label() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_label()\n";
	}
	#endif
	auto ret = mupdf::pdf_field_label(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_field_set_border_style()`.  */
FZ_FUNCTION void PdfObj::pdf_field_set_border_style(const char *text) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_set_border_style()\n";
	}
	#endif
	mupdf::pdf_field_set_border_style(*this, text);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_field_set_button_caption()`.  */
FZ_FUNCTION void PdfObj::pdf_field_set_button_caption(const char *text) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_set_button_caption()\n";
	}
	#endif
	mupdf::pdf_field_set_button_caption(*this, text);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_field_set_display()`.  */
FZ_FUNCTION void PdfObj::pdf_field_set_display(int d) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_set_display()\n";
	}
	#endif
	mupdf::pdf_field_set_display(*this, d);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_field_set_fill_color()`.  */
FZ_FUNCTION void PdfObj::pdf_field_set_fill_color(const PdfObj& col) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_set_fill_color()\n";
	}
	#endif
	mupdf::pdf_field_set_fill_color(*this, col);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_field_set_text_color()`.  */
FZ_FUNCTION void PdfObj::pdf_field_set_text_color(const PdfObj& col) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_set_text_color()\n";
	}
	#endif
	mupdf::pdf_field_set_text_color(*this, col);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_field_type()`.  */
FZ_FUNCTION int PdfObj::pdf_field_type() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_type()\n";
	}
	#endif
	auto ret = mupdf::pdf_field_type(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_field_type_string()`.  */
FZ_FUNCTION const char *PdfObj::pdf_field_type_string() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_type_string()\n";
	}
	#endif
	auto ret = mupdf::pdf_field_type_string(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_field_value()`.  */
FZ_FUNCTION const char *PdfObj::pdf_field_value() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_value()\n";
	}
	#endif
	auto ret = mupdf::pdf_field_value(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_filter_xobject_instance()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_filter_xobject_instance(const PdfObj& page_res, const FzMatrix& ctm, PdfFilterOptions& options, const PdfCycleList& cycle_up) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_filter_xobject_instance()\n";
	}
	#endif
	auto ret = mupdf::pdf_filter_xobject_instance(*this, page_res, ctm, options, cycle_up);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_flatten_inheritable_page_items()`.  */
FZ_FUNCTION void PdfObj::pdf_flatten_inheritable_page_items() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_flatten_inheritable_page_items()\n";
	}
	#endif
	mupdf::pdf_flatten_inheritable_page_items(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_get_bound_document()`.  */
FZ_FUNCTION PdfDocument PdfObj::pdf_get_bound_document() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_get_bound_document()\n";
	}
	#endif
	auto ret = mupdf::pdf_get_bound_document(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_get_embedded_file_params()`.  */
FZ_FUNCTION void PdfObj::pdf_get_embedded_file_params(const PdfEmbeddedFileParams& out) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_get_embedded_file_params()\n";
	}
	#endif
	mupdf::pdf_get_embedded_file_params(*this, out);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_get_indirect_document()`.  */
FZ_FUNCTION PdfDocument PdfObj::pdf_get_indirect_document() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_get_indirect_document()\n";
	}
	#endif
	auto ret = mupdf::pdf_get_indirect_document(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_intent_from_name()`.  */
FZ_FUNCTION enum pdf_intent PdfObj::pdf_intent_from_name() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_intent_from_name()\n";
	}
	#endif
	auto ret = mupdf::pdf_intent_from_name(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_is_array()`.  */
FZ_FUNCTION int PdfObj::pdf_is_array() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_array()\n";
	}
	#endif
	auto ret = mupdf::pdf_is_array(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_is_bool()`.  */
FZ_FUNCTION int PdfObj::pdf_is_bool() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_bool()\n";
	}
	#endif
	auto ret = mupdf::pdf_is_bool(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_is_dict()`.  */
FZ_FUNCTION int PdfObj::pdf_is_dict() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_dict()\n";
	}
	#endif
	auto ret = mupdf::pdf_is_dict(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_is_embedded_file()`.  */
FZ_FUNCTION int PdfObj::pdf_is_embedded_file() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_embedded_file()\n";
	}
	#endif
	auto ret = mupdf::pdf_is_embedded_file(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_is_indirect()`.  */
FZ_FUNCTION int PdfObj::pdf_is_indirect() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_indirect()\n";
	}
	#endif
	auto ret = mupdf::pdf_is_indirect(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_is_int()`.  */
FZ_FUNCTION int PdfObj::pdf_is_int() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_int()\n";
	}
	#endif
	auto ret = mupdf::pdf_is_int(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_is_jpx_image()`.  */
FZ_FUNCTION int PdfObj::pdf_is_jpx_image() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_jpx_image()\n";
	}
	#endif
	auto ret = mupdf::pdf_is_jpx_image(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_is_name()`.  */
FZ_FUNCTION int PdfObj::pdf_is_name() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_name()\n";
	}
	#endif
	auto ret = mupdf::pdf_is_name(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_is_null()`.  */
FZ_FUNCTION int PdfObj::pdf_is_null() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_null()\n";
	}
	#endif
	auto ret = mupdf::pdf_is_null(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_is_number()`.  */
FZ_FUNCTION int PdfObj::pdf_is_number() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_number()\n";
	}
	#endif
	auto ret = mupdf::pdf_is_number(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_is_real()`.  */
FZ_FUNCTION int PdfObj::pdf_is_real() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_real()\n";
	}
	#endif
	auto ret = mupdf::pdf_is_real(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_is_stream()`.  */
FZ_FUNCTION int PdfObj::pdf_is_stream() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_stream()\n";
	}
	#endif
	auto ret = mupdf::pdf_is_stream(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_is_string()`.  */
FZ_FUNCTION int PdfObj::pdf_is_string() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_string()\n";
	}
	#endif
	auto ret = mupdf::pdf_is_string(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_line_ending_from_name()`.  */
FZ_FUNCTION enum pdf_line_ending PdfObj::pdf_line_ending_from_name() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_line_ending_from_name()\n";
	}
	#endif
	auto ret = mupdf::pdf_line_ending_from_name(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_colorspace()`.  */
FZ_FUNCTION FzColorspace PdfObj::pdf_load_colorspace() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_colorspace()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_colorspace(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_embedded_file_contents()`.  */
FZ_FUNCTION FzBuffer PdfObj::pdf_load_embedded_file_contents() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_embedded_file_contents()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_embedded_file_contents(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_field_name()`.  */
FZ_FUNCTION char *PdfObj::pdf_load_field_name() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_field_name()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_field_name(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_function()`.  */
FZ_FUNCTION PdfFunction PdfObj::pdf_load_function(int in, int out) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_function()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_function(*this, in, out);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_raw_stream()`.  */
FZ_FUNCTION FzBuffer PdfObj::pdf_load_raw_stream() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_raw_stream()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_raw_stream(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_stream()`.  */
FZ_FUNCTION FzBuffer PdfObj::pdf_load_stream() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_stream()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_stream(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_stream_or_string_as_utf8()`.  */
FZ_FUNCTION char *PdfObj::pdf_load_stream_or_string_as_utf8() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_stream_or_string_as_utf8()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_stream_or_string_as_utf8(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_lookup_field()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_lookup_field(const char *name) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_field()\n";
	}
	#endif
	auto ret = mupdf::pdf_lookup_field(*this, name);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_lookup_number()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_lookup_number(int needle) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_number()\n";
	}
	#endif
	auto ret = mupdf::pdf_lookup_number(*this, needle);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_mark_obj()`.  */
FZ_FUNCTION int PdfObj::pdf_mark_obj() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_mark_obj()\n";
	}
	#endif
	auto ret = mupdf::pdf_mark_obj(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_name_eq()`.  */
FZ_FUNCTION int PdfObj::pdf_name_eq(const PdfObj& b) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_name_eq()\n";
	}
	#endif
	auto ret = mupdf::pdf_name_eq(*this, b);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_utf8_from_pdf_stream_obj()`.  */
FZ_FUNCTION char *PdfObj::pdf_new_utf8_from_pdf_stream_obj() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_utf8_from_pdf_stream_obj()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_utf8_from_pdf_stream_obj(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_utf8_from_pdf_string_obj()`.  */
FZ_FUNCTION char *PdfObj::pdf_new_utf8_from_pdf_string_obj() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_utf8_from_pdf_string_obj()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_utf8_from_pdf_string_obj(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_obj_is_dirty()`.  */
FZ_FUNCTION int PdfObj::pdf_obj_is_dirty() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_obj_is_dirty()\n";
	}
	#endif
	auto ret = mupdf::pdf_obj_is_dirty(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_obj_is_incremental()`.  */
FZ_FUNCTION int PdfObj::pdf_obj_is_incremental() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_obj_is_incremental()\n";
	}
	#endif
	auto ret = mupdf::pdf_obj_is_incremental(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_obj_marked()`.  */
FZ_FUNCTION int PdfObj::pdf_obj_marked() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_obj_marked()\n";
	}
	#endif
	auto ret = mupdf::pdf_obj_marked(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_obj_memo()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_obj_memo(int bit)` => `(int, int memo)`
	 */
FZ_FUNCTION int PdfObj::pdf_obj_memo(int bit, int *memo) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_obj_memo()\n";
	}
	#endif
	auto ret = mupdf::pdf_obj_memo(*this, bit, memo);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_obj_parent_num()`.  */
FZ_FUNCTION int PdfObj::pdf_obj_parent_num() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_obj_parent_num()\n";
	}
	#endif
	auto ret = mupdf::pdf_obj_parent_num(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_obj_refs()`.  */
FZ_FUNCTION int PdfObj::pdf_obj_refs() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_obj_refs()\n";
	}
	#endif
	auto ret = mupdf::pdf_obj_refs(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_objcmp()`.  */
FZ_FUNCTION int PdfObj::pdf_objcmp(const PdfObj& b) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_objcmp()\n";
	}
	#endif
	auto ret = mupdf::pdf_objcmp(*this, b);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_objcmp_deep()`.  */
FZ_FUNCTION int PdfObj::pdf_objcmp_deep(const PdfObj& b) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_objcmp_deep()\n";
	}
	#endif
	auto ret = mupdf::pdf_objcmp_deep(*this, b);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_objcmp_resolve()`.  */
FZ_FUNCTION int PdfObj::pdf_objcmp_resolve(const PdfObj& b) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_objcmp_resolve()\n";
	}
	#endif
	auto ret = mupdf::pdf_objcmp_resolve(*this, b);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_open_raw_stream()`.  */
FZ_FUNCTION FzStream PdfObj::pdf_open_raw_stream() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_raw_stream()\n";
	}
	#endif
	auto ret = mupdf::pdf_open_raw_stream(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_open_stream()`.  */
FZ_FUNCTION FzStream PdfObj::pdf_open_stream() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_stream()\n";
	}
	#endif
	auto ret = mupdf::pdf_open_stream(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_page_obj_transform()`.  */
FZ_FUNCTION void PdfObj::pdf_page_obj_transform(FzRect& outbox, FzMatrix& outctm) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_obj_transform()\n";
	}
	#endif
	mupdf::pdf_page_obj_transform(*this, outbox, outctm);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_page_obj_transform_box()`.  */
FZ_FUNCTION void PdfObj::pdf_page_obj_transform_box(FzRect& outbox, FzMatrix& out, ::fz_box_type box) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_obj_transform_box()\n";
	}
	#endif
	mupdf::pdf_page_obj_transform_box(*this, outbox, out, box);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_pin_document()`.  */
FZ_FUNCTION PdfDocument PdfObj::pdf_pin_document() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_pin_document()\n";
	}
	#endif
	auto ret = mupdf::pdf_pin_document(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_recolor_shade()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_recolor_shade(::pdf_shade_recolorer *reshade, void *opaque) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_recolor_shade()\n";
	}
	#endif
	auto ret = mupdf::pdf_recolor_shade(*this, reshade, opaque);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_resolve_indirect()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_resolve_indirect() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_resolve_indirect()\n";
	}
	#endif
	auto ret = mupdf::pdf_resolve_indirect(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_resolve_indirect_chain()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_resolve_indirect_chain() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_resolve_indirect_chain()\n";
	}
	#endif
	auto ret = mupdf::pdf_resolve_indirect_chain(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_set_int()`.  */
FZ_FUNCTION void PdfObj::pdf_set_int(int64_t i) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_int()\n";
	}
	#endif
	mupdf::pdf_set_int(*this, i);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_obj_memo()`.  */
FZ_FUNCTION void PdfObj::pdf_set_obj_memo(int bit, int memo) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_obj_memo()\n";
	}
	#endif
	mupdf::pdf_set_obj_memo(*this, bit, memo);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_obj_parent()`.  */
FZ_FUNCTION void PdfObj::pdf_set_obj_parent(int num) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_obj_parent()\n";
	}
	#endif
	mupdf::pdf_set_obj_parent(*this, num);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_str_len()`.  */
FZ_FUNCTION void PdfObj::pdf_set_str_len(size_t newlen) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_str_len()\n";
	}
	#endif
	mupdf::pdf_set_str_len(*this, newlen);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_sort_dict()`.  */
FZ_FUNCTION void PdfObj::pdf_sort_dict() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_sort_dict()\n";
	}
	#endif
	mupdf::pdf_sort_dict(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_store_item()`.  */
FZ_FUNCTION void PdfObj::pdf_store_item(void *val, size_t itemsize) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_store_item()\n";
	}
	#endif
	mupdf::pdf_store_item(*this, val, itemsize);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_to_bool()`.  */
FZ_FUNCTION int PdfObj::pdf_to_bool() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_bool()\n";
	}
	#endif
	auto ret = mupdf::pdf_to_bool(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_to_bool_default()`.  */
FZ_FUNCTION int PdfObj::pdf_to_bool_default(int def) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_bool_default()\n";
	}
	#endif
	auto ret = mupdf::pdf_to_bool_default(*this, def);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_to_date()`.  */
FZ_FUNCTION int64_t PdfObj::pdf_to_date() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_date()\n";
	}
	#endif
	auto ret = mupdf::pdf_to_date(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_to_gen()`.  */
FZ_FUNCTION int PdfObj::pdf_to_gen() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_gen()\n";
	}
	#endif
	auto ret = mupdf::pdf_to_gen(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_to_int()`.  */
FZ_FUNCTION int PdfObj::pdf_to_int() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_int()\n";
	}
	#endif
	auto ret = mupdf::pdf_to_int(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_to_int64()`.  */
FZ_FUNCTION int64_t PdfObj::pdf_to_int64() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_int64()\n";
	}
	#endif
	auto ret = mupdf::pdf_to_int64(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_to_int_default()`.  */
FZ_FUNCTION int PdfObj::pdf_to_int_default(int def) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_int_default()\n";
	}
	#endif
	auto ret = mupdf::pdf_to_int_default(*this, def);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_to_matrix()`.  */
FZ_FUNCTION FzMatrix PdfObj::pdf_to_matrix() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_matrix()\n";
	}
	#endif
	auto ret = mupdf::pdf_to_matrix(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_to_name()`.  */
FZ_FUNCTION const char *PdfObj::pdf_to_name() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_name()\n";
	}
	#endif
	auto ret = mupdf::pdf_to_name(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_to_num()`.  */
FZ_FUNCTION int PdfObj::pdf_to_num() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_num()\n";
	}
	#endif
	auto ret = mupdf::pdf_to_num(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_to_quad()`.  */
FZ_FUNCTION FzQuad PdfObj::pdf_to_quad(int offset) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_quad()\n";
	}
	#endif
	auto ret = mupdf::pdf_to_quad(*this, offset);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_to_real()`.  */
FZ_FUNCTION float PdfObj::pdf_to_real() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_real()\n";
	}
	#endif
	auto ret = mupdf::pdf_to_real(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_to_real_default()`.  */
FZ_FUNCTION float PdfObj::pdf_to_real_default(float def) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_real_default()\n";
	}
	#endif
	auto ret = mupdf::pdf_to_real_default(*this, def);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_to_rect()`.  */
FZ_FUNCTION FzRect PdfObj::pdf_to_rect() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_rect()\n";
	}
	#endif
	auto ret = mupdf::pdf_to_rect(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_to_str_buf()`.  */
FZ_FUNCTION char *PdfObj::pdf_to_str_buf() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_str_buf()\n";
	}
	#endif
	auto ret = mupdf::pdf_to_str_buf(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_to_str_len()`.  */
FZ_FUNCTION size_t PdfObj::pdf_to_str_len() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_str_len()\n";
	}
	#endif
	auto ret = mupdf::pdf_to_str_len(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_to_string()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_to_string()` => `(const char *, size_t sizep)`
	 */
FZ_FUNCTION const char *PdfObj::pdf_to_string(size_t *sizep) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_string()\n";
	}
	#endif
	auto ret = mupdf::pdf_to_string(*this, sizep);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_to_text_string()`.  */
FZ_FUNCTION const char *PdfObj::pdf_to_text_string() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_text_string()\n";
	}
	#endif
	auto ret = mupdf::pdf_to_text_string(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_unmark_obj()`.  */
FZ_FUNCTION void PdfObj::pdf_unmark_obj() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_unmark_obj()\n";
	}
	#endif
	mupdf::pdf_unmark_obj(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_verify_embedded_file_checksum()`.  */
FZ_FUNCTION int PdfObj::pdf_verify_embedded_file_checksum() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_verify_embedded_file_checksum()\n";
	}
	#endif
	auto ret = mupdf::pdf_verify_embedded_file_checksum(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_walk_tree()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_walk_tree(::pdf_obj *kid_name, void (*arrive)(::fz_context *, ::pdf_obj *, void *, ::pdf_obj **), void (*leave)(::fz_context *, ::pdf_obj *, void *), void *arg, ::pdf_obj **names, ::pdf_obj **values)` => `()`
	 */
FZ_FUNCTION void PdfObj::pdf_walk_tree(const PdfObj& kid_name, void (*arrive)(::fz_context *, ::pdf_obj *, void *, ::pdf_obj **), void (*leave)(::fz_context *, ::pdf_obj *, void *), void *arg, PdfObj& names, PdfObj& values) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_walk_tree()\n";
	}
	#endif
	mupdf::pdf_walk_tree(*this, kid_name, arrive, leave, arg, names, values);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_xobject_bbox()`.  */
FZ_FUNCTION FzRect PdfObj::pdf_xobject_bbox() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xobject_bbox()\n";
	}
	#endif
	auto ret = mupdf::pdf_xobject_bbox(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_xobject_colorspace()`.  */
FZ_FUNCTION FzColorspace PdfObj::pdf_xobject_colorspace() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xobject_colorspace()\n";
	}
	#endif
	auto ret = mupdf::pdf_xobject_colorspace(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_xobject_isolated()`.  */
FZ_FUNCTION int PdfObj::pdf_xobject_isolated() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xobject_isolated()\n";
	}
	#endif
	auto ret = mupdf::pdf_xobject_isolated(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_xobject_knockout()`.  */
FZ_FUNCTION int PdfObj::pdf_xobject_knockout() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xobject_knockout()\n";
	}
	#endif
	auto ret = mupdf::pdf_xobject_knockout(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_xobject_matrix()`.  */
FZ_FUNCTION FzMatrix PdfObj::pdf_xobject_matrix() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xobject_matrix()\n";
	}
	#endif
	auto ret = mupdf::pdf_xobject_matrix(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_xobject_resources()`.  */
FZ_FUNCTION PdfObj PdfObj::pdf_xobject_resources() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xobject_resources()\n";
	}
	#endif
	auto ret = mupdf::pdf_xobject_resources(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_xobject_transparency()`.  */
FZ_FUNCTION int PdfObj::pdf_xobject_transparency() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xobject_transparency()\n";
	}
	#endif
	auto ret = mupdf::pdf_xobject_transparency(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/** Custom method. */
FZ_FUNCTION PdfObj PdfObj::pdf_dict_get(int key)
{
	::pdf_obj* temp = ll_pdf_dict_get(this->m_internal, (::pdf_obj*)(uintptr_t) key);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}

/** Custom method. */
FZ_FUNCTION std::string PdfObj::pdf_load_field_name2()
{
	return mupdf::pdf_load_field_name2( *this);
}

FZ_FUNCTION PdfObj::PdfObj(::pdf_obj* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfObj::~PdfObj()
{
	ll_pdf_drop_obj(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfObj_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long PdfObj::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfObj::s_num_instances = 0;


/* Implementation of methods for PdfOcgDescriptor (wrapper for pdf_ocg_descriptor). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfOcgDescriptor::PdfOcgDescriptor()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfOcgDescriptor::PdfOcgDescriptor(::pdf_ocg_descriptor* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfOcgDescriptor::~PdfOcgDescriptor()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfOcgDescriptor::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfOcgDescriptor::s_num_instances = 0;


/* Implementation of methods for PdfPage (wrapper for pdf_page). */

#ifndef NDEBUG
static RefsCheck<::pdf_page, PdfPage> s_PdfPage_refs_check(offsetof(::pdf_page, super.refs), 32);
#endif

/** Copy constructor using `pdf_keep_page()`. */
FZ_FUNCTION PdfPage::PdfPage(const PdfPage& rhs)
: m_internal(ll_pdf_keep_page(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_pdf_keep_page(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `pdf_keep_page()` and `pdf_drop_page()`. */
FZ_FUNCTION PdfPage& PdfPage::operator=(const PdfPage& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_pdf_drop_page(this->m_internal)"
				<< " and ll_pdf_keep_page(rhs.m_internal)\n"
				;
	}
	#endif
	ll_pdf_drop_page(this->m_internal);
	ll_pdf_keep_page(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfPage::PdfPage()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::pdf_bound_page()`.  */
FZ_FUNCTION FzRect PdfPage::pdf_bound_page(::fz_box_type box) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_bound_page()\n";
	}
	#endif
	auto ret = mupdf::pdf_bound_page(*this, box);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_create_annot()`.  */
FZ_FUNCTION PdfAnnot PdfPage::pdf_create_annot(enum pdf_annot_type type) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_create_annot()\n";
	}
	#endif
	auto ret = mupdf::pdf_create_annot(*this, type);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_create_annot_raw()`.  */
FZ_FUNCTION PdfAnnot PdfPage::pdf_create_annot_raw(enum pdf_annot_type type) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_create_annot_raw()\n";
	}
	#endif
	auto ret = mupdf::pdf_create_annot_raw(*this, type);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_create_link()`.  */
FZ_FUNCTION FzLink PdfPage::pdf_create_link(const FzRect& bbox, const char *uri) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_create_link()\n";
	}
	#endif
	auto ret = mupdf::pdf_create_link(*this, bbox, uri);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_create_signature_widget()`.  */
FZ_FUNCTION PdfAnnot PdfPage::pdf_create_signature_widget(char *name) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_create_signature_widget()\n";
	}
	#endif
	auto ret = mupdf::pdf_create_signature_widget(*this, name);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_delete_annot()`.  */
FZ_FUNCTION void PdfPage::pdf_delete_annot(const PdfAnnot& annot) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_delete_annot()\n";
	}
	#endif
	mupdf::pdf_delete_annot(*this, annot);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_delete_link()`.  */
FZ_FUNCTION void PdfPage::pdf_delete_link(const FzLink& link) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_delete_link()\n";
	}
	#endif
	mupdf::pdf_delete_link(*this, link);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_first_annot()`.  */
FZ_FUNCTION PdfAnnot PdfPage::pdf_first_annot() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_first_annot()\n";
	}
	#endif
	auto ret = mupdf::pdf_first_annot(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_first_widget()`.  */
FZ_FUNCTION PdfAnnot PdfPage::pdf_first_widget() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_first_widget()\n";
	}
	#endif
	auto ret = mupdf::pdf_first_widget(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_load_links()`.  */
FZ_FUNCTION FzLink PdfPage::pdf_load_links() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_links()\n";
	}
	#endif
	auto ret = mupdf::pdf_load_links(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_link()`.  */
FZ_FUNCTION FzLink PdfPage::pdf_new_link(const FzRect& rect, const char *uri, const PdfObj& obj) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_link()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_link(*this, rect, uri, obj);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_pixmap_from_page_contents_with_separations_and_usage()`.  */
FZ_FUNCTION FzPixmap PdfPage::pdf_new_pixmap_from_page_contents_with_separations_and_usage(const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha, const char *usage, ::fz_box_type box) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_pixmap_from_page_contents_with_separations_and_usage()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_pixmap_from_page_contents_with_separations_and_usage(*this, ctm, cs, seps, alpha, usage, box);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_pixmap_from_page_contents_with_usage()`.  */
FZ_FUNCTION FzPixmap PdfPage::pdf_new_pixmap_from_page_contents_with_usage(const FzMatrix& ctm, const FzColorspace& cs, int alpha, const char *usage, ::fz_box_type box) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_pixmap_from_page_contents_with_usage()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_pixmap_from_page_contents_with_usage(*this, ctm, cs, alpha, usage, box);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_pixmap_from_page_with_separations_and_usage()`.  */
FZ_FUNCTION FzPixmap PdfPage::pdf_new_pixmap_from_page_with_separations_and_usage(const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha, const char *usage, ::fz_box_type box) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_pixmap_from_page_with_separations_and_usage()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_pixmap_from_page_with_separations_and_usage(*this, ctm, cs, seps, alpha, usage, box);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_new_pixmap_from_page_with_usage()`.  */
FZ_FUNCTION FzPixmap PdfPage::pdf_new_pixmap_from_page_with_usage(const FzMatrix& ctm, const FzColorspace& cs, int alpha, const char *usage, ::fz_box_type box) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_pixmap_from_page_with_usage()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_pixmap_from_page_with_usage(*this, ctm, cs, alpha, usage, box);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_page_contents()`.  */
FZ_FUNCTION PdfObj PdfPage::pdf_page_contents() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_contents()\n";
	}
	#endif
	auto ret = mupdf::pdf_page_contents(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_page_event_close()`.  */
FZ_FUNCTION void PdfPage::pdf_page_event_close() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_event_close()\n";
	}
	#endif
	mupdf::pdf_page_event_close(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_page_event_open()`.  */
FZ_FUNCTION void PdfPage::pdf_page_event_open() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_event_open()\n";
	}
	#endif
	mupdf::pdf_page_event_open(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_page_group()`.  */
FZ_FUNCTION PdfObj PdfPage::pdf_page_group() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_group()\n";
	}
	#endif
	auto ret = mupdf::pdf_page_group(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_page_has_transparency()`.  */
FZ_FUNCTION int PdfPage::pdf_page_has_transparency() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_has_transparency()\n";
	}
	#endif
	auto ret = mupdf::pdf_page_has_transparency(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_page_presentation()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_page_presentation(::fz_transition *transition)` => `(fz_transition *, float duration)`
	 */
FZ_FUNCTION FzTransition PdfPage::pdf_page_presentation(FzTransition& transition, float *duration) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_presentation()\n";
	}
	#endif
	auto ret = mupdf::pdf_page_presentation(*this, transition, duration);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_page_resources()`.  */
FZ_FUNCTION PdfObj PdfPage::pdf_page_resources() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_resources()\n";
	}
	#endif
	auto ret = mupdf::pdf_page_resources(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_page_separations()`.  */
FZ_FUNCTION FzSeparations PdfPage::pdf_page_separations() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_separations()\n";
	}
	#endif
	auto ret = mupdf::pdf_page_separations(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_page_transform()`.  */
FZ_FUNCTION void PdfPage::pdf_page_transform(FzRect& mediabox, FzMatrix& ctm) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_transform()\n";
	}
	#endif
	mupdf::pdf_page_transform(*this, mediabox, ctm);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_page_transform_box()`.  */
FZ_FUNCTION void PdfPage::pdf_page_transform_box(FzRect& mediabox, FzMatrix& ctm, ::fz_box_type box) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_transform_box()\n";
	}
	#endif
	mupdf::pdf_page_transform_box(*this, mediabox, ctm, box);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_run_page()`.  */
FZ_FUNCTION void PdfPage::pdf_run_page(const FzDevice& dev, const FzMatrix& ctm, FzCookie& cookie) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_page()\n";
	}
	#endif
	mupdf::pdf_run_page(*this, dev, ctm, cookie);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_run_page_annots()`.  */
FZ_FUNCTION void PdfPage::pdf_run_page_annots(const FzDevice& dev, const FzMatrix& ctm, FzCookie& cookie) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_page_annots()\n";
	}
	#endif
	mupdf::pdf_run_page_annots(*this, dev, ctm, cookie);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_run_page_annots_with_usage()`.  */
FZ_FUNCTION void PdfPage::pdf_run_page_annots_with_usage(const FzDevice& dev, const FzMatrix& ctm, const char *usage, FzCookie& cookie) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_page_annots_with_usage()\n";
	}
	#endif
	mupdf::pdf_run_page_annots_with_usage(*this, dev, ctm, usage, cookie);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_run_page_contents()`.  */
FZ_FUNCTION void PdfPage::pdf_run_page_contents(const FzDevice& dev, const FzMatrix& ctm, FzCookie& cookie) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_page_contents()\n";
	}
	#endif
	mupdf::pdf_run_page_contents(*this, dev, ctm, cookie);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_run_page_contents_with_usage()`.  */
FZ_FUNCTION void PdfPage::pdf_run_page_contents_with_usage(const FzDevice& dev, const FzMatrix& ctm, const char *usage, FzCookie& cookie) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_page_contents_with_usage()\n";
	}
	#endif
	mupdf::pdf_run_page_contents_with_usage(*this, dev, ctm, usage, cookie);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_run_page_widgets()`.  */
FZ_FUNCTION void PdfPage::pdf_run_page_widgets(const FzDevice& dev, const FzMatrix& ctm, FzCookie& cookie) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_page_widgets()\n";
	}
	#endif
	mupdf::pdf_run_page_widgets(*this, dev, ctm, cookie);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_run_page_widgets_with_usage()`.  */
FZ_FUNCTION void PdfPage::pdf_run_page_widgets_with_usage(const FzDevice& dev, const FzMatrix& ctm, const char *usage, FzCookie& cookie) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_page_widgets_with_usage()\n";
	}
	#endif
	mupdf::pdf_run_page_widgets_with_usage(*this, dev, ctm, usage, cookie);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_run_page_with_usage()`.  */
FZ_FUNCTION void PdfPage::pdf_run_page_with_usage(const FzDevice& dev, const FzMatrix& ctm, const char *usage, FzCookie& cookie) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_page_with_usage()\n";
	}
	#endif
	mupdf::pdf_run_page_with_usage(*this, dev, ctm, usage, cookie);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_set_page_box()`.  */
FZ_FUNCTION void PdfPage::pdf_set_page_box(::fz_box_type box, const FzRect& rect) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_page_box()\n";
	}
	#endif
	mupdf::pdf_set_page_box(*this, box, rect);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_update_page()`.  */
FZ_FUNCTION int PdfPage::pdf_update_page() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_update_page()\n";
	}
	#endif
	auto ret = mupdf::pdf_update_page(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/** Custom method. */
FZ_FUNCTION FzPage PdfPage::super()
{
	return FzPage( ll_fz_keep_page( &m_internal->super));
}

/** Custom method. */
FZ_FUNCTION PdfDocument PdfPage::doc()
{
	return PdfDocument( ll_pdf_keep_document( m_internal->doc));
}

/** Custom method. */
FZ_FUNCTION PdfObj PdfPage::obj()
{
	return PdfObj( ll_pdf_keep_obj( m_internal->obj));
}

FZ_FUNCTION PdfPage::PdfPage(::pdf_page* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfPage::~PdfPage()
{
	ll_pdf_drop_page(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPage_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long PdfPage::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfPage::s_num_instances = 0;


/* Implementation of methods for PdfPattern (wrapper for pdf_pattern). */

#ifndef NDEBUG
static RefsCheck<::pdf_pattern, PdfPattern> s_PdfPattern_refs_check(offsetof(::pdf_pattern, storable.refs), 32);
#endif

/** Copy constructor using `pdf_keep_pattern()`. */
FZ_FUNCTION PdfPattern::PdfPattern(const PdfPattern& rhs)
: m_internal(ll_pdf_keep_pattern(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_pdf_keep_pattern(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPattern_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `pdf_keep_pattern()` and `pdf_drop_pattern()`. */
FZ_FUNCTION PdfPattern& PdfPattern::operator=(const PdfPattern& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_pdf_drop_pattern(this->m_internal)"
				<< " and ll_pdf_keep_pattern(rhs.m_internal)\n"
				;
	}
	#endif
	ll_pdf_drop_pattern(this->m_internal);
	ll_pdf_keep_pattern(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPattern_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPattern_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfPattern::PdfPattern()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPattern_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfPattern::PdfPattern(::pdf_pattern* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPattern_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfPattern::~PdfPattern()
{
	ll_pdf_drop_pattern(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfPattern_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long PdfPattern::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfPattern::s_num_instances = 0;


/* Implementation of methods for PdfPkcs7DistinguishedName (wrapper for pdf_pkcs7_distinguished_name). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfPkcs7DistinguishedName::PdfPkcs7DistinguishedName()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::pdf_signature_drop_distinguished_name()`.  */
FZ_FUNCTION void PdfPkcs7DistinguishedName::pdf_signature_drop_distinguished_name() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_drop_distinguished_name()\n";
	}
	#endif
	mupdf::pdf_signature_drop_distinguished_name(*this);
}

/* Class-aware wrapper for `::pdf_signature_format_distinguished_name()`.  */
FZ_FUNCTION char *PdfPkcs7DistinguishedName::pdf_signature_format_distinguished_name() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_format_distinguished_name()\n";
	}
	#endif
	auto ret = mupdf::pdf_signature_format_distinguished_name(*this);
	return ret;
}

FZ_FUNCTION PdfPkcs7DistinguishedName::PdfPkcs7DistinguishedName(::pdf_pkcs7_distinguished_name* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfPkcs7DistinguishedName::~PdfPkcs7DistinguishedName()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfPkcs7DistinguishedName::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfPkcs7DistinguishedName::s_num_instances = 0;


/* Implementation of methods for PdfPkcs7Signer (wrapper for pdf_pkcs7_signer). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfPkcs7Signer::PdfPkcs7Signer()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfPkcs7Signer::PdfPkcs7Signer(::pdf_pkcs7_signer* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfPkcs7Signer::~PdfPkcs7Signer()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfPkcs7Signer::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfPkcs7Signer::s_num_instances = 0;


/* Implementation of methods for PdfPkcs7Verifier (wrapper for pdf_pkcs7_verifier). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfPkcs7Verifier::PdfPkcs7Verifier()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfPkcs7Verifier::PdfPkcs7Verifier(::pdf_pkcs7_verifier* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfPkcs7Verifier::~PdfPkcs7Verifier()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfPkcs7Verifier::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfPkcs7Verifier::s_num_instances = 0;


/* Implementation of methods for PdfProcessor (wrapper for pdf_processor). */

#ifndef NDEBUG
static RefsCheck<::pdf_processor, PdfProcessor> s_PdfProcessor_refs_check(offsetof(::pdf_processor, refs), 32);
#endif

/* Constructor using `pdf_new_buffer_processor()`. */
FZ_FUNCTION PdfProcessor::PdfProcessor(const FzBuffer& buffer, int ahxencode, int newlines)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_buffer_processor()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_buffer_processor(buffer.m_internal, ahxencode, newlines);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfProcessor_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_output_processor()`. */
FZ_FUNCTION PdfProcessor::PdfProcessor(const FzOutput& out, int ahxencode, int newlines)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_output_processor()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_output_processor(out.m_internal, ahxencode, newlines);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfProcessor_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_run_processor()`. */
FZ_FUNCTION PdfProcessor::PdfProcessor(const PdfDocument& doc, const FzDevice& dev, const FzMatrix& ctm, int struct_parent, const char *usage, const PdfGstate& gstate, const FzDefaultColorspaces& default_cs, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_run_processor()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_run_processor(doc.m_internal, dev.m_internal, * ctm.internal(), struct_parent, usage, gstate.m_internal, default_cs.m_internal, &cookie.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfProcessor_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Constructor using `pdf_new_sanitize_filter()`. */
FZ_FUNCTION PdfProcessor::PdfProcessor(const PdfDocument& doc, const PdfProcessor& chain, int struct_parents, const FzMatrix& transform, PdfFilterOptions& options, void *sopts)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_sanitize_filter()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_sanitize_filter(doc.m_internal, chain.m_internal, struct_parents, * transform.internal(),  options.internal(), sopts);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfProcessor_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Copy constructor using `pdf_keep_processor()`. */
FZ_FUNCTION PdfProcessor::PdfProcessor(const PdfProcessor& rhs)
: m_internal(ll_pdf_keep_processor(rhs.m_internal))
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " have called ll_pdf_keep_processor(rhs.m_internal)\n"
				;
	}
	#endif
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfProcessor_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* operator= using `pdf_keep_processor()` and `pdf_drop_processor()`. */
FZ_FUNCTION PdfProcessor& PdfProcessor::operator=(const PdfProcessor& rhs)
{
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling ll_pdf_drop_processor(this->m_internal)"
				<< " and ll_pdf_keep_processor(rhs.m_internal)\n"
				;
	}
	#endif
	ll_pdf_drop_processor(this->m_internal);
	ll_pdf_keep_processor(rhs.m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfProcessor_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	this->m_internal = rhs.m_internal;
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfProcessor_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return *this;
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfProcessor::PdfProcessor()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfProcessor_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::pdf_new_color_filter()`.  */
FZ_FUNCTION PdfProcessor PdfProcessor::pdf_new_color_filter(const PdfDocument& doc, const PdfProcessor& chain, int struct_parents, const FzMatrix& transform, PdfFilterOptions& options, void *copts)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_color_filter()\n";
	}
	#endif
	auto ret = mupdf::pdf_new_color_filter(doc, chain, struct_parents, transform, options, copts);
	return ret;
}

/* Class-aware wrapper for `::pdf_close_processor()`.  */
FZ_FUNCTION void PdfProcessor::pdf_close_processor() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_close_processor()\n";
	}
	#endif
	mupdf::pdf_close_processor(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfProcessor_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_process_annot()`.  */
FZ_FUNCTION void PdfProcessor::pdf_process_annot(const PdfAnnot& annot, FzCookie& cookie) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_process_annot()\n";
	}
	#endif
	mupdf::pdf_process_annot(*this, annot, cookie);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfProcessor_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_process_contents()`.
	
	This method has out-params. Python/C# wrappers look like:
		`pdf_process_contents(::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm, ::fz_cookie *cookie, ::pdf_obj **out_res)` => 
	 */
FZ_FUNCTION void PdfProcessor::pdf_process_contents(const PdfDocument& doc, const PdfObj& res, const PdfObj& stm, FzCookie& cookie, PdfObj& out_res) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_process_contents()\n";
	}
	#endif
	mupdf::pdf_process_contents(*this, doc, res, stm, cookie, out_res);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfProcessor_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_process_glyph()`.  */
FZ_FUNCTION void PdfProcessor::pdf_process_glyph(const PdfDocument& doc, const PdfObj& resources, const FzBuffer& contents) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_process_glyph()\n";
	}
	#endif
	mupdf::pdf_process_glyph(*this, doc, resources, contents);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfProcessor_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_process_raw_contents()`.  */
FZ_FUNCTION void PdfProcessor::pdf_process_raw_contents(const PdfDocument& doc, const PdfObj& rdb, const PdfObj& stmobj, FzCookie& cookie) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_process_raw_contents()\n";
	}
	#endif
	mupdf::pdf_process_raw_contents(*this, doc, rdb, stmobj, cookie);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfProcessor_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_processor_pop_resources()`.  */
FZ_FUNCTION PdfObj PdfProcessor::pdf_processor_pop_resources() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_processor_pop_resources()\n";
	}
	#endif
	auto ret = mupdf::pdf_processor_pop_resources(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfProcessor_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	return ret;
}

/* Class-aware wrapper for `::pdf_processor_push_resources()`.  */
FZ_FUNCTION void PdfProcessor::pdf_processor_push_resources(const PdfObj& res) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_processor_push_resources()\n";
	}
	#endif
	mupdf::pdf_processor_push_resources(*this, res);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfProcessor_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

/* Class-aware wrapper for `::pdf_reset_processor()`.  */
FZ_FUNCTION void PdfProcessor::pdf_reset_processor() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_reset_processor()\n";
	}
	#endif
	mupdf::pdf_reset_processor(*this);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfProcessor_refs_check.check( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
}

FZ_FUNCTION PdfProcessor::PdfProcessor(::pdf_processor* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfProcessor_refs_check.add( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfProcessor::~PdfProcessor()
{
	ll_pdf_drop_processor(m_internal);
	#ifndef NDEBUG
	if (s_check_refs)
	{
		s_PdfProcessor_refs_check.remove( this, __FILE__, __LINE__, __FUNCTION__);
	}
	#endif
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}

/** Custom method. */
FZ_FUNCTION long long PdfProcessor::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfProcessor::s_num_instances = 0;

/* Implementation of methods for `PdfProcessor2`, virtual_fnptrs wrapper for `pdf_processor`). */


FZ_FUNCTION PdfProcessor2::PdfProcessor2()
{

	
	m_internal = (::pdf_processor*) ll_pdf_new_processor(
			sizeof(*m_internal)
			+ sizeof(PdfProcessor2*)
			);
	*((PdfProcessor2**) (m_internal + 1)) = this;
	
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::PdfProcessor2(): this=" << this << "\n";
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::PdfProcessor2(): m_internal=" << m_internal << "\n";
		PdfProcessor2* self = (*(PdfProcessor2**) (m_internal + 1));
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::PdfProcessor2(): self=" << self << "\n";
	}
	#endif
}
/* Static callback, calls self->close_processor(). */
static void PdfProcessor2_s_close_processor(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_close_processor(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->close_processor(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_close_processor(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->drop_processor(). */
static void PdfProcessor2_s_drop_processor(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_drop_processor(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->drop_processor(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_drop_processor(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->reset_processor(). */
static void PdfProcessor2_s_reset_processor(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_reset_processor(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->reset_processor(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_reset_processor(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->push_resources(). */
static void PdfProcessor2_s_push_resources(::fz_context *arg_0, ::pdf_processor *arg_1, ::pdf_obj *arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_push_resources(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->push_resources(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_push_resources(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->pop_resources(). */
static ::pdf_obj * PdfProcessor2_s_pop_resources(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_pop_resources(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->pop_resources(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_pop_resources(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_w(). */
static void PdfProcessor2_s_op_w(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_w(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_w(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_w(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_j(). */
static void PdfProcessor2_s_op_j(::fz_context *arg_0, ::pdf_processor *arg_1, int arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_j(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_j(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_j(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_J(). */
static void PdfProcessor2_s_op_J(::fz_context *arg_0, ::pdf_processor *arg_1, int arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_J(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_J(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_J(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_M(). */
static void PdfProcessor2_s_op_M(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_M(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_M(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_M(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_d(). */
static void PdfProcessor2_s_op_d(::fz_context *arg_0, ::pdf_processor *arg_1, ::pdf_obj *arg_2, float arg_3)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_d(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_d(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_d(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_ri(). */
static void PdfProcessor2_s_op_ri(::fz_context *arg_0, ::pdf_processor *arg_1, const char *arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_ri(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_ri(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_ri(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_i(). */
static void PdfProcessor2_s_op_i(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_i(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_i(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_i(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_gs_begin(). */
static void PdfProcessor2_s_op_gs_begin(::fz_context *arg_0, ::pdf_processor *arg_1, const char *arg_2, ::pdf_obj *arg_3)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_gs_begin(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_gs_begin(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_gs_begin(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_gs_BM(). */
static void PdfProcessor2_s_op_gs_BM(::fz_context *arg_0, ::pdf_processor *arg_1, const char *arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_gs_BM(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_gs_BM(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_gs_BM(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_gs_ca(). */
static void PdfProcessor2_s_op_gs_ca(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_gs_ca(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_gs_ca(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_gs_ca(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_gs_CA(). */
static void PdfProcessor2_s_op_gs_CA(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_gs_CA(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_gs_CA(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_gs_CA(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_gs_SMask(). */
static void PdfProcessor2_s_op_gs_SMask(::fz_context *arg_0, ::pdf_processor *arg_1, ::pdf_obj *arg_2, float *arg_3, int arg_4, ::pdf_obj *arg_5)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_gs_SMask(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_gs_SMask(arg_0, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_gs_SMask(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_gs_end(). */
static void PdfProcessor2_s_op_gs_end(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_gs_end(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_gs_end(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_gs_end(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_q(). */
static void PdfProcessor2_s_op_q(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_q(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_q(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_q(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_Q(). */
static void PdfProcessor2_s_op_Q(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Q(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_Q(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Q(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_cm(). */
static void PdfProcessor2_s_op_cm(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2, float arg_3, float arg_4, float arg_5, float arg_6, float arg_7)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_cm(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_cm(arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_cm(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_m(). */
static void PdfProcessor2_s_op_m(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2, float arg_3)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_m(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_m(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_m(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_l(). */
static void PdfProcessor2_s_op_l(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2, float arg_3)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_l(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_l(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_l(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_c(). */
static void PdfProcessor2_s_op_c(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2, float arg_3, float arg_4, float arg_5, float arg_6, float arg_7)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_c(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_c(arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_c(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_v(). */
static void PdfProcessor2_s_op_v(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2, float arg_3, float arg_4, float arg_5)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_v(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_v(arg_0, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_v(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_y(). */
static void PdfProcessor2_s_op_y(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2, float arg_3, float arg_4, float arg_5)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_y(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_y(arg_0, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_y(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_h(). */
static void PdfProcessor2_s_op_h(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_h(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_h(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_h(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_re(). */
static void PdfProcessor2_s_op_re(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2, float arg_3, float arg_4, float arg_5)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_re(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_re(arg_0, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_re(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_S(). */
static void PdfProcessor2_s_op_S(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_S(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_S(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_S(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_s(). */
static void PdfProcessor2_s_op_s(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_s(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_s(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_s(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_F(). */
static void PdfProcessor2_s_op_F(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_F(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_F(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_F(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_f(). */
static void PdfProcessor2_s_op_f(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_f(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_f(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_f(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_fstar(). */
static void PdfProcessor2_s_op_fstar(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_fstar(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_fstar(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_fstar(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_B(). */
static void PdfProcessor2_s_op_B(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_B(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_B(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_B(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_Bstar(). */
static void PdfProcessor2_s_op_Bstar(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Bstar(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_Bstar(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Bstar(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_b(). */
static void PdfProcessor2_s_op_b(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_b(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_b(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_b(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_bstar(). */
static void PdfProcessor2_s_op_bstar(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_bstar(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_bstar(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_bstar(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_n(). */
static void PdfProcessor2_s_op_n(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_n(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_n(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_n(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_W(). */
static void PdfProcessor2_s_op_W(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_W(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_W(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_W(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_Wstar(). */
static void PdfProcessor2_s_op_Wstar(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Wstar(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_Wstar(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Wstar(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_BT(). */
static void PdfProcessor2_s_op_BT(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_BT(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_BT(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_BT(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_ET(). */
static void PdfProcessor2_s_op_ET(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_ET(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_ET(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_ET(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_Tc(). */
static void PdfProcessor2_s_op_Tc(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Tc(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_Tc(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Tc(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_Tw(). */
static void PdfProcessor2_s_op_Tw(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Tw(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_Tw(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Tw(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_Tz(). */
static void PdfProcessor2_s_op_Tz(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Tz(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_Tz(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Tz(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_TL(). */
static void PdfProcessor2_s_op_TL(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_TL(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_TL(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_TL(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_Tf(). */
static void PdfProcessor2_s_op_Tf(::fz_context *arg_0, ::pdf_processor *arg_1, const char *arg_2, ::pdf_font_desc *arg_3, float arg_4)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Tf(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_Tf(arg_0, arg_2, arg_3, arg_4);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Tf(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_Tr(). */
static void PdfProcessor2_s_op_Tr(::fz_context *arg_0, ::pdf_processor *arg_1, int arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Tr(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_Tr(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Tr(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_Ts(). */
static void PdfProcessor2_s_op_Ts(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Ts(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_Ts(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Ts(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_Td(). */
static void PdfProcessor2_s_op_Td(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2, float arg_3)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Td(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_Td(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Td(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_TD(). */
static void PdfProcessor2_s_op_TD(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2, float arg_3)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_TD(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_TD(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_TD(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_Tm(). */
static void PdfProcessor2_s_op_Tm(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2, float arg_3, float arg_4, float arg_5, float arg_6, float arg_7)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Tm(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_Tm(arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Tm(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_Tstar(). */
static void PdfProcessor2_s_op_Tstar(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Tstar(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_Tstar(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Tstar(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_TJ(). */
static void PdfProcessor2_s_op_TJ(::fz_context *arg_0, ::pdf_processor *arg_1, ::pdf_obj *arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_TJ(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_TJ(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_TJ(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_Tj(). */
static void PdfProcessor2_s_op_Tj(::fz_context *arg_0, ::pdf_processor *arg_1, char *arg_2, size_t arg_3)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Tj(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_Tj(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Tj(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_squote(). */
static void PdfProcessor2_s_op_squote(::fz_context *arg_0, ::pdf_processor *arg_1, char *arg_2, size_t arg_3)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_squote(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_squote(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_squote(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_dquote(). */
static void PdfProcessor2_s_op_dquote(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2, float arg_3, char *arg_4, size_t arg_5)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_dquote(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_dquote(arg_0, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_dquote(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_d0(). */
static void PdfProcessor2_s_op_d0(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2, float arg_3)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_d0(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_d0(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_d0(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_d1(). */
static void PdfProcessor2_s_op_d1(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2, float arg_3, float arg_4, float arg_5, float arg_6, float arg_7)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_d1(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_d1(arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_d1(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_CS(). */
static void PdfProcessor2_s_op_CS(::fz_context *arg_0, ::pdf_processor *arg_1, const char *arg_2, ::fz_colorspace *arg_3)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_CS(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_CS(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_CS(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_cs(). */
static void PdfProcessor2_s_op_cs(::fz_context *arg_0, ::pdf_processor *arg_1, const char *arg_2, ::fz_colorspace *arg_3)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_cs(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_cs(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_cs(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_SC_pattern(). */
static void PdfProcessor2_s_op_SC_pattern(::fz_context *arg_0, ::pdf_processor *arg_1, const char *arg_2, ::pdf_pattern *arg_3, int arg_4, float *arg_5)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_SC_pattern(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_SC_pattern(arg_0, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_SC_pattern(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_sc_pattern(). */
static void PdfProcessor2_s_op_sc_pattern(::fz_context *arg_0, ::pdf_processor *arg_1, const char *arg_2, ::pdf_pattern *arg_3, int arg_4, float *arg_5)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_sc_pattern(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_sc_pattern(arg_0, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_sc_pattern(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_SC_shade(). */
static void PdfProcessor2_s_op_SC_shade(::fz_context *arg_0, ::pdf_processor *arg_1, const char *arg_2, ::fz_shade *arg_3)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_SC_shade(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_SC_shade(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_SC_shade(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_sc_shade(). */
static void PdfProcessor2_s_op_sc_shade(::fz_context *arg_0, ::pdf_processor *arg_1, const char *arg_2, ::fz_shade *arg_3)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_sc_shade(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_sc_shade(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_sc_shade(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_SC_color(). */
static void PdfProcessor2_s_op_SC_color(::fz_context *arg_0, ::pdf_processor *arg_1, int arg_2, float *arg_3)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_SC_color(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_SC_color(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_SC_color(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_sc_color(). */
static void PdfProcessor2_s_op_sc_color(::fz_context *arg_0, ::pdf_processor *arg_1, int arg_2, float *arg_3)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_sc_color(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_sc_color(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_sc_color(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_G(). */
static void PdfProcessor2_s_op_G(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_G(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_G(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_G(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_g(). */
static void PdfProcessor2_s_op_g(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_g(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_g(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_g(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_RG(). */
static void PdfProcessor2_s_op_RG(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2, float arg_3, float arg_4)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_RG(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_RG(arg_0, arg_2, arg_3, arg_4);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_RG(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_rg(). */
static void PdfProcessor2_s_op_rg(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2, float arg_3, float arg_4)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_rg(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_rg(arg_0, arg_2, arg_3, arg_4);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_rg(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_K(). */
static void PdfProcessor2_s_op_K(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2, float arg_3, float arg_4, float arg_5)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_K(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_K(arg_0, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_K(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_k(). */
static void PdfProcessor2_s_op_k(::fz_context *arg_0, ::pdf_processor *arg_1, float arg_2, float arg_3, float arg_4, float arg_5)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_k(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_k(arg_0, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_k(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_BI(). */
static void PdfProcessor2_s_op_BI(::fz_context *arg_0, ::pdf_processor *arg_1, ::fz_image *arg_2, const char *arg_3)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_BI(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_BI(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_BI(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_sh(). */
static void PdfProcessor2_s_op_sh(::fz_context *arg_0, ::pdf_processor *arg_1, const char *arg_2, ::fz_shade *arg_3)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_sh(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_sh(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_sh(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_Do_image(). */
static void PdfProcessor2_s_op_Do_image(::fz_context *arg_0, ::pdf_processor *arg_1, const char *arg_2, ::fz_image *arg_3)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Do_image(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_Do_image(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Do_image(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_Do_form(). */
static void PdfProcessor2_s_op_Do_form(::fz_context *arg_0, ::pdf_processor *arg_1, const char *arg_2, ::pdf_obj *arg_3)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Do_form(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_Do_form(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_Do_form(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_MP(). */
static void PdfProcessor2_s_op_MP(::fz_context *arg_0, ::pdf_processor *arg_1, const char *arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_MP(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_MP(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_MP(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_DP(). */
static void PdfProcessor2_s_op_DP(::fz_context *arg_0, ::pdf_processor *arg_1, const char *arg_2, ::pdf_obj *arg_3, ::pdf_obj *arg_4)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_DP(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_DP(arg_0, arg_2, arg_3, arg_4);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_DP(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_BMC(). */
static void PdfProcessor2_s_op_BMC(::fz_context *arg_0, ::pdf_processor *arg_1, const char *arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_BMC(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_BMC(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_BMC(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_BDC(). */
static void PdfProcessor2_s_op_BDC(::fz_context *arg_0, ::pdf_processor *arg_1, const char *arg_2, ::pdf_obj *arg_3, ::pdf_obj *arg_4)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_BDC(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_BDC(arg_0, arg_2, arg_3, arg_4);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_BDC(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_EMC(). */
static void PdfProcessor2_s_op_EMC(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_EMC(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_EMC(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_EMC(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_BX(). */
static void PdfProcessor2_s_op_BX(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_BX(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_BX(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_BX(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_EX(). */
static void PdfProcessor2_s_op_EX(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_EX(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_EX(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_EX(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_gs_OP(). */
static void PdfProcessor2_s_op_gs_OP(::fz_context *arg_0, ::pdf_processor *arg_1, int arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_gs_OP(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_gs_OP(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_gs_OP(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_gs_op(). */
static void PdfProcessor2_s_op_gs_op(::fz_context *arg_0, ::pdf_processor *arg_1, int arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_gs_op(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_gs_op(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_gs_op(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_gs_OPM(). */
static void PdfProcessor2_s_op_gs_OPM(::fz_context *arg_0, ::pdf_processor *arg_1, int arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_gs_OPM(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_gs_OPM(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_gs_OPM(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_gs_UseBlackPtComp(). */
static void PdfProcessor2_s_op_gs_UseBlackPtComp(::fz_context *arg_0, ::pdf_processor *arg_1, ::pdf_obj *arg_2)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_gs_UseBlackPtComp(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_gs_UseBlackPtComp(arg_0, arg_2);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_gs_UseBlackPtComp(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->op_END(). */
static void PdfProcessor2_s_op_END(::fz_context *arg_0, ::pdf_processor *arg_1)
{
	PdfProcessor2* self = (*(PdfProcessor2**) (arg_1 + 1));
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_END(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->op_END(arg_0);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2_s_op_END(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
FZ_FUNCTION void PdfProcessor2::use_virtual_close_processor( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_close_processor(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->close_processor = (use) ? PdfProcessor2_s_close_processor : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_drop_processor( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_drop_processor(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->drop_processor = (use) ? PdfProcessor2_s_drop_processor : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_reset_processor( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_reset_processor(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->reset_processor = (use) ? PdfProcessor2_s_reset_processor : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_push_resources( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_push_resources(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->push_resources = (use) ? PdfProcessor2_s_push_resources : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_pop_resources( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_pop_resources(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->pop_resources = (use) ? PdfProcessor2_s_pop_resources : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_w( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_w(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_w = (use) ? PdfProcessor2_s_op_w : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_j( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_j(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_j = (use) ? PdfProcessor2_s_op_j : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_J( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_J(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_J = (use) ? PdfProcessor2_s_op_J : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_M( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_M(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_M = (use) ? PdfProcessor2_s_op_M : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_d( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_d(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_d = (use) ? PdfProcessor2_s_op_d : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_ri( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_ri(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_ri = (use) ? PdfProcessor2_s_op_ri : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_i( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_i(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_i = (use) ? PdfProcessor2_s_op_i : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_gs_begin( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_gs_begin(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_gs_begin = (use) ? PdfProcessor2_s_op_gs_begin : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_gs_BM( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_gs_BM(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_gs_BM = (use) ? PdfProcessor2_s_op_gs_BM : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_gs_ca( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_gs_ca(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_gs_ca = (use) ? PdfProcessor2_s_op_gs_ca : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_gs_CA( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_gs_CA(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_gs_CA = (use) ? PdfProcessor2_s_op_gs_CA : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_gs_SMask( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_gs_SMask(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_gs_SMask = (use) ? PdfProcessor2_s_op_gs_SMask : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_gs_end( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_gs_end(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_gs_end = (use) ? PdfProcessor2_s_op_gs_end : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_q( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_q(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_q = (use) ? PdfProcessor2_s_op_q : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_Q( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_Q(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_Q = (use) ? PdfProcessor2_s_op_Q : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_cm( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_cm(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_cm = (use) ? PdfProcessor2_s_op_cm : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_m( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_m(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_m = (use) ? PdfProcessor2_s_op_m : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_l( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_l(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_l = (use) ? PdfProcessor2_s_op_l : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_c( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_c(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_c = (use) ? PdfProcessor2_s_op_c : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_v( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_v(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_v = (use) ? PdfProcessor2_s_op_v : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_y( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_y(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_y = (use) ? PdfProcessor2_s_op_y : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_h( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_h(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_h = (use) ? PdfProcessor2_s_op_h : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_re( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_re(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_re = (use) ? PdfProcessor2_s_op_re : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_S( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_S(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_S = (use) ? PdfProcessor2_s_op_S : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_s( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_s(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_s = (use) ? PdfProcessor2_s_op_s : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_F( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_F(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_F = (use) ? PdfProcessor2_s_op_F : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_f( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_f(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_f = (use) ? PdfProcessor2_s_op_f : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_fstar( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_fstar(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_fstar = (use) ? PdfProcessor2_s_op_fstar : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_B( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_B(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_B = (use) ? PdfProcessor2_s_op_B : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_Bstar( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_Bstar(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_Bstar = (use) ? PdfProcessor2_s_op_Bstar : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_b( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_b(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_b = (use) ? PdfProcessor2_s_op_b : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_bstar( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_bstar(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_bstar = (use) ? PdfProcessor2_s_op_bstar : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_n( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_n(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_n = (use) ? PdfProcessor2_s_op_n : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_W( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_W(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_W = (use) ? PdfProcessor2_s_op_W : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_Wstar( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_Wstar(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_Wstar = (use) ? PdfProcessor2_s_op_Wstar : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_BT( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_BT(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_BT = (use) ? PdfProcessor2_s_op_BT : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_ET( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_ET(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_ET = (use) ? PdfProcessor2_s_op_ET : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_Tc( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_Tc(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_Tc = (use) ? PdfProcessor2_s_op_Tc : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_Tw( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_Tw(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_Tw = (use) ? PdfProcessor2_s_op_Tw : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_Tz( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_Tz(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_Tz = (use) ? PdfProcessor2_s_op_Tz : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_TL( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_TL(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_TL = (use) ? PdfProcessor2_s_op_TL : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_Tf( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_Tf(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_Tf = (use) ? PdfProcessor2_s_op_Tf : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_Tr( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_Tr(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_Tr = (use) ? PdfProcessor2_s_op_Tr : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_Ts( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_Ts(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_Ts = (use) ? PdfProcessor2_s_op_Ts : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_Td( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_Td(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_Td = (use) ? PdfProcessor2_s_op_Td : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_TD( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_TD(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_TD = (use) ? PdfProcessor2_s_op_TD : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_Tm( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_Tm(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_Tm = (use) ? PdfProcessor2_s_op_Tm : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_Tstar( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_Tstar(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_Tstar = (use) ? PdfProcessor2_s_op_Tstar : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_TJ( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_TJ(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_TJ = (use) ? PdfProcessor2_s_op_TJ : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_Tj( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_Tj(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_Tj = (use) ? PdfProcessor2_s_op_Tj : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_squote( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_squote(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_squote = (use) ? PdfProcessor2_s_op_squote : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_dquote( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_dquote(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_dquote = (use) ? PdfProcessor2_s_op_dquote : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_d0( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_d0(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_d0 = (use) ? PdfProcessor2_s_op_d0 : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_d1( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_d1(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_d1 = (use) ? PdfProcessor2_s_op_d1 : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_CS( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_CS(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_CS = (use) ? PdfProcessor2_s_op_CS : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_cs( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_cs(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_cs = (use) ? PdfProcessor2_s_op_cs : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_SC_pattern( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_SC_pattern(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_SC_pattern = (use) ? PdfProcessor2_s_op_SC_pattern : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_sc_pattern( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_sc_pattern(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_sc_pattern = (use) ? PdfProcessor2_s_op_sc_pattern : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_SC_shade( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_SC_shade(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_SC_shade = (use) ? PdfProcessor2_s_op_SC_shade : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_sc_shade( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_sc_shade(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_sc_shade = (use) ? PdfProcessor2_s_op_sc_shade : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_SC_color( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_SC_color(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_SC_color = (use) ? PdfProcessor2_s_op_SC_color : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_sc_color( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_sc_color(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_sc_color = (use) ? PdfProcessor2_s_op_sc_color : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_G( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_G(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_G = (use) ? PdfProcessor2_s_op_G : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_g( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_g(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_g = (use) ? PdfProcessor2_s_op_g : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_RG( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_RG(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_RG = (use) ? PdfProcessor2_s_op_RG : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_rg( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_rg(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_rg = (use) ? PdfProcessor2_s_op_rg : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_K( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_K(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_K = (use) ? PdfProcessor2_s_op_K : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_k( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_k(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_k = (use) ? PdfProcessor2_s_op_k : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_BI( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_BI(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_BI = (use) ? PdfProcessor2_s_op_BI : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_sh( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_sh(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_sh = (use) ? PdfProcessor2_s_op_sh : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_Do_image( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_Do_image(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_Do_image = (use) ? PdfProcessor2_s_op_Do_image : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_Do_form( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_Do_form(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_Do_form = (use) ? PdfProcessor2_s_op_Do_form : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_MP( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_MP(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_MP = (use) ? PdfProcessor2_s_op_MP : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_DP( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_DP(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_DP = (use) ? PdfProcessor2_s_op_DP : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_BMC( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_BMC(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_BMC = (use) ? PdfProcessor2_s_op_BMC : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_BDC( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_BDC(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_BDC = (use) ? PdfProcessor2_s_op_BDC : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_EMC( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_EMC(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_EMC = (use) ? PdfProcessor2_s_op_EMC : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_BX( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_BX(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_BX = (use) ? PdfProcessor2_s_op_BX : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_EX( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_EX(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_EX = (use) ? PdfProcessor2_s_op_EX : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_gs_OP( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_gs_OP(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_gs_OP = (use) ? PdfProcessor2_s_op_gs_OP : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_gs_op( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_gs_op(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_gs_op = (use) ? PdfProcessor2_s_op_gs_op : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_gs_OPM( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_gs_OPM(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_gs_OPM = (use) ? PdfProcessor2_s_op_gs_OPM : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_gs_UseBlackPtComp( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_gs_UseBlackPtComp(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_gs_UseBlackPtComp = (use) ? PdfProcessor2_s_op_gs_UseBlackPtComp : nullptr;
}
FZ_FUNCTION void PdfProcessor2::use_virtual_op_END( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfProcessor2::use_virtual_op_END(): this=" << this << " use=" << use << "\n";
	}
	#endif
	m_internal->op_END = (use) ? PdfProcessor2_s_op_END : nullptr;
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::close_processor(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::close_processor(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::close_processor()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::drop_processor(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::drop_processor(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::drop_processor()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::reset_processor(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::reset_processor(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::reset_processor()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::push_resources(::fz_context *arg_0, ::pdf_obj *arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::push_resources(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::push_resources()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION ::pdf_obj * PdfProcessor2::pop_resources(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::pop_resources(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::pop_resources()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_w(::fz_context *arg_0, float arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_w(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_w()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_j(::fz_context *arg_0, int arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_j(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_j()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_J(::fz_context *arg_0, int arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_J(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_J()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_M(::fz_context *arg_0, float arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_M(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_M()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_d(::fz_context *arg_0, ::pdf_obj *arg_2, float arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_d(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_d()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_ri(::fz_context *arg_0, const char *arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_ri(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_ri()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_i(::fz_context *arg_0, float arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_i(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_i()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_gs_begin(::fz_context *arg_0, const char *arg_2, ::pdf_obj *arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_gs_begin(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_gs_begin()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_gs_BM(::fz_context *arg_0, const char *arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_gs_BM(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_gs_BM()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_gs_ca(::fz_context *arg_0, float arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_gs_ca(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_gs_ca()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_gs_CA(::fz_context *arg_0, float arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_gs_CA(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_gs_CA()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_gs_SMask(::fz_context *arg_0, ::pdf_obj *arg_2, float *arg_3, int arg_4, ::pdf_obj *arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_gs_SMask(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_gs_SMask()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_gs_end(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_gs_end(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_gs_end()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_q(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_q(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_q()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_Q(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Q(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Q()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_cm(::fz_context *arg_0, float arg_2, float arg_3, float arg_4, float arg_5, float arg_6, float arg_7)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_cm(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_cm()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_m(::fz_context *arg_0, float arg_2, float arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_m(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_m()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_l(::fz_context *arg_0, float arg_2, float arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_l(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_l()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_c(::fz_context *arg_0, float arg_2, float arg_3, float arg_4, float arg_5, float arg_6, float arg_7)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_c(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_c()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_v(::fz_context *arg_0, float arg_2, float arg_3, float arg_4, float arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_v(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_v()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_y(::fz_context *arg_0, float arg_2, float arg_3, float arg_4, float arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_y(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_y()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_h(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_h(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_h()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_re(::fz_context *arg_0, float arg_2, float arg_3, float arg_4, float arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_re(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_re()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_S(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_S(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_S()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_s(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_s(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_s()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_F(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_F(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_F()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_f(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_f(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_f()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_fstar(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_fstar(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_fstar()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_B(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_B(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_B()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_Bstar(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Bstar(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Bstar()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_b(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_b(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_b()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_bstar(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_bstar(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_bstar()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_n(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_n(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_n()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_W(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_W(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_W()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_Wstar(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Wstar(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Wstar()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_BT(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_BT(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_BT()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_ET(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_ET(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_ET()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_Tc(::fz_context *arg_0, float arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Tc(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Tc()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_Tw(::fz_context *arg_0, float arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Tw(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Tw()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_Tz(::fz_context *arg_0, float arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Tz(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Tz()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_TL(::fz_context *arg_0, float arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_TL(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_TL()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_Tf(::fz_context *arg_0, const char *arg_2, ::pdf_font_desc *arg_3, float arg_4)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Tf(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Tf()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_Tr(::fz_context *arg_0, int arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Tr(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Tr()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_Ts(::fz_context *arg_0, float arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Ts(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Ts()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_Td(::fz_context *arg_0, float arg_2, float arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Td(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Td()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_TD(::fz_context *arg_0, float arg_2, float arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_TD(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_TD()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_Tm(::fz_context *arg_0, float arg_2, float arg_3, float arg_4, float arg_5, float arg_6, float arg_7)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Tm(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Tm()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_Tstar(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Tstar(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Tstar()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_TJ(::fz_context *arg_0, ::pdf_obj *arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_TJ(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_TJ()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_Tj(::fz_context *arg_0, char *arg_2, unsigned long arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Tj(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Tj()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_squote(::fz_context *arg_0, char *arg_2, unsigned long arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_squote(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_squote()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_dquote(::fz_context *arg_0, float arg_2, float arg_3, char *arg_4, unsigned long arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_dquote(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_dquote()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_d0(::fz_context *arg_0, float arg_2, float arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_d0(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_d0()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_d1(::fz_context *arg_0, float arg_2, float arg_3, float arg_4, float arg_5, float arg_6, float arg_7)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_d1(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_d1()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_CS(::fz_context *arg_0, const char *arg_2, ::fz_colorspace *arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_CS(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_CS()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_cs(::fz_context *arg_0, const char *arg_2, ::fz_colorspace *arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_cs(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_cs()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_SC_pattern(::fz_context *arg_0, const char *arg_2, ::pdf_pattern *arg_3, int arg_4, float *arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_SC_pattern(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_SC_pattern()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_sc_pattern(::fz_context *arg_0, const char *arg_2, ::pdf_pattern *arg_3, int arg_4, float *arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_sc_pattern(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_sc_pattern()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_SC_shade(::fz_context *arg_0, const char *arg_2, ::fz_shade *arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_SC_shade(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_SC_shade()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_sc_shade(::fz_context *arg_0, const char *arg_2, ::fz_shade *arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_sc_shade(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_sc_shade()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_SC_color(::fz_context *arg_0, int arg_2, float *arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_SC_color(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_SC_color()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_sc_color(::fz_context *arg_0, int arg_2, float *arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_sc_color(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_sc_color()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_G(::fz_context *arg_0, float arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_G(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_G()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_g(::fz_context *arg_0, float arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_g(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_g()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_RG(::fz_context *arg_0, float arg_2, float arg_3, float arg_4)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_RG(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_RG()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_rg(::fz_context *arg_0, float arg_2, float arg_3, float arg_4)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_rg(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_rg()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_K(::fz_context *arg_0, float arg_2, float arg_3, float arg_4, float arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_K(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_K()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_k(::fz_context *arg_0, float arg_2, float arg_3, float arg_4, float arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_k(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_k()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_BI(::fz_context *arg_0, ::fz_image *arg_2, const char *arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_BI(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_BI()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_sh(::fz_context *arg_0, const char *arg_2, ::fz_shade *arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_sh(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_sh()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_Do_image(::fz_context *arg_0, const char *arg_2, ::fz_image *arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Do_image(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Do_image()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_Do_form(::fz_context *arg_0, const char *arg_2, ::pdf_obj *arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Do_form(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_Do_form()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_MP(::fz_context *arg_0, const char *arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_MP(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_MP()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_DP(::fz_context *arg_0, const char *arg_2, ::pdf_obj *arg_3, ::pdf_obj *arg_4)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_DP(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_DP()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_BMC(::fz_context *arg_0, const char *arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_BMC(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_BMC()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_BDC(::fz_context *arg_0, const char *arg_2, ::pdf_obj *arg_3, ::pdf_obj *arg_4)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_BDC(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_BDC()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_EMC(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_EMC(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_EMC()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_BX(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_BX(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_BX()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_EX(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_EX(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_EX()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_gs_OP(::fz_context *arg_0, int arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_gs_OP(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_gs_OP()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_gs_op(::fz_context *arg_0, int arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_gs_op(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_gs_op()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_gs_OPM(::fz_context *arg_0, int arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_gs_OPM(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_gs_OPM()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_gs_UseBlackPtComp(::fz_context *arg_0, ::pdf_obj *arg_2)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_gs_UseBlackPtComp(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_gs_UseBlackPtComp()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfProcessor2::op_END(::fz_context *arg_0)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_END(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfProcessor2::op_END()");
}

/* Implementation of methods for PdfRange (wrapper for pdf_range). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfRange::PdfRange()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfRange::PdfRange(::pdf_range* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfRange::~PdfRange()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfRange::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfRange::s_num_instances = 0;


/* Implementation of methods for PdfRedactOptions (wrapper for pdf_redact_options). */

/** Default constructor, sets each member to default value. */
FZ_FUNCTION PdfRedactOptions::PdfRedactOptions()
{
	this->black_boxes = {};
	this->image_method = {};
	this->line_art = {};
	this->text = {};
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfRedactOptions::PdfRedactOptions(const ::pdf_redact_options* internal)
{
	assert( internal);
	this->black_boxes = internal->black_boxes;
	this->image_method = internal->image_method;
	this->line_art = internal->line_art;
	this->text = internal->text;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfRedactOptions::PdfRedactOptions(const ::pdf_redact_options internal)
{
	this->black_boxes = internal.black_boxes;
	this->image_method = internal.image_method;
	this->line_art = internal.line_art;
	this->text = internal.text;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::pdf_redact_options`. */
FZ_FUNCTION ::pdf_redact_options* PdfRedactOptions::internal()
{
	auto ret = (::pdf_redact_options*) &this->black_boxes;
	return ret;
}

/** Constructor using raw copy of pre-existing `::pdf_redact_options`. */
FZ_FUNCTION const ::pdf_redact_options* PdfRedactOptions::internal() const
{
	auto ret = (const ::pdf_redact_options*) &this->black_boxes;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION PdfRedactOptions::~PdfRedactOptions()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfRedactOptions::s_num_instances = 0;

FZ_FUNCTION std::string PdfRedactOptions::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool PdfRedactOptions::operator==(const PdfRedactOptions& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool PdfRedactOptions::operator!=(const PdfRedactOptions& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for PdfRevPageMap (wrapper for pdf_rev_page_map). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfRevPageMap::PdfRevPageMap()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfRevPageMap::PdfRevPageMap(::pdf_rev_page_map* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfRevPageMap::~PdfRevPageMap()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfRevPageMap::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfRevPageMap::s_num_instances = 0;


/* Implementation of methods for PdfSanitizeFilterOptions (wrapper for pdf_sanitize_filter_options). */

/** Default constructor, sets each member to default value. */
FZ_FUNCTION PdfSanitizeFilterOptions::PdfSanitizeFilterOptions()
{
	this->opaque = {};
	this->image_filter = {};
	this->text_filter = {};
	this->after_text_object = {};
	this->culler = {};
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfSanitizeFilterOptions::PdfSanitizeFilterOptions(const ::pdf_sanitize_filter_options* internal)
{
	assert( internal);
	this->opaque = internal->opaque;
	this->image_filter = internal->image_filter;
	this->text_filter = internal->text_filter;
	this->after_text_object = internal->after_text_object;
	this->culler = internal->culler;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfSanitizeFilterOptions::PdfSanitizeFilterOptions(const ::pdf_sanitize_filter_options internal)
{
	this->opaque = internal.opaque;
	this->image_filter = internal.image_filter;
	this->text_filter = internal.text_filter;
	this->after_text_object = internal.after_text_object;
	this->culler = internal.culler;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::pdf_sanitize_filter_options`. */
FZ_FUNCTION ::pdf_sanitize_filter_options* PdfSanitizeFilterOptions::internal()
{
	auto ret = (::pdf_sanitize_filter_options*) &this->opaque;
	return ret;
}

/** Constructor using raw copy of pre-existing `::pdf_sanitize_filter_options`. */
FZ_FUNCTION const ::pdf_sanitize_filter_options* PdfSanitizeFilterOptions::internal() const
{
	auto ret = (const ::pdf_sanitize_filter_options*) &this->opaque;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION PdfSanitizeFilterOptions::~PdfSanitizeFilterOptions()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfSanitizeFilterOptions::s_num_instances = 0;

FZ_FUNCTION std::string PdfSanitizeFilterOptions::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool PdfSanitizeFilterOptions::operator==(const PdfSanitizeFilterOptions& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool PdfSanitizeFilterOptions::operator!=(const PdfSanitizeFilterOptions& rhs)
{
	return ::operator!=( *this, rhs);
}

/* Implementation of methods for `PdfSanitizeFilterOptions2`, virtual_fnptrs wrapper for `pdf_sanitize_filter_options`). */


FZ_FUNCTION PdfSanitizeFilterOptions2::PdfSanitizeFilterOptions2()
{

	this->opaque = this;
	
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfSanitizeFilterOptions2::PdfSanitizeFilterOptions2(): this=" << this << "\n";
	}
	#endif
}
/* Static callback, calls self->image_filter(). */
static ::fz_image * PdfSanitizeFilterOptions2_s_image_filter(::fz_context *arg_0, void *arg_1, ::fz_matrix arg_2, const char *arg_3, ::fz_image *arg_4, ::fz_rect arg_5)
{
	PdfSanitizeFilterOptions2* self = (PdfSanitizeFilterOptions2*) arg_1;
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfSanitizeFilterOptions2_s_image_filter(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->image_filter(arg_0, arg_2, arg_3, arg_4, arg_5);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfSanitizeFilterOptions2_s_image_filter(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->text_filter(). */
static int PdfSanitizeFilterOptions2_s_text_filter(::fz_context *arg_0, void *arg_1, int *arg_2, int arg_3, ::fz_matrix arg_4, ::fz_matrix arg_5, ::fz_rect arg_6)
{
	PdfSanitizeFilterOptions2* self = (PdfSanitizeFilterOptions2*) arg_1;
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfSanitizeFilterOptions2_s_text_filter(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->text_filter(arg_0, arg_2, arg_3, arg_4, arg_5, arg_6);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfSanitizeFilterOptions2_s_text_filter(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->after_text_object(). */
static void PdfSanitizeFilterOptions2_s_after_text_object(::fz_context *arg_0, void *arg_1, ::pdf_document *arg_2, ::pdf_processor *arg_3, ::fz_matrix arg_4)
{
	PdfSanitizeFilterOptions2* self = (PdfSanitizeFilterOptions2*) arg_1;
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfSanitizeFilterOptions2_s_after_text_object(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->after_text_object(arg_0, arg_2, arg_3, arg_4);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfSanitizeFilterOptions2_s_after_text_object(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
/* Static callback, calls self->culler(). */
static int PdfSanitizeFilterOptions2_s_culler(::fz_context *arg_0, void *arg_1, ::fz_rect arg_2, ::fz_cull_type arg_3)
{
	PdfSanitizeFilterOptions2* self = (PdfSanitizeFilterOptions2*) arg_1;
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfSanitizeFilterOptions2_s_culler(): arg_0=" << arg_0 << " arg_1=" << arg_1 << " self=" << self << "\n";
	}
	#endif
	try
	{
		return self->culler(arg_0, arg_2, arg_3);
	}
	catch (std::exception& e)
	{
		#ifndef NDEBUG
		if (s_trace_director)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfSanitizeFilterOptions2_s_culler(): converting std::exception to fz_throw(): " << e.what() << "\n";
		}
		#endif
		fz_throw(arg_0, FZ_ERROR_GENERIC, "%s", e.what());
	}
}
FZ_FUNCTION void PdfSanitizeFilterOptions2::use_virtual_image_filter( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfSanitizeFilterOptions2::use_virtual_image_filter(): this=" << this << " use=" << use << "\n";
	}
	#endif
	PdfSanitizeFilterOptions::image_filter = (use) ? PdfSanitizeFilterOptions2_s_image_filter : nullptr;
}
FZ_FUNCTION void PdfSanitizeFilterOptions2::use_virtual_text_filter( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfSanitizeFilterOptions2::use_virtual_text_filter(): this=" << this << " use=" << use << "\n";
	}
	#endif
	PdfSanitizeFilterOptions::text_filter = (use) ? PdfSanitizeFilterOptions2_s_text_filter : nullptr;
}
FZ_FUNCTION void PdfSanitizeFilterOptions2::use_virtual_after_text_object( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfSanitizeFilterOptions2::use_virtual_after_text_object(): this=" << this << " use=" << use << "\n";
	}
	#endif
	PdfSanitizeFilterOptions::after_text_object = (use) ? PdfSanitizeFilterOptions2_s_after_text_object : nullptr;
}
FZ_FUNCTION void PdfSanitizeFilterOptions2::use_virtual_culler( bool use)
{
	#ifndef NDEBUG
	if (s_trace_director)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": PdfSanitizeFilterOptions2::use_virtual_culler(): this=" << this << " use=" << use << "\n";
	}
	#endif
	PdfSanitizeFilterOptions::culler = (use) ? PdfSanitizeFilterOptions2_s_culler : nullptr;
}
/* Default implementation of virtual method. */
FZ_FUNCTION ::fz_image * PdfSanitizeFilterOptions2::image_filter(::fz_context *arg_0, ::fz_matrix arg_2, const char *arg_3, ::fz_image *arg_4, ::fz_rect arg_5)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfSanitizeFilterOptions2::image_filter(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfSanitizeFilterOptions2::image_filter()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION int PdfSanitizeFilterOptions2::text_filter(::fz_context *arg_0, int *arg_2, int arg_3, ::fz_matrix arg_4, ::fz_matrix arg_5, ::fz_rect arg_6)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfSanitizeFilterOptions2::text_filter(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfSanitizeFilterOptions2::text_filter()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION void PdfSanitizeFilterOptions2::after_text_object(::fz_context *arg_0, ::pdf_document *arg_2, ::pdf_processor *arg_3, ::fz_matrix arg_4)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfSanitizeFilterOptions2::after_text_object(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfSanitizeFilterOptions2::after_text_object()");
}
/* Default implementation of virtual method. */
FZ_FUNCTION int PdfSanitizeFilterOptions2::culler(::fz_context *arg_0, ::fz_rect arg_2, ::fz_cull_type arg_3)
{
	std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn PdfSanitizeFilterOptions2::culler(): this=" << this << ".\n";
	throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn PdfSanitizeFilterOptions2::culler()");
}

/* Implementation of methods for PdfTextObjectState (wrapper for pdf_text_object_state). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfTextObjectState::PdfTextObjectState()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
/* Class-aware wrapper for `::pdf_tos_get_text()`.  */
FZ_FUNCTION FzText PdfTextObjectState::pdf_tos_get_text() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_tos_get_text()\n";
	}
	#endif
	auto ret = mupdf::pdf_tos_get_text(*this);
	return ret;
}

/* Class-aware wrapper for `::pdf_tos_make_trm()`.  */
FZ_FUNCTION int PdfTextObjectState::pdf_tos_make_trm(const PdfTextState& text, const PdfFontDesc& fontdesc, int cid, FzMatrix& trm) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_tos_make_trm()\n";
	}
	#endif
	auto ret = mupdf::pdf_tos_make_trm(*this, text, fontdesc, cid, trm);
	return ret;
}

/* Class-aware wrapper for `::pdf_tos_move_after_char()`.  */
FZ_FUNCTION void PdfTextObjectState::pdf_tos_move_after_char() const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_tos_move_after_char()\n";
	}
	#endif
	mupdf::pdf_tos_move_after_char(*this);
}

/* Class-aware wrapper for `::pdf_tos_newline()`.  */
FZ_FUNCTION void PdfTextObjectState::pdf_tos_newline(float leading) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_tos_newline()\n";
	}
	#endif
	mupdf::pdf_tos_newline(*this, leading);
}

/* Class-aware wrapper for `::pdf_tos_reset()`.  */
FZ_FUNCTION void PdfTextObjectState::pdf_tos_reset(int render) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_tos_reset()\n";
	}
	#endif
	mupdf::pdf_tos_reset(*this, render);
}

/* Class-aware wrapper for `::pdf_tos_set_matrix()`.  */
FZ_FUNCTION void PdfTextObjectState::pdf_tos_set_matrix(float a, float b, float c, float d, float e, float f) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_tos_set_matrix()\n";
	}
	#endif
	mupdf::pdf_tos_set_matrix(*this, a, b, c, d, e, f);
}

/* Class-aware wrapper for `::pdf_tos_translate()`.  */
FZ_FUNCTION void PdfTextObjectState::pdf_tos_translate(float tx, float ty) const
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_tos_translate()\n";
	}
	#endif
	mupdf::pdf_tos_translate(*this, tx, ty);
}

FZ_FUNCTION PdfTextObjectState::PdfTextObjectState(::pdf_text_object_state* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfTextObjectState::~PdfTextObjectState()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfTextObjectState::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfTextObjectState::s_num_instances = 0;


/* Implementation of methods for PdfTextState (wrapper for pdf_text_state). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfTextState::PdfTextState()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfTextState::PdfTextState(::pdf_text_state* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfTextState::~PdfTextState()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfTextState::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfTextState::s_num_instances = 0;


/* Implementation of methods for PdfUnsavedSig (wrapper for pdf_unsaved_sig). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfUnsavedSig::PdfUnsavedSig()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfUnsavedSig::PdfUnsavedSig(::pdf_unsaved_sig* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfUnsavedSig::~PdfUnsavedSig()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfUnsavedSig::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfUnsavedSig::s_num_instances = 0;


/* Implementation of methods for PdfVmtx (wrapper for pdf_vmtx). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfVmtx::PdfVmtx()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfVmtx::PdfVmtx(::pdf_vmtx* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfVmtx::~PdfVmtx()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfVmtx::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfVmtx::s_num_instances = 0;


/* Implementation of methods for PdfWriteOptions (wrapper for pdf_write_options). */

/** Custom constructor. */
FZ_FUNCTION PdfWriteOptions::PdfWriteOptions()
{
	/* Use memcpy() otherwise we get 'invalid array assignment' errors. */
	memcpy(this->internal(), &pdf_default_write_options, sizeof(*this->internal()));
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Custom constructor. */
FZ_FUNCTION PdfWriteOptions::PdfWriteOptions(const PdfWriteOptions& rhs)
{
	*this = rhs;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/* Class-aware wrapper for `::pdf_parse_write_options()`.  */
FZ_FUNCTION PdfWriteOptions PdfWriteOptions::pdf_parse_write_options(const char *args)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_parse_write_options()\n";
	}
	#endif
	auto ret = mupdf::pdf_parse_write_options(*this, args);
	return ret;
}

/** Custom method. */
FZ_FUNCTION PdfWriteOptions& PdfWriteOptions::operator=(const PdfWriteOptions& rhs)
{
	memcpy(this->internal(), rhs.internal(), sizeof(*this->internal()));
	return *this;
}

/** Custom method. */
FZ_FUNCTION void PdfWriteOptions::opwd_utf8_set_value(const std::string& text)
{
	size_t len = std::min(text.size(), sizeof(opwd_utf8) - 1);
	memcpy(opwd_utf8, text.c_str(), len);
	opwd_utf8[len] = 0;
}

/** Custom method. */
FZ_FUNCTION void PdfWriteOptions::upwd_utf8_set_value(const std::string& text)
{
	size_t len = std::min(text.size(), sizeof(upwd_utf8) - 1);
	memcpy(upwd_utf8, text.c_str(), len);
	upwd_utf8[len] = 0;
}

FZ_FUNCTION PdfWriteOptions::PdfWriteOptions(const ::pdf_write_options* internal)
{
	assert( internal);
	this->do_incremental = internal->do_incremental;
	this->do_pretty = internal->do_pretty;
	this->do_ascii = internal->do_ascii;
	this->do_compress = internal->do_compress;
	this->do_compress_images = internal->do_compress_images;
	this->do_compress_fonts = internal->do_compress_fonts;
	this->do_decompress = internal->do_decompress;
	this->do_garbage = internal->do_garbage;
	this->do_linear = internal->do_linear;
	this->do_clean = internal->do_clean;
	this->do_sanitize = internal->do_sanitize;
	this->do_appearance = internal->do_appearance;
	this->do_encrypt = internal->do_encrypt;
	this->dont_regenerate_id = internal->dont_regenerate_id;
	this->permissions = internal->permissions;
	memcpy(this->opwd_utf8, internal->opwd_utf8, sizeof(this->opwd_utf8));
	memcpy(this->upwd_utf8, internal->upwd_utf8, sizeof(this->upwd_utf8));
	this->do_snapshot = internal->do_snapshot;
	this->do_preserve_metadata = internal->do_preserve_metadata;
	this->do_use_objstms = internal->do_use_objstms;
	this->compression_effort = internal->compression_effort;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

FZ_FUNCTION PdfWriteOptions::PdfWriteOptions(const ::pdf_write_options internal)
{
	this->do_incremental = internal.do_incremental;
	this->do_pretty = internal.do_pretty;
	this->do_ascii = internal.do_ascii;
	this->do_compress = internal.do_compress;
	this->do_compress_images = internal.do_compress_images;
	this->do_compress_fonts = internal.do_compress_fonts;
	this->do_decompress = internal.do_decompress;
	this->do_garbage = internal.do_garbage;
	this->do_linear = internal.do_linear;
	this->do_clean = internal.do_clean;
	this->do_sanitize = internal.do_sanitize;
	this->do_appearance = internal.do_appearance;
	this->do_encrypt = internal.do_encrypt;
	this->dont_regenerate_id = internal.dont_regenerate_id;
	this->permissions = internal.permissions;
	memcpy(this->opwd_utf8, &internal.opwd_utf8, sizeof(this->opwd_utf8));
	memcpy(this->upwd_utf8, &internal.upwd_utf8, sizeof(this->upwd_utf8));
	this->do_snapshot = internal.do_snapshot;
	this->do_preserve_metadata = internal.do_preserve_metadata;
	this->do_use_objstms = internal.do_use_objstms;
	this->compression_effort = internal.compression_effort;
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Constructor using raw copy of pre-existing `::pdf_write_options`. */
FZ_FUNCTION ::pdf_write_options* PdfWriteOptions::internal()
{
	auto ret = (::pdf_write_options*) &this->do_incremental;
	return ret;
}

/** Constructor using raw copy of pre-existing `::pdf_write_options`. */
FZ_FUNCTION const ::pdf_write_options* PdfWriteOptions::internal() const
{
	auto ret = (const ::pdf_write_options*) &this->do_incremental;
	return ret;
}

#ifndef NDEBUG
FZ_FUNCTION PdfWriteOptions::~PdfWriteOptions()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfWriteOptions::s_num_instances = 0;

FZ_FUNCTION std::string PdfWriteOptions::to_string()
{
	std::ostringstream buffer;
	buffer << *this;
	return buffer.str();
}

FZ_FUNCTION bool PdfWriteOptions::operator==(const PdfWriteOptions& rhs)
{
	return ::operator==( *this, rhs);
}

FZ_FUNCTION bool PdfWriteOptions::operator!=(const PdfWriteOptions& rhs)
{
	return ::operator!=( *this, rhs);
}


/* Implementation of methods for PdfXrange (wrapper for pdf_xrange). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfXrange::PdfXrange()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfXrange::PdfXrange(::pdf_xrange* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfXrange::~PdfXrange()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfXrange::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfXrange::s_num_instances = 0;


/* Implementation of methods for PdfXref (wrapper for pdf_xref). */

/* Constructor using `pdf_new_local_xref()`. */
FZ_FUNCTION PdfXref::PdfXref(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_local_xref()\n";
	}
	#endif
	this->m_internal = ll_pdf_new_local_xref(doc.m_internal);
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfXref::PdfXref()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfXref::PdfXref(::pdf_xref* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfXref::~PdfXref()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfXref::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfXref::s_num_instances = 0;


/* Implementation of methods for PdfXrefEntry (wrapper for pdf_xref_entry). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfXrefEntry::PdfXrefEntry()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfXrefEntry::PdfXrefEntry(::pdf_xref_entry* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfXrefEntry::~PdfXrefEntry()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfXrefEntry::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfXrefEntry::s_num_instances = 0;


/* Implementation of methods for PdfXrefSubsec (wrapper for pdf_xref_subsec). */

/** Default constructor, sets `m_internal` to null. */
FZ_FUNCTION PdfXrefSubsec::PdfXrefSubsec()
: m_internal(nullptr)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
};
FZ_FUNCTION PdfXrefSubsec::PdfXrefSubsec(::pdf_xref_subsec* internal)
: m_internal(internal)
{
	#ifndef NDEBUG
	++s_num_instances;
	#endif
}

#ifndef NDEBUG
FZ_FUNCTION PdfXrefSubsec::~PdfXrefSubsec()
{
	#ifndef NDEBUG
	--s_num_instances;
	#endif
}
#endif

/** Custom method. */
FZ_FUNCTION long long PdfXrefSubsec::m_internal_value()
{
	return (uintptr_t) m_internal;
}

/* Ideally this would be in `#ifndef NDEBUG...#endif`, but Swig will
generate code regardless so we always need to have this available. */
int PdfXrefSubsec::s_num_instances = 0;

FZ_FUNCTION std::map<std::string, int> num_instances()
{
	std::map<std::string, int> ret;
	ret["FzAaContext"] = FzAaContext::s_num_instances;
	ret["FzAes"] = FzAes::s_num_instances;
	ret["FzAllocContext"] = FzAllocContext::s_num_instances;
	ret["FzArc4"] = FzArc4::s_num_instances;
	ret["FzArchive"] = FzArchive::s_num_instances;
	ret["FzArchiveHandler"] = FzArchiveHandler::s_num_instances;
	ret["FzArchiveHandlerContext"] = FzArchiveHandlerContext::s_num_instances;
	ret["FzBandWriter"] = FzBandWriter::s_num_instances;
	ret["FzBitmap"] = FzBitmap::s_num_instances;
	ret["FzBuffer"] = FzBuffer::s_num_instances;
	ret["FzColorParams"] = FzColorParams::s_num_instances;
	ret["FzColorspace"] = FzColorspace::s_num_instances;
	ret["FzColorspaceContext"] = FzColorspaceContext::s_num_instances;
	ret["FzCompressedBuffer"] = FzCompressedBuffer::s_num_instances;
	ret["FzCompressedImage"] = FzCompressedImage::s_num_instances;
	ret["FzCompressionParams"] = FzCompressionParams::s_num_instances;
	ret["FzContext"] = FzContext::s_num_instances;
	ret["FzCookie"] = FzCookie::s_num_instances;
	ret["FzDefaultColorspaces"] = FzDefaultColorspaces::s_num_instances;
	ret["FzDevice"] = FzDevice::s_num_instances;
	ret["FzDeviceContainerStack"] = FzDeviceContainerStack::s_num_instances;
	ret["FzDisplayList"] = FzDisplayList::s_num_instances;
	ret["FzDocument"] = FzDocument::s_num_instances;
	ret["FzDocumentHandler"] = FzDocumentHandler::s_num_instances;
	ret["FzDocumentHandlerContext"] = FzDocumentHandlerContext::s_num_instances;
	ret["FzDocumentWriter"] = FzDocumentWriter::s_num_instances;
	ret["FzDrawOptions"] = FzDrawOptions::s_num_instances;
	ret["FzErrorContext"] = FzErrorContext::s_num_instances;
	ret["FzErrorStackSlot"] = FzErrorStackSlot::s_num_instances;
	ret["FzFont"] = FzFont::s_num_instances;
	ret["FzFontContext"] = FzFontContext::s_num_instances;
	ret["FzFontFlagsT"] = FzFontFlagsT::s_num_instances;
	ret["FzFunction"] = FzFunction::s_num_instances;
	ret["FzGetoptLongOptions"] = FzGetoptLongOptions::s_num_instances;
	ret["FzGlyph"] = FzGlyph::s_num_instances;
	ret["FzGlyphCache"] = FzGlyphCache::s_num_instances;
	ret["FzHalftone"] = FzHalftone::s_num_instances;
	ret["FzHashTable"] = FzHashTable::s_num_instances;
	ret["FzIccProfile"] = FzIccProfile::s_num_instances;
	ret["FzImage"] = FzImage::s_num_instances;
	ret["FzInstallLoadSystemFontFuncsArgs"] = FzInstallLoadSystemFontFuncsArgs::s_num_instances;
	ret["FzInt2"] = FzInt2::s_num_instances;
	ret["FzInt2Heap"] = FzInt2Heap::s_num_instances;
	ret["FzIntHeap"] = FzIntHeap::s_num_instances;
	ret["FzIntptr"] = FzIntptr::s_num_instances;
	ret["FzIntptrHeap"] = FzIntptrHeap::s_num_instances;
	ret["FzIrect"] = FzIrect::s_num_instances;
	ret["FzJbig2Globals"] = FzJbig2Globals::s_num_instances;
	ret["FzKeyStorable"] = FzKeyStorable::s_num_instances;
	ret["FzLayoutBlock"] = FzLayoutBlock::s_num_instances;
	ret["FzLayoutChar"] = FzLayoutChar::s_num_instances;
	ret["FzLayoutLine"] = FzLayoutLine::s_num_instances;
	ret["FzLink"] = FzLink::s_num_instances;
	ret["FzLinkDest"] = FzLinkDest::s_num_instances;
	ret["FzLocation"] = FzLocation::s_num_instances;
	ret["FzLocksContext"] = FzLocksContext::s_num_instances;
	ret["FzMatrix"] = FzMatrix::s_num_instances;
	ret["FzMd5"] = FzMd5::s_num_instances;
	ret["FzOutline"] = FzOutline::s_num_instances;
	ret["FzOutlineItem"] = FzOutlineItem::s_num_instances;
	ret["FzOutlineIterator"] = FzOutlineIterator::s_num_instances;
	ret["FzOutput"] = FzOutput::s_num_instances;
	ret["FzOverprint"] = FzOverprint::s_num_instances;
	ret["FzPage"] = FzPage::s_num_instances;
	ret["FzPath"] = FzPath::s_num_instances;
	ret["FzPathWalker"] = FzPathWalker::s_num_instances;
	ret["FzPclOptions"] = FzPclOptions::s_num_instances;
	ret["FzPclmOptions"] = FzPclmOptions::s_num_instances;
	ret["FzPdfocrOptions"] = FzPdfocrOptions::s_num_instances;
	ret["FzPixmap"] = FzPixmap::s_num_instances;
	ret["FzPixmapImage"] = FzPixmapImage::s_num_instances;
	ret["FzPoint"] = FzPoint::s_num_instances;
	ret["FzPool"] = FzPool::s_num_instances;
	ret["FzPtrHeap"] = FzPtrHeap::s_num_instances;
	ret["FzPwgOptions"] = FzPwgOptions::s_num_instances;
	ret["FzQuad"] = FzQuad::s_num_instances;
	ret["FzRange"] = FzRange::s_num_instances;
	ret["FzRect"] = FzRect::s_num_instances;
	ret["FzSeparations"] = FzSeparations::s_num_instances;
	ret["FzSha256"] = FzSha256::s_num_instances;
	ret["FzSha384"] = FzSha384::s_num_instances;
	ret["FzSha512"] = FzSha512::s_num_instances;
	ret["FzShade"] = FzShade::s_num_instances;
	ret["FzShadeColorCache"] = FzShadeColorCache::s_num_instances;
	ret["FzShaperDataT"] = FzShaperDataT::s_num_instances;
	ret["FzStextBlock"] = FzStextBlock::s_num_instances;
	ret["FzStextChar"] = FzStextChar::s_num_instances;
	ret["FzStextLine"] = FzStextLine::s_num_instances;
	ret["FzStextOptions"] = FzStextOptions::s_num_instances;
	ret["FzStextPage"] = FzStextPage::s_num_instances;
	ret["FzStorable"] = FzStorable::s_num_instances;
	ret["FzStore"] = FzStore::s_num_instances;
	ret["FzStoreHash"] = FzStoreHash::s_num_instances;
	ret["FzStoreType"] = FzStoreType::s_num_instances;
	ret["FzStory"] = FzStory::s_num_instances;
	ret["FzStoryElementPosition"] = FzStoryElementPosition::s_num_instances;
	ret["FzStream"] = FzStream::s_num_instances;
	ret["FzString"] = FzString::s_num_instances;
	ret["FzStrokeState"] = FzStrokeState::s_num_instances;
	ret["FzStyleContext"] = FzStyleContext::s_num_instances;
	ret["FzText"] = FzText::s_num_instances;
	ret["FzTextDecoder"] = FzTextDecoder::s_num_instances;
	ret["FzTextItem"] = FzTextItem::s_num_instances;
	ret["FzTextSpan"] = FzTextSpan::s_num_instances;
	ret["FzTransition"] = FzTransition::s_num_instances;
	ret["FzTree"] = FzTree::s_num_instances;
	ret["FzTuningContext"] = FzTuningContext::s_num_instances;
	ret["FzVertex"] = FzVertex::s_num_instances;
	ret["FzWarnContext"] = FzWarnContext::s_num_instances;
	ret["FzWriteStoryPosition"] = FzWriteStoryPosition::s_num_instances;
	ret["FzWriteStoryPositions"] = FzWriteStoryPositions::s_num_instances;
	ret["FzXml"] = FzXml::s_num_instances;
	ret["FzXmlDoc"] = FzXmlDoc::s_num_instances;
	ret["FzZipWriter"] = FzZipWriter::s_num_instances;
	ret["PdfAlertEvent"] = PdfAlertEvent::s_num_instances;
	ret["PdfAnnot"] = PdfAnnot::s_num_instances;
	ret["PdfCleanOptions"] = PdfCleanOptions::s_num_instances;
	ret["PdfCmap"] = PdfCmap::s_num_instances;
	ret["PdfColorFilterOptions"] = PdfColorFilterOptions::s_num_instances;
	ret["PdfCrypt"] = PdfCrypt::s_num_instances;
	ret["PdfCsi"] = PdfCsi::s_num_instances;
	ret["PdfCycleList"] = PdfCycleList::s_num_instances;
	ret["PdfDocEvent"] = PdfDocEvent::s_num_instances;
	ret["PdfDocument"] = PdfDocument::s_num_instances;
	ret["PdfEmbeddedFileParams"] = PdfEmbeddedFileParams::s_num_instances;
	ret["PdfFilterFactory"] = PdfFilterFactory::s_num_instances;
	ret["PdfFilterOptions"] = PdfFilterOptions::s_num_instances;
	ret["PdfFontDesc"] = PdfFontDesc::s_num_instances;
	ret["PdfFontResourceKey"] = PdfFontResourceKey::s_num_instances;
	ret["PdfFunction"] = PdfFunction::s_num_instances;
	ret["PdfGraftMap"] = PdfGraftMap::s_num_instances;
	ret["PdfGstate"] = PdfGstate::s_num_instances;
	ret["PdfHintPage"] = PdfHintPage::s_num_instances;
	ret["PdfHintShared"] = PdfHintShared::s_num_instances;
	ret["PdfHmtx"] = PdfHmtx::s_num_instances;
	ret["PdfImageRewriterOptions"] = PdfImageRewriterOptions::s_num_instances;
	ret["PdfJournal"] = PdfJournal::s_num_instances;
	ret["PdfJs"] = PdfJs::s_num_instances;
	ret["PdfJsConsole"] = PdfJsConsole::s_num_instances;
	ret["PdfKeystrokeEvent"] = PdfKeystrokeEvent::s_num_instances;
	ret["PdfLaunchUrlEvent"] = PdfLaunchUrlEvent::s_num_instances;
	ret["PdfLayerConfig"] = PdfLayerConfig::s_num_instances;
	ret["PdfLayerConfigUi"] = PdfLayerConfigUi::s_num_instances;
	ret["PdfLexbuf"] = PdfLexbuf::s_num_instances;
	ret["PdfLexbufLarge"] = PdfLexbufLarge::s_num_instances;
	ret["PdfLockedFields"] = PdfLockedFields::s_num_instances;
	ret["PdfMailDocEvent"] = PdfMailDocEvent::s_num_instances;
	ret["PdfMarkBits"] = PdfMarkBits::s_num_instances;
	ret["PdfMarkList"] = PdfMarkList::s_num_instances;
	ret["PdfMrange"] = PdfMrange::s_num_instances;
	ret["PdfObj"] = PdfObj::s_num_instances;
	ret["PdfOcgDescriptor"] = PdfOcgDescriptor::s_num_instances;
	ret["PdfPage"] = PdfPage::s_num_instances;
	ret["PdfPattern"] = PdfPattern::s_num_instances;
	ret["PdfPkcs7DistinguishedName"] = PdfPkcs7DistinguishedName::s_num_instances;
	ret["PdfPkcs7Signer"] = PdfPkcs7Signer::s_num_instances;
	ret["PdfPkcs7Verifier"] = PdfPkcs7Verifier::s_num_instances;
	ret["PdfProcessor"] = PdfProcessor::s_num_instances;
	ret["PdfRange"] = PdfRange::s_num_instances;
	ret["PdfRedactOptions"] = PdfRedactOptions::s_num_instances;
	ret["PdfRevPageMap"] = PdfRevPageMap::s_num_instances;
	ret["PdfSanitizeFilterOptions"] = PdfSanitizeFilterOptions::s_num_instances;
	ret["PdfTextObjectState"] = PdfTextObjectState::s_num_instances;
	ret["PdfTextState"] = PdfTextState::s_num_instances;
	ret["PdfUnsavedSig"] = PdfUnsavedSig::s_num_instances;
	ret["PdfVmtx"] = PdfVmtx::s_num_instances;
	ret["PdfWriteOptions"] = PdfWriteOptions::s_num_instances;
	ret["PdfXrange"] = PdfXrange::s_num_instances;
	ret["PdfXref"] = PdfXref::s_num_instances;
	ret["PdfXrefEntry"] = PdfXrefEntry::s_num_instances;
	ret["PdfXrefSubsec"] = PdfXrefSubsec::s_num_instances;
	
	return ret;
}

} /* End of namespace mupdf. */

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::FzAaContext& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::FzAaContext& lhs, const mupdf::FzAaContext& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::FzAaContext& lhs, const mupdf::FzAaContext& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::FzColorParams& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::FzColorParams& lhs, const mupdf::FzColorParams& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::FzColorParams& lhs, const mupdf::FzColorParams& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::FzCookie& rhs)
{
	return out << rhs.m_internal;
}

FZ_FUNCTION bool operator==( const mupdf::FzCookie& lhs, const mupdf::FzCookie& rhs)
{
	return lhs.m_internal == rhs.m_internal;
}

FZ_FUNCTION bool operator!=( const mupdf::FzCookie& lhs, const mupdf::FzCookie& rhs)
{
	return lhs.m_internal != rhs.m_internal;
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::FzDrawOptions& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::FzDrawOptions& lhs, const mupdf::FzDrawOptions& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::FzDrawOptions& lhs, const mupdf::FzDrawOptions& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::FzInstallLoadSystemFontFuncsArgs& rhs)
{
	return out << rhs.m_internal;
}

FZ_FUNCTION bool operator==( const mupdf::FzInstallLoadSystemFontFuncsArgs& lhs, const mupdf::FzInstallLoadSystemFontFuncsArgs& rhs)
{
	return lhs.m_internal == rhs.m_internal;
}

FZ_FUNCTION bool operator!=( const mupdf::FzInstallLoadSystemFontFuncsArgs& lhs, const mupdf::FzInstallLoadSystemFontFuncsArgs& rhs)
{
	return lhs.m_internal != rhs.m_internal;
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::FzIrect& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::FzIrect& lhs, const mupdf::FzIrect& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::FzIrect& lhs, const mupdf::FzIrect& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::FzLocation& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::FzLocation& lhs, const mupdf::FzLocation& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::FzLocation& lhs, const mupdf::FzLocation& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::FzMatrix& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::FzMatrix& lhs, const mupdf::FzMatrix& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::FzMatrix& lhs, const mupdf::FzMatrix& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::FzMd5& rhs)
{
	return out << rhs.m_internal;
}

FZ_FUNCTION bool operator==( const mupdf::FzMd5& lhs, const mupdf::FzMd5& rhs)
{
	return lhs.m_internal == rhs.m_internal;
}

FZ_FUNCTION bool operator!=( const mupdf::FzMd5& lhs, const mupdf::FzMd5& rhs)
{
	return lhs.m_internal != rhs.m_internal;
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::FzPdfocrOptions& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::FzPdfocrOptions& lhs, const mupdf::FzPdfocrOptions& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::FzPdfocrOptions& lhs, const mupdf::FzPdfocrOptions& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::FzPoint& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::FzPoint& lhs, const mupdf::FzPoint& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::FzPoint& lhs, const mupdf::FzPoint& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::FzPwgOptions& rhs)
{
	return out << rhs.m_internal;
}

FZ_FUNCTION bool operator==( const mupdf::FzPwgOptions& lhs, const mupdf::FzPwgOptions& rhs)
{
	return lhs.m_internal == rhs.m_internal;
}

FZ_FUNCTION bool operator!=( const mupdf::FzPwgOptions& lhs, const mupdf::FzPwgOptions& rhs)
{
	return lhs.m_internal != rhs.m_internal;
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::FzQuad& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::FzQuad& lhs, const mupdf::FzQuad& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::FzQuad& lhs, const mupdf::FzQuad& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::FzRect& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::FzRect& lhs, const mupdf::FzRect& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::FzRect& lhs, const mupdf::FzRect& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::FzStextOptions& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::FzStextOptions& lhs, const mupdf::FzStextOptions& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::FzStextOptions& lhs, const mupdf::FzStextOptions& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::FzStoryElementPosition& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::FzStoryElementPosition& lhs, const mupdf::FzStoryElementPosition& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::FzStoryElementPosition& lhs, const mupdf::FzStoryElementPosition& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::FzTransition& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::FzTransition& lhs, const mupdf::FzTransition& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::FzTransition& lhs, const mupdf::FzTransition& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::PdfCleanOptions& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::PdfCleanOptions& lhs, const mupdf::PdfCleanOptions& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::PdfCleanOptions& lhs, const mupdf::PdfCleanOptions& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::PdfFilterFactory& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::PdfFilterFactory& lhs, const mupdf::PdfFilterFactory& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::PdfFilterFactory& lhs, const mupdf::PdfFilterFactory& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::PdfFilterOptions& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::PdfFilterOptions& lhs, const mupdf::PdfFilterOptions& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::PdfFilterOptions& lhs, const mupdf::PdfFilterOptions& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::PdfImageRewriterOptions& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::PdfImageRewriterOptions& lhs, const mupdf::PdfImageRewriterOptions& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::PdfImageRewriterOptions& lhs, const mupdf::PdfImageRewriterOptions& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::PdfLayerConfig& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::PdfLayerConfig& lhs, const mupdf::PdfLayerConfig& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::PdfLayerConfig& lhs, const mupdf::PdfLayerConfig& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::PdfLayerConfigUi& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::PdfLayerConfigUi& lhs, const mupdf::PdfLayerConfigUi& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::PdfLayerConfigUi& lhs, const mupdf::PdfLayerConfigUi& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::PdfRedactOptions& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::PdfRedactOptions& lhs, const mupdf::PdfRedactOptions& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::PdfRedactOptions& lhs, const mupdf::PdfRedactOptions& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::PdfSanitizeFilterOptions& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::PdfSanitizeFilterOptions& lhs, const mupdf::PdfSanitizeFilterOptions& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::PdfSanitizeFilterOptions& lhs, const mupdf::PdfSanitizeFilterOptions& rhs)
{
	return *lhs.internal() != *rhs.internal();
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const mupdf::PdfWriteOptions& rhs)
{
	return out << *rhs.internal();
}

FZ_FUNCTION bool operator==( const mupdf::PdfWriteOptions& lhs, const mupdf::PdfWriteOptions& rhs)
{
	return *lhs.internal() == *rhs.internal();
}

FZ_FUNCTION bool operator!=( const mupdf::PdfWriteOptions& lhs, const mupdf::PdfWriteOptions& rhs)
{
	return *lhs.internal() != *rhs.internal();
}
