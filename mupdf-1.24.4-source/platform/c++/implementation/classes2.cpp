/**
This file was auto-generated by mupdfwrap.py.
*/


#include "mupdf/classes2.h"
#include "mupdf/exceptions.h"
#include "mupdf/internal.h"

#include "mupdf/fitz/geometry.h"

#include <map>
#include <mutex>
#include <sstream>
#include <string.h>
#include <thread>

#include <string.h>

#ifndef NDEBUG
	static const int    s_trace = mupdf::internal_env_flag("MUPDF_trace");
#else
	static const int    s_trace = mupdf::internal_env_flag_check_unset("#ifndef NDEBUG", "MUPDF_trace");
#endif

namespace mupdf
{

/* Class-aware wrapper for `::fz_aa_level()`.  */
FZ_FUNCTION int fz_aa_level()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_aa_level()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_aa_level();
	return ret;
}


/* Class-aware wrapper for `::fz_abs()`.  */
FZ_FUNCTION float fz_abs(float f)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_abs()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_abs(f);
	return ret;
}


/* Class-aware wrapper for `::fz_absi()`.  */
FZ_FUNCTION int fz_absi(int i)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_absi()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_absi(i);
	return ret;
}


/* Class-aware wrapper for `::fz_add_layout_char()`.  */
FZ_FUNCTION void fz_add_layout_char(const FzLayoutBlock& block, float x, float w, const char *p)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_add_layout_char()\n";
	}
	#endif
	mupdf::ll_fz_add_layout_char(block.m_internal, x, w, p);
}


/* Class-aware wrapper for `::fz_add_layout_line()`.  */
FZ_FUNCTION void fz_add_layout_line(const FzLayoutBlock& block, float x, float y, float h, const char *p)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_add_layout_line()\n";
	}
	#endif
	mupdf::ll_fz_add_layout_line(block.m_internal, x, y, h, p);
}


/* Class-aware wrapper for `::fz_add_separation()`.  */
FZ_FUNCTION void fz_add_separation(const FzSeparations& sep, const char *name, const FzColorspace& cs, int cs_channel)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_add_separation()\n";
	}
	#endif
	mupdf::ll_fz_add_separation(sep.m_internal, name, cs.m_internal, cs_channel);
}


/* Class-aware wrapper for `::fz_add_separation_equivalents()`.  */
FZ_FUNCTION void fz_add_separation_equivalents(const FzSeparations& sep, uint32_t rgba, uint32_t cmyk, const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_add_separation_equivalents()\n";
	}
	#endif
	mupdf::ll_fz_add_separation_equivalents(sep.m_internal, rgba, cmyk, name);
}


/* Class-aware wrapper for `::fz_adjust_rect_for_stroke()`.  */
FZ_FUNCTION FzRect fz_adjust_rect_for_stroke(const FzRect& rect, const FzStrokeState& stroke, const FzMatrix& ctm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_adjust_rect_for_stroke()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_fz_adjust_rect_for_stroke(* rect.internal(), stroke.m_internal, * ctm.internal());
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_advance_glyph()`.  */
FZ_FUNCTION float fz_advance_glyph(const FzFont& font, int glyph, int wmode)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_advance_glyph()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_advance_glyph(font.m_internal, glyph, wmode);
	return ret;
}


/* Class-aware wrapper for `::fz_aes_crypt_cbc()`.  */
FZ_FUNCTION void fz_aes_crypt_cbc(const FzAes& ctx, int mode, size_t length, unsigned char iv[16], const unsigned char *input, unsigned char *output)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_aes_crypt_cbc()\n";
	}
	#endif
	mupdf::ll_fz_aes_crypt_cbc(ctx.m_internal, mode, length, iv, input, output);
}


/* Class-aware wrapper for `::fz_aes_setkey_dec()`.  */
FZ_FUNCTION int fz_aes_setkey_dec(const FzAes& ctx, const unsigned char *key, int keysize)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_aes_setkey_dec()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_aes_setkey_dec(ctx.m_internal, key, keysize);
	return ret;
}


/* Class-aware wrapper for `::fz_aes_setkey_enc()`.  */
FZ_FUNCTION int fz_aes_setkey_enc(const FzAes& ctx, const unsigned char *key, int keysize)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_aes_setkey_enc()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_aes_setkey_enc(ctx.m_internal, key, keysize);
	return ret;
}


/* Class-aware wrapper for `::fz_alpha_from_gray()`.  */
FZ_FUNCTION FzPixmap fz_alpha_from_gray(const FzPixmap& gray)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_alpha_from_gray()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_alpha_from_gray(gray.m_internal);
	ll_fz_keep_pixmap(temp);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_append_base64()`.  */
FZ_FUNCTION void fz_append_base64(const FzBuffer& out, const unsigned char *data, size_t size, int newline)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_base64()\n";
	}
	#endif
	mupdf::ll_fz_append_base64(out.m_internal, data, size, newline);
}


/* Class-aware wrapper for `::fz_append_base64_buffer()`.  */
FZ_FUNCTION void fz_append_base64_buffer(const FzBuffer& out, const FzBuffer& data, int newline)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_base64_buffer()\n";
	}
	#endif
	mupdf::ll_fz_append_base64_buffer(out.m_internal, data.m_internal, newline);
}


/* Class-aware wrapper for `::fz_append_bits()`.  */
FZ_FUNCTION void fz_append_bits(const FzBuffer& buf, int value, int count)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_bits()\n";
	}
	#endif
	mupdf::ll_fz_append_bits(buf.m_internal, value, count);
}


/* Class-aware wrapper for `::fz_append_bits_pad()`.  */
FZ_FUNCTION void fz_append_bits_pad(const FzBuffer& buf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_bits_pad()\n";
	}
	#endif
	mupdf::ll_fz_append_bits_pad(buf.m_internal);
}


/* Class-aware wrapper for `::fz_append_buffer()`.  */
FZ_FUNCTION void fz_append_buffer(const FzBuffer& destination, const FzBuffer& source)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_buffer()\n";
	}
	#endif
	mupdf::ll_fz_append_buffer(destination.m_internal, source.m_internal);
}


/* Class-aware wrapper for `::fz_append_byte()`.  */
FZ_FUNCTION void fz_append_byte(const FzBuffer& buf, int c)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_byte()\n";
	}
	#endif
	mupdf::ll_fz_append_byte(buf.m_internal, c);
}


/* Class-aware wrapper for `::fz_append_data()`.  */
FZ_FUNCTION void fz_append_data(const FzBuffer& buf, const void *data, size_t len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_data()\n";
	}
	#endif
	mupdf::ll_fz_append_data(buf.m_internal, data, len);
}


/* Class-aware wrapper for `::fz_append_image_as_data_uri()`.  */
FZ_FUNCTION void fz_append_image_as_data_uri(const FzBuffer& out, const FzImage& image)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_image_as_data_uri()\n";
	}
	#endif
	mupdf::ll_fz_append_image_as_data_uri(out.m_internal, image.m_internal);
}


/* Class-aware wrapper for `::fz_append_int16_be()`.  */
FZ_FUNCTION void fz_append_int16_be(const FzBuffer& buf, int x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_int16_be()\n";
	}
	#endif
	mupdf::ll_fz_append_int16_be(buf.m_internal, x);
}


/* Class-aware wrapper for `::fz_append_int16_le()`.  */
FZ_FUNCTION void fz_append_int16_le(const FzBuffer& buf, int x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_int16_le()\n";
	}
	#endif
	mupdf::ll_fz_append_int16_le(buf.m_internal, x);
}


/* Class-aware wrapper for `::fz_append_int32_be()`.  */
FZ_FUNCTION void fz_append_int32_be(const FzBuffer& buf, int x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_int32_be()\n";
	}
	#endif
	mupdf::ll_fz_append_int32_be(buf.m_internal, x);
}


/* Class-aware wrapper for `::fz_append_int32_le()`.  */
FZ_FUNCTION void fz_append_int32_le(const FzBuffer& buf, int x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_int32_le()\n";
	}
	#endif
	mupdf::ll_fz_append_int32_le(buf.m_internal, x);
}


/* Class-aware wrapper for `::fz_append_pdf_string()`.  */
FZ_FUNCTION void fz_append_pdf_string(const FzBuffer& buffer, const char *text)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_pdf_string()\n";
	}
	#endif
	mupdf::ll_fz_append_pdf_string(buffer.m_internal, text);
}


/* Class-aware wrapper for `::fz_append_pixmap_as_data_uri()`.  */
FZ_FUNCTION void fz_append_pixmap_as_data_uri(const FzBuffer& out, const FzPixmap& pixmap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_pixmap_as_data_uri()\n";
	}
	#endif
	mupdf::ll_fz_append_pixmap_as_data_uri(out.m_internal, pixmap.m_internal);
}


/* Class-aware wrapper for `::fz_append_rune()`.  */
FZ_FUNCTION void fz_append_rune(const FzBuffer& buf, int c)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_rune()\n";
	}
	#endif
	mupdf::ll_fz_append_rune(buf.m_internal, c);
}


/* Class-aware wrapper for `::fz_append_string()`.  */
FZ_FUNCTION void fz_append_string(const FzBuffer& buf, const char *data)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_string()\n";
	}
	#endif
	mupdf::ll_fz_append_string(buf.m_internal, data);
}


/* Class-aware wrapper for `::fz_append_vprintf()`.  */
FZ_FUNCTION void fz_append_vprintf(const FzBuffer& buffer, const char *fmt, va_list args)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_append_vprintf()\n";
	}
	#endif
	mupdf::ll_fz_append_vprintf(buffer.m_internal, fmt, args);
}


/* Class-aware wrapper for `::fz_arc4_encrypt()`.  */
FZ_FUNCTION void fz_arc4_encrypt(const FzArc4& state, unsigned char *dest, const unsigned char *src, size_t len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_arc4_encrypt()\n";
	}
	#endif
	mupdf::ll_fz_arc4_encrypt(state.m_internal, dest, src, len);
}


/* Class-aware wrapper for `::fz_arc4_final()`.  */
FZ_FUNCTION void fz_arc4_final(const FzArc4& state)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_arc4_final()\n";
	}
	#endif
	mupdf::ll_fz_arc4_final(state.m_internal);
}


/* Class-aware wrapper for `::fz_arc4_init()`.  */
FZ_FUNCTION void fz_arc4_init(const FzArc4& state, const unsigned char *key, size_t len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_arc4_init()\n";
	}
	#endif
	mupdf::ll_fz_arc4_init(state.m_internal, key, len);
}


/* Class-aware wrapper for `::fz_archive_format()`.  */
FZ_FUNCTION const char *fz_archive_format(const FzArchive& arch)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_archive_format()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_archive_format(arch.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_atof()`.  */
FZ_FUNCTION float fz_atof(const char *s)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_atof()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_atof(s);
	return ret;
}


/* Class-aware wrapper for `::fz_atoi()`.  */
FZ_FUNCTION int fz_atoi(const char *s)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_atoi()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_atoi(s);
	return ret;
}


/* Class-aware wrapper for `::fz_atoi64()`.  */
FZ_FUNCTION int64_t fz_atoi64(const char *s)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_atoi64()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_atoi64(s);
	return ret;
}


/* Class-aware wrapper for `::fz_authenticate_password()`.  */
FZ_FUNCTION int fz_authenticate_password(const FzDocument& doc, const char *password)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_authenticate_password()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_authenticate_password(doc.m_internal, password);
	return ret;
}


/* Class-aware wrapper for `::fz_available()`.  */
FZ_FUNCTION size_t fz_available(const FzStream& stm, size_t max)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_available()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_available(stm.m_internal, max);
	return ret;
}


/* Class-aware wrapper for `::fz_base_colorspace()`.  */
FZ_FUNCTION FzColorspace fz_base_colorspace(const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_base_colorspace()\n";
	}
	#endif
	::fz_colorspace* temp = mupdf::ll_fz_base_colorspace(cs.m_internal);
	ll_fz_keep_colorspace(temp);
	auto ret = FzColorspace(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_basename()`.  */
FZ_FUNCTION const char *fz_basename(const char *path)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_basename()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_basename(path);
	return ret;
}


/* Class-aware wrapper for `::fz_begin_group()`.  */
FZ_FUNCTION void fz_begin_group(const FzDevice& dev, const FzRect& area, const FzColorspace& cs, int isolated, int knockout, int blendmode, float alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_begin_group()\n";
	}
	#endif
	mupdf::ll_fz_begin_group(dev.m_internal, * area.internal(), cs.m_internal, isolated, knockout, blendmode, alpha);
}


/* Class-aware wrapper for `::fz_begin_layer()`.  */
FZ_FUNCTION void fz_begin_layer(const FzDevice& dev, const char *layer_name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_begin_layer()\n";
	}
	#endif
	mupdf::ll_fz_begin_layer(dev.m_internal, layer_name);
}


/* Class-aware wrapper for `::fz_begin_mask()`.  */
FZ_FUNCTION void fz_begin_mask(const FzDevice& dev, const FzRect& area, int luminosity, const FzColorspace& colorspace, const float *bc, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_begin_mask()\n";
	}
	#endif
	mupdf::ll_fz_begin_mask(dev.m_internal, * area.internal(), luminosity, colorspace.m_internal, bc, * color_params.internal());
}


/* Class-aware wrapper for `::fz_begin_metatext()`.  */
FZ_FUNCTION void fz_begin_metatext(const FzDevice& dev, ::fz_metatext meta, const char *text)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_begin_metatext()\n";
	}
	#endif
	mupdf::ll_fz_begin_metatext(dev.m_internal, meta, text);
}


/* Class-aware wrapper for `::fz_begin_page()`.  */
FZ_FUNCTION FzDevice fz_begin_page(const FzDocumentWriter& wri, const FzRect& mediabox)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_begin_page()\n";
	}
	#endif
	::fz_device* temp = mupdf::ll_fz_begin_page(wri.m_internal, * mediabox.internal());
	ll_fz_keep_device(temp);
	auto ret = FzDevice(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_begin_structure()`.  */
FZ_FUNCTION void fz_begin_structure(const FzDevice& dev, ::fz_structure standard, const char *raw, int idx)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_begin_structure()\n";
	}
	#endif
	mupdf::ll_fz_begin_structure(dev.m_internal, standard, raw, idx);
}


/* Class-aware wrapper for `::fz_begin_tile()`.  */
FZ_FUNCTION void fz_begin_tile(const FzDevice& dev, const FzRect& area, const FzRect& view, float xstep, float ystep, const FzMatrix& ctm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_begin_tile()\n";
	}
	#endif
	mupdf::ll_fz_begin_tile(dev.m_internal, * area.internal(), * view.internal(), xstep, ystep, * ctm.internal());
}


/* Class-aware wrapper for `::fz_begin_tile_id()`.  */
FZ_FUNCTION int fz_begin_tile_id(const FzDevice& dev, const FzRect& area, const FzRect& view, float xstep, float ystep, const FzMatrix& ctm, int id)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_begin_tile_id()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_begin_tile_id(dev.m_internal, * area.internal(), * view.internal(), xstep, ystep, * ctm.internal(), id);
	return ret;
}


/* Class-aware wrapper for `::fz_bidi_fragment_text()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_bidi_fragment_text(const uint32_t *text, size_t textlen, ::fz_bidi_fragment_fn *callback, void *arg, int flags)` => ::fz_bidi_direction baseDir
	 */
FZ_FUNCTION void fz_bidi_fragment_text(const uint32_t *text, size_t textlen, ::fz_bidi_direction *baseDir, ::fz_bidi_fragment_fn *callback, void *arg, int flags)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_bidi_fragment_text()\n";
	}
	#endif
	mupdf::ll_fz_bidi_fragment_text(text, textlen, baseDir, callback, arg, flags);
}


/* Class-aware wrapper for `::fz_bitmap_details()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_bitmap_details(::fz_bitmap *bitmap)` => `(int w, int h, int n, int stride)`
	 */
FZ_FUNCTION void fz_bitmap_details(const FzBitmap& bitmap, int *w, int *h, int *n, int *stride)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_bitmap_details()\n";
	}
	#endif
	mupdf::ll_fz_bitmap_details(bitmap.m_internal, w, h, n, stride);
}


/* Class-aware wrapper for `::fz_blendmode_name()`.  */
FZ_FUNCTION const char *fz_blendmode_name(int blendmode)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_blendmode_name()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_blendmode_name(blendmode);
	return ret;
}


/* Class-aware wrapper for `::fz_bound_display_list()`.  */
FZ_FUNCTION FzRect fz_bound_display_list(const FzDisplayList& list)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_bound_display_list()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_fz_bound_display_list(list.m_internal);
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_bound_glyph()`.  */
FZ_FUNCTION FzRect fz_bound_glyph(const FzFont& font, int gid, const FzMatrix& trm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_bound_glyph()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_fz_bound_glyph(font.m_internal, gid, * trm.internal());
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_bound_page()`.  */
FZ_FUNCTION FzRect fz_bound_page(const FzPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_bound_page()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_fz_bound_page(page.m_internal);
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_bound_page_box()`.  */
FZ_FUNCTION FzRect fz_bound_page_box(const FzPage& page, ::fz_box_type box)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_bound_page_box()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_fz_bound_page_box(page.m_internal, box);
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_bound_path()`.  */
FZ_FUNCTION FzRect fz_bound_path(const FzPath& path, const FzStrokeState& stroke, const FzMatrix& ctm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_bound_path()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_fz_bound_path(path.m_internal, stroke.m_internal, * ctm.internal());
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_bound_shade()`.  */
FZ_FUNCTION FzRect fz_bound_shade(const FzShade& shade, const FzMatrix& ctm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_bound_shade()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_fz_bound_shade(shade.m_internal, * ctm.internal());
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_bound_text()`.  */
FZ_FUNCTION FzRect fz_bound_text(const FzText& text, const FzStrokeState& stroke, const FzMatrix& ctm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_bound_text()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_fz_bound_text(text.m_internal, stroke.m_internal, * ctm.internal());
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_box_type_from_string()`.  */
FZ_FUNCTION ::fz_box_type fz_box_type_from_string(const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_box_type_from_string()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_box_type_from_string(name);
	return ret;
}


/* Class-aware wrapper for `::fz_buffer_extract()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_buffer_extract(::fz_buffer *buf)` => `(size_t, unsigned char *data)`
	 */
FZ_FUNCTION size_t fz_buffer_extract(const FzBuffer& buf, unsigned char **data)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_buffer_extract()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_buffer_extract(buf.m_internal, data);
	return ret;
}


/* Class-aware wrapper for `::fz_buffer_storage()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_buffer_storage(::fz_buffer *buf)` => `(size_t, unsigned char *datap)`
	 */
FZ_FUNCTION size_t fz_buffer_storage(const FzBuffer& buf, unsigned char **datap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_buffer_storage()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_buffer_storage(buf.m_internal, datap);
	return ret;
}


/* Class-aware wrapper for `::fz_calloc()`.  */
FZ_FUNCTION void *fz_calloc(size_t count, size_t size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_calloc()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_calloc(count, size);
	return ret;
}


/* Class-aware wrapper for `::fz_calloc_no_throw()`.  */
FZ_FUNCTION void *fz_calloc_no_throw(size_t count, size_t size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_calloc_no_throw()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_calloc_no_throw(count, size);
	return ret;
}


/* Class-aware wrapper for `::fz_caught()`.  */
FZ_FUNCTION int fz_caught()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_caught()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_caught();
	return ret;
}


/* Class-aware wrapper for `::fz_caught_errno()`.  */
FZ_FUNCTION int fz_caught_errno()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_caught_errno()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_caught_errno();
	return ret;
}


/* Class-aware wrapper for `::fz_caught_message()`.  */
FZ_FUNCTION const char *fz_caught_message()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_caught_message()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_caught_message();
	return ret;
}


/* Class-aware wrapper for `::fz_chartorune()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_chartorune(const char *str)` => `(int, int rune)`
	 */
FZ_FUNCTION int fz_chartorune(int *rune, const char *str)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_chartorune()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_chartorune(rune, str);
	return ret;
}


/* Class-aware wrapper for `::fz_clamp()`.  */
FZ_FUNCTION float fz_clamp(float x, float min, float max)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clamp()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_clamp(x, min, max);
	return ret;
}


/* Class-aware wrapper for `::fz_clamp64()`.  */
FZ_FUNCTION int64_t fz_clamp64(int64_t x, int64_t min, int64_t max)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clamp64()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_clamp64(x, min, max);
	return ret;
}


/* Class-aware wrapper for `::fz_clamp_color()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_clamp_color(::fz_colorspace *cs, const float *in)` => float out
	 */
FZ_FUNCTION void fz_clamp_color(const FzColorspace& cs, const float *in, float *out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clamp_color()\n";
	}
	#endif
	mupdf::ll_fz_clamp_color(cs.m_internal, in, out);
}


/* Class-aware wrapper for `::fz_clamp_location()`.  */
FZ_FUNCTION FzLocation fz_clamp_location(const FzDocument& doc, const FzLocation& loc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clamp_location()\n";
	}
	#endif
	::fz_location temp = mupdf::ll_fz_clamp_location(doc.m_internal, * loc.internal());
	auto ret = FzLocation(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_clampd()`.  */
FZ_FUNCTION double fz_clampd(double x, double min, double max)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clampd()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_clampd(x, min, max);
	return ret;
}


/* Class-aware wrapper for `::fz_clampi()`.  */
FZ_FUNCTION int fz_clampi(int x, int min, int max)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clampi()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_clampi(x, min, max);
	return ret;
}


/* Class-aware wrapper for `::fz_clampp()`.  */
FZ_FUNCTION void *fz_clampp(void *x, void *min, void *max)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clampp()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_clampp(x, min, max);
	return ret;
}


/* Class-aware wrapper for `::fz_cleanname()`.  */
FZ_FUNCTION char *fz_cleanname(char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_cleanname()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_cleanname(name);
	return ret;
}


/* Class-aware wrapper for `::fz_cleanname_strdup()`.  */
FZ_FUNCTION char *fz_cleanname_strdup(const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_cleanname_strdup()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_cleanname_strdup(name);
	return ret;
}


/* Class-aware wrapper for `::fz_clear_bitmap()`.  */
FZ_FUNCTION void fz_clear_bitmap(const FzBitmap& bit)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clear_bitmap()\n";
	}
	#endif
	mupdf::ll_fz_clear_bitmap(bit.m_internal);
}


/* Class-aware wrapper for `::fz_clear_buffer()`.  */
FZ_FUNCTION void fz_clear_buffer(const FzBuffer& buf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clear_buffer()\n";
	}
	#endif
	mupdf::ll_fz_clear_buffer(buf.m_internal);
}


/* Class-aware wrapper for `::fz_clear_pixmap()`.  */
FZ_FUNCTION void fz_clear_pixmap(const FzPixmap& pix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clear_pixmap()\n";
	}
	#endif
	mupdf::ll_fz_clear_pixmap(pix.m_internal);
}


/* Class-aware wrapper for `::fz_clear_pixmap_rect_with_value()`.  */
FZ_FUNCTION void fz_clear_pixmap_rect_with_value(const FzPixmap& pix, int value, const FzIrect& r)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clear_pixmap_rect_with_value()\n";
	}
	#endif
	mupdf::ll_fz_clear_pixmap_rect_with_value(pix.m_internal, value, * r.internal());
}


/* Class-aware wrapper for `::fz_clear_pixmap_with_value()`.  */
FZ_FUNCTION void fz_clear_pixmap_with_value(const FzPixmap& pix, int value)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clear_pixmap_with_value()\n";
	}
	#endif
	mupdf::ll_fz_clear_pixmap_with_value(pix.m_internal, value);
}


/* Class-aware wrapper for `::fz_clip_image_mask()`.  */
FZ_FUNCTION void fz_clip_image_mask(const FzDevice& dev, const FzImage& image, const FzMatrix& ctm, const FzRect& scissor)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clip_image_mask()\n";
	}
	#endif
	mupdf::ll_fz_clip_image_mask(dev.m_internal, image.m_internal, * ctm.internal(), * scissor.internal());
}


/* Class-aware wrapper for `::fz_clip_path()`.  */
FZ_FUNCTION void fz_clip_path(const FzDevice& dev, const FzPath& path, int even_odd, const FzMatrix& ctm, const FzRect& scissor)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clip_path()\n";
	}
	#endif
	mupdf::ll_fz_clip_path(dev.m_internal, path.m_internal, even_odd, * ctm.internal(), * scissor.internal());
}


/* Class-aware wrapper for `::fz_clip_stroke_path()`.  */
FZ_FUNCTION void fz_clip_stroke_path(const FzDevice& dev, const FzPath& path, const FzStrokeState& stroke, const FzMatrix& ctm, const FzRect& scissor)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clip_stroke_path()\n";
	}
	#endif
	mupdf::ll_fz_clip_stroke_path(dev.m_internal, path.m_internal, stroke.m_internal, * ctm.internal(), * scissor.internal());
}


/* Class-aware wrapper for `::fz_clip_stroke_text()`.  */
FZ_FUNCTION void fz_clip_stroke_text(const FzDevice& dev, const FzText& text, const FzStrokeState& stroke, const FzMatrix& ctm, const FzRect& scissor)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clip_stroke_text()\n";
	}
	#endif
	mupdf::ll_fz_clip_stroke_text(dev.m_internal, text.m_internal, stroke.m_internal, * ctm.internal(), * scissor.internal());
}


/* Class-aware wrapper for `::fz_clip_text()`.  */
FZ_FUNCTION void fz_clip_text(const FzDevice& dev, const FzText& text, const FzMatrix& ctm, const FzRect& scissor)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clip_text()\n";
	}
	#endif
	mupdf::ll_fz_clip_text(dev.m_internal, text.m_internal, * ctm.internal(), * scissor.internal());
}


/* Class-aware wrapper for `::fz_clone_buffer()`.  */
FZ_FUNCTION FzBuffer fz_clone_buffer(const FzBuffer& buf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clone_buffer()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_clone_buffer(buf.m_internal);
	ll_fz_keep_buffer(temp);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_clone_default_colorspaces()`.  */
FZ_FUNCTION FzDefaultColorspaces fz_clone_default_colorspaces(const FzDefaultColorspaces& base)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clone_default_colorspaces()\n";
	}
	#endif
	::fz_default_colorspaces* temp = mupdf::ll_fz_clone_default_colorspaces(base.m_internal);
	ll_fz_keep_default_colorspaces(temp);
	auto ret = FzDefaultColorspaces(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_clone_path()`.  */
FZ_FUNCTION FzPath fz_clone_path(const FzPath& path)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clone_path()\n";
	}
	#endif
	::fz_path* temp = mupdf::ll_fz_clone_path(path.m_internal);
	ll_fz_keep_path(temp);
	auto ret = FzPath(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_clone_pixmap()`.  */
FZ_FUNCTION FzPixmap fz_clone_pixmap(const FzPixmap& old)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clone_pixmap()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_clone_pixmap(old.m_internal);
	ll_fz_keep_pixmap(temp);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_clone_pixmap_area_with_different_seps()`.  */
FZ_FUNCTION FzPixmap fz_clone_pixmap_area_with_different_seps(const FzPixmap& src, FzIrect& bbox, const FzColorspace& dcs, const FzSeparations& seps, const FzColorParams& color_params, const FzDefaultColorspaces& default_cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clone_pixmap_area_with_different_seps()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_clone_pixmap_area_with_different_seps(src.m_internal,  bbox.internal(), dcs.m_internal, seps.m_internal, * color_params.internal(), default_cs.m_internal);
	ll_fz_keep_pixmap(temp);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_clone_separations_for_overprint()`.  */
FZ_FUNCTION FzSeparations fz_clone_separations_for_overprint(const FzSeparations& seps)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clone_separations_for_overprint()\n";
	}
	#endif
	::fz_separations* temp = mupdf::ll_fz_clone_separations_for_overprint(seps.m_internal);
	ll_fz_keep_separations(temp);
	auto ret = FzSeparations(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_clone_stroke_state()`.  */
FZ_FUNCTION FzStrokeState fz_clone_stroke_state(const FzStrokeState& stroke)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_clone_stroke_state()\n";
	}
	#endif
	::fz_stroke_state* temp = mupdf::ll_fz_clone_stroke_state(stroke.m_internal);
	ll_fz_keep_stroke_state(temp);
	auto ret = FzStrokeState(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_close_band_writer()`.  */
FZ_FUNCTION void fz_close_band_writer(const FzBandWriter& writer)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_close_band_writer()\n";
	}
	#endif
	mupdf::ll_fz_close_band_writer(writer.m_internal);
}


/* Class-aware wrapper for `::fz_close_device()`.  */
FZ_FUNCTION void fz_close_device(const FzDevice& dev)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_close_device()\n";
	}
	#endif
	mupdf::ll_fz_close_device(dev.m_internal);
}


/* Class-aware wrapper for `::fz_close_document_writer()`.  */
FZ_FUNCTION void fz_close_document_writer(const FzDocumentWriter& wri)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_close_document_writer()\n";
	}
	#endif
	mupdf::ll_fz_close_document_writer(wri.m_internal);
}


/* Class-aware wrapper for `::fz_close_output()`.  */
FZ_FUNCTION void fz_close_output(const FzOutput& arg_0)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_close_output()\n";
	}
	#endif
	mupdf::ll_fz_close_output(arg_0.m_internal);
}


/* Class-aware wrapper for `::fz_close_zip_writer()`.  */
FZ_FUNCTION void fz_close_zip_writer(const FzZipWriter& zip)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_close_zip_writer()\n";
	}
	#endif
	mupdf::ll_fz_close_zip_writer(zip.m_internal);
}


/* Class-aware wrapper for `::fz_closepath()`.  */
FZ_FUNCTION void fz_closepath(const FzPath& path)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_closepath()\n";
	}
	#endif
	mupdf::ll_fz_closepath(path.m_internal);
}


/* Class-aware wrapper for `::fz_colorspace_colorant()`.  */
FZ_FUNCTION const char *fz_colorspace_colorant(const FzColorspace& cs, int n)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_colorant()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_colorspace_colorant(cs.m_internal, n);
	return ret;
}


/* Class-aware wrapper for `::fz_colorspace_device_n_has_cmyk()`.  */
FZ_FUNCTION int fz_colorspace_device_n_has_cmyk(const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_device_n_has_cmyk()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_colorspace_device_n_has_cmyk(cs.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_colorspace_device_n_has_only_cmyk()`.  */
FZ_FUNCTION int fz_colorspace_device_n_has_only_cmyk(const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_device_n_has_only_cmyk()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_colorspace_device_n_has_only_cmyk(cs.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_colorspace_is_cmyk()`.  */
FZ_FUNCTION int fz_colorspace_is_cmyk(const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_cmyk()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_colorspace_is_cmyk(cs.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_colorspace_is_device()`.  */
FZ_FUNCTION int fz_colorspace_is_device(const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_device()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_colorspace_is_device(cs.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_colorspace_is_device_cmyk()`.  */
FZ_FUNCTION int fz_colorspace_is_device_cmyk(const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_device_cmyk()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_colorspace_is_device_cmyk(cs.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_colorspace_is_device_gray()`.  */
FZ_FUNCTION int fz_colorspace_is_device_gray(const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_device_gray()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_colorspace_is_device_gray(cs.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_colorspace_is_device_n()`.  */
FZ_FUNCTION int fz_colorspace_is_device_n(const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_device_n()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_colorspace_is_device_n(cs.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_colorspace_is_gray()`.  */
FZ_FUNCTION int fz_colorspace_is_gray(const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_gray()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_colorspace_is_gray(cs.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_colorspace_is_indexed()`.  */
FZ_FUNCTION int fz_colorspace_is_indexed(const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_indexed()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_colorspace_is_indexed(cs.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_colorspace_is_lab()`.  */
FZ_FUNCTION int fz_colorspace_is_lab(const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_lab()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_colorspace_is_lab(cs.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_colorspace_is_lab_icc()`.  */
FZ_FUNCTION int fz_colorspace_is_lab_icc(const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_lab_icc()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_colorspace_is_lab_icc(cs.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_colorspace_is_rgb()`.  */
FZ_FUNCTION int fz_colorspace_is_rgb(const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_rgb()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_colorspace_is_rgb(cs.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_colorspace_is_subtractive()`.  */
FZ_FUNCTION int fz_colorspace_is_subtractive(const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_is_subtractive()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_colorspace_is_subtractive(cs.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_colorspace_n()`.  */
FZ_FUNCTION int fz_colorspace_n(const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_n()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_colorspace_n(cs.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_colorspace_name()`.  */
FZ_FUNCTION const char *fz_colorspace_name(const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_name()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_colorspace_name(cs.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_colorspace_name_colorant()`.  */
FZ_FUNCTION void fz_colorspace_name_colorant(const FzColorspace& cs, int n, const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_name_colorant()\n";
	}
	#endif
	mupdf::ll_fz_colorspace_name_colorant(cs.m_internal, n, name);
}


/* Class-aware wrapper for `::fz_colorspace_type()`.  */
FZ_FUNCTION enum fz_colorspace_type fz_colorspace_type(const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_colorspace_type()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_colorspace_type(cs.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_compare_separations()`.  */
FZ_FUNCTION int fz_compare_separations(const FzSeparations& sep1, const FzSeparations& sep2)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_compare_separations()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_compare_separations(sep1.m_internal, sep2.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_compress_ccitt_fax_g3()`.  */
FZ_FUNCTION FzBuffer fz_compress_ccitt_fax_g3(const unsigned char *data, int columns, int rows, int stride)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_compress_ccitt_fax_g3()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_compress_ccitt_fax_g3(data, columns, rows, stride);
	ll_fz_keep_buffer(temp);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_compress_ccitt_fax_g4()`.  */
FZ_FUNCTION FzBuffer fz_compress_ccitt_fax_g4(const unsigned char *data, int columns, int rows, int stride)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_compress_ccitt_fax_g4()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_compress_ccitt_fax_g4(data, columns, rows, stride);
	ll_fz_keep_buffer(temp);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_compressed_buffer_size()`.  */
FZ_FUNCTION size_t fz_compressed_buffer_size(const FzCompressedBuffer& buffer)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_compressed_buffer_size()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_compressed_buffer_size(buffer.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_compressed_image_buffer()`.  */
FZ_FUNCTION FzCompressedBuffer fz_compressed_image_buffer(const FzImage& image)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_compressed_image_buffer()\n";
	}
	#endif
	::fz_compressed_buffer* temp = mupdf::ll_fz_compressed_image_buffer(image.m_internal);
	ll_fz_keep_compressed_buffer(temp);
	auto ret = FzCompressedBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_compressed_image_type()`.  */
FZ_FUNCTION int fz_compressed_image_type(const FzImage& image)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_compressed_image_type()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_compressed_image_type(image.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_concat()`.  */
FZ_FUNCTION FzMatrix fz_concat(const FzMatrix& left, const FzMatrix& right)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_concat()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_fz_concat(* left.internal(), * right.internal());
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_contains_rect()`.  */
FZ_FUNCTION int fz_contains_rect(const FzRect& a, const FzRect& b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_contains_rect()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_contains_rect(* a.internal(), * b.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_convert_color()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_convert_color(::fz_colorspace *ss, const float *sv, ::fz_colorspace *ds, ::fz_colorspace *is, ::fz_color_params params)` => float dv
	 */
FZ_FUNCTION void fz_convert_color(const FzColorspace& ss, const float *sv, const FzColorspace& ds, float *dv, const FzColorspace& is, const FzColorParams& params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_convert_color()\n";
	}
	#endif
	mupdf::ll_fz_convert_color(ss.m_internal, sv, ds.m_internal, dv, is.m_internal, * params.internal());
}


/* Class-aware wrapper for `::fz_convert_error()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_convert_error()` => `(const char *, int code)`
	 */
FZ_FUNCTION const char *fz_convert_error(int *code)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_convert_error()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_convert_error(code);
	return ret;
}


/* Class-aware wrapper for `::fz_convert_indexed_pixmap_to_base()`.  */
FZ_FUNCTION FzPixmap fz_convert_indexed_pixmap_to_base(const FzPixmap& src)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_convert_indexed_pixmap_to_base()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_convert_indexed_pixmap_to_base(src.m_internal);
	ll_fz_keep_pixmap(temp);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_convert_pixmap()`.  */
FZ_FUNCTION FzPixmap fz_convert_pixmap(const FzPixmap& pix, const FzColorspace& cs_des, const FzColorspace& prf, const FzDefaultColorspaces& default_cs, const FzColorParams& color_params, int keep_alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_convert_pixmap()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_convert_pixmap(pix.m_internal, cs_des.m_internal, prf.m_internal, default_cs.m_internal, * color_params.internal(), keep_alpha);
	ll_fz_keep_pixmap(temp);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_convert_separation_colors()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_convert_separation_colors(::fz_colorspace *src_cs, const float *src_color, ::fz_separations *dst_seps, ::fz_colorspace *dst_cs, ::fz_color_params color_params)` => float dst_color
	 */
FZ_FUNCTION void fz_convert_separation_colors(const FzColorspace& src_cs, const float *src_color, const FzSeparations& dst_seps, const FzColorspace& dst_cs, float *dst_color, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_convert_separation_colors()\n";
	}
	#endif
	mupdf::ll_fz_convert_separation_colors(src_cs.m_internal, src_color, dst_seps.m_internal, dst_cs.m_internal, dst_color, * color_params.internal());
}


/* Class-aware wrapper for `::fz_convert_separation_pixmap_to_base()`.  */
FZ_FUNCTION FzPixmap fz_convert_separation_pixmap_to_base(const FzPixmap& src)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_convert_separation_pixmap_to_base()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_convert_separation_pixmap_to_base(src.m_internal);
	ll_fz_keep_pixmap(temp);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_copy_option()`.  */
FZ_FUNCTION size_t fz_copy_option(const char *val, char *dest, size_t maxlen)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_copy_option()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_copy_option(val, dest, maxlen);
	return ret;
}


/* Class-aware wrapper for `::fz_copy_pixmap_rect()`.  */
FZ_FUNCTION void fz_copy_pixmap_rect(const FzPixmap& dest, const FzPixmap& src, const FzIrect& r, const FzDefaultColorspaces& default_cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_copy_pixmap_rect()\n";
	}
	#endif
	mupdf::ll_fz_copy_pixmap_rect(dest.m_internal, src.m_internal, * r.internal(), default_cs.m_internal);
}


/* Class-aware wrapper for `::fz_copy_rectangle()`.  */
FZ_FUNCTION char *fz_copy_rectangle(const FzStextPage& page, const FzRect& area, int crlf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_copy_rectangle()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_copy_rectangle(page.m_internal, * area.internal(), crlf);
	return ret;
}


/* Class-aware wrapper for `::fz_copy_selection()`.  */
FZ_FUNCTION char *fz_copy_selection(const FzStextPage& page, const FzPoint& a, const FzPoint& b, int crlf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_copy_selection()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_copy_selection(page.m_internal, * a.internal(), * b.internal(), crlf);
	return ret;
}


/* Class-aware wrapper for `::fz_count_active_separations()`.  */
FZ_FUNCTION int fz_count_active_separations(const FzSeparations& seps)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_count_active_separations()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_count_active_separations(seps.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_count_archive_entries()`.  */
FZ_FUNCTION int fz_count_archive_entries(const FzArchive& arch)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_count_archive_entries()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_count_archive_entries(arch.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_count_chapter_pages()`.  */
FZ_FUNCTION int fz_count_chapter_pages(const FzDocument& doc, int chapter)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_count_chapter_pages()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_count_chapter_pages(doc.m_internal, chapter);
	return ret;
}


/* Class-aware wrapper for `::fz_count_chapters()`.  */
FZ_FUNCTION int fz_count_chapters(const FzDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_count_chapters()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_count_chapters(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_count_pages()`.  */
FZ_FUNCTION int fz_count_pages(const FzDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_count_pages()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_count_pages(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_count_separations()`.  */
FZ_FUNCTION int fz_count_separations(const FzSeparations& sep)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_count_separations()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_count_separations(sep.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_create_link()`.  */
FZ_FUNCTION FzLink fz_create_link(const FzPage& page, const FzRect& bbox, const char *uri)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_create_link()\n";
	}
	#endif
	::fz_link* temp = mupdf::ll_fz_create_link(page.m_internal, * bbox.internal(), uri);
	auto ret = FzLink(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_currentpoint()`.  */
FZ_FUNCTION FzPoint fz_currentpoint(const FzPath& path)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_currentpoint()\n";
	}
	#endif
	::fz_point temp = mupdf::ll_fz_currentpoint(path.m_internal);
	auto ret = FzPoint(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_curveto()`.  */
FZ_FUNCTION void fz_curveto(const FzPath& path, float x0, float y0, float x1, float y1, float x2, float y2)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_curveto()\n";
	}
	#endif
	mupdf::ll_fz_curveto(path.m_internal, x0, y0, x1, y1, x2, y2);
}


/* Class-aware wrapper for `::fz_curvetov()`.  */
FZ_FUNCTION void fz_curvetov(const FzPath& path, float x1, float y1, float x2, float y2)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_curvetov()\n";
	}
	#endif
	mupdf::ll_fz_curvetov(path.m_internal, x1, y1, x2, y2);
}


/* Class-aware wrapper for `::fz_curvetoy()`.  */
FZ_FUNCTION void fz_curvetoy(const FzPath& path, float x0, float y0, float x2, float y2)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_curvetoy()\n";
	}
	#endif
	mupdf::ll_fz_curvetoy(path.m_internal, x0, y0, x2, y2);
}


/* Class-aware wrapper for `::fz_debug_store()`.  */
FZ_FUNCTION void fz_debug_store(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_debug_store()\n";
	}
	#endif
	mupdf::ll_fz_debug_store(out.m_internal);
}


/* Class-aware wrapper for `::fz_debug_xml()`.  */
FZ_FUNCTION void fz_debug_xml(const FzXml& item, int level)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_debug_xml()\n";
	}
	#endif
	mupdf::ll_fz_debug_xml(item.m_internal, level);
}


/* Class-aware wrapper for `::fz_decode_tile()`.  */
FZ_FUNCTION void fz_decode_tile(const FzPixmap& pix, const float *decode)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_decode_tile()\n";
	}
	#endif
	mupdf::ll_fz_decode_tile(pix.m_internal, decode);
}


/* Class-aware wrapper for `::fz_decode_uri()`.  */
FZ_FUNCTION char *fz_decode_uri(const char *s)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_decode_uri()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_decode_uri(s);
	return ret;
}


/* Class-aware wrapper for `::fz_decode_uri_component()`.  */
FZ_FUNCTION char *fz_decode_uri_component(const char *s)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_decode_uri_component()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_decode_uri_component(s);
	return ret;
}


/* Class-aware wrapper for `::fz_decomp_image_from_stream()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_decomp_image_from_stream(::fz_stream *stm, ::fz_compressed_image *image, ::fz_irect *subarea, int indexed, int l2factor)` => `(fz_pixmap *, int l2extra)`
	 */
FZ_FUNCTION FzPixmap fz_decomp_image_from_stream(const FzStream& stm, const FzCompressedImage& image, FzIrect& subarea, int indexed, int l2factor, int *l2extra)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_decomp_image_from_stream()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_decomp_image_from_stream(stm.m_internal, image.m_internal,  subarea.internal(), indexed, l2factor, l2extra);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_decouple_type3_font()`.  */
FZ_FUNCTION void fz_decouple_type3_font(const FzFont& font, void *t3doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_decouple_type3_font()\n";
	}
	#endif
	mupdf::ll_fz_decouple_type3_font(font.m_internal, t3doc);
}


/* Class-aware wrapper for `::fz_default_cmyk()`.  */
FZ_FUNCTION FzColorspace fz_default_cmyk(const FzDefaultColorspaces& default_cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_default_cmyk()\n";
	}
	#endif
	::fz_colorspace* temp = mupdf::ll_fz_default_cmyk(default_cs.m_internal);
	ll_fz_keep_colorspace(temp);
	auto ret = FzColorspace(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_default_error_callback()`.  */
FZ_FUNCTION void fz_default_error_callback(void *user, const char *message)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_default_error_callback()\n";
	}
	#endif
	mupdf::ll_fz_default_error_callback(user, message);
}


/* Class-aware wrapper for `::fz_default_gray()`.  */
FZ_FUNCTION FzColorspace fz_default_gray(const FzDefaultColorspaces& default_cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_default_gray()\n";
	}
	#endif
	::fz_colorspace* temp = mupdf::ll_fz_default_gray(default_cs.m_internal);
	ll_fz_keep_colorspace(temp);
	auto ret = FzColorspace(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_default_halftone()`.  */
FZ_FUNCTION FzHalftone fz_default_halftone(int num_comps)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_default_halftone()\n";
	}
	#endif
	::fz_halftone* temp = mupdf::ll_fz_default_halftone(num_comps);
	ll_fz_keep_halftone(temp);
	auto ret = FzHalftone(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_default_output_intent()`.  */
FZ_FUNCTION FzColorspace fz_default_output_intent(const FzDefaultColorspaces& default_cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_default_output_intent()\n";
	}
	#endif
	::fz_colorspace* temp = mupdf::ll_fz_default_output_intent(default_cs.m_internal);
	ll_fz_keep_colorspace(temp);
	auto ret = FzColorspace(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_default_rgb()`.  */
FZ_FUNCTION FzColorspace fz_default_rgb(const FzDefaultColorspaces& default_cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_default_rgb()\n";
	}
	#endif
	::fz_colorspace* temp = mupdf::ll_fz_default_rgb(default_cs.m_internal);
	ll_fz_keep_colorspace(temp);
	auto ret = FzColorspace(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_default_warning_callback()`.  */
FZ_FUNCTION void fz_default_warning_callback(void *user, const char *message)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_default_warning_callback()\n";
	}
	#endif
	mupdf::ll_fz_default_warning_callback(user, message);
}


/* Class-aware wrapper for `::fz_defer_reap_end()`.  */
FZ_FUNCTION void fz_defer_reap_end()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_defer_reap_end()\n";
	}
	#endif
	mupdf::ll_fz_defer_reap_end();
}


/* Class-aware wrapper for `::fz_defer_reap_start()`.  */
FZ_FUNCTION void fz_defer_reap_start()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_defer_reap_start()\n";
	}
	#endif
	mupdf::ll_fz_defer_reap_start();
}


/* Class-aware wrapper for `::fz_deflate()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_deflate(unsigned char *dest, const unsigned char *source, size_t source_length, ::fz_deflate_level level)` => size_t compressed_length
	 */
FZ_FUNCTION void fz_deflate(unsigned char *dest, size_t *compressed_length, const unsigned char *source, size_t source_length, ::fz_deflate_level level)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_deflate()\n";
	}
	#endif
	mupdf::ll_fz_deflate(dest, compressed_length, source, source_length, level);
}


/* Class-aware wrapper for `::fz_deflate_bound()`.  */
FZ_FUNCTION size_t fz_deflate_bound(size_t size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_deflate_bound()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_deflate_bound(size);
	return ret;
}


/* Class-aware wrapper for `::fz_delete_link()`.  */
FZ_FUNCTION void fz_delete_link(const FzPage& page, const FzLink& link)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_delete_link()\n";
	}
	#endif
	mupdf::ll_fz_delete_link(page.m_internal, link.m_internal);
}


/* Class-aware wrapper for `::fz_detach_xml()`.  */
FZ_FUNCTION void fz_detach_xml(const FzXml& node)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_detach_xml()\n";
	}
	#endif
	mupdf::ll_fz_detach_xml(node.m_internal);
}


/* Class-aware wrapper for `::fz_device_bgr()`.  */
FZ_FUNCTION FzColorspace fz_device_bgr()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_device_bgr()\n";
	}
	#endif
	::fz_colorspace* temp = mupdf::ll_fz_device_bgr();
	ll_fz_keep_colorspace(temp);
	auto ret = FzColorspace(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_device_cmyk()`.  */
FZ_FUNCTION FzColorspace fz_device_cmyk()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_device_cmyk()\n";
	}
	#endif
	::fz_colorspace* temp = mupdf::ll_fz_device_cmyk();
	ll_fz_keep_colorspace(temp);
	auto ret = FzColorspace(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_device_current_scissor()`.  */
FZ_FUNCTION FzRect fz_device_current_scissor(const FzDevice& dev)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_device_current_scissor()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_fz_device_current_scissor(dev.m_internal);
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_device_gray()`.  */
FZ_FUNCTION FzColorspace fz_device_gray()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_device_gray()\n";
	}
	#endif
	::fz_colorspace* temp = mupdf::ll_fz_device_gray();
	ll_fz_keep_colorspace(temp);
	auto ret = FzColorspace(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_device_lab()`.  */
FZ_FUNCTION FzColorspace fz_device_lab()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_device_lab()\n";
	}
	#endif
	::fz_colorspace* temp = mupdf::ll_fz_device_lab();
	ll_fz_keep_colorspace(temp);
	auto ret = FzColorspace(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_device_rgb()`.  */
FZ_FUNCTION FzColorspace fz_device_rgb()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_device_rgb()\n";
	}
	#endif
	::fz_colorspace* temp = mupdf::ll_fz_device_rgb();
	ll_fz_keep_colorspace(temp);
	auto ret = FzColorspace(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_dirname()`.  */
FZ_FUNCTION void fz_dirname(char *dir, const char *path, size_t dirsize)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dirname()\n";
	}
	#endif
	mupdf::ll_fz_dirname(dir, path, dirsize);
}


/* Class-aware wrapper for `::fz_disable_device_hints()`.  */
FZ_FUNCTION void fz_disable_device_hints(const FzDevice& dev, int hints)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_disable_device_hints()\n";
	}
	#endif
	mupdf::ll_fz_disable_device_hints(dev.m_internal, hints);
}


/* Class-aware wrapper for `::fz_disable_icc()`.  */
FZ_FUNCTION void fz_disable_icc()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_disable_icc()\n";
	}
	#endif
	mupdf::ll_fz_disable_icc();
}


/* Class-aware wrapper for `::fz_display_list_is_empty()`.  */
FZ_FUNCTION int fz_display_list_is_empty(const FzDisplayList& list)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_display_list_is_empty()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_display_list_is_empty(list.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_div255()`.  */
FZ_FUNCTION int fz_div255(int c, int a)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_div255()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_div255(c, a);
	return ret;
}


/* Class-aware wrapper for `::fz_do_always()`.  */
FZ_FUNCTION int fz_do_always()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_do_always()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_do_always();
	return ret;
}


/* Class-aware wrapper for `::fz_do_catch()`.  */
FZ_FUNCTION int fz_do_catch()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_do_catch()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_do_catch();
	return ret;
}


/* Class-aware wrapper for `::fz_do_try()`.  */
FZ_FUNCTION int fz_do_try()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_do_try()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_do_try();
	return ret;
}


/* Class-aware wrapper for `::fz_document_open_fn_call()`.  */
FZ_FUNCTION FzDocument fz_document_open_fn_call(::fz_document_open_fn fn, const FzStream& stream, const FzStream& accel, const FzArchive& dir)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_document_open_fn_call()\n";
	}
	#endif
	::fz_document* temp = mupdf::ll_fz_document_open_fn_call(fn, stream.m_internal, accel.m_internal, dir.m_internal);
	ll_fz_keep_document(temp);
	auto ret = FzDocument(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_document_output_intent()`.  */
FZ_FUNCTION FzColorspace fz_document_output_intent(const FzDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_document_output_intent()\n";
	}
	#endif
	::fz_colorspace* temp = mupdf::ll_fz_document_output_intent(doc.m_internal);
	ll_fz_keep_colorspace(temp);
	auto ret = FzColorspace(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_document_recognize_content_fn_call()`.  */
FZ_FUNCTION int fz_document_recognize_content_fn_call(::fz_document_recognize_content_fn fn, const FzStream& stream, const FzArchive& dir)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_document_recognize_content_fn_call()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_document_recognize_content_fn_call(fn, stream.m_internal, dir.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_document_supports_accelerator()`.  */
FZ_FUNCTION int fz_document_supports_accelerator(const FzDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_document_supports_accelerator()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_document_supports_accelerator(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_dom_add_attribute()`.  */
FZ_FUNCTION void fz_dom_add_attribute(const FzXml& elt, const char *att, const char *value)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_add_attribute()\n";
	}
	#endif
	mupdf::ll_fz_dom_add_attribute(elt.m_internal, att, value);
}


/* Class-aware wrapper for `::fz_dom_append_child()`.  */
FZ_FUNCTION void fz_dom_append_child(const FzXml& parent, const FzXml& child)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_append_child()\n";
	}
	#endif
	mupdf::ll_fz_dom_append_child(parent.m_internal, child.m_internal);
}


/* Class-aware wrapper for `::fz_dom_attribute()`.  */
FZ_FUNCTION const char *fz_dom_attribute(const FzXml& elt, const char *att)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_attribute()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_dom_attribute(elt.m_internal, att);
	return ret;
}


/* Class-aware wrapper for `::fz_dom_body()`.  */
FZ_FUNCTION FzXml fz_dom_body(const FzXml& dom)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_body()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_dom_body(dom.m_internal);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_dom_clone()`.  */
FZ_FUNCTION FzXml fz_dom_clone(const FzXml& elt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_clone()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_dom_clone(elt.m_internal);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_dom_create_element()`.  */
FZ_FUNCTION FzXml fz_dom_create_element(const FzXml& dom, const char *tag)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_create_element()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_dom_create_element(dom.m_internal, tag);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_dom_create_text_node()`.  */
FZ_FUNCTION FzXml fz_dom_create_text_node(const FzXml& dom, const char *text)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_create_text_node()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_dom_create_text_node(dom.m_internal, text);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_dom_document_element()`.  */
FZ_FUNCTION FzXml fz_dom_document_element(const FzXml& dom)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_document_element()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_dom_document_element(dom.m_internal);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_dom_find()`.  */
FZ_FUNCTION FzXml fz_dom_find(const FzXml& elt, const char *tag, const char *att, const char *match)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_find()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_dom_find(elt.m_internal, tag, att, match);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_dom_find_next()`.  */
FZ_FUNCTION FzXml fz_dom_find_next(const FzXml& elt, const char *tag, const char *att, const char *match)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_find_next()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_dom_find_next(elt.m_internal, tag, att, match);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_dom_first_child()`.  */
FZ_FUNCTION FzXml fz_dom_first_child(const FzXml& elt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_first_child()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_dom_first_child(elt.m_internal);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_dom_get_attribute()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_dom_get_attribute(::fz_xml *elt, int i)` => `(const char *, const char *att)`
	 */
FZ_FUNCTION const char *fz_dom_get_attribute(const FzXml& elt, int i, const char **att)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_get_attribute()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_dom_get_attribute(elt.m_internal, i, att);
	return ret;
}


/* Class-aware wrapper for `::fz_dom_insert_after()`.  */
FZ_FUNCTION void fz_dom_insert_after(const FzXml& node, const FzXml& new_elt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_insert_after()\n";
	}
	#endif
	mupdf::ll_fz_dom_insert_after(node.m_internal, new_elt.m_internal);
}


/* Class-aware wrapper for `::fz_dom_insert_before()`.  */
FZ_FUNCTION void fz_dom_insert_before(const FzXml& node, const FzXml& new_elt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_insert_before()\n";
	}
	#endif
	mupdf::ll_fz_dom_insert_before(node.m_internal, new_elt.m_internal);
}


/* Class-aware wrapper for `::fz_dom_next()`.  */
FZ_FUNCTION FzXml fz_dom_next(const FzXml& elt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_next()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_dom_next(elt.m_internal);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_dom_parent()`.  */
FZ_FUNCTION FzXml fz_dom_parent(const FzXml& elt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_parent()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_dom_parent(elt.m_internal);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_dom_previous()`.  */
FZ_FUNCTION FzXml fz_dom_previous(const FzXml& elt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_previous()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_dom_previous(elt.m_internal);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_dom_remove()`.  */
FZ_FUNCTION void fz_dom_remove(const FzXml& elt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_remove()\n";
	}
	#endif
	mupdf::ll_fz_dom_remove(elt.m_internal);
}


/* Class-aware wrapper for `::fz_dom_remove_attribute()`.  */
FZ_FUNCTION void fz_dom_remove_attribute(const FzXml& elt, const char *att)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dom_remove_attribute()\n";
	}
	#endif
	mupdf::ll_fz_dom_remove_attribute(elt.m_internal, att);
}


/* Class-aware wrapper for `::fz_draw_story()`.  */
FZ_FUNCTION void fz_draw_story(const FzStory& story, const FzDevice& dev, const FzMatrix& ctm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_draw_story()\n";
	}
	#endif
	mupdf::ll_fz_draw_story(story.m_internal, dev.m_internal, * ctm.internal());
}


/* Class-aware wrapper for `::fz_dump_glyph_cache_stats()`.  */
FZ_FUNCTION void fz_dump_glyph_cache_stats(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_dump_glyph_cache_stats()\n";
	}
	#endif
	mupdf::ll_fz_dump_glyph_cache_stats(out.m_internal);
}


/* Class-aware wrapper for `::fz_duplicate_glyph_names_from_unicode()`.  */
FZ_FUNCTION const char **fz_duplicate_glyph_names_from_unicode(int unicode)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_duplicate_glyph_names_from_unicode()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_duplicate_glyph_names_from_unicode(unicode);
	return ret;
}


/* Class-aware wrapper for `::fz_empty_store()`.  */
FZ_FUNCTION void fz_empty_store()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_empty_store()\n";
	}
	#endif
	mupdf::ll_fz_empty_store();
}


/* Class-aware wrapper for `::fz_enable_device_hints()`.  */
FZ_FUNCTION void fz_enable_device_hints(const FzDevice& dev, int hints)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_enable_device_hints()\n";
	}
	#endif
	mupdf::ll_fz_enable_device_hints(dev.m_internal, hints);
}


/* Class-aware wrapper for `::fz_enable_icc()`.  */
FZ_FUNCTION void fz_enable_icc()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_enable_icc()\n";
	}
	#endif
	mupdf::ll_fz_enable_icc();
}


/* Class-aware wrapper for `::fz_encode_character()`.  */
FZ_FUNCTION int fz_encode_character(const FzFont& font, int unicode)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_encode_character()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_encode_character(font.m_internal, unicode);
	return ret;
}


/* Class-aware wrapper for `::fz_encode_character_by_glyph_name()`.  */
FZ_FUNCTION int fz_encode_character_by_glyph_name(const FzFont& font, const char *glyphname)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_encode_character_by_glyph_name()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_encode_character_by_glyph_name(font.m_internal, glyphname);
	return ret;
}


/* Class-aware wrapper for `::fz_encode_character_sc()`.  */
FZ_FUNCTION int fz_encode_character_sc(const FzFont& font, int unicode)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_encode_character_sc()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_encode_character_sc(font.m_internal, unicode);
	return ret;
}


/* Class-aware wrapper for `::fz_encode_character_with_fallback()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_encode_character_with_fallback(::fz_font *font, int unicode, int script, int language, ::fz_font **out_font)` => `(int)`
	 */
FZ_FUNCTION int fz_encode_character_with_fallback(const FzFont& font, int unicode, int script, int language, FzFont& out_font)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_encode_character_with_fallback()\n";
	}
	#endif
	/* Out-param out_font.m_internal will be overwritten. */
	ll_fz_drop_font(out_font.m_internal);
	out_font.m_internal = nullptr;
	auto ret = mupdf::ll_fz_encode_character_with_fallback(font.m_internal, unicode, script, language, &out_font.m_internal);
	/* We assume that out-param out_font.m_internal is a borrowed reference. */
	ll_fz_keep_font(out_font.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_encode_uri()`.  */
FZ_FUNCTION char *fz_encode_uri(const char *s)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_encode_uri()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_encode_uri(s);
	return ret;
}


/* Class-aware wrapper for `::fz_encode_uri_component()`.  */
FZ_FUNCTION char *fz_encode_uri_component(const char *s)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_encode_uri_component()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_encode_uri_component(s);
	return ret;
}


/* Class-aware wrapper for `::fz_encode_uri_pathname()`.  */
FZ_FUNCTION char *fz_encode_uri_pathname(const char *s)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_encode_uri_pathname()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_encode_uri_pathname(s);
	return ret;
}


/* Class-aware wrapper for `::fz_end_group()`.  */
FZ_FUNCTION void fz_end_group(const FzDevice& dev)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_end_group()\n";
	}
	#endif
	mupdf::ll_fz_end_group(dev.m_internal);
}


/* Class-aware wrapper for `::fz_end_layer()`.  */
FZ_FUNCTION void fz_end_layer(const FzDevice& dev)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_end_layer()\n";
	}
	#endif
	mupdf::ll_fz_end_layer(dev.m_internal);
}


/* Class-aware wrapper for `::fz_end_mask()`.  */
FZ_FUNCTION void fz_end_mask(const FzDevice& dev)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_end_mask()\n";
	}
	#endif
	mupdf::ll_fz_end_mask(dev.m_internal);
}


/* Class-aware wrapper for `::fz_end_mask_tr()`.  */
FZ_FUNCTION void fz_end_mask_tr(const FzDevice& dev, const FzFunction& fn)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_end_mask_tr()\n";
	}
	#endif
	mupdf::ll_fz_end_mask_tr(dev.m_internal, fn.m_internal);
}


/* Class-aware wrapper for `::fz_end_metatext()`.  */
FZ_FUNCTION void fz_end_metatext(const FzDevice& dev)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_end_metatext()\n";
	}
	#endif
	mupdf::ll_fz_end_metatext(dev.m_internal);
}


/* Class-aware wrapper for `::fz_end_page()`.  */
FZ_FUNCTION void fz_end_page(const FzDocumentWriter& wri)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_end_page()\n";
	}
	#endif
	mupdf::ll_fz_end_page(wri.m_internal);
}


/* Class-aware wrapper for `::fz_end_structure()`.  */
FZ_FUNCTION void fz_end_structure(const FzDevice& dev)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_end_structure()\n";
	}
	#endif
	mupdf::ll_fz_end_structure(dev.m_internal);
}


/* Class-aware wrapper for `::fz_end_throw_on_repair()`.  */
FZ_FUNCTION void fz_end_throw_on_repair()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_end_throw_on_repair()\n";
	}
	#endif
	mupdf::ll_fz_end_throw_on_repair();
}


/* Class-aware wrapper for `::fz_end_tile()`.  */
FZ_FUNCTION void fz_end_tile(const FzDevice& dev)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_end_tile()\n";
	}
	#endif
	mupdf::ll_fz_end_tile(dev.m_internal);
}


/* Class-aware wrapper for `::fz_error_callback()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_error_callback()` => `(fz_error_cb *, void *user)`
	 */
FZ_FUNCTION ::fz_error_cb *fz_error_callback(void **user)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_error_callback()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_error_callback(user);
	return ret;
}


/* Class-aware wrapper for `::fz_eval_function()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_eval_function(::fz_function *func, const float *in, int inlen, int outlen)` => float out
	 */
FZ_FUNCTION void fz_eval_function(const FzFunction& func, const float *in, int inlen, float *out, int outlen)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_eval_function()\n";
	}
	#endif
	mupdf::ll_fz_eval_function(func.m_internal, in, inlen, out, outlen);
}


/* Class-aware wrapper for `::fz_expand_irect()`.  */
FZ_FUNCTION FzIrect fz_expand_irect(const FzIrect& a, int expand)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_expand_irect()\n";
	}
	#endif
	::fz_irect temp = mupdf::ll_fz_expand_irect(* a.internal(), expand);
	auto ret = FzIrect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_expand_rect()`.  */
FZ_FUNCTION FzRect fz_expand_rect(const FzRect& b, float expand)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_expand_rect()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_fz_expand_rect(* b.internal(), expand);
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_extract_ttf_from_ttc()`.  */
FZ_FUNCTION FzBuffer fz_extract_ttf_from_ttc(const FzFont& font)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_extract_ttf_from_ttc()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_extract_ttf_from_ttc(font.m_internal);
	ll_fz_keep_buffer(temp);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_file_exists()`.  */
FZ_FUNCTION int fz_file_exists(const char *path)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_file_exists()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_file_exists(path);
	return ret;
}


/* Class-aware wrapper for `::fz_fill_image()`.  */
FZ_FUNCTION void fz_fill_image(const FzDevice& dev, const FzImage& image, const FzMatrix& ctm, float alpha, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_fill_image()\n";
	}
	#endif
	mupdf::ll_fz_fill_image(dev.m_internal, image.m_internal, * ctm.internal(), alpha, * color_params.internal());
}


/* Class-aware wrapper for `::fz_fill_image_mask()`.  */
FZ_FUNCTION void fz_fill_image_mask(const FzDevice& dev, const FzImage& image, const FzMatrix& ctm, const FzColorspace& colorspace, const float *color, float alpha, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_fill_image_mask()\n";
	}
	#endif
	mupdf::ll_fz_fill_image_mask(dev.m_internal, image.m_internal, * ctm.internal(), colorspace.m_internal, color, alpha, * color_params.internal());
}


/* Class-aware wrapper for `::fz_fill_path()`.  */
FZ_FUNCTION void fz_fill_path(const FzDevice& dev, const FzPath& path, int even_odd, const FzMatrix& ctm, const FzColorspace& colorspace, const float *color, float alpha, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_fill_path()\n";
	}
	#endif
	mupdf::ll_fz_fill_path(dev.m_internal, path.m_internal, even_odd, * ctm.internal(), colorspace.m_internal, color, alpha, * color_params.internal());
}


/* Class-aware wrapper for `::fz_fill_pixmap_from_display_list()`.  */
FZ_FUNCTION FzPixmap fz_fill_pixmap_from_display_list(const FzDisplayList& list, const FzMatrix& ctm, const FzPixmap& pix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_fill_pixmap_from_display_list()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_fill_pixmap_from_display_list(list.m_internal, * ctm.internal(), pix.m_internal);
	ll_fz_keep_pixmap(temp);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_fill_pixmap_with_color()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_fill_pixmap_with_color(::fz_pixmap *pix, ::fz_colorspace *colorspace, ::fz_color_params color_params)` => float color
	 */
FZ_FUNCTION void fz_fill_pixmap_with_color(const FzPixmap& pix, const FzColorspace& colorspace, float *color, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_fill_pixmap_with_color()\n";
	}
	#endif
	mupdf::ll_fz_fill_pixmap_with_color(pix.m_internal, colorspace.m_internal, color, * color_params.internal());
}


/* Class-aware wrapper for `::fz_fill_shade()`.  */
FZ_FUNCTION void fz_fill_shade(const FzDevice& dev, const FzShade& shade, const FzMatrix& ctm, float alpha, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_fill_shade()\n";
	}
	#endif
	mupdf::ll_fz_fill_shade(dev.m_internal, shade.m_internal, * ctm.internal(), alpha, * color_params.internal());
}


/* Class-aware wrapper for `::fz_fill_text()`.  */
FZ_FUNCTION void fz_fill_text(const FzDevice& dev, const FzText& text, const FzMatrix& ctm, const FzColorspace& colorspace, const float *color, float alpha, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_fill_text()\n";
	}
	#endif
	mupdf::ll_fz_fill_text(dev.m_internal, text.m_internal, * ctm.internal(), colorspace.m_internal, color, alpha, * color_params.internal());
}


/* Class-aware wrapper for `::fz_filter_store()`.  */
FZ_FUNCTION void fz_filter_store(::fz_store_filter_fn *fn, void *arg, const FzStoreType& type)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_filter_store()\n";
	}
	#endif
	mupdf::ll_fz_filter_store(fn, arg, type.m_internal);
}


/* Class-aware wrapper for `::fz_find_item()`.  */
FZ_FUNCTION void *fz_find_item(::fz_store_drop_fn *drop, void *key, const FzStoreType& type)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_find_item()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_find_item(drop, key, type.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_flush_output()`.  */
FZ_FUNCTION void fz_flush_output(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_flush_output()\n";
	}
	#endif
	mupdf::ll_fz_flush_output(out.m_internal);
}


/* Class-aware wrapper for `::fz_flush_warnings()`.  */
FZ_FUNCTION void fz_flush_warnings()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_flush_warnings()\n";
	}
	#endif
	mupdf::ll_fz_flush_warnings();
}


/* Class-aware wrapper for `::fz_font_ascender()`.  */
FZ_FUNCTION float fz_font_ascender(const FzFont& font)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_ascender()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_font_ascender(font.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_font_bbox()`.  */
FZ_FUNCTION FzRect fz_font_bbox(const FzFont& font)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_bbox()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_fz_font_bbox(font.m_internal);
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_font_descender()`.  */
FZ_FUNCTION float fz_font_descender(const FzFont& font)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_descender()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_font_descender(font.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_font_digest()`.  */
FZ_FUNCTION void fz_font_digest(const FzFont& font, unsigned char digest[16])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_digest()\n";
	}
	#endif
	mupdf::ll_fz_font_digest(font.m_internal, digest);
}


/* Class-aware wrapper for `::fz_font_ft_face()`.  */
FZ_FUNCTION void *fz_font_ft_face(const FzFont& font)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_ft_face()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_font_ft_face(font.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_font_is_bold()`.  */
FZ_FUNCTION int fz_font_is_bold(const FzFont& font)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_is_bold()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_font_is_bold(font.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_font_is_italic()`.  */
FZ_FUNCTION int fz_font_is_italic(const FzFont& font)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_is_italic()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_font_is_italic(font.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_font_is_monospaced()`.  */
FZ_FUNCTION int fz_font_is_monospaced(const FzFont& font)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_is_monospaced()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_font_is_monospaced(font.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_font_is_serif()`.  */
FZ_FUNCTION int fz_font_is_serif(const FzFont& font)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_is_serif()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_font_is_serif(font.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_font_name()`.  */
FZ_FUNCTION const char *fz_font_name(const FzFont& font)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_name()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_font_name(font.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_font_t3_procs()`.  */
FZ_FUNCTION ::fz_buffer **fz_font_t3_procs(const FzFont& font)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_font_t3_procs()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_font_t3_procs(font.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_format_double()`.  */
FZ_FUNCTION std::string fz_format_double(const char *fmt, double value)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_format_double()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_format_double(fmt, value);
	return ret;
}


/* Class-aware wrapper for `::fz_format_link_uri()`.  */
FZ_FUNCTION char *fz_format_link_uri(const FzDocument& doc, const FzLinkDest& dest)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_format_link_uri()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_format_link_uri(doc.m_internal, *dest.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_format_output_path()`.  */
FZ_FUNCTION void fz_format_output_path(char *path, size_t size, const char *fmt, int page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_format_output_path()\n";
	}
	#endif
	mupdf::ll_fz_format_output_path(path, size, fmt, page);
}


/* Class-aware wrapper for `::fz_format_string()`.  */
FZ_FUNCTION void fz_format_string(void *user, void (*emit)(::fz_context *, void *, int ), const char *fmt, va_list args)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_format_string()\n";
	}
	#endif
	mupdf::ll_fz_format_string(user, emit, fmt, args);
}


/* Class-aware wrapper for `::fz_free()`.  */
FZ_FUNCTION void fz_free(void *p)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_free()\n";
	}
	#endif
	mupdf::ll_fz_free(p);
}


/* Class-aware wrapper for `::fz_ft_lock()`.  */
FZ_FUNCTION void fz_ft_lock()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_ft_lock()\n";
	}
	#endif
	mupdf::ll_fz_ft_lock();
}


/* Class-aware wrapper for `::fz_ft_lock_held()`.  */
FZ_FUNCTION int fz_ft_lock_held()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_ft_lock_held()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_ft_lock_held();
	return ret;
}


/* Class-aware wrapper for `::fz_ft_unlock()`.  */
FZ_FUNCTION void fz_ft_unlock()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_ft_unlock()\n";
	}
	#endif
	mupdf::ll_fz_ft_unlock();
}


/* Class-aware wrapper for `::fz_function_size()`.  */
FZ_FUNCTION size_t fz_function_size(const FzFunction& func)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_function_size()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_function_size(func.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_gamma_pixmap()`.  */
FZ_FUNCTION void fz_gamma_pixmap(const FzPixmap& pix, float gamma)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_gamma_pixmap()\n";
	}
	#endif
	mupdf::ll_fz_gamma_pixmap(pix.m_internal, gamma);
}


/* Class-aware wrapper for `::fz_generate_transition()`.  */
FZ_FUNCTION int fz_generate_transition(const FzPixmap& tpix, const FzPixmap& opix, const FzPixmap& npix, int time, FzTransition& trans)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_generate_transition()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_generate_transition(tpix.m_internal, opix.m_internal, npix.m_internal, time,  trans.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_get_glyph_name()`.  */
FZ_FUNCTION void fz_get_glyph_name(const FzFont& font, int glyph, char *buf, int size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_get_glyph_name()\n";
	}
	#endif
	mupdf::ll_fz_get_glyph_name(font.m_internal, glyph, buf, size);
}


/* Class-aware wrapper for `::fz_get_glyph_name2()`.  */
FZ_FUNCTION std::string fz_get_glyph_name2(const FzFont& font, int glyph)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_get_glyph_name2()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_get_glyph_name2(font.m_internal, glyph);
	return ret;
}


/* Class-aware wrapper for `::fz_get_pixmap_from_image()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_get_pixmap_from_image(::fz_image *image, const ::fz_irect *subarea, ::fz_matrix *ctm)` => `(fz_pixmap *, int w, int h)`
	 */
FZ_FUNCTION FzPixmap fz_get_pixmap_from_image(const FzImage& image, FzIrect& subarea, FzMatrix& ctm, int *w, int *h)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_get_pixmap_from_image()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_get_pixmap_from_image(image.m_internal,  subarea.internal(),  ctm.internal(), w, h);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_get_unscaled_pixmap_from_image()`.  */
FZ_FUNCTION FzPixmap fz_get_unscaled_pixmap_from_image(const FzImage& image)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_get_unscaled_pixmap_from_image()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_get_unscaled_pixmap_from_image(image.m_internal);
	ll_fz_keep_pixmap(temp);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_getopt()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_getopt(int nargc, const char *ostr)` => `(int, char *nargv)`
	 */
FZ_FUNCTION int fz_getopt(int nargc, char **nargv, const char *ostr)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_getopt()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_getopt(nargc, nargv, ostr);
	return ret;
}


/* Class-aware wrapper for `::fz_getopt_long()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_getopt_long(int nargc, const char *ostr, const ::fz_getopt_long_options *longopts)` => `(int, char *nargv)`
	 */
FZ_FUNCTION int fz_getopt_long(int nargc, char **nargv, const char *ostr, const FzGetoptLongOptions& longopts)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_getopt_long()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_getopt_long(nargc, nargv, ostr, longopts.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_glyph_bbox()`.  */
FZ_FUNCTION FzIrect fz_glyph_bbox(const FzGlyph& glyph)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_glyph_bbox()\n";
	}
	#endif
	::fz_irect temp = mupdf::ll_fz_glyph_bbox(glyph.m_internal);
	auto ret = FzIrect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_glyph_bbox_no_ctx()`.  */
FZ_FUNCTION FzIrect fz_glyph_bbox_no_ctx(const FzGlyph& src)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_glyph_bbox_no_ctx()\n";
	}
	#endif
	::fz_irect temp = mupdf::ll_fz_glyph_bbox_no_ctx(src.m_internal);
	auto ret = FzIrect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_glyph_cacheable()`.  */
FZ_FUNCTION int fz_glyph_cacheable(const FzFont& font, int gid)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_glyph_cacheable()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_glyph_cacheable(font.m_internal, gid);
	return ret;
}


/* Class-aware wrapper for `::fz_glyph_height()`.  */
FZ_FUNCTION int fz_glyph_height(const FzGlyph& glyph)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_glyph_height()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_glyph_height(glyph.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_glyph_name_from_unicode_sc()`.  */
FZ_FUNCTION const char *fz_glyph_name_from_unicode_sc(int unicode)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_glyph_name_from_unicode_sc()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_glyph_name_from_unicode_sc(unicode);
	return ret;
}


/* Class-aware wrapper for `::fz_glyph_width()`.  */
FZ_FUNCTION int fz_glyph_width(const FzGlyph& glyph)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_glyph_width()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_glyph_width(glyph.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_graphics_aa_level()`.  */
FZ_FUNCTION int fz_graphics_aa_level()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_graphics_aa_level()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_graphics_aa_level();
	return ret;
}


/* Class-aware wrapper for `::fz_graphics_min_line_width()`.  */
FZ_FUNCTION float fz_graphics_min_line_width()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_graphics_min_line_width()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_graphics_min_line_width();
	return ret;
}


/* Class-aware wrapper for `::fz_gridfit_matrix()`.  */
FZ_FUNCTION FzMatrix fz_gridfit_matrix(int as_tiled, const FzMatrix& m)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_gridfit_matrix()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_fz_gridfit_matrix(as_tiled, * m.internal());
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_grisu()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_grisu(float f, char *s)` => `(int, int exp)`
	 */
FZ_FUNCTION int fz_grisu(float f, char *s, int *exp)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_grisu()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_grisu(f, s, exp);
	return ret;
}


/* Class-aware wrapper for `::fz_grow_buffer()`.  */
FZ_FUNCTION void fz_grow_buffer(const FzBuffer& buf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_grow_buffer()\n";
	}
	#endif
	mupdf::ll_fz_grow_buffer(buf.m_internal);
}


/* Class-aware wrapper for `::fz_has_archive_entry()`.  */
FZ_FUNCTION int fz_has_archive_entry(const FzArchive& arch, const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_has_archive_entry()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_has_archive_entry(arch.m_internal, name);
	return ret;
}


/* Class-aware wrapper for `::fz_has_option()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_has_option(const char *opts, const char *key)` => `(int, const char *val)`
	 */
FZ_FUNCTION int fz_has_option(const char *opts, const char *key, const char **val)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_has_option()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_has_option(opts, key, val);
	return ret;
}


/* Class-aware wrapper for `::fz_has_permission()`.  */
FZ_FUNCTION int fz_has_permission(const FzDocument& doc, ::fz_permission p)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_has_permission()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_has_permission(doc.m_internal, p);
	return ret;
}


/* Class-aware wrapper for `::fz_hash_filter()`.  */
FZ_FUNCTION void fz_hash_filter(const FzHashTable& table, void *state, ::fz_hash_table_filter_fn *callback)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_hash_filter()\n";
	}
	#endif
	mupdf::ll_fz_hash_filter(table.m_internal, state, callback);
}


/* Class-aware wrapper for `::fz_hash_find()`.  */
FZ_FUNCTION void *fz_hash_find(const FzHashTable& table, const void *key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_hash_find()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_hash_find(table.m_internal, key);
	return ret;
}


/* Class-aware wrapper for `::fz_hash_for_each()`.  */
FZ_FUNCTION void fz_hash_for_each(const FzHashTable& table, void *state, ::fz_hash_table_for_each_fn *callback)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_hash_for_each()\n";
	}
	#endif
	mupdf::ll_fz_hash_for_each(table.m_internal, state, callback);
}


/* Class-aware wrapper for `::fz_hash_insert()`.  */
FZ_FUNCTION void *fz_hash_insert(const FzHashTable& table, const void *key, void *val)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_hash_insert()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_hash_insert(table.m_internal, key, val);
	return ret;
}


/* Class-aware wrapper for `::fz_hash_remove()`.  */
FZ_FUNCTION void fz_hash_remove(const FzHashTable& table, const void *key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_hash_remove()\n";
	}
	#endif
	mupdf::ll_fz_hash_remove(table.m_internal, key);
}


/* Class-aware wrapper for `::fz_hb_lock()`.  */
FZ_FUNCTION void fz_hb_lock()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_hb_lock()\n";
	}
	#endif
	mupdf::ll_fz_hb_lock();
}


/* Class-aware wrapper for `::fz_hb_unlock()`.  */
FZ_FUNCTION void fz_hb_unlock()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_hb_unlock()\n";
	}
	#endif
	mupdf::ll_fz_hb_unlock();
}


/* Class-aware wrapper for `::fz_highlight_selection()`.  */
FZ_FUNCTION int fz_highlight_selection(const FzStextPage& page, const FzPoint& a, const FzPoint& b, FzQuad& quads, int max_quads)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_highlight_selection()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_highlight_selection(page.m_internal, * a.internal(), * b.internal(),  quads.internal(), max_quads);
	return ret;
}


/* Class-aware wrapper for `::fz_highlight_selection2()`.  */
FZ_FUNCTION std::vector<fz_quad> fz_highlight_selection2(const FzStextPage& page, const FzPoint& a, const FzPoint& b, int max_quads)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_highlight_selection2()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_highlight_selection2(page.m_internal, * a.internal(), * b.internal(), max_quads);
	return ret;
}


/* Class-aware wrapper for `::fz_ignore_error()`.  */
FZ_FUNCTION void fz_ignore_error()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_ignore_error()\n";
	}
	#endif
	mupdf::ll_fz_ignore_error();
}


/* Class-aware wrapper for `::fz_ignore_text()`.  */
FZ_FUNCTION void fz_ignore_text(const FzDevice& dev, const FzText& text, const FzMatrix& ctm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_ignore_text()\n";
	}
	#endif
	mupdf::ll_fz_ignore_text(dev.m_internal, text.m_internal, * ctm.internal());
}


/* Class-aware wrapper for `::fz_image_orientation()`.  */
FZ_FUNCTION uint8_t fz_image_orientation(const FzImage& image)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_image_orientation()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_image_orientation(image.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_image_orientation_matrix()`.  */
FZ_FUNCTION FzMatrix fz_image_orientation_matrix(const FzImage& image)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_image_orientation_matrix()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_fz_image_orientation_matrix(image.m_internal);
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_image_resolution()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_image_resolution(::fz_image *image)` => `(int xres, int yres)`
	 */
FZ_FUNCTION void fz_image_resolution(const FzImage& image, int *xres, int *yres)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_image_resolution()\n";
	}
	#endif
	mupdf::ll_fz_image_resolution(image.m_internal, xres, yres);
}


/* Class-aware wrapper for `::fz_image_size()`.  */
FZ_FUNCTION size_t fz_image_size(const FzImage& im)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_image_size()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_image_size(im.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_image_type_name()`.  */
FZ_FUNCTION const char *fz_image_type_name(int type)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_image_type_name()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_image_type_name(type);
	return ret;
}


/* Class-aware wrapper for `::fz_include_point_in_rect()`.  */
FZ_FUNCTION FzRect fz_include_point_in_rect(const FzRect& r, const FzPoint& p)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_include_point_in_rect()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_fz_include_point_in_rect(* r.internal(), * p.internal());
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_init_text_decoder()`.  */
FZ_FUNCTION void fz_init_text_decoder(const FzTextDecoder& dec, const char *encoding)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_init_text_decoder()\n";
	}
	#endif
	mupdf::ll_fz_init_text_decoder(dec.m_internal, encoding);
}


/* Class-aware wrapper for `::fz_install_load_system_font_funcs()`.  */
FZ_FUNCTION void fz_install_load_system_font_funcs(::fz_load_system_font_fn *f, ::fz_load_system_cjk_font_fn *f_cjk, ::fz_load_system_fallback_font_fn *f_fallback)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_install_load_system_font_funcs()\n";
	}
	#endif
	mupdf::ll_fz_install_load_system_font_funcs(f, f_cjk, f_fallback);
}


/* Class-aware wrapper for `::fz_install_load_system_font_funcs2()`.  */
FZ_FUNCTION void fz_install_load_system_font_funcs2(FzInstallLoadSystemFontFuncsArgs& args)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_install_load_system_font_funcs2()\n";
	}
	#endif
	mupdf::ll_fz_install_load_system_font_funcs2(&args.m_internal);
}


/* Class-aware wrapper for `::fz_int2_heap_insert()`.  */
FZ_FUNCTION void fz_int2_heap_insert(const FzInt2Heap& heap, const FzInt2& v)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_int2_heap_insert()\n";
	}
	#endif
	mupdf::ll_fz_int2_heap_insert(heap.m_internal, *v.m_internal);
}


/* Class-aware wrapper for `::fz_int2_heap_sort()`.  */
FZ_FUNCTION void fz_int2_heap_sort(const FzInt2Heap& heap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_int2_heap_sort()\n";
	}
	#endif
	mupdf::ll_fz_int2_heap_sort(heap.m_internal);
}


/* Class-aware wrapper for `::fz_int2_heap_uniq()`.  */
FZ_FUNCTION void fz_int2_heap_uniq(const FzInt2Heap& heap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_int2_heap_uniq()\n";
	}
	#endif
	mupdf::ll_fz_int2_heap_uniq(heap.m_internal);
}


/* Class-aware wrapper for `::fz_int_heap_insert()`.  */
FZ_FUNCTION void fz_int_heap_insert(const FzIntHeap& heap, int v)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_int_heap_insert()\n";
	}
	#endif
	mupdf::ll_fz_int_heap_insert(heap.m_internal, v);
}


/* Class-aware wrapper for `::fz_int_heap_sort()`.  */
FZ_FUNCTION void fz_int_heap_sort(const FzIntHeap& heap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_int_heap_sort()\n";
	}
	#endif
	mupdf::ll_fz_int_heap_sort(heap.m_internal);
}


/* Class-aware wrapper for `::fz_int_heap_uniq()`.  */
FZ_FUNCTION void fz_int_heap_uniq(const FzIntHeap& heap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_int_heap_uniq()\n";
	}
	#endif
	mupdf::ll_fz_int_heap_uniq(heap.m_internal);
}


/* Class-aware wrapper for `::fz_intersect_irect()`.  */
FZ_FUNCTION FzIrect fz_intersect_irect(const FzIrect& a, const FzIrect& b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_intersect_irect()\n";
	}
	#endif
	::fz_irect temp = mupdf::ll_fz_intersect_irect(* a.internal(), * b.internal());
	auto ret = FzIrect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_intersect_rect()`.  */
FZ_FUNCTION FzRect fz_intersect_rect(const FzRect& a, const FzRect& b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_intersect_rect()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_fz_intersect_rect(* a.internal(), * b.internal());
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_intptr_heap_insert()`.  */
FZ_FUNCTION void fz_intptr_heap_insert(const FzIntptrHeap& heap, const FzIntptr& v)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_intptr_heap_insert()\n";
	}
	#endif
	mupdf::ll_fz_intptr_heap_insert(heap.m_internal, *v.m_internal);
}


/* Class-aware wrapper for `::fz_intptr_heap_sort()`.  */
FZ_FUNCTION void fz_intptr_heap_sort(const FzIntptrHeap& heap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_intptr_heap_sort()\n";
	}
	#endif
	mupdf::ll_fz_intptr_heap_sort(heap.m_internal);
}


/* Class-aware wrapper for `::fz_intptr_heap_uniq()`.  */
FZ_FUNCTION void fz_intptr_heap_uniq(const FzIntptrHeap& heap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_intptr_heap_uniq()\n";
	}
	#endif
	mupdf::ll_fz_intptr_heap_uniq(heap.m_internal);
}


/* Class-aware wrapper for `::fz_invert_bitmap()`.  */
FZ_FUNCTION void fz_invert_bitmap(const FzBitmap& bmp)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_invert_bitmap()\n";
	}
	#endif
	mupdf::ll_fz_invert_bitmap(bmp.m_internal);
}


/* Class-aware wrapper for `::fz_invert_matrix()`.  */
FZ_FUNCTION FzMatrix fz_invert_matrix(const FzMatrix& matrix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_invert_matrix()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_fz_invert_matrix(* matrix.internal());
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_invert_pixmap()`.  */
FZ_FUNCTION void fz_invert_pixmap(const FzPixmap& pix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_invert_pixmap()\n";
	}
	#endif
	mupdf::ll_fz_invert_pixmap(pix.m_internal);
}


/* Class-aware wrapper for `::fz_invert_pixmap_alpha()`.  */
FZ_FUNCTION void fz_invert_pixmap_alpha(const FzPixmap& pix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_invert_pixmap_alpha()\n";
	}
	#endif
	mupdf::ll_fz_invert_pixmap_alpha(pix.m_internal);
}


/* Class-aware wrapper for `::fz_invert_pixmap_luminance()`.  */
FZ_FUNCTION void fz_invert_pixmap_luminance(const FzPixmap& pix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_invert_pixmap_luminance()\n";
	}
	#endif
	mupdf::ll_fz_invert_pixmap_luminance(pix.m_internal);
}


/* Class-aware wrapper for `::fz_invert_pixmap_raw()`.  */
FZ_FUNCTION void fz_invert_pixmap_raw(const FzPixmap& pix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_invert_pixmap_raw()\n";
	}
	#endif
	mupdf::ll_fz_invert_pixmap_raw(pix.m_internal);
}


/* Class-aware wrapper for `::fz_invert_pixmap_rect()`.  */
FZ_FUNCTION void fz_invert_pixmap_rect(const FzPixmap& image, const FzIrect& rect)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_invert_pixmap_rect()\n";
	}
	#endif
	mupdf::ll_fz_invert_pixmap_rect(image.m_internal, * rect.internal());
}


/* Class-aware wrapper for `::fz_irect_from_rect()`.  */
FZ_FUNCTION FzIrect fz_irect_from_rect(const FzRect& rect)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_irect_from_rect()\n";
	}
	#endif
	::fz_irect temp = mupdf::ll_fz_irect_from_rect(* rect.internal());
	auto ret = FzIrect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_irect_height()`.  */
FZ_FUNCTION int fz_irect_height(const FzIrect& r)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_irect_height()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_irect_height(* r.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_irect_width()`.  */
FZ_FUNCTION unsigned int fz_irect_width(const FzIrect& r)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_irect_width()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_irect_width(* r.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_is_cfb_archive()`.  */
FZ_FUNCTION int fz_is_cfb_archive(const FzStream& file)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_cfb_archive()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_cfb_archive(file.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_is_directory()`.  */
FZ_FUNCTION int fz_is_directory(const char *path)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_directory()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_directory(path);
	return ret;
}


/* Class-aware wrapper for `::fz_is_document_reflowable()`.  */
FZ_FUNCTION int fz_is_document_reflowable(const FzDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_document_reflowable()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_document_reflowable(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_is_empty_irect()`.  */
FZ_FUNCTION int fz_is_empty_irect(const FzIrect& r)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_empty_irect()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_empty_irect(* r.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_is_empty_rect()`.  */
FZ_FUNCTION int fz_is_empty_rect(const FzRect& r)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_empty_rect()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_empty_rect(* r.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_is_eof()`.  */
FZ_FUNCTION int fz_is_eof(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_eof()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_eof(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_is_eof_bits()`.  */
FZ_FUNCTION int fz_is_eof_bits(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_eof_bits()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_eof_bits(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_is_external_link()`.  */
FZ_FUNCTION int fz_is_external_link(const char *uri)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_external_link()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_external_link(uri);
	return ret;
}


/* Class-aware wrapper for `::fz_is_identity()`.  */
FZ_FUNCTION int fz_is_identity(const FzMatrix& m)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_identity()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_identity(* m.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_is_infinite_irect()`.  */
FZ_FUNCTION int fz_is_infinite_irect(const FzIrect& r)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_infinite_irect()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_infinite_irect(* r.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_is_infinite_rect()`.  */
FZ_FUNCTION int fz_is_infinite_rect(const FzRect& r)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_infinite_rect()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_infinite_rect(* r.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_is_libarchive_archive()`.  */
FZ_FUNCTION int fz_is_libarchive_archive(const FzStream& file)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_libarchive_archive()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_libarchive_archive(file.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_is_page_range()`.  */
FZ_FUNCTION int fz_is_page_range(const char *s)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_page_range()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_page_range(s);
	return ret;
}


/* Class-aware wrapper for `::fz_is_pixmap_monochrome()`.  */
FZ_FUNCTION int fz_is_pixmap_monochrome(const FzPixmap& pixmap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_pixmap_monochrome()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_pixmap_monochrome(pixmap.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_is_point_inside_irect()`.  */
FZ_FUNCTION int fz_is_point_inside_irect(int x, int y, const FzIrect& r)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_point_inside_irect()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_point_inside_irect(x, y, * r.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_is_point_inside_quad()`.  */
FZ_FUNCTION int fz_is_point_inside_quad(const FzPoint& p, const FzQuad& q)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_point_inside_quad()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_point_inside_quad(* p.internal(), * q.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_is_point_inside_rect()`.  */
FZ_FUNCTION int fz_is_point_inside_rect(const FzPoint& p, const FzRect& r)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_point_inside_rect()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_point_inside_rect(* p.internal(), * r.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_is_pow2()`.  */
FZ_FUNCTION int fz_is_pow2(int a)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_pow2()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_pow2(a);
	return ret;
}


/* Class-aware wrapper for `::fz_is_quad_inside_quad()`.  */
FZ_FUNCTION int fz_is_quad_inside_quad(const FzQuad& needle, const FzQuad& haystack)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_quad_inside_quad()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_quad_inside_quad(* needle.internal(), * haystack.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_is_quad_intersecting_quad()`.  */
FZ_FUNCTION int fz_is_quad_intersecting_quad(const FzQuad& a, const FzQuad& b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_quad_intersecting_quad()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_quad_intersecting_quad(* a.internal(), * b.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_is_rectilinear()`.  */
FZ_FUNCTION int fz_is_rectilinear(const FzMatrix& m)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_rectilinear()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_rectilinear(* m.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_is_tar_archive()`.  */
FZ_FUNCTION int fz_is_tar_archive(const FzStream& file)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_tar_archive()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_tar_archive(file.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_is_valid_blend_colorspace()`.  */
FZ_FUNCTION int fz_is_valid_blend_colorspace(const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_valid_blend_colorspace()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_valid_blend_colorspace(cs.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_is_valid_irect()`.  */
FZ_FUNCTION int fz_is_valid_irect(const FzIrect& r)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_valid_irect()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_valid_irect(* r.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_is_valid_rect()`.  */
FZ_FUNCTION int fz_is_valid_rect(const FzRect& r)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_valid_rect()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_valid_rect(* r.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_is_zip_archive()`.  */
FZ_FUNCTION int fz_is_zip_archive(const FzStream& file)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_is_zip_archive()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_is_zip_archive(file.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_iso8859_1_from_unicode()`.  */
FZ_FUNCTION int fz_iso8859_1_from_unicode(int u)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_iso8859_1_from_unicode()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_iso8859_1_from_unicode(u);
	return ret;
}


/* Class-aware wrapper for `::fz_iso8859_7_from_unicode()`.  */
FZ_FUNCTION int fz_iso8859_7_from_unicode(int u)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_iso8859_7_from_unicode()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_iso8859_7_from_unicode(u);
	return ret;
}


/* Class-aware wrapper for `::fz_jbig2_globals_data()`.  */
FZ_FUNCTION FzBuffer fz_jbig2_globals_data(const FzJbig2Globals& globals)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_jbig2_globals_data()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_jbig2_globals_data(globals.m_internal);
	ll_fz_keep_buffer(temp);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_koi8u_from_unicode()`.  */
FZ_FUNCTION int fz_koi8u_from_unicode(int u)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_koi8u_from_unicode()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_koi8u_from_unicode(u);
	return ret;
}


/* Class-aware wrapper for `::fz_last_page()`.  */
FZ_FUNCTION FzLocation fz_last_page(const FzDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_last_page()\n";
	}
	#endif
	::fz_location temp = mupdf::ll_fz_last_page(doc.m_internal);
	auto ret = FzLocation(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_layout_document()`.  */
FZ_FUNCTION void fz_layout_document(const FzDocument& doc, float w, float h, float em)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_layout_document()\n";
	}
	#endif
	mupdf::ll_fz_layout_document(doc.m_internal, w, h, em);
}


/* Class-aware wrapper for `::fz_lineto()`.  */
FZ_FUNCTION void fz_lineto(const FzPath& path, float x, float y)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lineto()\n";
	}
	#endif
	mupdf::ll_fz_lineto(path.m_internal, x, y);
}


/* Class-aware wrapper for `::fz_list_archive_entry()`.  */
FZ_FUNCTION const char *fz_list_archive_entry(const FzArchive& arch, int idx)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_list_archive_entry()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_list_archive_entry(arch.m_internal, idx);
	return ret;
}


/* Class-aware wrapper for `::fz_load_bmp_subimage()`.  */
FZ_FUNCTION FzPixmap fz_load_bmp_subimage(const unsigned char *buf, size_t len, int subimage)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_bmp_subimage()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_load_bmp_subimage(buf, len, subimage);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_load_bmp_subimage_count()`.  */
FZ_FUNCTION int fz_load_bmp_subimage_count(const unsigned char *buf, size_t len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_bmp_subimage_count()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_load_bmp_subimage_count(buf, len);
	return ret;
}


/* Class-aware wrapper for `::fz_load_chapter_page()`.  */
FZ_FUNCTION FzPage fz_load_chapter_page(const FzDocument& doc, int chapter, int page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_chapter_page()\n";
	}
	#endif
	::fz_page* temp = mupdf::ll_fz_load_chapter_page(doc.m_internal, chapter, page);
	auto ret = FzPage(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_load_fallback_font()`.  */
FZ_FUNCTION FzFont fz_load_fallback_font(int script, int language, int serif, int bold, int italic)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_fallback_font()\n";
	}
	#endif
	::fz_font* temp = mupdf::ll_fz_load_fallback_font(script, language, serif, bold, italic);
	auto ret = FzFont(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_load_jbig2_globals()`.  */
FZ_FUNCTION FzJbig2Globals fz_load_jbig2_globals(const FzBuffer& buf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_jbig2_globals()\n";
	}
	#endif
	::fz_jbig2_globals* temp = mupdf::ll_fz_load_jbig2_globals(buf.m_internal);
	auto ret = FzJbig2Globals(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_load_jbig2_subimage()`.  */
FZ_FUNCTION FzPixmap fz_load_jbig2_subimage(const unsigned char *buf, size_t len, int subimage)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_jbig2_subimage()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_load_jbig2_subimage(buf, len, subimage);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_load_jbig2_subimage_count()`.  */
FZ_FUNCTION int fz_load_jbig2_subimage_count(const unsigned char *buf, size_t len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_jbig2_subimage_count()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_load_jbig2_subimage_count(buf, len);
	return ret;
}


/* Class-aware wrapper for `::fz_load_jpx()`.  */
FZ_FUNCTION FzPixmap fz_load_jpx(const unsigned char *data, size_t size, const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_jpx()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_load_jpx(data, size, cs.m_internal);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_load_links()`.  */
FZ_FUNCTION FzLink fz_load_links(const FzPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_links()\n";
	}
	#endif
	::fz_link* temp = mupdf::ll_fz_load_links(page.m_internal);
	auto ret = FzLink(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_load_outline()`.  */
FZ_FUNCTION FzOutline fz_load_outline(const FzDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_outline()\n";
	}
	#endif
	::fz_outline* temp = mupdf::ll_fz_load_outline(doc.m_internal);
	auto ret = FzOutline(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_load_outline_from_iterator()`.  */
FZ_FUNCTION FzOutline fz_load_outline_from_iterator(const FzOutlineIterator& iter)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_outline_from_iterator()\n";
	}
	#endif
	::fz_outline* temp = mupdf::ll_fz_load_outline_from_iterator(iter.m_internal);
	auto ret = FzOutline(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_load_page()`.  */
FZ_FUNCTION FzPage fz_load_page(const FzDocument& doc, int number)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_page()\n";
	}
	#endif
	::fz_page* temp = mupdf::ll_fz_load_page(doc.m_internal, number);
	auto ret = FzPage(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_load_pnm_subimage()`.  */
FZ_FUNCTION FzPixmap fz_load_pnm_subimage(const unsigned char *buf, size_t len, int subimage)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_pnm_subimage()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_load_pnm_subimage(buf, len, subimage);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_load_pnm_subimage_count()`.  */
FZ_FUNCTION int fz_load_pnm_subimage_count(const unsigned char *buf, size_t len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_pnm_subimage_count()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_load_pnm_subimage_count(buf, len);
	return ret;
}


/* Class-aware wrapper for `::fz_load_system_cjk_font()`.  */
FZ_FUNCTION FzFont fz_load_system_cjk_font(const char *name, int ordering, int serif)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_system_cjk_font()\n";
	}
	#endif
	::fz_font* temp = mupdf::ll_fz_load_system_cjk_font(name, ordering, serif);
	auto ret = FzFont(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_load_system_font()`.  */
FZ_FUNCTION FzFont fz_load_system_font(const char *name, int bold, int italic, int needs_exact_metrics)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_system_font()\n";
	}
	#endif
	::fz_font* temp = mupdf::ll_fz_load_system_font(name, bold, italic, needs_exact_metrics);
	auto ret = FzFont(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_load_tiff_subimage()`.  */
FZ_FUNCTION FzPixmap fz_load_tiff_subimage(const unsigned char *buf, size_t len, int subimage)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_tiff_subimage()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_load_tiff_subimage(buf, len, subimage);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_load_tiff_subimage_count()`.  */
FZ_FUNCTION int fz_load_tiff_subimage_count(const unsigned char *buf, size_t len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_load_tiff_subimage_count()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_load_tiff_subimage_count(buf, len);
	return ret;
}


/* Class-aware wrapper for `::fz_location_from_page_number()`.  */
FZ_FUNCTION FzLocation fz_location_from_page_number(const FzDocument& doc, int number)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_location_from_page_number()\n";
	}
	#endif
	::fz_location temp = mupdf::ll_fz_location_from_page_number(doc.m_internal, number);
	auto ret = FzLocation(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_lock()`.  */
FZ_FUNCTION void fz_lock(int lock)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lock()\n";
	}
	#endif
	mupdf::ll_fz_lock(lock);
}


/* Class-aware wrapper for `::fz_log_error()`.  */
FZ_FUNCTION void fz_log_error(const char *str)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_log_error()\n";
	}
	#endif
	mupdf::ll_fz_log_error(str);
}


/* Class-aware wrapper for `::fz_lookup_base14_font()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_lookup_base14_font(const char *name)` => `(const unsigned char *, int len)`
	 */
FZ_FUNCTION const unsigned char *fz_lookup_base14_font(const char *name, int *len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_base14_font()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_lookup_base14_font(name, len);
	return ret;
}


/* Class-aware wrapper for `::fz_lookup_blendmode()`.  */
FZ_FUNCTION int fz_lookup_blendmode(const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_blendmode()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_lookup_blendmode(name);
	return ret;
}


/* Class-aware wrapper for `::fz_lookup_bookmark()`.  */
FZ_FUNCTION FzLocation fz_lookup_bookmark(const FzDocument& doc, ::fz_bookmark mark)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_bookmark()\n";
	}
	#endif
	::fz_location temp = mupdf::ll_fz_lookup_bookmark(doc.m_internal, mark);
	auto ret = FzLocation(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_lookup_builtin_font()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_lookup_builtin_font(const char *name, int bold, int italic)` => `(const unsigned char *, int len)`
	 */
FZ_FUNCTION const unsigned char *fz_lookup_builtin_font(const char *name, int bold, int italic, int *len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_builtin_font()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_lookup_builtin_font(name, bold, italic, len);
	return ret;
}


/* Class-aware wrapper for `::fz_lookup_cjk_font()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_lookup_cjk_font(int ordering)` => `(const unsigned char *, int len, int index)`
	 */
FZ_FUNCTION const unsigned char *fz_lookup_cjk_font(int ordering, int *len, int *index)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_cjk_font()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_lookup_cjk_font(ordering, len, index);
	return ret;
}


/* Class-aware wrapper for `::fz_lookup_cjk_font_by_language()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_lookup_cjk_font_by_language(const char *lang)` => `(const unsigned char *, int len, int subfont)`
	 */
FZ_FUNCTION const unsigned char *fz_lookup_cjk_font_by_language(const char *lang, int *len, int *subfont)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_cjk_font_by_language()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_lookup_cjk_font_by_language(lang, len, subfont);
	return ret;
}


/* Class-aware wrapper for `::fz_lookup_cjk_ordering_by_language()`.  */
FZ_FUNCTION int fz_lookup_cjk_ordering_by_language(const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_cjk_ordering_by_language()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_lookup_cjk_ordering_by_language(name);
	return ret;
}


/* Class-aware wrapper for `::fz_lookup_image_type()`.  */
FZ_FUNCTION int fz_lookup_image_type(const char *type)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_image_type()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_lookup_image_type(type);
	return ret;
}


/* Class-aware wrapper for `::fz_lookup_metadata()`.  */
FZ_FUNCTION int fz_lookup_metadata(const FzDocument& doc, const char *key, char *buf, int size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_metadata()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_lookup_metadata(doc.m_internal, key, buf, size);
	return ret;
}


/* Class-aware wrapper for `::fz_lookup_metadata2()`.  */
FZ_FUNCTION std::string fz_lookup_metadata2(const FzDocument& doc, const char *key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_metadata2()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_lookup_metadata2(doc.m_internal, key);
	return ret;
}


/* Class-aware wrapper for `::fz_lookup_noto_boxes_font()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_lookup_noto_boxes_font()` => `(const unsigned char *, int len)`
	 */
FZ_FUNCTION const unsigned char *fz_lookup_noto_boxes_font(int *len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_noto_boxes_font()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_lookup_noto_boxes_font(len);
	return ret;
}


/* Class-aware wrapper for `::fz_lookup_noto_emoji_font()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_lookup_noto_emoji_font()` => `(const unsigned char *, int len)`
	 */
FZ_FUNCTION const unsigned char *fz_lookup_noto_emoji_font(int *len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_noto_emoji_font()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_lookup_noto_emoji_font(len);
	return ret;
}


/* Class-aware wrapper for `::fz_lookup_noto_font()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_lookup_noto_font(int script, int lang)` => `(const unsigned char *, int len, int subfont)`
	 */
FZ_FUNCTION const unsigned char *fz_lookup_noto_font(int script, int lang, int *len, int *subfont)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_noto_font()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_lookup_noto_font(script, lang, len, subfont);
	return ret;
}


/* Class-aware wrapper for `::fz_lookup_noto_math_font()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_lookup_noto_math_font()` => `(const unsigned char *, int len)`
	 */
FZ_FUNCTION const unsigned char *fz_lookup_noto_math_font(int *len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_noto_math_font()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_lookup_noto_math_font(len);
	return ret;
}


/* Class-aware wrapper for `::fz_lookup_noto_music_font()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_lookup_noto_music_font()` => `(const unsigned char *, int len)`
	 */
FZ_FUNCTION const unsigned char *fz_lookup_noto_music_font(int *len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_noto_music_font()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_lookup_noto_music_font(len);
	return ret;
}


/* Class-aware wrapper for `::fz_lookup_noto_symbol1_font()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_lookup_noto_symbol1_font()` => `(const unsigned char *, int len)`
	 */
FZ_FUNCTION const unsigned char *fz_lookup_noto_symbol1_font(int *len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_noto_symbol1_font()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_lookup_noto_symbol1_font(len);
	return ret;
}


/* Class-aware wrapper for `::fz_lookup_noto_symbol2_font()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_lookup_noto_symbol2_font()` => `(const unsigned char *, int len)`
	 */
FZ_FUNCTION const unsigned char *fz_lookup_noto_symbol2_font(int *len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_noto_symbol2_font()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_lookup_noto_symbol2_font(len);
	return ret;
}


/* Class-aware wrapper for `::fz_lookup_rendering_intent()`.  */
FZ_FUNCTION int fz_lookup_rendering_intent(const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_lookup_rendering_intent()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_lookup_rendering_intent(name);
	return ret;
}


/* Class-aware wrapper for `::fz_make_bookmark()`.  */
FZ_FUNCTION ::fz_bookmark fz_make_bookmark(const FzDocument& doc, const FzLocation& loc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_make_bookmark()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_make_bookmark(doc.m_internal, * loc.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_make_irect()`.  */
FZ_FUNCTION FzIrect fz_make_irect(int x0, int y0, int x1, int y1)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_make_irect()\n";
	}
	#endif
	::fz_irect temp = mupdf::ll_fz_make_irect(x0, y0, x1, y1);
	auto ret = FzIrect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_make_location()`.  */
FZ_FUNCTION FzLocation fz_make_location(int chapter, int page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_make_location()\n";
	}
	#endif
	::fz_location temp = mupdf::ll_fz_make_location(chapter, page);
	auto ret = FzLocation(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_make_matrix()`.  */
FZ_FUNCTION FzMatrix fz_make_matrix(float a, float b, float c, float d, float e, float f)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_make_matrix()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_fz_make_matrix(a, b, c, d, e, f);
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_make_point()`.  */
FZ_FUNCTION FzPoint fz_make_point(float x, float y)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_make_point()\n";
	}
	#endif
	::fz_point temp = mupdf::ll_fz_make_point(x, y);
	auto ret = FzPoint(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_make_quad()`.  */
FZ_FUNCTION FzQuad fz_make_quad(float ul_x, float ul_y, float ur_x, float ur_y, float ll_x, float ll_y, float lr_x, float lr_y)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_make_quad()\n";
	}
	#endif
	::fz_quad temp = mupdf::ll_fz_make_quad(ul_x, ul_y, ur_x, ur_y, ll_x, ll_y, lr_x, lr_y);
	auto ret = FzQuad(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_make_rect()`.  */
FZ_FUNCTION FzRect fz_make_rect(float x0, float y0, float x1, float y1)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_make_rect()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_fz_make_rect(x0, y0, x1, y1);
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_malloc()`.  */
FZ_FUNCTION void *fz_malloc(size_t size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_malloc()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_malloc(size);
	return ret;
}


/* Class-aware wrapper for `::fz_malloc_no_throw()`.  */
FZ_FUNCTION void *fz_malloc_no_throw(size_t size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_malloc_no_throw()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_malloc_no_throw(size);
	return ret;
}


/* Class-aware wrapper for `::fz_matrix_expansion()`.  */
FZ_FUNCTION float fz_matrix_expansion(const FzMatrix& m)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_matrix_expansion()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_matrix_expansion(* m.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_matrix_max_expansion()`.  */
FZ_FUNCTION float fz_matrix_max_expansion(const FzMatrix& m)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_matrix_max_expansion()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_matrix_max_expansion(* m.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_max()`.  */
FZ_FUNCTION float fz_max(float a, float b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_max()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_max(a, b);
	return ret;
}


/* Class-aware wrapper for `::fz_maxi()`.  */
FZ_FUNCTION int fz_maxi(int a, int b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_maxi()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_maxi(a, b);
	return ret;
}


/* Class-aware wrapper for `::fz_maxi64()`.  */
FZ_FUNCTION int64_t fz_maxi64(int64_t a, int64_t b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_maxi64()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_maxi64(a, b);
	return ret;
}


/* Class-aware wrapper for `::fz_maxz()`.  */
FZ_FUNCTION size_t fz_maxz(size_t a, size_t b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_maxz()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_maxz(a, b);
	return ret;
}


/* Class-aware wrapper for `::fz_md5_buffer()`.  */
FZ_FUNCTION void fz_md5_buffer(const FzBuffer& buffer, unsigned char digest[16])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_md5_buffer()\n";
	}
	#endif
	mupdf::ll_fz_md5_buffer(buffer.m_internal, digest);
}


/* Class-aware wrapper for `::fz_md5_final()`.  */
FZ_FUNCTION void fz_md5_final(FzMd5& state, unsigned char digest[16])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_md5_final()\n";
	}
	#endif
	mupdf::ll_fz_md5_final(&state.m_internal, digest);
}


/* Class-aware wrapper for `::fz_md5_final2()`.  */
FZ_FUNCTION std::vector<unsigned char> fz_md5_final2(FzMd5& md5)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_md5_final2()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_md5_final2(&md5.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_md5_init()`.  */
FZ_FUNCTION void fz_md5_init(FzMd5& state)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_md5_init()\n";
	}
	#endif
	mupdf::ll_fz_md5_init(&state.m_internal);
}


/* Class-aware wrapper for `::fz_md5_pixmap()`.  */
FZ_FUNCTION void fz_md5_pixmap(const FzPixmap& pixmap, unsigned char digest[16])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_md5_pixmap()\n";
	}
	#endif
	mupdf::ll_fz_md5_pixmap(pixmap.m_internal, digest);
}


/* Class-aware wrapper for `::fz_md5_pixmap2()`.  */
FZ_FUNCTION std::vector<unsigned char> fz_md5_pixmap2(const FzPixmap& pixmap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_md5_pixmap2()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_md5_pixmap2(pixmap.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_md5_update()`.  */
FZ_FUNCTION void fz_md5_update(FzMd5& state, const unsigned char *input, size_t inlen)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_md5_update()\n";
	}
	#endif
	mupdf::ll_fz_md5_update(&state.m_internal, input, inlen);
}


/* Class-aware wrapper for `::fz_md5_update_int64()`.  */
FZ_FUNCTION void fz_md5_update_int64(FzMd5& state, int64_t i)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_md5_update_int64()\n";
	}
	#endif
	mupdf::ll_fz_md5_update_int64(&state.m_internal, i);
}


/* Class-aware wrapper for `::fz_measure_string()`.  */
FZ_FUNCTION FzMatrix fz_measure_string(const FzFont& user_font, const FzMatrix& trm, const char *s, int wmode, int bidi_level, ::fz_bidi_direction markup_dir, ::fz_text_language language)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_measure_string()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_fz_measure_string(user_font.m_internal, * trm.internal(), s, wmode, bidi_level, markup_dir, language);
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_memmem()`.  */
FZ_FUNCTION void *fz_memmem(const void *haystack, size_t haystacklen, const void *needle, size_t needlelen)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_memmem()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_memmem(haystack, haystacklen, needle, needlelen);
	return ret;
}


/* Class-aware wrapper for `::fz_memrnd()`.  */
FZ_FUNCTION void fz_memrnd(uint8_t *block, int len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_memrnd()\n";
	}
	#endif
	mupdf::ll_fz_memrnd(block, len);
}


/* Class-aware wrapper for `::fz_min()`.  */
FZ_FUNCTION float fz_min(float a, float b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_min()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_min(a, b);
	return ret;
}


/* Class-aware wrapper for `::fz_mini()`.  */
FZ_FUNCTION int fz_mini(int a, int b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_mini()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_mini(a, b);
	return ret;
}


/* Class-aware wrapper for `::fz_mini64()`.  */
FZ_FUNCTION int64_t fz_mini64(int64_t a, int64_t b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_mini64()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_mini64(a, b);
	return ret;
}


/* Class-aware wrapper for `::fz_minz()`.  */
FZ_FUNCTION size_t fz_minz(size_t a, size_t b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_minz()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_minz(a, b);
	return ret;
}


/* Class-aware wrapper for `::fz_mkdir()`.  */
FZ_FUNCTION int fz_mkdir(char *path)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_mkdir()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_mkdir(path);
	return ret;
}


/* Class-aware wrapper for `::fz_morph_error()`.  */
FZ_FUNCTION void fz_morph_error(int fromcode, int tocode)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_morph_error()\n";
	}
	#endif
	mupdf::ll_fz_morph_error(fromcode, tocode);
}


/* Class-aware wrapper for `::fz_mount_multi_archive()`.  */
FZ_FUNCTION void fz_mount_multi_archive(const FzArchive& arch_, const FzArchive& sub, const char *path)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_mount_multi_archive()\n";
	}
	#endif
	mupdf::ll_fz_mount_multi_archive(arch_.m_internal, sub.m_internal, path);
}


/* Class-aware wrapper for `::fz_moveto()`.  */
FZ_FUNCTION void fz_moveto(const FzPath& path, float x, float y)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_moveto()\n";
	}
	#endif
	mupdf::ll_fz_moveto(path.m_internal, x, y);
}


/* Class-aware wrapper for `::fz_mul255()`.  */
FZ_FUNCTION int fz_mul255(int a, int b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_mul255()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_mul255(a, b);
	return ret;
}


/* Class-aware wrapper for `::fz_needs_password()`.  */
FZ_FUNCTION int fz_needs_password(const FzDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_needs_password()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_needs_password(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_new_archive_of_size()`.  */
FZ_FUNCTION FzArchive fz_new_archive_of_size(const FzStream& file, int size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_archive_of_size()\n";
	}
	#endif
	::fz_archive* temp = mupdf::ll_fz_new_archive_of_size(file.m_internal, size);
	auto ret = FzArchive(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_base14_font()`.  */
FZ_FUNCTION FzFont fz_new_base14_font(const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_base14_font()\n";
	}
	#endif
	::fz_font* temp = mupdf::ll_fz_new_base14_font(name);
	auto ret = FzFont(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_bbox_device()`.  */
FZ_FUNCTION FzDevice fz_new_bbox_device(FzRect& rectp)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_bbox_device()\n";
	}
	#endif
	::fz_device* temp = mupdf::ll_fz_new_bbox_device( rectp.internal());
	auto ret = FzDevice(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_bitmap()`.  */
FZ_FUNCTION FzBitmap fz_new_bitmap(int w, int h, int n, int xres, int yres)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_bitmap()\n";
	}
	#endif
	::fz_bitmap* temp = mupdf::ll_fz_new_bitmap(w, h, n, xres, yres);
	auto ret = FzBitmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_bitmap_from_pixmap()`.  */
FZ_FUNCTION FzBitmap fz_new_bitmap_from_pixmap(const FzPixmap& pix, const FzHalftone& ht)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_bitmap_from_pixmap()\n";
	}
	#endif
	::fz_bitmap* temp = mupdf::ll_fz_new_bitmap_from_pixmap(pix.m_internal, ht.m_internal);
	auto ret = FzBitmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_bitmap_from_pixmap_band()`.  */
FZ_FUNCTION FzBitmap fz_new_bitmap_from_pixmap_band(const FzPixmap& pix, const FzHalftone& ht, int band_start)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_bitmap_from_pixmap_band()\n";
	}
	#endif
	::fz_bitmap* temp = mupdf::ll_fz_new_bitmap_from_pixmap_band(pix.m_internal, ht.m_internal, band_start);
	auto ret = FzBitmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer(size_t capacity)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer(capacity);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_base64()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_base64(const char *data, size_t size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_base64()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_base64(data, size);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_copied_data()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_copied_data(const unsigned char *data, size_t size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_copied_data()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_copied_data(data, size);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_data()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_data(unsigned char *data, size_t size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_data()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_data(data, size);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_display_list()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_display_list(const FzDisplayList& list, FzStextOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_display_list()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_display_list(list.m_internal,  options.internal());
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_image_as_jpeg()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_image_as_jpeg(const FzImage& image, const FzColorParams& color_params, int quality, int invert_cmyk)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_image_as_jpeg()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_image_as_jpeg(image.m_internal, * color_params.internal(), quality, invert_cmyk);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_image_as_jpx()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_image_as_jpx(const FzImage& image, const FzColorParams& color_params, int quality)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_image_as_jpx()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_image_as_jpx(image.m_internal, * color_params.internal(), quality);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_image_as_pam()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_image_as_pam(const FzImage& image, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_image_as_pam()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_image_as_pam(image.m_internal, * color_params.internal());
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_image_as_png()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_image_as_png(const FzImage& image, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_image_as_png()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_image_as_png(image.m_internal, * color_params.internal());
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_image_as_pnm()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_image_as_pnm(const FzImage& image, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_image_as_pnm()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_image_as_pnm(image.m_internal, * color_params.internal());
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_image_as_psd()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_image_as_psd(const FzImage& image, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_image_as_psd()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_image_as_psd(image.m_internal, * color_params.internal());
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_page()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_page(const FzPage& page, FzStextOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_page()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_page(page.m_internal,  options.internal());
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_page_number()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_page_number(const FzDocument& doc, int number, FzStextOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_page_number()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_page_number(doc.m_internal, number,  options.internal());
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_page_with_format()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_page_with_format(const FzPage& page, const char *format, const char *options, const FzMatrix& transform, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_page_with_format()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_page_with_format(page.m_internal, format, options, * transform.internal(), &cookie.m_internal);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_jpeg()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_pixmap_as_jpeg(const FzPixmap& pixmap, const FzColorParams& color_params, int quality, int invert_cmyk)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_pixmap_as_jpeg()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_pixmap_as_jpeg(pixmap.m_internal, * color_params.internal(), quality, invert_cmyk);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_jpx()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_pixmap_as_jpx(const FzPixmap& pix, const FzColorParams& color_params, int quality)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_pixmap_as_jpx()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_pixmap_as_jpx(pix.m_internal, * color_params.internal(), quality);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pam()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_pixmap_as_pam(const FzPixmap& pixmap, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_pixmap_as_pam()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_pixmap_as_pam(pixmap.m_internal, * color_params.internal());
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_png()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_pixmap_as_png(const FzPixmap& pixmap, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_pixmap_as_png()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_pixmap_as_png(pixmap.m_internal, * color_params.internal());
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pnm()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_pixmap_as_pnm(const FzPixmap& pixmap, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_pixmap_as_pnm()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_pixmap_as_pnm(pixmap.m_internal, * color_params.internal());
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_psd()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_pixmap_as_psd(const FzPixmap& pix, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_pixmap_as_psd()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_pixmap_as_psd(pix.m_internal, * color_params.internal());
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_shared_data()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_shared_data(const unsigned char *data, size_t size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_shared_data()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_shared_data(data, size);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_buffer_from_stext_page()`.  */
FZ_FUNCTION FzBuffer fz_new_buffer_from_stext_page(const FzStextPage& text)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_buffer_from_stext_page()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_new_buffer_from_stext_page(text.m_internal);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_builtin_font()`.  */
FZ_FUNCTION FzFont fz_new_builtin_font(const char *name, int is_bold, int is_italic)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_builtin_font()\n";
	}
	#endif
	::fz_font* temp = mupdf::ll_fz_new_builtin_font(name, is_bold, is_italic);
	auto ret = FzFont(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_cal_gray_colorspace()`.  */
FZ_FUNCTION FzColorspace fz_new_cal_gray_colorspace(float wp[3], float bp[3], float gamma)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_cal_gray_colorspace()\n";
	}
	#endif
	::fz_colorspace* temp = mupdf::ll_fz_new_cal_gray_colorspace(wp, bp, gamma);
	auto ret = FzColorspace(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_cal_rgb_colorspace()`.  */
FZ_FUNCTION FzColorspace fz_new_cal_rgb_colorspace(float wp[3], float bp[3], float gamma[3], float matrix[9])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_cal_rgb_colorspace()\n";
	}
	#endif
	::fz_colorspace* temp = mupdf::ll_fz_new_cal_rgb_colorspace(wp, bp, gamma, matrix);
	auto ret = FzColorspace(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_cjk_font()`.  */
FZ_FUNCTION FzFont fz_new_cjk_font(int ordering)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_cjk_font()\n";
	}
	#endif
	::fz_font* temp = mupdf::ll_fz_new_cjk_font(ordering);
	auto ret = FzFont(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_colorspace()`.  */
FZ_FUNCTION FzColorspace fz_new_colorspace(enum fz_colorspace_type type, int flags, int n, const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_colorspace()\n";
	}
	#endif
	::fz_colorspace* temp = mupdf::ll_fz_new_colorspace(type, flags, n, name);
	auto ret = FzColorspace(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_compressed_buffer()`.  */
FZ_FUNCTION FzCompressedBuffer fz_new_compressed_buffer()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_compressed_buffer()\n";
	}
	#endif
	::fz_compressed_buffer* temp = mupdf::ll_fz_new_compressed_buffer();
	auto ret = FzCompressedBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_default_colorspaces()`.  */
FZ_FUNCTION FzDefaultColorspaces fz_new_default_colorspaces()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_default_colorspaces()\n";
	}
	#endif
	::fz_default_colorspaces* temp = mupdf::ll_fz_new_default_colorspaces();
	auto ret = FzDefaultColorspaces(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_deflated_data()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_new_deflated_data(const unsigned char *source, size_t source_length, ::fz_deflate_level level)` => `(unsigned char *, size_t compressed_length)`
	 */
FZ_FUNCTION unsigned char *fz_new_deflated_data(size_t *compressed_length, const unsigned char *source, size_t source_length, ::fz_deflate_level level)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_deflated_data()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_new_deflated_data(compressed_length, source, source_length, level);
	return ret;
}


/* Class-aware wrapper for `::fz_new_deflated_data_from_buffer()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_new_deflated_data_from_buffer(::fz_buffer *buffer, ::fz_deflate_level level)` => `(unsigned char *, size_t compressed_length)`
	 */
FZ_FUNCTION unsigned char *fz_new_deflated_data_from_buffer(size_t *compressed_length, const FzBuffer& buffer, ::fz_deflate_level level)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_deflated_data_from_buffer()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_new_deflated_data_from_buffer(compressed_length, buffer.m_internal, level);
	return ret;
}


/* Class-aware wrapper for `::fz_new_device_of_size()`.  */
FZ_FUNCTION FzDevice fz_new_device_of_size(int size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_device_of_size()\n";
	}
	#endif
	::fz_device* temp = mupdf::ll_fz_new_device_of_size(size);
	auto ret = FzDevice(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_display_list()`.  */
FZ_FUNCTION FzDisplayList fz_new_display_list(const FzRect& mediabox)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_display_list()\n";
	}
	#endif
	::fz_display_list* temp = mupdf::ll_fz_new_display_list(* mediabox.internal());
	auto ret = FzDisplayList(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_display_list_from_page()`.  */
FZ_FUNCTION FzDisplayList fz_new_display_list_from_page(const FzPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_display_list_from_page()\n";
	}
	#endif
	::fz_display_list* temp = mupdf::ll_fz_new_display_list_from_page(page.m_internal);
	auto ret = FzDisplayList(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_display_list_from_page_contents()`.  */
FZ_FUNCTION FzDisplayList fz_new_display_list_from_page_contents(const FzPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_display_list_from_page_contents()\n";
	}
	#endif
	::fz_display_list* temp = mupdf::ll_fz_new_display_list_from_page_contents(page.m_internal);
	auto ret = FzDisplayList(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_display_list_from_page_number()`.  */
FZ_FUNCTION FzDisplayList fz_new_display_list_from_page_number(const FzDocument& doc, int number)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_display_list_from_page_number()\n";
	}
	#endif
	::fz_display_list* temp = mupdf::ll_fz_new_display_list_from_page_number(doc.m_internal, number);
	auto ret = FzDisplayList(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_display_list_from_svg()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_new_display_list_from_svg(::fz_buffer *buf, const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`
	 */
FZ_FUNCTION FzDisplayList fz_new_display_list_from_svg(const FzBuffer& buf, const char *base_uri, const FzArchive& dir, float *w, float *h)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_display_list_from_svg()\n";
	}
	#endif
	::fz_display_list* temp = mupdf::ll_fz_new_display_list_from_svg(buf.m_internal, base_uri, dir.m_internal, w, h);
	auto ret = FzDisplayList(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_display_list_from_svg_xml()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_new_display_list_from_svg_xml(::fz_xml_doc *xmldoc, ::fz_xml *xml, const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`
	 */
FZ_FUNCTION FzDisplayList fz_new_display_list_from_svg_xml(const FzXml& xmldoc, const FzXml& xml, const char *base_uri, const FzArchive& dir, float *w, float *h)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_display_list_from_svg_xml()\n";
	}
	#endif
	::fz_display_list* temp = mupdf::ll_fz_new_display_list_from_svg_xml(xmldoc.m_internal, xml.m_internal, base_uri, dir.m_internal, w, h);
	auto ret = FzDisplayList(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_document_of_size()`.  */
FZ_FUNCTION void *fz_new_document_of_size(int size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_document_of_size()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_new_document_of_size(size);
	return ret;
}


/* Class-aware wrapper for `::fz_new_draw_device()`.  */
FZ_FUNCTION FzDevice fz_new_draw_device(const FzMatrix& transform, const FzPixmap& dest)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_draw_device()\n";
	}
	#endif
	::fz_device* temp = mupdf::ll_fz_new_draw_device(* transform.internal(), dest.m_internal);
	auto ret = FzDevice(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_draw_device_type3()`.  */
FZ_FUNCTION FzDevice fz_new_draw_device_type3(const FzMatrix& transform, const FzPixmap& dest)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_draw_device_type3()\n";
	}
	#endif
	::fz_device* temp = mupdf::ll_fz_new_draw_device_type3(* transform.internal(), dest.m_internal);
	auto ret = FzDevice(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_draw_device_with_bbox()`.  */
FZ_FUNCTION FzDevice fz_new_draw_device_with_bbox(const FzMatrix& transform, const FzPixmap& dest, FzIrect& clip)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_draw_device_with_bbox()\n";
	}
	#endif
	::fz_device* temp = mupdf::ll_fz_new_draw_device_with_bbox(* transform.internal(), dest.m_internal,  clip.internal());
	auto ret = FzDevice(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_draw_device_with_bbox_proof()`.  */
FZ_FUNCTION FzDevice fz_new_draw_device_with_bbox_proof(const FzMatrix& transform, const FzPixmap& dest, FzIrect& clip, const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_draw_device_with_bbox_proof()\n";
	}
	#endif
	::fz_device* temp = mupdf::ll_fz_new_draw_device_with_bbox_proof(* transform.internal(), dest.m_internal,  clip.internal(), cs.m_internal);
	auto ret = FzDevice(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_draw_device_with_options()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_new_draw_device_with_options(const ::fz_draw_options *options, ::fz_rect mediabox, ::fz_pixmap **pixmap)` => `(fz_device *)`
	 */
FZ_FUNCTION FzDevice fz_new_draw_device_with_options(FzDrawOptions& options, const FzRect& mediabox, FzPixmap& pixmap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_draw_device_with_options()\n";
	}
	#endif
	/* Out-param pixmap.m_internal will be overwritten. */
	ll_fz_drop_pixmap(pixmap.m_internal);
	pixmap.m_internal = nullptr;
	::fz_device* temp = mupdf::ll_fz_new_draw_device_with_options( options.internal(), * mediabox.internal(), &pixmap.m_internal);
	auto ret = FzDevice(temp);
	/* We assume that out-param pixmap.m_internal is a kept reference. */
	return ret;
}


/* Class-aware wrapper for `::fz_new_draw_device_with_proof()`.  */
FZ_FUNCTION FzDevice fz_new_draw_device_with_proof(const FzMatrix& transform, const FzPixmap& dest, const FzColorspace& proof_cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_draw_device_with_proof()\n";
	}
	#endif
	::fz_device* temp = mupdf::ll_fz_new_draw_device_with_proof(* transform.internal(), dest.m_internal, proof_cs.m_internal);
	auto ret = FzDevice(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_font_from_buffer()`.  */
FZ_FUNCTION FzFont fz_new_font_from_buffer(const char *name, const FzBuffer& buffer, int index, int use_glyph_bbox)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_font_from_buffer()\n";
	}
	#endif
	::fz_font* temp = mupdf::ll_fz_new_font_from_buffer(name, buffer.m_internal, index, use_glyph_bbox);
	auto ret = FzFont(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_font_from_file()`.  */
FZ_FUNCTION FzFont fz_new_font_from_file(const char *name, const char *path, int index, int use_glyph_bbox)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_font_from_file()\n";
	}
	#endif
	::fz_font* temp = mupdf::ll_fz_new_font_from_file(name, path, index, use_glyph_bbox);
	auto ret = FzFont(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_font_from_memory()`.  */
FZ_FUNCTION FzFont fz_new_font_from_memory(const char *name, const unsigned char *data, int len, int index, int use_glyph_bbox)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_font_from_memory()\n";
	}
	#endif
	::fz_font* temp = mupdf::ll_fz_new_font_from_memory(name, data, len, index, use_glyph_bbox);
	auto ret = FzFont(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_function_of_size()`.  */
FZ_FUNCTION FzFunction fz_new_function_of_size(int size, size_t size2, int m, int n, ::fz_function_eval_fn *eval, ::fz_store_drop_fn *drop)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_function_of_size()\n";
	}
	#endif
	::fz_function* temp = mupdf::ll_fz_new_function_of_size(size, size2, m, n, eval, drop);
	auto ret = FzFunction(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_icc_colorspace()`.  */
FZ_FUNCTION FzColorspace fz_new_icc_colorspace(enum fz_colorspace_type type, int flags, const char *name, const FzBuffer& buf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_icc_colorspace()\n";
	}
	#endif
	::fz_colorspace* temp = mupdf::ll_fz_new_icc_colorspace(type, flags, name, buf.m_internal);
	auto ret = FzColorspace(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_image_from_buffer()`.  */
FZ_FUNCTION FzImage fz_new_image_from_buffer(const FzBuffer& buffer)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_from_buffer()\n";
	}
	#endif
	::fz_image* temp = mupdf::ll_fz_new_image_from_buffer(buffer.m_internal);
	auto ret = FzImage(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_image_from_compressed_buffer()`.  */
FZ_FUNCTION FzImage fz_new_image_from_compressed_buffer(int w, int h, int bpc, const FzColorspace& colorspace, int xres, int yres, int interpolate, int imagemask, const float *decode, const int *colorkey, const FzCompressedBuffer& buffer, const FzImage& mask)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_from_compressed_buffer()\n";
	}
	#endif
	::fz_image* temp = mupdf::ll_fz_new_image_from_compressed_buffer(w, h, bpc, colorspace.m_internal, xres, yres, interpolate, imagemask, decode, colorkey, buffer.m_internal, mask.m_internal);
	auto ret = FzImage(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_image_from_compressed_buffer2()`.  */
FZ_FUNCTION FzImage fz_new_image_from_compressed_buffer2(int w, int h, int bpc, const FzColorspace& colorspace, int xres, int yres, int interpolate, int imagemask, const std::vector<float> &decode, const std::vector<int> &colorkey, const FzCompressedBuffer& buffer, const FzImage& mask)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_from_compressed_buffer2()\n";
	}
	#endif
	::fz_image* temp = mupdf::ll_fz_new_image_from_compressed_buffer2(w, h, bpc, colorspace.m_internal, xres, yres, interpolate, imagemask, decode, colorkey, buffer.m_internal, mask.m_internal);
	auto ret = FzImage(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_image_from_display_list()`.  */
FZ_FUNCTION FzImage fz_new_image_from_display_list(float w, float h, const FzDisplayList& list)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_from_display_list()\n";
	}
	#endif
	::fz_image* temp = mupdf::ll_fz_new_image_from_display_list(w, h, list.m_internal);
	auto ret = FzImage(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_image_from_file()`.  */
FZ_FUNCTION FzImage fz_new_image_from_file(const char *path)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_from_file()\n";
	}
	#endif
	::fz_image* temp = mupdf::ll_fz_new_image_from_file(path);
	auto ret = FzImage(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_image_from_pixmap()`.  */
FZ_FUNCTION FzImage fz_new_image_from_pixmap(const FzPixmap& pixmap, const FzImage& mask)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_from_pixmap()\n";
	}
	#endif
	::fz_image* temp = mupdf::ll_fz_new_image_from_pixmap(pixmap.m_internal, mask.m_internal);
	auto ret = FzImage(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_image_from_svg()`.  */
FZ_FUNCTION FzImage fz_new_image_from_svg(const FzBuffer& buf, const char *base_uri, const FzArchive& dir)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_from_svg()\n";
	}
	#endif
	::fz_image* temp = mupdf::ll_fz_new_image_from_svg(buf.m_internal, base_uri, dir.m_internal);
	auto ret = FzImage(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_image_from_svg_xml()`.  */
FZ_FUNCTION FzImage fz_new_image_from_svg_xml(const FzXml& xmldoc, const FzXml& xml, const char *base_uri, const FzArchive& dir)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_from_svg_xml()\n";
	}
	#endif
	::fz_image* temp = mupdf::ll_fz_new_image_from_svg_xml(xmldoc.m_internal, xml.m_internal, base_uri, dir.m_internal);
	auto ret = FzImage(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_image_of_size()`.  */
FZ_FUNCTION FzImage fz_new_image_of_size(int w, int h, int bpc, const FzColorspace& colorspace, int xres, int yres, int interpolate, int imagemask, const float *decode, const int *colorkey, const FzImage& mask, size_t size, ::fz_image_get_pixmap_fn *get_pixmap, ::fz_image_get_size_fn *get_size, ::fz_drop_image_fn *drop)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_image_of_size()\n";
	}
	#endif
	::fz_image* temp = mupdf::ll_fz_new_image_of_size(w, h, bpc, colorspace.m_internal, xres, yres, interpolate, imagemask, decode, colorkey, mask.m_internal, size, get_pixmap, get_size, drop);
	auto ret = FzImage(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_indexed_colorspace()`.  */
FZ_FUNCTION FzColorspace fz_new_indexed_colorspace(const FzColorspace& base, int high, unsigned char *lookup)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_indexed_colorspace()\n";
	}
	#endif
	::fz_colorspace* temp = mupdf::ll_fz_new_indexed_colorspace(base.m_internal, high, lookup);
	auto ret = FzColorspace(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_link_of_size()`.  */
FZ_FUNCTION FzLink fz_new_link_of_size(int size, const FzRect& rect, const char *uri)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_link_of_size()\n";
	}
	#endif
	::fz_link* temp = mupdf::ll_fz_new_link_of_size(size, * rect.internal(), uri);
	auto ret = FzLink(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_list_device()`.  */
FZ_FUNCTION FzDevice fz_new_list_device(const FzDisplayList& list)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_list_device()\n";
	}
	#endif
	::fz_device* temp = mupdf::ll_fz_new_list_device(list.m_internal);
	auto ret = FzDevice(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_multi_archive()`.  */
FZ_FUNCTION FzArchive fz_new_multi_archive()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_multi_archive()\n";
	}
	#endif
	::fz_archive* temp = mupdf::ll_fz_new_multi_archive();
	auto ret = FzArchive(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_ocr_device()`.  */
FZ_FUNCTION FzDevice fz_new_ocr_device(const FzDevice& target, const FzMatrix& ctm, const FzRect& mediabox, int with_list, const char *language, const char *datadir, int (*progress)(::fz_context *, void *, int ), void *progress_arg)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_ocr_device()\n";
	}
	#endif
	::fz_device* temp = mupdf::ll_fz_new_ocr_device(target.m_internal, * ctm.internal(), * mediabox.internal(), with_list, language, datadir, progress, progress_arg);
	auto ret = FzDevice(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_outline()`.  */
FZ_FUNCTION FzOutline fz_new_outline()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_outline()\n";
	}
	#endif
	::fz_outline* temp = mupdf::ll_fz_new_outline();
	auto ret = FzOutline(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_page_of_size()`.  */
FZ_FUNCTION FzPage fz_new_page_of_size(int size, const FzDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_page_of_size()\n";
	}
	#endif
	::fz_page* temp = mupdf::ll_fz_new_page_of_size(size, doc.m_internal);
	auto ret = FzPage(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_path()`.  */
FZ_FUNCTION FzPath fz_new_path()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_path()\n";
	}
	#endif
	::fz_path* temp = mupdf::ll_fz_new_path();
	auto ret = FzPath(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_pixmap()`.  */
FZ_FUNCTION FzPixmap fz_new_pixmap(const FzColorspace& cs, int w, int h, const FzSeparations& seps, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_new_pixmap(cs.m_internal, w, h, seps.m_internal, alpha);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_pixmap_from_alpha_channel()`.  */
FZ_FUNCTION FzPixmap fz_new_pixmap_from_alpha_channel(const FzPixmap& src)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_alpha_channel()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_new_pixmap_from_alpha_channel(src.m_internal);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_pixmap_from_color_and_mask()`.  */
FZ_FUNCTION FzPixmap fz_new_pixmap_from_color_and_mask(const FzPixmap& color, const FzPixmap& mask)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_color_and_mask()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_new_pixmap_from_color_and_mask(color.m_internal, mask.m_internal);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_pixmap_from_display_list()`.  */
FZ_FUNCTION FzPixmap fz_new_pixmap_from_display_list(const FzDisplayList& list, const FzMatrix& ctm, const FzColorspace& cs, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_display_list()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_new_pixmap_from_display_list(list.m_internal, * ctm.internal(), cs.m_internal, alpha);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_pixmap_from_display_list_with_separations()`.  */
FZ_FUNCTION FzPixmap fz_new_pixmap_from_display_list_with_separations(const FzDisplayList& list, const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_display_list_with_separations()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_new_pixmap_from_display_list_with_separations(list.m_internal, * ctm.internal(), cs.m_internal, seps.m_internal, alpha);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_pixmap_from_page()`.  */
FZ_FUNCTION FzPixmap fz_new_pixmap_from_page(const FzPage& page, const FzMatrix& ctm, const FzColorspace& cs, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_page()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_new_pixmap_from_page(page.m_internal, * ctm.internal(), cs.m_internal, alpha);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_pixmap_from_page_contents()`.  */
FZ_FUNCTION FzPixmap fz_new_pixmap_from_page_contents(const FzPage& page, const FzMatrix& ctm, const FzColorspace& cs, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_page_contents()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_new_pixmap_from_page_contents(page.m_internal, * ctm.internal(), cs.m_internal, alpha);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_pixmap_from_page_contents_with_separations()`.  */
FZ_FUNCTION FzPixmap fz_new_pixmap_from_page_contents_with_separations(const FzPage& page, const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_page_contents_with_separations()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_new_pixmap_from_page_contents_with_separations(page.m_internal, * ctm.internal(), cs.m_internal, seps.m_internal, alpha);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_pixmap_from_page_number()`.  */
FZ_FUNCTION FzPixmap fz_new_pixmap_from_page_number(const FzDocument& doc, int number, const FzMatrix& ctm, const FzColorspace& cs, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_page_number()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_new_pixmap_from_page_number(doc.m_internal, number, * ctm.internal(), cs.m_internal, alpha);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_pixmap_from_page_number_with_separations()`.  */
FZ_FUNCTION FzPixmap fz_new_pixmap_from_page_number_with_separations(const FzDocument& doc, int number, const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_page_number_with_separations()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_new_pixmap_from_page_number_with_separations(doc.m_internal, number, * ctm.internal(), cs.m_internal, seps.m_internal, alpha);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_pixmap_from_page_with_separations()`.  */
FZ_FUNCTION FzPixmap fz_new_pixmap_from_page_with_separations(const FzPage& page, const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_page_with_separations()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_new_pixmap_from_page_with_separations(page.m_internal, * ctm.internal(), cs.m_internal, seps.m_internal, alpha);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_pixmap_from_pixmap()`.  */
FZ_FUNCTION FzPixmap fz_new_pixmap_from_pixmap(const FzPixmap& pixmap, FzIrect& rect)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_from_pixmap()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_new_pixmap_from_pixmap(pixmap.m_internal,  rect.internal());
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_pixmap_with_bbox()`.  */
FZ_FUNCTION FzPixmap fz_new_pixmap_with_bbox(const FzColorspace& colorspace, const FzIrect& bbox, const FzSeparations& seps, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_with_bbox()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_new_pixmap_with_bbox(colorspace.m_internal, * bbox.internal(), seps.m_internal, alpha);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_pixmap_with_bbox_and_data()`.  */
FZ_FUNCTION FzPixmap fz_new_pixmap_with_bbox_and_data(const FzColorspace& colorspace, const FzIrect& rect, const FzSeparations& seps, int alpha, unsigned char *samples)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_with_bbox_and_data()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_new_pixmap_with_bbox_and_data(colorspace.m_internal, * rect.internal(), seps.m_internal, alpha, samples);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_pixmap_with_data()`.  */
FZ_FUNCTION FzPixmap fz_new_pixmap_with_data(const FzColorspace& colorspace, int w, int h, const FzSeparations& seps, int alpha, int stride, unsigned char *samples)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_pixmap_with_data()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_new_pixmap_with_data(colorspace.m_internal, w, h, seps.m_internal, alpha, stride, samples);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_separations()`.  */
FZ_FUNCTION FzSeparations fz_new_separations(int controllable)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_separations()\n";
	}
	#endif
	::fz_separations* temp = mupdf::ll_fz_new_separations(controllable);
	auto ret = FzSeparations(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_stext_device()`.  */
FZ_FUNCTION FzDevice fz_new_stext_device(const FzStextPage& page, FzStextOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_stext_device()\n";
	}
	#endif
	::fz_device* temp = mupdf::ll_fz_new_stext_device(page.m_internal,  options.internal());
	auto ret = FzDevice(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_store_context()`.  */
FZ_FUNCTION void fz_new_store_context(size_t max)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_store_context()\n";
	}
	#endif
	mupdf::ll_fz_new_store_context(max);
}


/* Class-aware wrapper for `::fz_new_stream()`.  */
FZ_FUNCTION FzStream fz_new_stream(void *state, ::fz_stream_next_fn *next, ::fz_stream_drop_fn *drop)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_stream()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_new_stream(state, next, drop);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_string()`.  */
FZ_FUNCTION FzString fz_new_string(const char *str)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_string()\n";
	}
	#endif
	::fz_string* temp = mupdf::ll_fz_new_string(str);
	auto ret = FzString(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_stroke_state()`.  */
FZ_FUNCTION FzStrokeState fz_new_stroke_state()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_stroke_state()\n";
	}
	#endif
	::fz_stroke_state* temp = mupdf::ll_fz_new_stroke_state();
	auto ret = FzStrokeState(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_stroke_state_with_dash_len()`.  */
FZ_FUNCTION FzStrokeState fz_new_stroke_state_with_dash_len(int len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_stroke_state_with_dash_len()\n";
	}
	#endif
	::fz_stroke_state* temp = mupdf::ll_fz_new_stroke_state_with_dash_len(len);
	auto ret = FzStrokeState(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_svg_device()`.  */
FZ_FUNCTION FzDevice fz_new_svg_device(const FzOutput& out, float page_width, float page_height, int text_format, int reuse_images)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_svg_device()\n";
	}
	#endif
	::fz_device* temp = mupdf::ll_fz_new_svg_device(out.m_internal, page_width, page_height, text_format, reuse_images);
	auto ret = FzDevice(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_svg_device_with_id()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_new_svg_device_with_id(::fz_output *out, float page_width, float page_height, int text_format, int reuse_images)` => `(fz_device *, int id)`
	 */
FZ_FUNCTION FzDevice fz_new_svg_device_with_id(const FzOutput& out, float page_width, float page_height, int text_format, int reuse_images, int *id)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_svg_device_with_id()\n";
	}
	#endif
	::fz_device* temp = mupdf::ll_fz_new_svg_device_with_id(out.m_internal, page_width, page_height, text_format, reuse_images, id);
	auto ret = FzDevice(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_test_device()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_new_test_device(float threshold, int options, ::fz_device *passthrough)` => `(fz_device *, int is_color)`
	 */
FZ_FUNCTION FzDevice fz_new_test_device(int *is_color, float threshold, int options, const FzDevice& passthrough)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_test_device()\n";
	}
	#endif
	::fz_device* temp = mupdf::ll_fz_new_test_device(is_color, threshold, options, passthrough.m_internal);
	auto ret = FzDevice(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_text()`.  */
FZ_FUNCTION FzText fz_new_text()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_text()\n";
	}
	#endif
	::fz_text* temp = mupdf::ll_fz_new_text();
	auto ret = FzText(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_trace_device()`.  */
FZ_FUNCTION FzDevice fz_new_trace_device(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_trace_device()\n";
	}
	#endif
	::fz_device* temp = mupdf::ll_fz_new_trace_device(out.m_internal);
	auto ret = FzDevice(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_tree_archive()`.  */
FZ_FUNCTION FzArchive fz_new_tree_archive(const FzTree& tree)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_tree_archive()\n";
	}
	#endif
	::fz_archive* temp = mupdf::ll_fz_new_tree_archive(tree.m_internal);
	auto ret = FzArchive(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_type3_font()`.  */
FZ_FUNCTION FzFont fz_new_type3_font(const char *name, const FzMatrix& matrix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_type3_font()\n";
	}
	#endif
	::fz_font* temp = mupdf::ll_fz_new_type3_font(name, * matrix.internal());
	auto ret = FzFont(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_xhtml_document_from_document()`.  */
FZ_FUNCTION FzDocument fz_new_xhtml_document_from_document(const FzDocument& old_doc, FzStextOptions& opts)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_xhtml_document_from_document()\n";
	}
	#endif
	::fz_document* temp = mupdf::ll_fz_new_xhtml_document_from_document(old_doc.m_internal,  opts.internal());
	auto ret = FzDocument(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_new_xmltext_device()`.  */
FZ_FUNCTION FzDevice fz_new_xmltext_device(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_new_xmltext_device()\n";
	}
	#endif
	::fz_device* temp = mupdf::ll_fz_new_xmltext_device(out.m_internal);
	auto ret = FzDevice(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_next_page()`.  */
FZ_FUNCTION FzLocation fz_next_page(const FzDocument& doc, const FzLocation& loc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_next_page()\n";
	}
	#endif
	::fz_location temp = mupdf::ll_fz_next_page(doc.m_internal, * loc.internal());
	auto ret = FzLocation(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_normalize_vector()`.  */
FZ_FUNCTION FzPoint fz_normalize_vector(const FzPoint& p)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_normalize_vector()\n";
	}
	#endif
	::fz_point temp = mupdf::ll_fz_normalize_vector(* p.internal());
	auto ret = FzPoint(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_a85d()`.  */
FZ_FUNCTION FzStream fz_open_a85d(const FzStream& chain)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_a85d()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_a85d(chain.m_internal);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_accelerated_document()`.  */
FZ_FUNCTION FzDocument fz_open_accelerated_document(const char *filename, const char *accel)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_accelerated_document()\n";
	}
	#endif
	::fz_document* temp = mupdf::ll_fz_open_accelerated_document(filename, accel);
	auto ret = FzDocument(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_accelerated_document_with_stream()`.  */
FZ_FUNCTION FzDocument fz_open_accelerated_document_with_stream(const char *magic, const FzStream& stream, const FzStream& accel)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_accelerated_document_with_stream()\n";
	}
	#endif
	::fz_document* temp = mupdf::ll_fz_open_accelerated_document_with_stream(magic, stream.m_internal, accel.m_internal);
	auto ret = FzDocument(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_accelerated_document_with_stream_and_dir()`.  */
FZ_FUNCTION FzDocument fz_open_accelerated_document_with_stream_and_dir(const char *magic, const FzStream& stream, const FzStream& accel, const FzArchive& dir)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_accelerated_document_with_stream_and_dir()\n";
	}
	#endif
	::fz_document* temp = mupdf::ll_fz_open_accelerated_document_with_stream_and_dir(magic, stream.m_internal, accel.m_internal, dir.m_internal);
	auto ret = FzDocument(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_aesd()`.  */
FZ_FUNCTION FzStream fz_open_aesd(const FzStream& chain, unsigned char *key, unsigned int keylen)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_aesd()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_aesd(chain.m_internal, key, keylen);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_ahxd()`.  */
FZ_FUNCTION FzStream fz_open_ahxd(const FzStream& chain)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_ahxd()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_ahxd(chain.m_internal);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_arc4()`.  */
FZ_FUNCTION FzStream fz_open_arc4(const FzStream& chain, unsigned char *key, unsigned int keylen)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_arc4()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_arc4(chain.m_internal, key, keylen);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_archive()`.  */
FZ_FUNCTION FzArchive fz_open_archive(const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_archive()\n";
	}
	#endif
	::fz_archive* temp = mupdf::ll_fz_open_archive(filename);
	auto ret = FzArchive(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_archive_entry()`.  */
FZ_FUNCTION FzStream fz_open_archive_entry(const FzArchive& arch, const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_archive_entry()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_archive_entry(arch.m_internal, name);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_archive_with_stream()`.  */
FZ_FUNCTION FzArchive fz_open_archive_with_stream(const FzStream& file)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_archive_with_stream()\n";
	}
	#endif
	::fz_archive* temp = mupdf::ll_fz_open_archive_with_stream(file.m_internal);
	auto ret = FzArchive(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_buffer()`.  */
FZ_FUNCTION FzStream fz_open_buffer(const FzBuffer& buf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_buffer()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_buffer(buf.m_internal);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_cfb_archive()`.  */
FZ_FUNCTION FzArchive fz_open_cfb_archive(const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_cfb_archive()\n";
	}
	#endif
	::fz_archive* temp = mupdf::ll_fz_open_cfb_archive(filename);
	auto ret = FzArchive(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_cfb_archive_with_stream()`.  */
FZ_FUNCTION FzArchive fz_open_cfb_archive_with_stream(const FzStream& file)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_cfb_archive_with_stream()\n";
	}
	#endif
	::fz_archive* temp = mupdf::ll_fz_open_cfb_archive_with_stream(file.m_internal);
	auto ret = FzArchive(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_compressed_buffer()`.  */
FZ_FUNCTION FzStream fz_open_compressed_buffer(const FzCompressedBuffer& arg_0)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_compressed_buffer()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_compressed_buffer(arg_0.m_internal);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_concat()`.  */
FZ_FUNCTION FzStream fz_open_concat(int max, int pad)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_concat()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_concat(max, pad);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_dctd()`.  */
FZ_FUNCTION FzStream fz_open_dctd(const FzStream& chain, int color_transform, int invert_cmyk, int l2factor, const FzStream& jpegtables)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_dctd()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_dctd(chain.m_internal, color_transform, invert_cmyk, l2factor, jpegtables.m_internal);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_directory()`.  */
FZ_FUNCTION FzArchive fz_open_directory(const char *path)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_directory()\n";
	}
	#endif
	::fz_archive* temp = mupdf::ll_fz_open_directory(path);
	auto ret = FzArchive(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_document()`.  */
FZ_FUNCTION FzDocument fz_open_document(const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_document()\n";
	}
	#endif
	::fz_document* temp = mupdf::ll_fz_open_document(filename);
	auto ret = FzDocument(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_document_with_buffer()`.  */
FZ_FUNCTION FzDocument fz_open_document_with_buffer(const char *magic, const FzBuffer& buffer)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_document_with_buffer()\n";
	}
	#endif
	::fz_document* temp = mupdf::ll_fz_open_document_with_buffer(magic, buffer.m_internal);
	auto ret = FzDocument(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_document_with_stream()`.  */
FZ_FUNCTION FzDocument fz_open_document_with_stream(const char *magic, const FzStream& stream)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_document_with_stream()\n";
	}
	#endif
	::fz_document* temp = mupdf::ll_fz_open_document_with_stream(magic, stream.m_internal);
	auto ret = FzDocument(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_document_with_stream_and_dir()`.  */
FZ_FUNCTION FzDocument fz_open_document_with_stream_and_dir(const char *magic, const FzStream& stream, const FzArchive& dir)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_document_with_stream_and_dir()\n";
	}
	#endif
	::fz_document* temp = mupdf::ll_fz_open_document_with_stream_and_dir(magic, stream.m_internal, dir.m_internal);
	auto ret = FzDocument(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_endstream_filter()`.  */
FZ_FUNCTION FzStream fz_open_endstream_filter(const FzStream& chain, uint64_t len, int64_t offset)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_endstream_filter()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_endstream_filter(chain.m_internal, len, offset);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_faxd()`.  */
FZ_FUNCTION FzStream fz_open_faxd(const FzStream& chain, int k, int end_of_line, int encoded_byte_align, int columns, int rows, int end_of_block, int black_is_1)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_faxd()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_faxd(chain.m_internal, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_file()`.  */
FZ_FUNCTION FzStream fz_open_file(const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_file()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_file(filename);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_file_ptr_no_close()`.  */
FZ_FUNCTION FzStream fz_open_file_ptr_no_close(FILE *file)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_file_ptr_no_close()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_file_ptr_no_close(file);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_flated()`.  */
FZ_FUNCTION FzStream fz_open_flated(const FzStream& chain, int window_bits)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_flated()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_flated(chain.m_internal, window_bits);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_image_decomp_stream()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_open_image_decomp_stream(::fz_stream *arg_0, ::fz_compression_params *arg_1)` => `(fz_stream *, int l2factor)`
	 */
FZ_FUNCTION FzStream fz_open_image_decomp_stream(const FzStream& arg_0, const FzCompressionParams& arg_1, int *l2factor)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_image_decomp_stream()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_image_decomp_stream(arg_0.m_internal, arg_1.m_internal, l2factor);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_image_decomp_stream_from_buffer()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_open_image_decomp_stream_from_buffer(::fz_compressed_buffer *arg_0)` => `(fz_stream *, int l2factor)`
	 */
FZ_FUNCTION FzStream fz_open_image_decomp_stream_from_buffer(const FzCompressedBuffer& arg_0, int *l2factor)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_image_decomp_stream_from_buffer()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_image_decomp_stream_from_buffer(arg_0.m_internal, l2factor);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_jbig2d()`.  */
FZ_FUNCTION FzStream fz_open_jbig2d(const FzStream& chain, const FzJbig2Globals& globals, int embedded)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_jbig2d()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_jbig2d(chain.m_internal, globals.m_internal, embedded);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_leecher()`.  */
FZ_FUNCTION FzStream fz_open_leecher(const FzStream& chain, const FzBuffer& buf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_leecher()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_leecher(chain.m_internal, buf.m_internal);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_libarchive_archive()`.  */
FZ_FUNCTION FzArchive fz_open_libarchive_archive(const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_libarchive_archive()\n";
	}
	#endif
	::fz_archive* temp = mupdf::ll_fz_open_libarchive_archive(filename);
	auto ret = FzArchive(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_libarchive_archive_with_stream()`.  */
FZ_FUNCTION FzArchive fz_open_libarchive_archive_with_stream(const FzStream& file)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_libarchive_archive_with_stream()\n";
	}
	#endif
	::fz_archive* temp = mupdf::ll_fz_open_libarchive_archive_with_stream(file.m_internal);
	auto ret = FzArchive(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_libarchived()`.  */
FZ_FUNCTION FzStream fz_open_libarchived(const FzStream& chain)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_libarchived()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_libarchived(chain.m_internal);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_lzwd()`.  */
FZ_FUNCTION FzStream fz_open_lzwd(const FzStream& chain, int early_change, int min_bits, int reverse_bits, int old_tiff)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_lzwd()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_lzwd(chain.m_internal, early_change, min_bits, reverse_bits, old_tiff);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_memory()`.  */
FZ_FUNCTION FzStream fz_open_memory(const unsigned char *data, size_t len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_memory()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_memory(data, len);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_null_filter()`.  */
FZ_FUNCTION FzStream fz_open_null_filter(const FzStream& chain, uint64_t len, int64_t offset)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_null_filter()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_null_filter(chain.m_internal, len, offset);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_predict()`.  */
FZ_FUNCTION FzStream fz_open_predict(const FzStream& chain, int predictor, int columns, int colors, int bpc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_predict()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_predict(chain.m_internal, predictor, columns, colors, bpc);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_range_filter()`.  */
FZ_FUNCTION FzStream fz_open_range_filter(const FzStream& chain, const FzRange& ranges, int nranges)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_range_filter()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_range_filter(chain.m_internal, ranges.m_internal, nranges);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_reflowed_document()`.  */
FZ_FUNCTION FzDocument fz_open_reflowed_document(const FzDocument& underdoc, FzStextOptions& opts)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_reflowed_document()\n";
	}
	#endif
	::fz_document* temp = mupdf::ll_fz_open_reflowed_document(underdoc.m_internal,  opts.internal());
	auto ret = FzDocument(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_rld()`.  */
FZ_FUNCTION FzStream fz_open_rld(const FzStream& chain)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_rld()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_rld(chain.m_internal);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_sgilog16()`.  */
FZ_FUNCTION FzStream fz_open_sgilog16(const FzStream& chain, int w)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_sgilog16()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_sgilog16(chain.m_internal, w);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_sgilog24()`.  */
FZ_FUNCTION FzStream fz_open_sgilog24(const FzStream& chain, int w)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_sgilog24()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_sgilog24(chain.m_internal, w);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_sgilog32()`.  */
FZ_FUNCTION FzStream fz_open_sgilog32(const FzStream& chain, int w)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_sgilog32()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_sgilog32(chain.m_internal, w);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_tar_archive()`.  */
FZ_FUNCTION FzArchive fz_open_tar_archive(const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_tar_archive()\n";
	}
	#endif
	::fz_archive* temp = mupdf::ll_fz_open_tar_archive(filename);
	auto ret = FzArchive(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_tar_archive_with_stream()`.  */
FZ_FUNCTION FzArchive fz_open_tar_archive_with_stream(const FzStream& file)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_tar_archive_with_stream()\n";
	}
	#endif
	::fz_archive* temp = mupdf::ll_fz_open_tar_archive_with_stream(file.m_internal);
	auto ret = FzArchive(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_thunder()`.  */
FZ_FUNCTION FzStream fz_open_thunder(const FzStream& chain, int w)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_thunder()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_open_thunder(chain.m_internal, w);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_zip_archive()`.  */
FZ_FUNCTION FzArchive fz_open_zip_archive(const char *path)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_zip_archive()\n";
	}
	#endif
	::fz_archive* temp = mupdf::ll_fz_open_zip_archive(path);
	auto ret = FzArchive(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_open_zip_archive_with_stream()`.  */
FZ_FUNCTION FzArchive fz_open_zip_archive_with_stream(const FzStream& file)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_open_zip_archive_with_stream()\n";
	}
	#endif
	::fz_archive* temp = mupdf::ll_fz_open_zip_archive_with_stream(file.m_internal);
	auto ret = FzArchive(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_opt_from_list()`.  */
FZ_FUNCTION int fz_opt_from_list(char *opt, const char *optlist)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_opt_from_list()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_opt_from_list(opt, optlist);
	return ret;
}


/* Class-aware wrapper for `::fz_option_eq()`.  */
FZ_FUNCTION int fz_option_eq(const char *a, const char *b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_option_eq()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_option_eq(a, b);
	return ret;
}


/* Class-aware wrapper for `::fz_outline_glyph()`.  */
FZ_FUNCTION FzPath fz_outline_glyph(const FzFont& font, int gid, const FzMatrix& ctm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_outline_glyph()\n";
	}
	#endif
	::fz_path* temp = mupdf::ll_fz_outline_glyph(font.m_internal, gid, * ctm.internal());
	ll_fz_keep_path(temp);
	auto ret = FzPath(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_outline_iterator_delete()`.  */
FZ_FUNCTION int fz_outline_iterator_delete(const FzOutlineIterator& iter)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_outline_iterator_delete()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_outline_iterator_delete(iter.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_outline_iterator_down()`.  */
FZ_FUNCTION int fz_outline_iterator_down(const FzOutlineIterator& iter)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_outline_iterator_down()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_outline_iterator_down(iter.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_outline_iterator_item()`.  */
FZ_FUNCTION FzOutlineItem fz_outline_iterator_item(const FzOutlineIterator& iter)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_outline_iterator_item()\n";
	}
	#endif
	::fz_outline_item* temp = mupdf::ll_fz_outline_iterator_item(iter.m_internal);
	auto ret = FzOutlineItem(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_outline_iterator_next()`.  */
FZ_FUNCTION int fz_outline_iterator_next(const FzOutlineIterator& iter)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_outline_iterator_next()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_outline_iterator_next(iter.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_outline_iterator_prev()`.  */
FZ_FUNCTION int fz_outline_iterator_prev(const FzOutlineIterator& iter)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_outline_iterator_prev()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_outline_iterator_prev(iter.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_outline_iterator_up()`.  */
FZ_FUNCTION int fz_outline_iterator_up(const FzOutlineIterator& iter)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_outline_iterator_up()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_outline_iterator_up(iter.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_output_accelerator()`.  */
FZ_FUNCTION void fz_output_accelerator(const FzDocument& doc, const FzOutput& accel)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_output_accelerator()\n";
	}
	#endif
	mupdf::ll_fz_output_accelerator(doc.m_internal, accel.m_internal);
}


/* Class-aware wrapper for `::fz_output_supports_stream()`.  */
FZ_FUNCTION int fz_output_supports_stream(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_output_supports_stream()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_output_supports_stream(out.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_output_xml()`.  */
FZ_FUNCTION void fz_output_xml(const FzOutput& out, const FzXml& item, int level)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_output_xml()\n";
	}
	#endif
	mupdf::ll_fz_output_xml(out.m_internal, item.m_internal, level);
}


/* Class-aware wrapper for `::fz_pack_path()`.  */
FZ_FUNCTION size_t fz_pack_path(uint8_t *pack, const FzPath& path)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pack_path()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_pack_path(pack, path.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_packed_path_size()`.  */
FZ_FUNCTION int fz_packed_path_size(const FzPath& path)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_packed_path_size()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_packed_path_size(path.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_page_label()`.  */
FZ_FUNCTION const char *fz_page_label(const FzPage& page, char *buf, int size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_page_label()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_page_label(page.m_internal, buf, size);
	return ret;
}


/* Class-aware wrapper for `::fz_page_number_from_location()`.  */
FZ_FUNCTION int fz_page_number_from_location(const FzDocument& doc, const FzLocation& loc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_page_number_from_location()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_page_number_from_location(doc.m_internal, * loc.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_page_presentation()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_page_presentation(::fz_page *page, ::fz_transition *transition)` => `(fz_transition *, float duration)`
	 */
FZ_FUNCTION FzTransition fz_page_presentation(const FzPage& page, FzTransition& transition, float *duration)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_page_presentation()\n";
	}
	#endif
	::fz_transition* temp = mupdf::ll_fz_page_presentation(page.m_internal,  transition.internal(), duration);
	auto ret = FzTransition(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_page_separations()`.  */
FZ_FUNCTION FzSeparations fz_page_separations(const FzPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_page_separations()\n";
	}
	#endif
	::fz_separations* temp = mupdf::ll_fz_page_separations(page.m_internal);
	ll_fz_keep_separations(temp);
	auto ret = FzSeparations(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_page_uses_overprint()`.  */
FZ_FUNCTION int fz_page_uses_overprint(const FzPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_page_uses_overprint()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_page_uses_overprint(page.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_paint_shade()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_paint_shade(::fz_shade *shade, ::fz_colorspace *override_cs, ::fz_matrix ctm, ::fz_pixmap *dest, ::fz_color_params color_params, ::fz_irect bbox, const ::fz_overprint *eop, ::fz_shade_color_cache **cache)` => 
	 */
FZ_FUNCTION void fz_paint_shade(const FzShade& shade, const FzColorspace& override_cs, const FzMatrix& ctm, const FzPixmap& dest, const FzColorParams& color_params, const FzIrect& bbox, const FzOverprint& eop, FzShadeColorCache& cache)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_paint_shade()\n";
	}
	#endif
	mupdf::ll_fz_paint_shade(shade.m_internal, override_cs.m_internal, * ctm.internal(), dest.m_internal, * color_params.internal(), * bbox.internal(), eop.m_internal, &cache.m_internal);
}


/* Class-aware wrapper for `::fz_parse_page_range()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_parse_page_range(const char *s, int n)` => `(const char *, int a, int b)`
	 */
FZ_FUNCTION const char *fz_parse_page_range(const char *s, int *a, int *b, int n)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_parse_page_range()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_parse_page_range(s, a, b, n);
	return ret;
}


/* Class-aware wrapper for `::fz_parse_pdfocr_options()`.  */
FZ_FUNCTION FzPdfocrOptions fz_parse_pdfocr_options(FzPdfocrOptions& opts, const char *args)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_parse_pdfocr_options()\n";
	}
	#endif
	::fz_pdfocr_options* temp = mupdf::ll_fz_parse_pdfocr_options( opts.internal(), args);
	auto ret = FzPdfocrOptions(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_parse_stext_options()`.  */
FZ_FUNCTION FzStextOptions fz_parse_stext_options(FzStextOptions& opts, const char *string)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_parse_stext_options()\n";
	}
	#endif
	::fz_stext_options* temp = mupdf::ll_fz_parse_stext_options( opts.internal(), string);
	auto ret = FzStextOptions(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_parse_xml()`.  */
FZ_FUNCTION FzXml fz_parse_xml(const FzBuffer& buf, int preserve_white)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_parse_xml()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_parse_xml(buf.m_internal, preserve_white);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_parse_xml_archive_entry()`.  */
FZ_FUNCTION FzXml fz_parse_xml_archive_entry(const FzArchive& dir, const char *filename, int preserve_white)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_parse_xml_archive_entry()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_parse_xml_archive_entry(dir.m_internal, filename, preserve_white);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_parse_xml_from_html5()`.  */
FZ_FUNCTION FzXml fz_parse_xml_from_html5(const FzBuffer& buf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_parse_xml_from_html5()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_parse_xml_from_html5(buf.m_internal);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_parse_xml_stream()`.  */
FZ_FUNCTION FzXml fz_parse_xml_stream(const FzStream& stream, int preserve_white)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_parse_xml_stream()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_parse_xml_stream(stream.m_internal, preserve_white);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_pcl_preset()`.  */
FZ_FUNCTION void fz_pcl_preset(const FzPclOptions& opts, const char *preset)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pcl_preset()\n";
	}
	#endif
	mupdf::ll_fz_pcl_preset(opts.m_internal, preset);
}


/* Class-aware wrapper for `::fz_pdfocr_band_writer_set_progress()`.  */
FZ_FUNCTION void fz_pdfocr_band_writer_set_progress(const FzBandWriter& writer, ::fz_pdfocr_progress_fn *progress_fn, void *progress_arg)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pdfocr_band_writer_set_progress()\n";
	}
	#endif
	mupdf::ll_fz_pdfocr_band_writer_set_progress(writer.m_internal, progress_fn, progress_arg);
}


/* Class-aware wrapper for `::fz_pdfocr_writer_set_progress()`.  */
FZ_FUNCTION void fz_pdfocr_writer_set_progress(const FzDocumentWriter& writer, ::fz_pdfocr_progress_fn *progress, void *arg_2)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pdfocr_writer_set_progress()\n";
	}
	#endif
	mupdf::ll_fz_pdfocr_writer_set_progress(writer.m_internal, progress, arg_2);
}


/* Class-aware wrapper for `::fz_peek_byte()`.  */
FZ_FUNCTION int fz_peek_byte(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_peek_byte()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_peek_byte(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_pixmap_alpha()`.  */
FZ_FUNCTION int fz_pixmap_alpha(const FzPixmap& pix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_alpha()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_pixmap_alpha(pix.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_pixmap_bbox()`.  */
FZ_FUNCTION FzIrect fz_pixmap_bbox(const FzPixmap& pix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_bbox()\n";
	}
	#endif
	::fz_irect temp = mupdf::ll_fz_pixmap_bbox(pix.m_internal);
	auto ret = FzIrect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_pixmap_colorants()`.  */
FZ_FUNCTION int fz_pixmap_colorants(const FzPixmap& pix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_colorants()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_pixmap_colorants(pix.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_pixmap_colorspace()`.  */
FZ_FUNCTION FzColorspace fz_pixmap_colorspace(const FzPixmap& pix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_colorspace()\n";
	}
	#endif
	::fz_colorspace* temp = mupdf::ll_fz_pixmap_colorspace(pix.m_internal);
	ll_fz_keep_colorspace(temp);
	auto ret = FzColorspace(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_pixmap_components()`.  */
FZ_FUNCTION int fz_pixmap_components(const FzPixmap& pix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_components()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_pixmap_components(pix.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_pixmap_height()`.  */
FZ_FUNCTION int fz_pixmap_height(const FzPixmap& pix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_height()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_pixmap_height(pix.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_pixmap_image_tile()`.  */
FZ_FUNCTION FzPixmap fz_pixmap_image_tile(const FzPixmapImage& cimg)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_image_tile()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_pixmap_image_tile(cimg.m_internal);
	ll_fz_keep_pixmap(temp);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_pixmap_samples()`.  */
FZ_FUNCTION unsigned char *fz_pixmap_samples(const FzPixmap& pix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_samples()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_pixmap_samples(pix.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_pixmap_samples_int()`.  */
FZ_FUNCTION long long fz_pixmap_samples_int(const FzPixmap& pixmap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_samples_int()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_pixmap_samples_int(pixmap.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_pixmap_size()`.  */
FZ_FUNCTION size_t fz_pixmap_size(const FzPixmap& pix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_size()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_pixmap_size(pix.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_pixmap_spots()`.  */
FZ_FUNCTION int fz_pixmap_spots(const FzPixmap& pix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_spots()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_pixmap_spots(pix.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_pixmap_stride()`.  */
FZ_FUNCTION int fz_pixmap_stride(const FzPixmap& pix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_stride()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_pixmap_stride(pix.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_pixmap_width()`.  */
FZ_FUNCTION int fz_pixmap_width(const FzPixmap& pix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_width()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_pixmap_width(pix.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_pixmap_x()`.  */
FZ_FUNCTION int fz_pixmap_x(const FzPixmap& pix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_x()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_pixmap_x(pix.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_pixmap_y()`.  */
FZ_FUNCTION int fz_pixmap_y(const FzPixmap& pix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pixmap_y()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_pixmap_y(pix.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_place_story()`.  */
FZ_FUNCTION int fz_place_story(const FzStory& story, const FzRect& where, FzRect& filled)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_place_story()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_place_story(story.m_internal, * where.internal(),  filled.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_place_story_flags()`.  */
FZ_FUNCTION int fz_place_story_flags(const FzStory& story, const FzRect& where, FzRect& filled, int flags)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_place_story_flags()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_place_story_flags(story.m_internal, * where.internal(),  filled.internal(), flags);
	return ret;
}


/* Class-aware wrapper for `::fz_pool_alloc()`.  */
FZ_FUNCTION void *fz_pool_alloc(const FzPool& pool, size_t size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pool_alloc()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_pool_alloc(pool.m_internal, size);
	return ret;
}


/* Class-aware wrapper for `::fz_pool_size()`.  */
FZ_FUNCTION size_t fz_pool_size(const FzPool& pool)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pool_size()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_pool_size(pool.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_pool_strdup()`.  */
FZ_FUNCTION char *fz_pool_strdup(const FzPool& pool, const char *s)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pool_strdup()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_pool_strdup(pool.m_internal, s);
	return ret;
}


/* Class-aware wrapper for `::fz_pop_clip()`.  */
FZ_FUNCTION void fz_pop_clip(const FzDevice& dev)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pop_clip()\n";
	}
	#endif
	mupdf::ll_fz_pop_clip(dev.m_internal);
}


/* Class-aware wrapper for `::fz_post_scale()`.  */
FZ_FUNCTION FzMatrix fz_post_scale(const FzMatrix& m, float sx, float sy)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_post_scale()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_fz_post_scale(* m.internal(), sx, sy);
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_pre_rotate()`.  */
FZ_FUNCTION FzMatrix fz_pre_rotate(const FzMatrix& m, float degrees)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pre_rotate()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_fz_pre_rotate(* m.internal(), degrees);
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_pre_scale()`.  */
FZ_FUNCTION FzMatrix fz_pre_scale(const FzMatrix& m, float sx, float sy)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pre_scale()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_fz_pre_scale(* m.internal(), sx, sy);
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_pre_shear()`.  */
FZ_FUNCTION FzMatrix fz_pre_shear(const FzMatrix& m, float sx, float sy)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pre_shear()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_fz_pre_shear(* m.internal(), sx, sy);
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_pre_translate()`.  */
FZ_FUNCTION FzMatrix fz_pre_translate(const FzMatrix& m, float tx, float ty)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_pre_translate()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_fz_pre_translate(* m.internal(), tx, ty);
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_prepare_t3_glyph()`.  */
FZ_FUNCTION void fz_prepare_t3_glyph(const FzFont& font, int gid)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_prepare_t3_glyph()\n";
	}
	#endif
	mupdf::ll_fz_prepare_t3_glyph(font.m_internal, gid);
}


/* Class-aware wrapper for `::fz_previous_page()`.  */
FZ_FUNCTION FzLocation fz_previous_page(const FzDocument& doc, const FzLocation& loc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_previous_page()\n";
	}
	#endif
	::fz_location temp = mupdf::ll_fz_previous_page(doc.m_internal, * loc.internal());
	auto ret = FzLocation(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_print_stext_header_as_html()`.  */
FZ_FUNCTION void fz_print_stext_header_as_html(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_print_stext_header_as_html()\n";
	}
	#endif
	mupdf::ll_fz_print_stext_header_as_html(out.m_internal);
}


/* Class-aware wrapper for `::fz_print_stext_header_as_xhtml()`.  */
FZ_FUNCTION void fz_print_stext_header_as_xhtml(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_print_stext_header_as_xhtml()\n";
	}
	#endif
	mupdf::ll_fz_print_stext_header_as_xhtml(out.m_internal);
}


/* Class-aware wrapper for `::fz_print_stext_page_as_html()`.  */
FZ_FUNCTION void fz_print_stext_page_as_html(const FzOutput& out, const FzStextPage& page, int id)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_print_stext_page_as_html()\n";
	}
	#endif
	mupdf::ll_fz_print_stext_page_as_html(out.m_internal, page.m_internal, id);
}


/* Class-aware wrapper for `::fz_print_stext_page_as_json()`.  */
FZ_FUNCTION void fz_print_stext_page_as_json(const FzOutput& out, const FzStextPage& page, float scale)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_print_stext_page_as_json()\n";
	}
	#endif
	mupdf::ll_fz_print_stext_page_as_json(out.m_internal, page.m_internal, scale);
}


/* Class-aware wrapper for `::fz_print_stext_page_as_text()`.  */
FZ_FUNCTION void fz_print_stext_page_as_text(const FzOutput& out, const FzStextPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_print_stext_page_as_text()\n";
	}
	#endif
	mupdf::ll_fz_print_stext_page_as_text(out.m_internal, page.m_internal);
}


/* Class-aware wrapper for `::fz_print_stext_page_as_xhtml()`.  */
FZ_FUNCTION void fz_print_stext_page_as_xhtml(const FzOutput& out, const FzStextPage& page, int id)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_print_stext_page_as_xhtml()\n";
	}
	#endif
	mupdf::ll_fz_print_stext_page_as_xhtml(out.m_internal, page.m_internal, id);
}


/* Class-aware wrapper for `::fz_print_stext_page_as_xml()`.  */
FZ_FUNCTION void fz_print_stext_page_as_xml(const FzOutput& out, const FzStextPage& page, int id)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_print_stext_page_as_xml()\n";
	}
	#endif
	mupdf::ll_fz_print_stext_page_as_xml(out.m_internal, page.m_internal, id);
}


/* Class-aware wrapper for `::fz_print_stext_trailer_as_html()`.  */
FZ_FUNCTION void fz_print_stext_trailer_as_html(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_print_stext_trailer_as_html()\n";
	}
	#endif
	mupdf::ll_fz_print_stext_trailer_as_html(out.m_internal);
}


/* Class-aware wrapper for `::fz_print_stext_trailer_as_xhtml()`.  */
FZ_FUNCTION void fz_print_stext_trailer_as_xhtml(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_print_stext_trailer_as_xhtml()\n";
	}
	#endif
	mupdf::ll_fz_print_stext_trailer_as_xhtml(out.m_internal);
}


/* Class-aware wrapper for `::fz_process_opened_pages()`.  */
FZ_FUNCTION void *fz_process_opened_pages(const FzDocument& doc, ::fz_process_opened_page_fn *process_openend_page, void *state)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_process_opened_pages()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_process_opened_pages(doc.m_internal, process_openend_page, state);
	return ret;
}


/* Class-aware wrapper for `::fz_process_shade()`.  */
FZ_FUNCTION void fz_process_shade(const FzShade& shade, const FzMatrix& ctm, const FzRect& scissor, ::fz_shade_prepare_fn *prepare, ::fz_shade_process_fn *process, void *process_arg)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_process_shade()\n";
	}
	#endif
	mupdf::ll_fz_process_shade(shade.m_internal, * ctm.internal(), * scissor.internal(), prepare, process, process_arg);
}


/* Class-aware wrapper for `::fz_ptr_heap_insert()`.  */
FZ_FUNCTION void fz_ptr_heap_insert(const FzPtrHeap& heap, void *v, int (*HEAP_CMP)(void **, void **))
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_ptr_heap_insert()\n";
	}
	#endif
	mupdf::ll_fz_ptr_heap_insert(heap.m_internal, v, HEAP_CMP);
}


/* Class-aware wrapper for `::fz_ptr_heap_sort()`.  */
FZ_FUNCTION void fz_ptr_heap_sort(const FzPtrHeap& heap, int (*HEAP_CMP)(void **, void **))
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_ptr_heap_sort()\n";
	}
	#endif
	mupdf::ll_fz_ptr_heap_sort(heap.m_internal, HEAP_CMP);
}


/* Class-aware wrapper for `::fz_ptr_heap_uniq()`.  */
FZ_FUNCTION void fz_ptr_heap_uniq(const FzPtrHeap& heap, int (*HEAP_CMP)(void **, void **))
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_ptr_heap_uniq()\n";
	}
	#endif
	mupdf::ll_fz_ptr_heap_uniq(heap.m_internal, HEAP_CMP);
}


/* Class-aware wrapper for `::fz_purge_glyph_cache()`.  */
FZ_FUNCTION void fz_purge_glyph_cache()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_purge_glyph_cache()\n";
	}
	#endif
	mupdf::ll_fz_purge_glyph_cache();
}


/* Class-aware wrapper for `::fz_quad_from_rect()`.  */
FZ_FUNCTION FzQuad fz_quad_from_rect(const FzRect& r)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_quad_from_rect()\n";
	}
	#endif
	::fz_quad temp = mupdf::ll_fz_quad_from_rect(* r.internal());
	auto ret = FzQuad(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_quadto()`.  */
FZ_FUNCTION void fz_quadto(const FzPath& path, float x0, float y0, float x1, float y1)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_quadto()\n";
	}
	#endif
	mupdf::ll_fz_quadto(path.m_internal, x0, y0, x1, y1);
}


/* Class-aware wrapper for `::fz_read()`.  */
FZ_FUNCTION size_t fz_read(const FzStream& stm, unsigned char *data, size_t len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read(stm.m_internal, data, len);
	return ret;
}


/* Class-aware wrapper for `::fz_read_all()`.  */
FZ_FUNCTION FzBuffer fz_read_all(const FzStream& stm, size_t initial)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_all()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_read_all(stm.m_internal, initial);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_read_archive_entry()`.  */
FZ_FUNCTION FzBuffer fz_read_archive_entry(const FzArchive& arch, const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_archive_entry()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_read_archive_entry(arch.m_internal, name);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_read_best()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_read_best(::fz_stream *stm, size_t initial, size_t worst_case)` => `(fz_buffer *, int truncated)`
	 */
FZ_FUNCTION FzBuffer fz_read_best(const FzStream& stm, size_t initial, int *truncated, size_t worst_case)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_best()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_read_best(stm.m_internal, initial, truncated, worst_case);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_read_bits()`.  */
FZ_FUNCTION unsigned int fz_read_bits(const FzStream& stm, int n)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_bits()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_bits(stm.m_internal, n);
	return ret;
}


/* Class-aware wrapper for `::fz_read_byte()`.  */
FZ_FUNCTION int fz_read_byte(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_byte()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_byte(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_read_file()`.  */
FZ_FUNCTION FzBuffer fz_read_file(const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_file()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_read_file(filename);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_read_float()`.  */
FZ_FUNCTION float fz_read_float(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_float()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_float(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_read_float_le()`.  */
FZ_FUNCTION float fz_read_float_le(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_float_le()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_float_le(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_read_int16()`.  */
FZ_FUNCTION int16_t fz_read_int16(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_int16()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_int16(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_read_int16_le()`.  */
FZ_FUNCTION int16_t fz_read_int16_le(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_int16_le()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_int16_le(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_read_int32()`.  */
FZ_FUNCTION int32_t fz_read_int32(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_int32()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_int32(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_read_int32_le()`.  */
FZ_FUNCTION int32_t fz_read_int32_le(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_int32_le()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_int32_le(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_read_int64()`.  */
FZ_FUNCTION int64_t fz_read_int64(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_int64()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_int64(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_read_int64_le()`.  */
FZ_FUNCTION int64_t fz_read_int64_le(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_int64_le()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_int64_le(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_read_line()`.  */
FZ_FUNCTION char *fz_read_line(const FzStream& stm, char *buf, size_t max)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_line()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_line(stm.m_internal, buf, max);
	return ret;
}


/* Class-aware wrapper for `::fz_read_rbits()`.  */
FZ_FUNCTION unsigned int fz_read_rbits(const FzStream& stm, int n)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_rbits()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_rbits(stm.m_internal, n);
	return ret;
}


/* Class-aware wrapper for `::fz_read_rune()`.  */
FZ_FUNCTION int fz_read_rune(const FzStream& in)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_rune()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_rune(in.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_read_string()`.  */
FZ_FUNCTION void fz_read_string(const FzStream& stm, char *buffer, int len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_string()\n";
	}
	#endif
	mupdf::ll_fz_read_string(stm.m_internal, buffer, len);
}


/* Class-aware wrapper for `::fz_read_uint16()`.  */
FZ_FUNCTION uint16_t fz_read_uint16(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_uint16()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_uint16(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_read_uint16_le()`.  */
FZ_FUNCTION uint16_t fz_read_uint16_le(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_uint16_le()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_uint16_le(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_read_uint24()`.  */
FZ_FUNCTION uint32_t fz_read_uint24(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_uint24()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_uint24(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_read_uint24_le()`.  */
FZ_FUNCTION uint32_t fz_read_uint24_le(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_uint24_le()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_uint24_le(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_read_uint32()`.  */
FZ_FUNCTION uint32_t fz_read_uint32(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_uint32()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_uint32(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_read_uint32_le()`.  */
FZ_FUNCTION uint32_t fz_read_uint32_le(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_uint32_le()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_uint32_le(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_read_uint64()`.  */
FZ_FUNCTION uint64_t fz_read_uint64(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_uint64()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_uint64(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_read_uint64_le()`.  */
FZ_FUNCTION uint64_t fz_read_uint64_le(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_uint64_le()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_uint64_le(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_read_utf16_be()`.  */
FZ_FUNCTION int fz_read_utf16_be(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_utf16_be()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_utf16_be(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_read_utf16_le()`.  */
FZ_FUNCTION int fz_read_utf16_le(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_read_utf16_le()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_read_utf16_le(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_realloc()`.  */
FZ_FUNCTION void *fz_realloc(void *p, size_t size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_realloc()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_realloc(p, size);
	return ret;
}


/* Class-aware wrapper for `::fz_realloc_no_throw()`.  */
FZ_FUNCTION void *fz_realloc_no_throw(void *p, size_t size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_realloc_no_throw()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_realloc_no_throw(p, size);
	return ret;
}


/* Class-aware wrapper for `::fz_realpath()`.  */
FZ_FUNCTION char *fz_realpath(const char *path, char *resolved_path)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_realpath()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_realpath(path, resolved_path);
	return ret;
}


/* Class-aware wrapper for `::fz_recognize_image_format()`.  */
FZ_FUNCTION int fz_recognize_image_format(unsigned char p[8])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_recognize_image_format()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_recognize_image_format(p);
	return ret;
}


/* Class-aware wrapper for `::fz_rect_from_irect()`.  */
FZ_FUNCTION FzRect fz_rect_from_irect(const FzIrect& bbox)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_rect_from_irect()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_fz_rect_from_irect(* bbox.internal());
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_rect_from_quad()`.  */
FZ_FUNCTION FzRect fz_rect_from_quad(const FzQuad& q)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_rect_from_quad()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_fz_rect_from_quad(* q.internal());
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_rectto()`.  */
FZ_FUNCTION void fz_rectto(const FzPath& path, float x0, float y0, float x1, float y1)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_rectto()\n";
	}
	#endif
	mupdf::ll_fz_rectto(path.m_internal, x0, y0, x1, y1);
}


/* Class-aware wrapper for `::fz_register_archive_handler()`.  */
FZ_FUNCTION void fz_register_archive_handler(const FzArchiveHandler& handler)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_register_archive_handler()\n";
	}
	#endif
	mupdf::ll_fz_register_archive_handler(handler.m_internal);
}


/* Class-aware wrapper for `::fz_register_document_handler()`.  */
FZ_FUNCTION void fz_register_document_handler(const FzDocumentHandler& handler)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_register_document_handler()\n";
	}
	#endif
	mupdf::ll_fz_register_document_handler(handler.m_internal);
}


/* Class-aware wrapper for `::fz_register_document_handlers()`.  */
FZ_FUNCTION void fz_register_document_handlers()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_register_document_handlers()\n";
	}
	#endif
	mupdf::ll_fz_register_document_handlers();
}


/* Class-aware wrapper for `::fz_remove_item()`.  */
FZ_FUNCTION void fz_remove_item(::fz_store_drop_fn *drop, void *key, const FzStoreType& type)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_remove_item()\n";
	}
	#endif
	mupdf::ll_fz_remove_item(drop, key, type.m_internal);
}


/* Class-aware wrapper for `::fz_render_flags()`.  */
FZ_FUNCTION void fz_render_flags(const FzDevice& dev, int set, int clear)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_render_flags()\n";
	}
	#endif
	mupdf::ll_fz_render_flags(dev.m_internal, set, clear);
}


/* Class-aware wrapper for `::fz_render_glyph_pixmap()`.  */
FZ_FUNCTION FzPixmap fz_render_glyph_pixmap(const FzFont& font, int gid, FzMatrix& ctm, FzIrect& scissor, int aa)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_render_glyph_pixmap()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_render_glyph_pixmap(font.m_internal, gid,  ctm.internal(),  scissor.internal(), aa);
	ll_fz_keep_pixmap(temp);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_render_t3_glyph_direct()`.  */
FZ_FUNCTION void fz_render_t3_glyph_direct(const FzDevice& dev, const FzFont& font, int gid, const FzMatrix& trm, void *gstate, const FzDefaultColorspaces& def_cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_render_t3_glyph_direct()\n";
	}
	#endif
	mupdf::ll_fz_render_t3_glyph_direct(dev.m_internal, font.m_internal, gid, * trm.internal(), gstate, def_cs.m_internal);
}


/* Class-aware wrapper for `::fz_rendering_intent_name()`.  */
FZ_FUNCTION const char *fz_rendering_intent_name(int ri)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_rendering_intent_name()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_rendering_intent_name(ri);
	return ret;
}


/* Class-aware wrapper for `::fz_report_error()`.  */
FZ_FUNCTION void fz_report_error()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_report_error()\n";
	}
	#endif
	mupdf::ll_fz_report_error();
}


/* Class-aware wrapper for `::fz_reset_output()`.  */
FZ_FUNCTION void fz_reset_output(const FzOutput& arg_0)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_reset_output()\n";
	}
	#endif
	mupdf::ll_fz_reset_output(arg_0.m_internal);
}


/* Class-aware wrapper for `::fz_reset_story()`.  */
FZ_FUNCTION void fz_reset_story(const FzStory& story)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_reset_story()\n";
	}
	#endif
	mupdf::ll_fz_reset_story(story.m_internal);
}


/* Class-aware wrapper for `::fz_resize_buffer()`.  */
FZ_FUNCTION void fz_resize_buffer(const FzBuffer& buf, size_t capacity)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_resize_buffer()\n";
	}
	#endif
	mupdf::ll_fz_resize_buffer(buf.m_internal, capacity);
}


/* Class-aware wrapper for `::fz_resolve_link()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_resolve_link(::fz_document *doc, const char *uri)` => `(fz_location, float xp, float yp)`
	 */
FZ_FUNCTION FzLocation fz_resolve_link(const FzDocument& doc, const char *uri, float *xp, float *yp)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_resolve_link()\n";
	}
	#endif
	::fz_location temp = mupdf::ll_fz_resolve_link(doc.m_internal, uri, xp, yp);
	auto ret = FzLocation(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_rethrow()`.  */
FZ_FUNCTION void fz_rethrow()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_rethrow()\n";
	}
	#endif
	mupdf::ll_fz_rethrow();
}


/* Class-aware wrapper for `::fz_rethrow_if()`.  */
FZ_FUNCTION void fz_rethrow_if(int errcode)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_rethrow_if()\n";
	}
	#endif
	mupdf::ll_fz_rethrow_if(errcode);
}


/* Class-aware wrapper for `::fz_rethrow_unless()`.  */
FZ_FUNCTION void fz_rethrow_unless(int errcode)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_rethrow_unless()\n";
	}
	#endif
	mupdf::ll_fz_rethrow_unless(errcode);
}


/* Class-aware wrapper for `::fz_rotate()`.  */
FZ_FUNCTION FzMatrix fz_rotate(float degrees)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_rotate()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_fz_rotate(degrees);
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_round_rect()`.  */
FZ_FUNCTION FzIrect fz_round_rect(const FzRect& rect)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_round_rect()\n";
	}
	#endif
	::fz_irect temp = mupdf::ll_fz_round_rect(* rect.internal());
	auto ret = FzIrect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_run_display_list()`.  */
FZ_FUNCTION void fz_run_display_list(const FzDisplayList& list, const FzDevice& dev, const FzMatrix& ctm, const FzRect& scissor, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_run_display_list()\n";
	}
	#endif
	mupdf::ll_fz_run_display_list(list.m_internal, dev.m_internal, * ctm.internal(), * scissor.internal(), &cookie.m_internal);
}


/* Class-aware wrapper for `::fz_run_document_structure()`.  */
FZ_FUNCTION void fz_run_document_structure(const FzDocument& doc, const FzDevice& dev, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_run_document_structure()\n";
	}
	#endif
	mupdf::ll_fz_run_document_structure(doc.m_internal, dev.m_internal, &cookie.m_internal);
}


/* Class-aware wrapper for `::fz_run_page()`.  */
FZ_FUNCTION void fz_run_page(const FzPage& page, const FzDevice& dev, const FzMatrix& transform, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_run_page()\n";
	}
	#endif
	mupdf::ll_fz_run_page(page.m_internal, dev.m_internal, * transform.internal(), &cookie.m_internal);
}


/* Class-aware wrapper for `::fz_run_page_annots()`.  */
FZ_FUNCTION void fz_run_page_annots(const FzPage& page, const FzDevice& dev, const FzMatrix& transform, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_run_page_annots()\n";
	}
	#endif
	mupdf::ll_fz_run_page_annots(page.m_internal, dev.m_internal, * transform.internal(), &cookie.m_internal);
}


/* Class-aware wrapper for `::fz_run_page_contents()`.  */
FZ_FUNCTION void fz_run_page_contents(const FzPage& page, const FzDevice& dev, const FzMatrix& transform, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_run_page_contents()\n";
	}
	#endif
	mupdf::ll_fz_run_page_contents(page.m_internal, dev.m_internal, * transform.internal(), &cookie.m_internal);
}


/* Class-aware wrapper for `::fz_run_page_widgets()`.  */
FZ_FUNCTION void fz_run_page_widgets(const FzPage& page, const FzDevice& dev, const FzMatrix& transform, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_run_page_widgets()\n";
	}
	#endif
	mupdf::ll_fz_run_page_widgets(page.m_internal, dev.m_internal, * transform.internal(), &cookie.m_internal);
}


/* Class-aware wrapper for `::fz_run_t3_glyph()`.  */
FZ_FUNCTION void fz_run_t3_glyph(const FzFont& font, int gid, const FzMatrix& trm, const FzDevice& dev)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_run_t3_glyph()\n";
	}
	#endif
	mupdf::ll_fz_run_t3_glyph(font.m_internal, gid, * trm.internal(), dev.m_internal);
}


/* Class-aware wrapper for `::fz_runeidx()`.  */
FZ_FUNCTION int fz_runeidx(const char *str, const char *p)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_runeidx()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_runeidx(str, p);
	return ret;
}


/* Class-aware wrapper for `::fz_runelen()`.  */
FZ_FUNCTION int fz_runelen(int rune)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_runelen()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_runelen(rune);
	return ret;
}


/* Class-aware wrapper for `::fz_runeptr()`.  */
FZ_FUNCTION const char *fz_runeptr(const char *str, int idx)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_runeptr()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_runeptr(str, idx);
	return ret;
}


/* Class-aware wrapper for `::fz_runetochar()`.  */
FZ_FUNCTION int fz_runetochar(char *str, int rune)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_runetochar()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_runetochar(str, rune);
	return ret;
}


/* Class-aware wrapper for `::fz_samples_get()`.  */
FZ_FUNCTION int fz_samples_get(const FzPixmap& pixmap, int offset)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_samples_get()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_samples_get(pixmap.m_internal, offset);
	return ret;
}


/* Class-aware wrapper for `::fz_samples_set()`.  */
FZ_FUNCTION void fz_samples_set(const FzPixmap& pixmap, int offset, int value)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_samples_set()\n";
	}
	#endif
	mupdf::ll_fz_samples_set(pixmap.m_internal, offset, value);
}


/* Class-aware wrapper for `::fz_save_accelerator()`.  */
FZ_FUNCTION void fz_save_accelerator(const FzDocument& doc, const char *accel)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_accelerator()\n";
	}
	#endif
	mupdf::ll_fz_save_accelerator(doc.m_internal, accel);
}


/* Class-aware wrapper for `::fz_save_bitmap_as_pbm()`.  */
FZ_FUNCTION void fz_save_bitmap_as_pbm(const FzBitmap& bitmap, const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_bitmap_as_pbm()\n";
	}
	#endif
	mupdf::ll_fz_save_bitmap_as_pbm(bitmap.m_internal, filename);
}


/* Class-aware wrapper for `::fz_save_bitmap_as_pcl()`.  */
FZ_FUNCTION void fz_save_bitmap_as_pcl(const FzBitmap& bitmap, char *filename, int append, const FzPclOptions& pcl)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_bitmap_as_pcl()\n";
	}
	#endif
	mupdf::ll_fz_save_bitmap_as_pcl(bitmap.m_internal, filename, append, pcl.m_internal);
}


/* Class-aware wrapper for `::fz_save_bitmap_as_pkm()`.  */
FZ_FUNCTION void fz_save_bitmap_as_pkm(const FzBitmap& bitmap, const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_bitmap_as_pkm()\n";
	}
	#endif
	mupdf::ll_fz_save_bitmap_as_pkm(bitmap.m_internal, filename);
}


/* Class-aware wrapper for `::fz_save_bitmap_as_pwg()`.  */
FZ_FUNCTION void fz_save_bitmap_as_pwg(const FzBitmap& bitmap, char *filename, int append, FzPwgOptions& pwg)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_bitmap_as_pwg()\n";
	}
	#endif
	mupdf::ll_fz_save_bitmap_as_pwg(bitmap.m_internal, filename, append, &pwg.m_internal);
}


/* Class-aware wrapper for `::fz_save_buffer()`.  */
FZ_FUNCTION void fz_save_buffer(const FzBuffer& buf, const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_buffer()\n";
	}
	#endif
	mupdf::ll_fz_save_buffer(buf.m_internal, filename);
}


/* Class-aware wrapper for `::fz_save_pixmap_as_jpeg()`.  */
FZ_FUNCTION void fz_save_pixmap_as_jpeg(const FzPixmap& pixmap, const char *filename, int quality)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_jpeg()\n";
	}
	#endif
	mupdf::ll_fz_save_pixmap_as_jpeg(pixmap.m_internal, filename, quality);
}


/* Class-aware wrapper for `::fz_save_pixmap_as_jpx()`.  */
FZ_FUNCTION void fz_save_pixmap_as_jpx(const FzPixmap& pixmap, const char *filename, int q)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_jpx()\n";
	}
	#endif
	mupdf::ll_fz_save_pixmap_as_jpx(pixmap.m_internal, filename, q);
}


/* Class-aware wrapper for `::fz_save_pixmap_as_pam()`.  */
FZ_FUNCTION void fz_save_pixmap_as_pam(const FzPixmap& pixmap, const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_pam()\n";
	}
	#endif
	mupdf::ll_fz_save_pixmap_as_pam(pixmap.m_internal, filename);
}


/* Class-aware wrapper for `::fz_save_pixmap_as_pbm()`.  */
FZ_FUNCTION void fz_save_pixmap_as_pbm(const FzPixmap& pixmap, const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_pbm()\n";
	}
	#endif
	mupdf::ll_fz_save_pixmap_as_pbm(pixmap.m_internal, filename);
}


/* Class-aware wrapper for `::fz_save_pixmap_as_pcl()`.  */
FZ_FUNCTION void fz_save_pixmap_as_pcl(const FzPixmap& pixmap, char *filename, int append, const FzPclOptions& pcl)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_pcl()\n";
	}
	#endif
	mupdf::ll_fz_save_pixmap_as_pcl(pixmap.m_internal, filename, append, pcl.m_internal);
}


/* Class-aware wrapper for `::fz_save_pixmap_as_pclm()`.  */
FZ_FUNCTION void fz_save_pixmap_as_pclm(const FzPixmap& pixmap, char *filename, int append, const FzPclmOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_pclm()\n";
	}
	#endif
	mupdf::ll_fz_save_pixmap_as_pclm(pixmap.m_internal, filename, append, options.m_internal);
}


/* Class-aware wrapper for `::fz_save_pixmap_as_pdfocr()`.  */
FZ_FUNCTION void fz_save_pixmap_as_pdfocr(const FzPixmap& pixmap, char *filename, int append, FzPdfocrOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_pdfocr()\n";
	}
	#endif
	mupdf::ll_fz_save_pixmap_as_pdfocr(pixmap.m_internal, filename, append,  options.internal());
}


/* Class-aware wrapper for `::fz_save_pixmap_as_pkm()`.  */
FZ_FUNCTION void fz_save_pixmap_as_pkm(const FzPixmap& pixmap, const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_pkm()\n";
	}
	#endif
	mupdf::ll_fz_save_pixmap_as_pkm(pixmap.m_internal, filename);
}


/* Class-aware wrapper for `::fz_save_pixmap_as_png()`.  */
FZ_FUNCTION void fz_save_pixmap_as_png(const FzPixmap& pixmap, const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_png()\n";
	}
	#endif
	mupdf::ll_fz_save_pixmap_as_png(pixmap.m_internal, filename);
}


/* Class-aware wrapper for `::fz_save_pixmap_as_pnm()`.  */
FZ_FUNCTION void fz_save_pixmap_as_pnm(const FzPixmap& pixmap, const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_pnm()\n";
	}
	#endif
	mupdf::ll_fz_save_pixmap_as_pnm(pixmap.m_internal, filename);
}


/* Class-aware wrapper for `::fz_save_pixmap_as_ps()`.  */
FZ_FUNCTION void fz_save_pixmap_as_ps(const FzPixmap& pixmap, char *filename, int append)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_ps()\n";
	}
	#endif
	mupdf::ll_fz_save_pixmap_as_ps(pixmap.m_internal, filename, append);
}


/* Class-aware wrapper for `::fz_save_pixmap_as_psd()`.  */
FZ_FUNCTION void fz_save_pixmap_as_psd(const FzPixmap& pixmap, const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_psd()\n";
	}
	#endif
	mupdf::ll_fz_save_pixmap_as_psd(pixmap.m_internal, filename);
}


/* Class-aware wrapper for `::fz_save_pixmap_as_pwg()`.  */
FZ_FUNCTION void fz_save_pixmap_as_pwg(const FzPixmap& pixmap, char *filename, int append, FzPwgOptions& pwg)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_save_pixmap_as_pwg()\n";
	}
	#endif
	mupdf::ll_fz_save_pixmap_as_pwg(pixmap.m_internal, filename, append, &pwg.m_internal);
}


/* Class-aware wrapper for `::fz_scale()`.  */
FZ_FUNCTION FzMatrix fz_scale(float sx, float sy)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_scale()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_fz_scale(sx, sy);
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_scale_pixmap()`.  */
FZ_FUNCTION FzPixmap fz_scale_pixmap(const FzPixmap& src, float x, float y, float w, float h, FzIrect& clip)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_scale_pixmap()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_scale_pixmap(src.m_internal, x, y, w, h,  clip.internal());
	ll_fz_keep_pixmap(temp);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_search_chapter_page_number()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_search_chapter_page_number(::fz_document *doc, int chapter, int page, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
	 */
FZ_FUNCTION int fz_search_chapter_page_number(const FzDocument& doc, int chapter, int page, const char *needle, int *hit_mark, FzQuad& hit_bbox, int hit_max)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_search_chapter_page_number()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_search_chapter_page_number(doc.m_internal, chapter, page, needle, hit_mark,  hit_bbox.internal(), hit_max);
	return ret;
}


/* Class-aware wrapper for `::fz_search_display_list()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_search_display_list(::fz_display_list *list, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
	 */
FZ_FUNCTION int fz_search_display_list(const FzDisplayList& list, const char *needle, int *hit_mark, FzQuad& hit_bbox, int hit_max)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_search_display_list()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_search_display_list(list.m_internal, needle, hit_mark,  hit_bbox.internal(), hit_max);
	return ret;
}


/* Class-aware wrapper for `::fz_search_page()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_search_page(::fz_page *page, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
	 */
FZ_FUNCTION int fz_search_page(const FzPage& page, const char *needle, int *hit_mark, FzQuad& hit_bbox, int hit_max)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_search_page()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_search_page(page.m_internal, needle, hit_mark,  hit_bbox.internal(), hit_max);
	return ret;
}


/* Class-aware wrapper for `::fz_search_page2()`.  */
FZ_FUNCTION std::vector<fz_search_page2_hit> fz_search_page2(const FzDocument& doc, int number, const char *needle, int hit_max)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_search_page2()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_search_page2(doc.m_internal, number, needle, hit_max);
	return ret;
}


/* Class-aware wrapper for `::fz_search_page_number()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_search_page_number(::fz_document *doc, int number, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
	 */
FZ_FUNCTION int fz_search_page_number(const FzDocument& doc, int number, const char *needle, int *hit_mark, FzQuad& hit_bbox, int hit_max)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_search_page_number()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_search_page_number(doc.m_internal, number, needle, hit_mark,  hit_bbox.internal(), hit_max);
	return ret;
}


/* Class-aware wrapper for `::fz_search_stext_page()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_search_stext_page(::fz_stext_page *text, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
	 */
FZ_FUNCTION int fz_search_stext_page(const FzStextPage& text, const char *needle, int *hit_mark, FzQuad& hit_bbox, int hit_max)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_search_stext_page()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_search_stext_page(text.m_internal, needle, hit_mark,  hit_bbox.internal(), hit_max);
	return ret;
}


/* Class-aware wrapper for `::fz_seek()`.  */
FZ_FUNCTION void fz_seek(const FzStream& stm, int64_t offset, int whence)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_seek()\n";
	}
	#endif
	mupdf::ll_fz_seek(stm.m_internal, offset, whence);
}


/* Class-aware wrapper for `::fz_seek_output()`.  */
FZ_FUNCTION void fz_seek_output(const FzOutput& out, int64_t off, int whence)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_seek_output()\n";
	}
	#endif
	mupdf::ll_fz_seek_output(out.m_internal, off, whence);
}


/* Class-aware wrapper for `::fz_separation_current_behavior()`.  */
FZ_FUNCTION ::fz_separation_behavior fz_separation_current_behavior(const FzSeparations& sep, int separation)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_separation_current_behavior()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_separation_current_behavior(sep.m_internal, separation);
	return ret;
}


/* Class-aware wrapper for `::fz_separation_equivalent()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_separation_equivalent(const ::fz_separations *seps, int idx, ::fz_colorspace *dst_cs, ::fz_colorspace *prf, ::fz_color_params color_params)` => float dst_color
	 */
FZ_FUNCTION void fz_separation_equivalent(const FzSeparations& seps, int idx, const FzColorspace& dst_cs, float *dst_color, const FzColorspace& prf, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_separation_equivalent()\n";
	}
	#endif
	mupdf::ll_fz_separation_equivalent(seps.m_internal, idx, dst_cs.m_internal, dst_color, prf.m_internal, * color_params.internal());
}


/* Class-aware wrapper for `::fz_separation_name()`.  */
FZ_FUNCTION const char *fz_separation_name(const FzSeparations& sep, int separation)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_separation_name()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_separation_name(sep.m_internal, separation);
	return ret;
}


/* Class-aware wrapper for `::fz_set_aa_level()`.  */
FZ_FUNCTION void fz_set_aa_level(int bits)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_aa_level()\n";
	}
	#endif
	mupdf::ll_fz_set_aa_level(bits);
}


/* Class-aware wrapper for `::fz_set_compressed_image_buffer()`.  */
FZ_FUNCTION void fz_set_compressed_image_buffer(const FzCompressedImage& cimg, const FzCompressedBuffer& buf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_compressed_image_buffer()\n";
	}
	#endif
	mupdf::ll_fz_set_compressed_image_buffer(cimg.m_internal, buf.m_internal);
}


/* Class-aware wrapper for `::fz_set_default_cmyk()`.  */
FZ_FUNCTION void fz_set_default_cmyk(const FzDefaultColorspaces& default_cs, const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_default_cmyk()\n";
	}
	#endif
	mupdf::ll_fz_set_default_cmyk(default_cs.m_internal, cs.m_internal);
}


/* Class-aware wrapper for `::fz_set_default_colorspaces()`.  */
FZ_FUNCTION void fz_set_default_colorspaces(const FzDevice& dev, const FzDefaultColorspaces& default_cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_default_colorspaces()\n";
	}
	#endif
	mupdf::ll_fz_set_default_colorspaces(dev.m_internal, default_cs.m_internal);
}


/* Class-aware wrapper for `::fz_set_default_gray()`.  */
FZ_FUNCTION void fz_set_default_gray(const FzDefaultColorspaces& default_cs, const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_default_gray()\n";
	}
	#endif
	mupdf::ll_fz_set_default_gray(default_cs.m_internal, cs.m_internal);
}


/* Class-aware wrapper for `::fz_set_default_output_intent()`.  */
FZ_FUNCTION void fz_set_default_output_intent(const FzDefaultColorspaces& default_cs, const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_default_output_intent()\n";
	}
	#endif
	mupdf::ll_fz_set_default_output_intent(default_cs.m_internal, cs.m_internal);
}


/* Class-aware wrapper for `::fz_set_default_rgb()`.  */
FZ_FUNCTION void fz_set_default_rgb(const FzDefaultColorspaces& default_cs, const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_default_rgb()\n";
	}
	#endif
	mupdf::ll_fz_set_default_rgb(default_cs.m_internal, cs.m_internal);
}


/* Class-aware wrapper for `::fz_set_error_callback()`.  */
FZ_FUNCTION void fz_set_error_callback(::fz_error_cb *error_cb, void *user)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_error_callback()\n";
	}
	#endif
	mupdf::ll_fz_set_error_callback(error_cb, user);
}


/* Class-aware wrapper for `::fz_set_font_bbox()`.  */
FZ_FUNCTION void fz_set_font_bbox(const FzFont& font, float xmin, float ymin, float xmax, float ymax)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_font_bbox()\n";
	}
	#endif
	mupdf::ll_fz_set_font_bbox(font.m_internal, xmin, ymin, xmax, ymax);
}


/* Class-aware wrapper for `::fz_set_font_embedding()`.  */
FZ_FUNCTION void fz_set_font_embedding(const FzFont& font, int embed)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_font_embedding()\n";
	}
	#endif
	mupdf::ll_fz_set_font_embedding(font.m_internal, embed);
}


/* Class-aware wrapper for `::fz_set_graphics_aa_level()`.  */
FZ_FUNCTION void fz_set_graphics_aa_level(int bits)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_graphics_aa_level()\n";
	}
	#endif
	mupdf::ll_fz_set_graphics_aa_level(bits);
}


/* Class-aware wrapper for `::fz_set_graphics_min_line_width()`.  */
FZ_FUNCTION void fz_set_graphics_min_line_width(float min_line_width)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_graphics_min_line_width()\n";
	}
	#endif
	mupdf::ll_fz_set_graphics_min_line_width(min_line_width);
}


/* Class-aware wrapper for `::fz_set_link_rect()`.  */
FZ_FUNCTION void fz_set_link_rect(const FzLink& link, const FzRect& rect)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_link_rect()\n";
	}
	#endif
	mupdf::ll_fz_set_link_rect(link.m_internal, * rect.internal());
}


/* Class-aware wrapper for `::fz_set_link_uri()`.  */
FZ_FUNCTION void fz_set_link_uri(const FzLink& link, const char *uri)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_link_uri()\n";
	}
	#endif
	mupdf::ll_fz_set_link_uri(link.m_internal, uri);
}


/* Class-aware wrapper for `::fz_set_metadata()`.  */
FZ_FUNCTION void fz_set_metadata(const FzDocument& doc, const char *key, const char *value)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_metadata()\n";
	}
	#endif
	mupdf::ll_fz_set_metadata(doc.m_internal, key, value);
}


/* Class-aware wrapper for `::fz_set_pixmap_image_tile()`.  */
FZ_FUNCTION void fz_set_pixmap_image_tile(const FzPixmapImage& cimg, const FzPixmap& pix)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_pixmap_image_tile()\n";
	}
	#endif
	mupdf::ll_fz_set_pixmap_image_tile(cimg.m_internal, pix.m_internal);
}


/* Class-aware wrapper for `::fz_set_pixmap_resolution()`.  */
FZ_FUNCTION void fz_set_pixmap_resolution(const FzPixmap& pix, int xres, int yres)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_pixmap_resolution()\n";
	}
	#endif
	mupdf::ll_fz_set_pixmap_resolution(pix.m_internal, xres, yres);
}


/* Class-aware wrapper for `::fz_set_separation_behavior()`.  */
FZ_FUNCTION void fz_set_separation_behavior(const FzSeparations& sep, int separation, ::fz_separation_behavior behavior)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_separation_behavior()\n";
	}
	#endif
	mupdf::ll_fz_set_separation_behavior(sep.m_internal, separation, behavior);
}


/* Class-aware wrapper for `::fz_set_stddbg()`.  */
FZ_FUNCTION void fz_set_stddbg(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_stddbg()\n";
	}
	#endif
	mupdf::ll_fz_set_stddbg(out.m_internal);
}


/* Class-aware wrapper for `::fz_set_text_aa_level()`.  */
FZ_FUNCTION void fz_set_text_aa_level(int bits)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_text_aa_level()\n";
	}
	#endif
	mupdf::ll_fz_set_text_aa_level(bits);
}


/* Class-aware wrapper for `::fz_set_use_document_css()`.  */
FZ_FUNCTION void fz_set_use_document_css(int use)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_use_document_css()\n";
	}
	#endif
	mupdf::ll_fz_set_use_document_css(use);
}


/* Class-aware wrapper for `::fz_set_user_context()`.  */
FZ_FUNCTION void fz_set_user_context(void *user)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_user_context()\n";
	}
	#endif
	mupdf::ll_fz_set_user_context(user);
}


/* Class-aware wrapper for `::fz_set_user_css()`.  */
FZ_FUNCTION void fz_set_user_css(const char *text)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_user_css()\n";
	}
	#endif
	mupdf::ll_fz_set_user_css(text);
}


/* Class-aware wrapper for `::fz_set_warning_callback()`.  */
FZ_FUNCTION void fz_set_warning_callback(::fz_warning_cb *warning_cb, void *user)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_set_warning_callback()\n";
	}
	#endif
	mupdf::ll_fz_set_warning_callback(warning_cb, user);
}


/* Class-aware wrapper for `::fz_sha256_final()`.  */
FZ_FUNCTION void fz_sha256_final(const FzSha256& state, unsigned char digest[32])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_sha256_final()\n";
	}
	#endif
	mupdf::ll_fz_sha256_final(state.m_internal, digest);
}


/* Class-aware wrapper for `::fz_sha256_init()`.  */
FZ_FUNCTION void fz_sha256_init(const FzSha256& state)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_sha256_init()\n";
	}
	#endif
	mupdf::ll_fz_sha256_init(state.m_internal);
}


/* Class-aware wrapper for `::fz_sha256_update()`.  */
FZ_FUNCTION void fz_sha256_update(const FzSha256& state, const unsigned char *input, size_t inlen)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_sha256_update()\n";
	}
	#endif
	mupdf::ll_fz_sha256_update(state.m_internal, input, inlen);
}


/* Class-aware wrapper for `::fz_sha384_final()`.  */
FZ_FUNCTION void fz_sha384_final(const FzSha512& state, unsigned char digest[64])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_sha384_final()\n";
	}
	#endif
	mupdf::ll_fz_sha384_final(state.m_internal, digest);
}


/* Class-aware wrapper for `::fz_sha384_init()`.  */
FZ_FUNCTION void fz_sha384_init(const FzSha512& state)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_sha384_init()\n";
	}
	#endif
	mupdf::ll_fz_sha384_init(state.m_internal);
}


/* Class-aware wrapper for `::fz_sha384_update()`.  */
FZ_FUNCTION void fz_sha384_update(const FzSha512& state, const unsigned char *input, size_t inlen)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_sha384_update()\n";
	}
	#endif
	mupdf::ll_fz_sha384_update(state.m_internal, input, inlen);
}


/* Class-aware wrapper for `::fz_sha512_final()`.  */
FZ_FUNCTION void fz_sha512_final(const FzSha512& state, unsigned char digest[64])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_sha512_final()\n";
	}
	#endif
	mupdf::ll_fz_sha512_final(state.m_internal, digest);
}


/* Class-aware wrapper for `::fz_sha512_init()`.  */
FZ_FUNCTION void fz_sha512_init(const FzSha512& state)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_sha512_init()\n";
	}
	#endif
	mupdf::ll_fz_sha512_init(state.m_internal);
}


/* Class-aware wrapper for `::fz_sha512_update()`.  */
FZ_FUNCTION void fz_sha512_update(const FzSha512& state, const unsigned char *input, size_t inlen)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_sha512_update()\n";
	}
	#endif
	mupdf::ll_fz_sha512_update(state.m_internal, input, inlen);
}


/* Class-aware wrapper for `::fz_shear()`.  */
FZ_FUNCTION FzMatrix fz_shear(float sx, float sy)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_shear()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_fz_shear(sx, sy);
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_show_glyph()`.  */
FZ_FUNCTION void fz_show_glyph(const FzText& text, const FzFont& font, const FzMatrix& trm, int glyph, int unicode, int wmode, int bidi_level, ::fz_bidi_direction markup_dir, ::fz_text_language language)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_show_glyph()\n";
	}
	#endif
	mupdf::ll_fz_show_glyph(text.m_internal, font.m_internal, * trm.internal(), glyph, unicode, wmode, bidi_level, markup_dir, language);
}


/* Class-aware wrapper for `::fz_show_glyph_aux()`.  */
FZ_FUNCTION void fz_show_glyph_aux(const FzText& text, const FzFont& font, const FzMatrix& trm, int glyph, int unicode, int cid, int wmode, int bidi_level, ::fz_bidi_direction markup_dir, ::fz_text_language lang)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_show_glyph_aux()\n";
	}
	#endif
	mupdf::ll_fz_show_glyph_aux(text.m_internal, font.m_internal, * trm.internal(), glyph, unicode, cid, wmode, bidi_level, markup_dir, lang);
}


/* Class-aware wrapper for `::fz_show_string()`.  */
FZ_FUNCTION FzMatrix fz_show_string(const FzText& text, const FzFont& font, const FzMatrix& trm, const char *s, int wmode, int bidi_level, ::fz_bidi_direction markup_dir, ::fz_text_language language)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_show_string()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_fz_show_string(text.m_internal, font.m_internal, * trm.internal(), s, wmode, bidi_level, markup_dir, language);
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_shrink_store()`.  */
FZ_FUNCTION int fz_shrink_store(unsigned int percent)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_shrink_store()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_shrink_store(percent);
	return ret;
}


/* Class-aware wrapper for `::fz_skip()`.  */
FZ_FUNCTION size_t fz_skip(const FzStream& stm, size_t len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_skip()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_skip(stm.m_internal, len);
	return ret;
}


/* Class-aware wrapper for `::fz_skip_space()`.  */
FZ_FUNCTION void fz_skip_space(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_skip_space()\n";
	}
	#endif
	mupdf::ll_fz_skip_space(stm.m_internal);
}


/* Class-aware wrapper for `::fz_skip_string()`.  */
FZ_FUNCTION int fz_skip_string(const FzStream& stm, const char *str)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_skip_string()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_skip_string(stm.m_internal, str);
	return ret;
}


/* Class-aware wrapper for `::fz_slice_buffer()`.  */
FZ_FUNCTION FzBuffer fz_slice_buffer(const FzBuffer& buf, int64_t start, int64_t end)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_slice_buffer()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_slice_buffer(buf.m_internal, start, end);
	ll_fz_keep_buffer(temp);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_snap_selection()`.  */
FZ_FUNCTION FzQuad fz_snap_selection(const FzStextPage& page, FzPoint& ap, FzPoint& bp, int mode)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_snap_selection()\n";
	}
	#endif
	::fz_quad temp = mupdf::ll_fz_snap_selection(page.m_internal,  ap.internal(),  bp.internal(), mode);
	auto ret = FzQuad(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_start_throw_on_repair()`.  */
FZ_FUNCTION void fz_start_throw_on_repair()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_start_throw_on_repair()\n";
	}
	#endif
	mupdf::ll_fz_start_throw_on_repair();
}


/* Class-aware wrapper for `::fz_stat_ctime()`.  */
FZ_FUNCTION int64_t fz_stat_ctime(const char *path)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_stat_ctime()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_stat_ctime(path);
	return ret;
}


/* Class-aware wrapper for `::fz_stat_mtime()`.  */
FZ_FUNCTION int64_t fz_stat_mtime(const char *path)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_stat_mtime()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_stat_mtime(path);
	return ret;
}


/* Class-aware wrapper for `::fz_store_item()`.  */
FZ_FUNCTION void *fz_store_item(void *key, void *val, size_t itemsize, const FzStoreType& type)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_store_item()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_store_item(key, val, itemsize, type.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_store_scavenge()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_store_scavenge(size_t size)` => `(int, int phase)`
	 */
FZ_FUNCTION int fz_store_scavenge(size_t size, int *phase)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_store_scavenge()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_store_scavenge(size, phase);
	return ret;
}


/* Class-aware wrapper for `::fz_store_scavenge_external()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_store_scavenge_external(size_t size)` => `(int, int phase)`
	 */
FZ_FUNCTION int fz_store_scavenge_external(size_t size, int *phase)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_store_scavenge_external()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_store_scavenge_external(size, phase);
	return ret;
}


/* Class-aware wrapper for `::fz_story_document()`.  */
FZ_FUNCTION FzXml fz_story_document(const FzStory& story)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_story_document()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_story_document(story.m_internal);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_story_positions()`.  */
FZ_FUNCTION void fz_story_positions(const FzStory& story, ::fz_story_position_callback *cb, void *arg)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_story_positions()\n";
	}
	#endif
	mupdf::ll_fz_story_positions(story.m_internal, cb, arg);
}


/* Class-aware wrapper for `::fz_story_warnings()`.  */
FZ_FUNCTION const char *fz_story_warnings(const FzStory& story)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_story_warnings()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_story_warnings(story.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_strcasecmp()`.  */
FZ_FUNCTION int fz_strcasecmp(const char *a, const char *b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_strcasecmp()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_strcasecmp(a, b);
	return ret;
}


/* Class-aware wrapper for `::fz_strdup()`.  */
FZ_FUNCTION char *fz_strdup(const char *s)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_strdup()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_strdup(s);
	return ret;
}


/* Class-aware wrapper for `::fz_stream_from_output()`.  */
FZ_FUNCTION FzStream fz_stream_from_output(const FzOutput& arg_0)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_stream_from_output()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_stream_from_output(arg_0.m_internal);
	ll_fz_keep_stream(temp);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_string_from_box_type()`.  */
FZ_FUNCTION const char *fz_string_from_box_type(::fz_box_type box)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_string_from_box_type()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_string_from_box_type(box);
	return ret;
}


/* Class-aware wrapper for `::fz_string_from_buffer()`.  */
FZ_FUNCTION const char *fz_string_from_buffer(const FzBuffer& buf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_string_from_buffer()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_string_from_buffer(buf.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_string_from_text_language()`.  */
FZ_FUNCTION char *fz_string_from_text_language(char str[8], ::fz_text_language lang)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_string_from_text_language()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_string_from_text_language(str, lang);
	return ret;
}


/* Class-aware wrapper for `::fz_string_from_text_language2()`.  */
FZ_FUNCTION std::string fz_string_from_text_language2(::fz_text_language lang)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_string_from_text_language2()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_string_from_text_language2(lang);
	return ret;
}


/* Class-aware wrapper for `::fz_strlcat()`.  */
FZ_FUNCTION size_t fz_strlcat(char *dst, const char *src, size_t n)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_strlcat()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_strlcat(dst, src, n);
	return ret;
}


/* Class-aware wrapper for `::fz_strlcpy()`.  */
FZ_FUNCTION size_t fz_strlcpy(char *dst, const char *src, size_t n)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_strlcpy()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_strlcpy(dst, src, n);
	return ret;
}


/* Class-aware wrapper for `::fz_strncasecmp()`.  */
FZ_FUNCTION int fz_strncasecmp(const char *a, const char *b, size_t n)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_strncasecmp()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_strncasecmp(a, b, n);
	return ret;
}


/* Class-aware wrapper for `::fz_strnlen()`.  */
FZ_FUNCTION size_t fz_strnlen(const char *s, size_t maxlen)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_strnlen()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_strnlen(s, maxlen);
	return ret;
}


/* Class-aware wrapper for `::fz_stroke_path()`.  */
FZ_FUNCTION void fz_stroke_path(const FzDevice& dev, const FzPath& path, const FzStrokeState& stroke, const FzMatrix& ctm, const FzColorspace& colorspace, const float *color, float alpha, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_stroke_path()\n";
	}
	#endif
	mupdf::ll_fz_stroke_path(dev.m_internal, path.m_internal, stroke.m_internal, * ctm.internal(), colorspace.m_internal, color, alpha, * color_params.internal());
}


/* Class-aware wrapper for `::fz_stroke_text()`.  */
FZ_FUNCTION void fz_stroke_text(const FzDevice& dev, const FzText& text, const FzStrokeState& stroke, const FzMatrix& ctm, const FzColorspace& colorspace, const float *color, float alpha, const FzColorParams& color_params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_stroke_text()\n";
	}
	#endif
	mupdf::ll_fz_stroke_text(dev.m_internal, text.m_internal, stroke.m_internal, * ctm.internal(), colorspace.m_internal, color, alpha, * color_params.internal());
}


/* Class-aware wrapper for `::fz_strsep()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_strsep(const char *delim)` => `(char *, char *stringp)`
	 */
FZ_FUNCTION char *fz_strsep(char **stringp, const char *delim)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_strsep()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_strsep(stringp, delim);
	return ret;
}


/* Class-aware wrapper for `::fz_strtof()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_strtof(const char *s)` => `(float, char *es)`
	 */
FZ_FUNCTION float fz_strtof(const char *s, char **es)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_strtof()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_strtof(s, es);
	return ret;
}


/* Class-aware wrapper for `::fz_structure_from_string()`.  */
FZ_FUNCTION ::fz_structure fz_structure_from_string(const char *str)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_structure_from_string()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_structure_from_string(str);
	return ret;
}


/* Class-aware wrapper for `::fz_structure_to_string()`.  */
FZ_FUNCTION const char *fz_structure_to_string(::fz_structure type)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_structure_to_string()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_structure_to_string(type);
	return ret;
}


/* Class-aware wrapper for `::fz_subpixel_adjust()`.  */
FZ_FUNCTION float fz_subpixel_adjust(FzMatrix& ctm, FzMatrix& subpix_ctm, unsigned char *qe, unsigned char *qf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_subpixel_adjust()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_subpixel_adjust( ctm.internal(),  subpix_ctm.internal(), qe, qf);
	return ret;
}


/* Class-aware wrapper for `::fz_subsample_pixmap()`.  */
FZ_FUNCTION void fz_subsample_pixmap(const FzPixmap& tile, int factor)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_subsample_pixmap()\n";
	}
	#endif
	mupdf::ll_fz_subsample_pixmap(tile.m_internal, factor);
}


/* Class-aware wrapper for `::fz_subset_cff_for_gids()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_subset_cff_for_gids(::fz_buffer *orig, int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
	 */
FZ_FUNCTION FzBuffer fz_subset_cff_for_gids(const FzBuffer& orig, int *gids, int num_gids, int symbolic, int cidfont)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_subset_cff_for_gids()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_subset_cff_for_gids(orig.m_internal, gids, num_gids, symbolic, cidfont);
	ll_fz_keep_buffer(temp);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_subset_ttf_for_gids()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_subset_ttf_for_gids(::fz_buffer *orig, int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
	 */
FZ_FUNCTION FzBuffer fz_subset_ttf_for_gids(const FzBuffer& orig, int *gids, int num_gids, int symbolic, int cidfont)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_subset_ttf_for_gids()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_subset_ttf_for_gids(orig.m_internal, gids, num_gids, symbolic, cidfont);
	ll_fz_keep_buffer(temp);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_sync_bits()`.  */
FZ_FUNCTION void fz_sync_bits(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_sync_bits()\n";
	}
	#endif
	mupdf::ll_fz_sync_bits(stm.m_internal);
}


/* Class-aware wrapper for `::fz_tell()`.  */
FZ_FUNCTION int64_t fz_tell(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_tell()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_tell(stm.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_tell_output()`.  */
FZ_FUNCTION int64_t fz_tell_output(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_tell_output()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_tell_output(out.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_terminate_buffer()`.  */
FZ_FUNCTION void fz_terminate_buffer(const FzBuffer& buf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_terminate_buffer()\n";
	}
	#endif
	mupdf::ll_fz_terminate_buffer(buf.m_internal);
}


/* Class-aware wrapper for `::fz_text_aa_level()`.  */
FZ_FUNCTION int fz_text_aa_level()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_text_aa_level()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_text_aa_level();
	return ret;
}


/* Class-aware wrapper for `::fz_text_language_from_string()`.  */
FZ_FUNCTION ::fz_text_language fz_text_language_from_string(const char *str)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_text_language_from_string()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_text_language_from_string(str);
	return ret;
}


/* Class-aware wrapper for `::fz_tint_pixmap()`.  */
FZ_FUNCTION void fz_tint_pixmap(const FzPixmap& pix, int black, int white)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_tint_pixmap()\n";
	}
	#endif
	mupdf::ll_fz_tint_pixmap(pix.m_internal, black, white);
}


/* Class-aware wrapper for `::fz_tolower()`.  */
FZ_FUNCTION int fz_tolower(int c)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_tolower()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_tolower(c);
	return ret;
}


/* Class-aware wrapper for `::fz_toupper()`.  */
FZ_FUNCTION int fz_toupper(int c)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_toupper()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_toupper(c);
	return ret;
}


/* Class-aware wrapper for `::fz_transform_page()`.  */
FZ_FUNCTION FzMatrix fz_transform_page(const FzRect& mediabox, float resolution, float rotate)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_transform_page()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_fz_transform_page(* mediabox.internal(), resolution, rotate);
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_transform_path()`.  */
FZ_FUNCTION void fz_transform_path(const FzPath& path, const FzMatrix& transform)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_transform_path()\n";
	}
	#endif
	mupdf::ll_fz_transform_path(path.m_internal, * transform.internal());
}


/* Class-aware wrapper for `::fz_transform_point()`.  */
FZ_FUNCTION FzPoint fz_transform_point(const FzPoint& point, const FzMatrix& m)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_transform_point()\n";
	}
	#endif
	::fz_point temp = mupdf::ll_fz_transform_point(* point.internal(), * m.internal());
	auto ret = FzPoint(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_transform_point_xy()`.  */
FZ_FUNCTION FzPoint fz_transform_point_xy(float x, float y, const FzMatrix& m)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_transform_point_xy()\n";
	}
	#endif
	::fz_point temp = mupdf::ll_fz_transform_point_xy(x, y, * m.internal());
	auto ret = FzPoint(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_transform_quad()`.  */
FZ_FUNCTION FzQuad fz_transform_quad(const FzQuad& q, const FzMatrix& m)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_transform_quad()\n";
	}
	#endif
	::fz_quad temp = mupdf::ll_fz_transform_quad(* q.internal(), * m.internal());
	auto ret = FzQuad(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_transform_rect()`.  */
FZ_FUNCTION FzRect fz_transform_rect(const FzRect& rect, const FzMatrix& m)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_transform_rect()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_fz_transform_rect(* rect.internal(), * m.internal());
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_transform_vector()`.  */
FZ_FUNCTION FzPoint fz_transform_vector(const FzPoint& vector, const FzMatrix& m)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_transform_vector()\n";
	}
	#endif
	::fz_point temp = mupdf::ll_fz_transform_vector(* vector.internal(), * m.internal());
	auto ret = FzPoint(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_translate()`.  */
FZ_FUNCTION FzMatrix fz_translate(float tx, float ty)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_translate()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_fz_translate(tx, ty);
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_translate_irect()`.  */
FZ_FUNCTION FzIrect fz_translate_irect(const FzIrect& a, int xoff, int yoff)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_translate_irect()\n";
	}
	#endif
	::fz_irect temp = mupdf::ll_fz_translate_irect(* a.internal(), xoff, yoff);
	auto ret = FzIrect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_translate_rect()`.  */
FZ_FUNCTION FzRect fz_translate_rect(const FzRect& a, float xoff, float yoff)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_translate_rect()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_fz_translate_rect(* a.internal(), xoff, yoff);
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_tree_archive_add_buffer()`.  */
FZ_FUNCTION void fz_tree_archive_add_buffer(const FzArchive& arch_, const char *name, const FzBuffer& buf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_tree_archive_add_buffer()\n";
	}
	#endif
	mupdf::ll_fz_tree_archive_add_buffer(arch_.m_internal, name, buf.m_internal);
}


/* Class-aware wrapper for `::fz_tree_archive_add_data()`.  */
FZ_FUNCTION void fz_tree_archive_add_data(const FzArchive& arch_, const char *name, const void *data, size_t size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_tree_archive_add_data()\n";
	}
	#endif
	mupdf::ll_fz_tree_archive_add_data(arch_.m_internal, name, data, size);
}


/* Class-aware wrapper for `::fz_tree_lookup()`.  */
FZ_FUNCTION void *fz_tree_lookup(const FzTree& node, const char *key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_tree_lookup()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_tree_lookup(node.m_internal, key);
	return ret;
}


/* Class-aware wrapper for `::fz_trim_buffer()`.  */
FZ_FUNCTION void fz_trim_buffer(const FzBuffer& buf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_trim_buffer()\n";
	}
	#endif
	mupdf::ll_fz_trim_buffer(buf.m_internal);
}


/* Class-aware wrapper for `::fz_trim_path()`.  */
FZ_FUNCTION void fz_trim_path(const FzPath& path)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_trim_path()\n";
	}
	#endif
	mupdf::ll_fz_trim_path(path.m_internal);
}


/* Class-aware wrapper for `::fz_truncate_output()`.  */
FZ_FUNCTION void fz_truncate_output(const FzOutput& arg_0)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_truncate_output()\n";
	}
	#endif
	mupdf::ll_fz_truncate_output(arg_0.m_internal);
}


/* Class-aware wrapper for `::fz_try_invert_matrix()`.  */
FZ_FUNCTION int fz_try_invert_matrix(FzMatrix& inv, const FzMatrix& src)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_try_invert_matrix()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_try_invert_matrix( inv.internal(), * src.internal());
	return ret;
}


/* Class-aware wrapper for `::fz_try_open_archive_entry()`.  */
FZ_FUNCTION FzStream fz_try_open_archive_entry(const FzArchive& arch, const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_try_open_archive_entry()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_try_open_archive_entry(arch.m_internal, name);
	ll_fz_keep_stream(temp);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_try_open_archive_with_stream()`.  */
FZ_FUNCTION FzArchive fz_try_open_archive_with_stream(const FzStream& file)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_try_open_archive_with_stream()\n";
	}
	#endif
	::fz_archive* temp = mupdf::ll_fz_try_open_archive_with_stream(file.m_internal);
	ll_fz_keep_archive(temp);
	auto ret = FzArchive(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_try_open_file()`.  */
FZ_FUNCTION FzStream fz_try_open_file(const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_try_open_file()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_try_open_file(name);
	ll_fz_keep_stream(temp);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_try_parse_xml_archive_entry()`.  */
FZ_FUNCTION FzXml fz_try_parse_xml_archive_entry(const FzArchive& dir, const char *filename, int preserve_white)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_try_parse_xml_archive_entry()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_try_parse_xml_archive_entry(dir.m_internal, filename, preserve_white);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_try_read_archive_entry()`.  */
FZ_FUNCTION FzBuffer fz_try_read_archive_entry(const FzArchive& arch, const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_try_read_archive_entry()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_try_read_archive_entry(arch.m_internal, name);
	ll_fz_keep_buffer(temp);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_try_read_file()`.  */
FZ_FUNCTION FzBuffer fz_try_read_file(const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_try_read_file()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_fz_try_read_file(filename);
	ll_fz_keep_buffer(temp);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_tune_image_decode()`.  */
FZ_FUNCTION void fz_tune_image_decode(::fz_tune_image_decode_fn *image_decode, void *arg)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_tune_image_decode()\n";
	}
	#endif
	mupdf::ll_fz_tune_image_decode(image_decode, arg);
}


/* Class-aware wrapper for `::fz_tune_image_scale()`.  */
FZ_FUNCTION void fz_tune_image_scale(::fz_tune_image_scale_fn *image_scale, void *arg)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_tune_image_scale()\n";
	}
	#endif
	mupdf::ll_fz_tune_image_scale(image_scale, arg);
}


/* Class-aware wrapper for `::fz_unicode_from_glyph_name()`.  */
FZ_FUNCTION int fz_unicode_from_glyph_name(const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_unicode_from_glyph_name()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_unicode_from_glyph_name(name);
	return ret;
}


/* Class-aware wrapper for `::fz_unicode_from_glyph_name_strict()`.  */
FZ_FUNCTION int fz_unicode_from_glyph_name_strict(const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_unicode_from_glyph_name_strict()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_unicode_from_glyph_name_strict(name);
	return ret;
}


/* Class-aware wrapper for `::fz_union_rect()`.  */
FZ_FUNCTION FzRect fz_union_rect(const FzRect& a, const FzRect& b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_union_rect()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_fz_union_rect(* a.internal(), * b.internal());
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::fz_unlock()`.  */
FZ_FUNCTION void fz_unlock(int lock)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_unlock()\n";
	}
	#endif
	mupdf::ll_fz_unlock(lock);
}


/* Class-aware wrapper for `::fz_unpack_stream()`.  */
FZ_FUNCTION FzStream fz_unpack_stream(const FzStream& src, int depth, int w, int h, int n, int indexed, int pad, int skip)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_unpack_stream()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_fz_unpack_stream(src.m_internal, depth, w, h, n, indexed, pad, skip);
	ll_fz_keep_stream(temp);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_unread_byte()`.  */
FZ_FUNCTION void fz_unread_byte(const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_unread_byte()\n";
	}
	#endif
	mupdf::ll_fz_unread_byte(stm.m_internal);
}


/* Class-aware wrapper for `::fz_unshare_stroke_state()`.  */
FZ_FUNCTION FzStrokeState fz_unshare_stroke_state(const FzStrokeState& shared)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_unshare_stroke_state()\n";
	}
	#endif
	::fz_stroke_state* temp = mupdf::ll_fz_unshare_stroke_state(shared.m_internal);
	ll_fz_keep_stroke_state(temp);
	auto ret = FzStrokeState(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_unshare_stroke_state_with_dash_len()`.  */
FZ_FUNCTION FzStrokeState fz_unshare_stroke_state_with_dash_len(const FzStrokeState& shared, int len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_unshare_stroke_state_with_dash_len()\n";
	}
	#endif
	::fz_stroke_state* temp = mupdf::ll_fz_unshare_stroke_state_with_dash_len(shared.m_internal, len);
	ll_fz_keep_stroke_state(temp);
	auto ret = FzStrokeState(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_urldecode()`.  */
FZ_FUNCTION char *fz_urldecode(char *url)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_urldecode()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_urldecode(url);
	return ret;
}


/* Class-aware wrapper for `::fz_use_document_css()`.  */
FZ_FUNCTION int fz_use_document_css()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_use_document_css()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_use_document_css();
	return ret;
}


/* Class-aware wrapper for `::fz_user_context()`.  */
FZ_FUNCTION void *fz_user_context()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_user_context()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_user_context();
	return ret;
}


/* Class-aware wrapper for `::fz_user_css()`.  */
FZ_FUNCTION const char *fz_user_css()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_user_css()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_user_css();
	return ret;
}


/* Class-aware wrapper for `::fz_utflen()`.  */
FZ_FUNCTION int fz_utflen(const char *s)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_utflen()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_utflen(s);
	return ret;
}


/* Class-aware wrapper for `::fz_var_imp()`.  */
FZ_FUNCTION void fz_var_imp(void *arg_0)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_var_imp()\n";
	}
	#endif
	mupdf::ll_fz_var_imp(arg_0);
}


/* Class-aware wrapper for `::fz_vlog_error_printf()`.  */
FZ_FUNCTION void fz_vlog_error_printf(const char *fmt, va_list ap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_vlog_error_printf()\n";
	}
	#endif
	mupdf::ll_fz_vlog_error_printf(fmt, ap);
}


/* Class-aware wrapper for `::fz_vsnprintf()`.  */
FZ_FUNCTION size_t fz_vsnprintf(char *buffer, size_t space, const char *fmt, va_list args)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_vsnprintf()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_vsnprintf(buffer, space, fmt, args);
	return ret;
}


/* Class-aware wrapper for `::fz_vthrow()`.  */
FZ_FUNCTION void fz_vthrow(int errcode, const char *arg_1, va_list ap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_vthrow()\n";
	}
	#endif
	mupdf::ll_fz_vthrow(errcode, arg_1, ap);
}


/* Class-aware wrapper for `::fz_vwarn()`.  */
FZ_FUNCTION void fz_vwarn(const char *fmt, va_list ap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_vwarn()\n";
	}
	#endif
	mupdf::ll_fz_vwarn(fmt, ap);
}


/* Class-aware wrapper for `::fz_walk_path()`.  */
FZ_FUNCTION void fz_walk_path(const FzPath& path, const FzPathWalker& walker, void *arg)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_walk_path()\n";
	}
	#endif
	mupdf::ll_fz_walk_path(path.m_internal, walker.m_internal, arg);
}


/* Class-aware wrapper for `::fz_warn()`.  */
FZ_FUNCTION void fz_warn(const char *fmt, ...)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_warn()\n";
	}
	#endif
	va_list ap;
	va_start( ap, fmt);
	ll_fz_vwarn( fmt, ap);
	va_end( ap);
}


/* Class-aware wrapper for `::fz_warning_callback()`.
	
	This function has out-params. Python/C# wrappers look like:
		`fz_warning_callback()` => `(fz_warning_cb *, void *user)`
	 */
FZ_FUNCTION ::fz_warning_cb *fz_warning_callback(void **user)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_warning_callback()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_warning_callback(user);
	return ret;
}


/* Class-aware wrapper for `::fz_warp_pixmap()`.  */
FZ_FUNCTION FzPixmap fz_warp_pixmap(const FzPixmap& src, const ::fz_point points[4], int width, int height)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_warp_pixmap()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_fz_warp_pixmap(src.m_internal, points, width, height);
	ll_fz_keep_pixmap(temp);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_windows_1250_from_unicode()`.  */
FZ_FUNCTION int fz_windows_1250_from_unicode(int u)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_windows_1250_from_unicode()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_windows_1250_from_unicode(u);
	return ret;
}


/* Class-aware wrapper for `::fz_windows_1251_from_unicode()`.  */
FZ_FUNCTION int fz_windows_1251_from_unicode(int u)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_windows_1251_from_unicode()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_windows_1251_from_unicode(u);
	return ret;
}


/* Class-aware wrapper for `::fz_windows_1252_from_unicode()`.  */
FZ_FUNCTION int fz_windows_1252_from_unicode(int u)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_windows_1252_from_unicode()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_windows_1252_from_unicode(u);
	return ret;
}


/* Class-aware wrapper for `::fz_write_band()`.  */
FZ_FUNCTION void fz_write_band(const FzBandWriter& writer, int stride, int band_height, const unsigned char *samples)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_band()\n";
	}
	#endif
	mupdf::ll_fz_write_band(writer.m_internal, stride, band_height, samples);
}


/* Class-aware wrapper for `::fz_write_base64()`.  */
FZ_FUNCTION void fz_write_base64(const FzOutput& out, const unsigned char *data, size_t size, int newline)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_base64()\n";
	}
	#endif
	mupdf::ll_fz_write_base64(out.m_internal, data, size, newline);
}


/* Class-aware wrapper for `::fz_write_base64_buffer()`.  */
FZ_FUNCTION void fz_write_base64_buffer(const FzOutput& out, const FzBuffer& data, int newline)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_base64_buffer()\n";
	}
	#endif
	mupdf::ll_fz_write_base64_buffer(out.m_internal, data.m_internal, newline);
}


/* Class-aware wrapper for `::fz_write_bitmap_as_pbm()`.  */
FZ_FUNCTION void fz_write_bitmap_as_pbm(const FzOutput& out, const FzBitmap& bitmap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_bitmap_as_pbm()\n";
	}
	#endif
	mupdf::ll_fz_write_bitmap_as_pbm(out.m_internal, bitmap.m_internal);
}


/* Class-aware wrapper for `::fz_write_bitmap_as_pcl()`.  */
FZ_FUNCTION void fz_write_bitmap_as_pcl(const FzOutput& out, const FzBitmap& bitmap, const FzPclOptions& pcl)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_bitmap_as_pcl()\n";
	}
	#endif
	mupdf::ll_fz_write_bitmap_as_pcl(out.m_internal, bitmap.m_internal, pcl.m_internal);
}


/* Class-aware wrapper for `::fz_write_bitmap_as_pkm()`.  */
FZ_FUNCTION void fz_write_bitmap_as_pkm(const FzOutput& out, const FzBitmap& bitmap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_bitmap_as_pkm()\n";
	}
	#endif
	mupdf::ll_fz_write_bitmap_as_pkm(out.m_internal, bitmap.m_internal);
}


/* Class-aware wrapper for `::fz_write_bitmap_as_pwg()`.  */
FZ_FUNCTION void fz_write_bitmap_as_pwg(const FzOutput& out, const FzBitmap& bitmap, FzPwgOptions& pwg)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_bitmap_as_pwg()\n";
	}
	#endif
	mupdf::ll_fz_write_bitmap_as_pwg(out.m_internal, bitmap.m_internal, &pwg.m_internal);
}


/* Class-aware wrapper for `::fz_write_bitmap_as_pwg_page()`.  */
FZ_FUNCTION void fz_write_bitmap_as_pwg_page(const FzOutput& out, const FzBitmap& bitmap, FzPwgOptions& pwg)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_bitmap_as_pwg_page()\n";
	}
	#endif
	mupdf::ll_fz_write_bitmap_as_pwg_page(out.m_internal, bitmap.m_internal, &pwg.m_internal);
}


/* Class-aware wrapper for `::fz_write_bits()`.  */
FZ_FUNCTION void fz_write_bits(const FzOutput& out, unsigned int data, int num_bits)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_bits()\n";
	}
	#endif
	mupdf::ll_fz_write_bits(out.m_internal, data, num_bits);
}


/* Class-aware wrapper for `::fz_write_bits_sync()`.  */
FZ_FUNCTION void fz_write_bits_sync(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_bits_sync()\n";
	}
	#endif
	mupdf::ll_fz_write_bits_sync(out.m_internal);
}


/* Class-aware wrapper for `::fz_write_buffer()`.  */
FZ_FUNCTION void fz_write_buffer(const FzOutput& out, const FzBuffer& data)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_buffer()\n";
	}
	#endif
	mupdf::ll_fz_write_buffer(out.m_internal, data.m_internal);
}


/* Class-aware wrapper for `::fz_write_byte()`.  */
FZ_FUNCTION void fz_write_byte(const FzOutput& out, unsigned char x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_byte()\n";
	}
	#endif
	mupdf::ll_fz_write_byte(out.m_internal, x);
}


/* Class-aware wrapper for `::fz_write_char()`.  */
FZ_FUNCTION void fz_write_char(const FzOutput& out, char x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_char()\n";
	}
	#endif
	mupdf::ll_fz_write_char(out.m_internal, x);
}


/* Class-aware wrapper for `::fz_write_data()`.  */
FZ_FUNCTION void fz_write_data(const FzOutput& out, const void *data, size_t size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_data()\n";
	}
	#endif
	mupdf::ll_fz_write_data(out.m_internal, data, size);
}


/* Class-aware wrapper for `::fz_write_document()`.  */
FZ_FUNCTION void fz_write_document(const FzDocumentWriter& wri, const FzDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_document()\n";
	}
	#endif
	mupdf::ll_fz_write_document(wri.m_internal, doc.m_internal);
}


/* Class-aware wrapper for `::fz_write_float_be()`.  */
FZ_FUNCTION void fz_write_float_be(const FzOutput& out, float f)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_float_be()\n";
	}
	#endif
	mupdf::ll_fz_write_float_be(out.m_internal, f);
}


/* Class-aware wrapper for `::fz_write_float_le()`.  */
FZ_FUNCTION void fz_write_float_le(const FzOutput& out, float f)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_float_le()\n";
	}
	#endif
	mupdf::ll_fz_write_float_le(out.m_internal, f);
}


/* Class-aware wrapper for `::fz_write_header()`.  */
FZ_FUNCTION void fz_write_header(const FzBandWriter& writer, int w, int h, int n, int alpha, int xres, int yres, int pagenum, const FzColorspace& cs, const FzSeparations& seps)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_header()\n";
	}
	#endif
	mupdf::ll_fz_write_header(writer.m_internal, w, h, n, alpha, xres, yres, pagenum, cs.m_internal, seps.m_internal);
}


/* Class-aware wrapper for `::fz_write_image_as_data_uri()`.  */
FZ_FUNCTION void fz_write_image_as_data_uri(const FzOutput& out, const FzImage& image)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_image_as_data_uri()\n";
	}
	#endif
	mupdf::ll_fz_write_image_as_data_uri(out.m_internal, image.m_internal);
}


/* Class-aware wrapper for `::fz_write_int16_be()`.  */
FZ_FUNCTION void fz_write_int16_be(const FzOutput& out, int x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_int16_be()\n";
	}
	#endif
	mupdf::ll_fz_write_int16_be(out.m_internal, x);
}


/* Class-aware wrapper for `::fz_write_int16_le()`.  */
FZ_FUNCTION void fz_write_int16_le(const FzOutput& out, int x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_int16_le()\n";
	}
	#endif
	mupdf::ll_fz_write_int16_le(out.m_internal, x);
}


/* Class-aware wrapper for `::fz_write_int32_be()`.  */
FZ_FUNCTION void fz_write_int32_be(const FzOutput& out, int x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_int32_be()\n";
	}
	#endif
	mupdf::ll_fz_write_int32_be(out.m_internal, x);
}


/* Class-aware wrapper for `::fz_write_int32_le()`.  */
FZ_FUNCTION void fz_write_int32_le(const FzOutput& out, int x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_int32_le()\n";
	}
	#endif
	mupdf::ll_fz_write_int32_le(out.m_internal, x);
}


/* Class-aware wrapper for `::fz_write_pixmap_as_data_uri()`.  */
FZ_FUNCTION void fz_write_pixmap_as_data_uri(const FzOutput& out, const FzPixmap& pixmap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_data_uri()\n";
	}
	#endif
	mupdf::ll_fz_write_pixmap_as_data_uri(out.m_internal, pixmap.m_internal);
}


/* Class-aware wrapper for `::fz_write_pixmap_as_jpeg()`.  */
FZ_FUNCTION void fz_write_pixmap_as_jpeg(const FzOutput& out, const FzPixmap& pix, int quality, int invert_cmyk)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_jpeg()\n";
	}
	#endif
	mupdf::ll_fz_write_pixmap_as_jpeg(out.m_internal, pix.m_internal, quality, invert_cmyk);
}


/* Class-aware wrapper for `::fz_write_pixmap_as_jpx()`.  */
FZ_FUNCTION void fz_write_pixmap_as_jpx(const FzOutput& out, const FzPixmap& pix, int quality)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_jpx()\n";
	}
	#endif
	mupdf::ll_fz_write_pixmap_as_jpx(out.m_internal, pix.m_internal, quality);
}


/* Class-aware wrapper for `::fz_write_pixmap_as_pam()`.  */
FZ_FUNCTION void fz_write_pixmap_as_pam(const FzOutput& out, const FzPixmap& pixmap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_pam()\n";
	}
	#endif
	mupdf::ll_fz_write_pixmap_as_pam(out.m_internal, pixmap.m_internal);
}


/* Class-aware wrapper for `::fz_write_pixmap_as_pcl()`.  */
FZ_FUNCTION void fz_write_pixmap_as_pcl(const FzOutput& out, const FzPixmap& pixmap, const FzPclOptions& pcl)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_pcl()\n";
	}
	#endif
	mupdf::ll_fz_write_pixmap_as_pcl(out.m_internal, pixmap.m_internal, pcl.m_internal);
}


/* Class-aware wrapper for `::fz_write_pixmap_as_pclm()`.  */
FZ_FUNCTION void fz_write_pixmap_as_pclm(const FzOutput& out, const FzPixmap& pixmap, const FzPclmOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_pclm()\n";
	}
	#endif
	mupdf::ll_fz_write_pixmap_as_pclm(out.m_internal, pixmap.m_internal, options.m_internal);
}


/* Class-aware wrapper for `::fz_write_pixmap_as_pdfocr()`.  */
FZ_FUNCTION void fz_write_pixmap_as_pdfocr(const FzOutput& out, const FzPixmap& pixmap, FzPdfocrOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_pdfocr()\n";
	}
	#endif
	mupdf::ll_fz_write_pixmap_as_pdfocr(out.m_internal, pixmap.m_internal,  options.internal());
}


/* Class-aware wrapper for `::fz_write_pixmap_as_png()`.  */
FZ_FUNCTION void fz_write_pixmap_as_png(const FzOutput& out, const FzPixmap& pixmap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_png()\n";
	}
	#endif
	mupdf::ll_fz_write_pixmap_as_png(out.m_internal, pixmap.m_internal);
}


/* Class-aware wrapper for `::fz_write_pixmap_as_pnm()`.  */
FZ_FUNCTION void fz_write_pixmap_as_pnm(const FzOutput& out, const FzPixmap& pixmap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_pnm()\n";
	}
	#endif
	mupdf::ll_fz_write_pixmap_as_pnm(out.m_internal, pixmap.m_internal);
}


/* Class-aware wrapper for `::fz_write_pixmap_as_ps()`.  */
FZ_FUNCTION void fz_write_pixmap_as_ps(const FzOutput& out, const FzPixmap& pixmap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_ps()\n";
	}
	#endif
	mupdf::ll_fz_write_pixmap_as_ps(out.m_internal, pixmap.m_internal);
}


/* Class-aware wrapper for `::fz_write_pixmap_as_psd()`.  */
FZ_FUNCTION void fz_write_pixmap_as_psd(const FzOutput& out, const FzPixmap& pixmap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_psd()\n";
	}
	#endif
	mupdf::ll_fz_write_pixmap_as_psd(out.m_internal, pixmap.m_internal);
}


/* Class-aware wrapper for `::fz_write_pixmap_as_pwg()`.  */
FZ_FUNCTION void fz_write_pixmap_as_pwg(const FzOutput& out, const FzPixmap& pixmap, FzPwgOptions& pwg)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_pwg()\n";
	}
	#endif
	mupdf::ll_fz_write_pixmap_as_pwg(out.m_internal, pixmap.m_internal, &pwg.m_internal);
}


/* Class-aware wrapper for `::fz_write_pixmap_as_pwg_page()`.  */
FZ_FUNCTION void fz_write_pixmap_as_pwg_page(const FzOutput& out, const FzPixmap& pixmap, FzPwgOptions& pwg)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pixmap_as_pwg_page()\n";
	}
	#endif
	mupdf::ll_fz_write_pixmap_as_pwg_page(out.m_internal, pixmap.m_internal, &pwg.m_internal);
}


/* Class-aware wrapper for `::fz_write_ps_file_header()`.  */
FZ_FUNCTION void fz_write_ps_file_header(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_ps_file_header()\n";
	}
	#endif
	mupdf::ll_fz_write_ps_file_header(out.m_internal);
}


/* Class-aware wrapper for `::fz_write_ps_file_trailer()`.  */
FZ_FUNCTION void fz_write_ps_file_trailer(const FzOutput& out, int pages)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_ps_file_trailer()\n";
	}
	#endif
	mupdf::ll_fz_write_ps_file_trailer(out.m_internal, pages);
}


/* Class-aware wrapper for `::fz_write_pwg_file_header()`.  */
FZ_FUNCTION void fz_write_pwg_file_header(const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_pwg_file_header()\n";
	}
	#endif
	mupdf::ll_fz_write_pwg_file_header(out.m_internal);
}


/* Class-aware wrapper for `::fz_write_rune()`.  */
FZ_FUNCTION void fz_write_rune(const FzOutput& out, int rune)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_rune()\n";
	}
	#endif
	mupdf::ll_fz_write_rune(out.m_internal, rune);
}


/* Class-aware wrapper for `::fz_write_stabilized_story()`.  */
FZ_FUNCTION void fz_write_stabilized_story(const FzDocumentWriter& writer, const char *user_css, float em, ::fz_write_story_contentfn contentfn, void *contentfn_ref, ::fz_write_story_rectfn rectfn, void *rectfn_ref, ::fz_write_story_pagefn pagefn, void *pagefn_ref, const FzArchive& dir)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_stabilized_story()\n";
	}
	#endif
	mupdf::ll_fz_write_stabilized_story(writer.m_internal, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir.m_internal);
}


/* Class-aware wrapper for `::fz_write_story()`.  */
FZ_FUNCTION void fz_write_story(const FzDocumentWriter& writer, const FzStory& story, ::fz_write_story_rectfn rectfn, void *rectfn_ref, ::fz_write_story_positionfn positionfn, void *positionfn_ref, ::fz_write_story_pagefn pagefn, void *pagefn_ref)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_story()\n";
	}
	#endif
	mupdf::ll_fz_write_story(writer.m_internal, story.m_internal, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref);
}


/* Class-aware wrapper for `::fz_write_string()`.  */
FZ_FUNCTION void fz_write_string(const FzOutput& out, const char *s)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_string()\n";
	}
	#endif
	mupdf::ll_fz_write_string(out.m_internal, s);
}


/* Class-aware wrapper for `::fz_write_uint16_be()`.  */
FZ_FUNCTION void fz_write_uint16_be(const FzOutput& out, unsigned int x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_uint16_be()\n";
	}
	#endif
	mupdf::ll_fz_write_uint16_be(out.m_internal, x);
}


/* Class-aware wrapper for `::fz_write_uint16_le()`.  */
FZ_FUNCTION void fz_write_uint16_le(const FzOutput& out, unsigned int x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_uint16_le()\n";
	}
	#endif
	mupdf::ll_fz_write_uint16_le(out.m_internal, x);
}


/* Class-aware wrapper for `::fz_write_uint32_be()`.  */
FZ_FUNCTION void fz_write_uint32_be(const FzOutput& out, unsigned int x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_uint32_be()\n";
	}
	#endif
	mupdf::ll_fz_write_uint32_be(out.m_internal, x);
}


/* Class-aware wrapper for `::fz_write_uint32_le()`.  */
FZ_FUNCTION void fz_write_uint32_le(const FzOutput& out, unsigned int x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_uint32_le()\n";
	}
	#endif
	mupdf::ll_fz_write_uint32_le(out.m_internal, x);
}


/* Class-aware wrapper for `::fz_write_vprintf()`.  */
FZ_FUNCTION void fz_write_vprintf(const FzOutput& out, const char *fmt, va_list ap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_vprintf()\n";
	}
	#endif
	mupdf::ll_fz_write_vprintf(out.m_internal, fmt, ap);
}


/* Class-aware wrapper for `::fz_write_zip_entry()`.  */
FZ_FUNCTION void fz_write_zip_entry(const FzZipWriter& zip, const char *name, const FzBuffer& buf, int compress)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_write_zip_entry()\n";
	}
	#endif
	mupdf::ll_fz_write_zip_entry(zip.m_internal, name, buf.m_internal, compress);
}


/* Class-aware wrapper for `::fz_xml_add_att()`.  */
FZ_FUNCTION void fz_xml_add_att(const FzPool& pool, const FzXml& node, const char *key, const char *val)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_add_att()\n";
	}
	#endif
	mupdf::ll_fz_xml_add_att(pool.m_internal, node.m_internal, key, val);
}


/* Class-aware wrapper for `::fz_xml_att()`.  */
FZ_FUNCTION char *fz_xml_att(const FzXml& item, const char *att)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_att()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_xml_att(item.m_internal, att);
	return ret;
}


/* Class-aware wrapper for `::fz_xml_att_alt()`.  */
FZ_FUNCTION char *fz_xml_att_alt(const FzXml& item, const char *one, const char *two)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_att_alt()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_xml_att_alt(item.m_internal, one, two);
	return ret;
}


/* Class-aware wrapper for `::fz_xml_att_eq()`.  */
FZ_FUNCTION int fz_xml_att_eq(const FzXml& item, const char *name, const char *match)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_att_eq()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_xml_att_eq(item.m_internal, name, match);
	return ret;
}


/* Class-aware wrapper for `::fz_xml_down()`.  */
FZ_FUNCTION FzXml fz_xml_down(const FzXml& item)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_down()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_xml_down(item.m_internal);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_xml_find()`.  */
FZ_FUNCTION FzXml fz_xml_find(const FzXml& item, const char *tag)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_find()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_xml_find(item.m_internal, tag);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_xml_find_dfs()`.  */
FZ_FUNCTION FzXml fz_xml_find_dfs(const FzXml& item, const char *tag, const char *att, const char *match)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_find_dfs()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_xml_find_dfs(item.m_internal, tag, att, match);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_xml_find_dfs_top()`.  */
FZ_FUNCTION FzXml fz_xml_find_dfs_top(const FzXml& item, const char *tag, const char *att, const char *match, const FzXml& top)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_find_dfs_top()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_xml_find_dfs_top(item.m_internal, tag, att, match, top.m_internal);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_xml_find_down()`.  */
FZ_FUNCTION FzXml fz_xml_find_down(const FzXml& item, const char *tag)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_find_down()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_xml_find_down(item.m_internal, tag);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_xml_find_down_match()`.  */
FZ_FUNCTION FzXml fz_xml_find_down_match(const FzXml& item, const char *tag, const char *att, const char *match)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_find_down_match()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_xml_find_down_match(item.m_internal, tag, att, match);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_xml_find_match()`.  */
FZ_FUNCTION FzXml fz_xml_find_match(const FzXml& item, const char *tag, const char *att, const char *match)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_find_match()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_xml_find_match(item.m_internal, tag, att, match);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_xml_find_next()`.  */
FZ_FUNCTION FzXml fz_xml_find_next(const FzXml& item, const char *tag)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_find_next()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_xml_find_next(item.m_internal, tag);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_xml_find_next_dfs()`.  */
FZ_FUNCTION FzXml fz_xml_find_next_dfs(const FzXml& item, const char *tag, const char *att, const char *match)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_find_next_dfs()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_xml_find_next_dfs(item.m_internal, tag, att, match);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_xml_find_next_dfs_top()`.  */
FZ_FUNCTION FzXml fz_xml_find_next_dfs_top(const FzXml& item, const char *tag, const char *att, const char *match, const FzXml& top)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_find_next_dfs_top()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_xml_find_next_dfs_top(item.m_internal, tag, att, match, top.m_internal);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_xml_find_next_match()`.  */
FZ_FUNCTION FzXml fz_xml_find_next_match(const FzXml& item, const char *tag, const char *att, const char *match)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_find_next_match()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_xml_find_next_match(item.m_internal, tag, att, match);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_xml_is_tag()`.  */
FZ_FUNCTION int fz_xml_is_tag(const FzXml& item, const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_is_tag()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_xml_is_tag(item.m_internal, name);
	return ret;
}


/* Class-aware wrapper for `::fz_xml_next()`.  */
FZ_FUNCTION FzXml fz_xml_next(const FzXml& item)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_next()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_xml_next(item.m_internal);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_xml_prev()`.  */
FZ_FUNCTION FzXml fz_xml_prev(const FzXml& item)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_prev()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_xml_prev(item.m_internal);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_xml_root()`.  */
FZ_FUNCTION FzXml fz_xml_root(const FzXml& xml)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_root()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_xml_root(xml.m_internal);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::fz_xml_tag()`.  */
FZ_FUNCTION char *fz_xml_tag(const FzXml& item)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_tag()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_xml_tag(item.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_xml_text()`.  */
FZ_FUNCTION char *fz_xml_text(const FzXml& item)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_text()\n";
	}
	#endif
	auto ret = mupdf::ll_fz_xml_text(item.m_internal);
	return ret;
}


/* Class-aware wrapper for `::fz_xml_up()`.  */
FZ_FUNCTION FzXml fz_xml_up(const FzXml& item)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_fz_xml_up()\n";
	}
	#endif
	::fz_xml* temp = mupdf::ll_fz_xml_up(item.m_internal);
	ll_fz_keep_xml(temp);
	auto ret = FzXml(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_abandon_operation()`.  */
FZ_FUNCTION void pdf_abandon_operation(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_abandon_operation()\n";
	}
	#endif
	mupdf::ll_pdf_abandon_operation(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_access_exec_menu_item_event()`.  */
FZ_FUNCTION const char *pdf_access_exec_menu_item_event(const PdfDocEvent& evt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_access_exec_menu_item_event()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_access_exec_menu_item_event(evt.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_add_annot_border_dash_item()`.  */
FZ_FUNCTION void pdf_add_annot_border_dash_item(const PdfAnnot& annot, float length)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_annot_border_dash_item()\n";
	}
	#endif
	mupdf::ll_pdf_add_annot_border_dash_item(annot.m_internal, length);
}


/* Class-aware wrapper for `::pdf_add_annot_ink_list()`.  */
FZ_FUNCTION void pdf_add_annot_ink_list(const PdfAnnot& annot, int n, ::fz_point stroke[])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_annot_ink_list()\n";
	}
	#endif
	mupdf::ll_pdf_add_annot_ink_list(annot.m_internal, n, stroke);
}


/* Class-aware wrapper for `::pdf_add_annot_ink_list_stroke()`.  */
FZ_FUNCTION void pdf_add_annot_ink_list_stroke(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_annot_ink_list_stroke()\n";
	}
	#endif
	mupdf::ll_pdf_add_annot_ink_list_stroke(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_add_annot_ink_list_stroke_vertex()`.  */
FZ_FUNCTION void pdf_add_annot_ink_list_stroke_vertex(const PdfAnnot& annot, const FzPoint& p)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_annot_ink_list_stroke_vertex()\n";
	}
	#endif
	mupdf::ll_pdf_add_annot_ink_list_stroke_vertex(annot.m_internal, * p.internal());
}


/* Class-aware wrapper for `::pdf_add_annot_quad_point()`.  */
FZ_FUNCTION void pdf_add_annot_quad_point(const PdfAnnot& annot, const FzQuad& quad)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_annot_quad_point()\n";
	}
	#endif
	mupdf::ll_pdf_add_annot_quad_point(annot.m_internal, * quad.internal());
}


/* Class-aware wrapper for `::pdf_add_annot_vertex()`.  */
FZ_FUNCTION void pdf_add_annot_vertex(const PdfAnnot& annot, const FzPoint& p)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_annot_vertex()\n";
	}
	#endif
	mupdf::ll_pdf_add_annot_vertex(annot.m_internal, * p.internal());
}


/* Class-aware wrapper for `::pdf_add_cid_font()`.  */
FZ_FUNCTION PdfObj pdf_add_cid_font(const PdfDocument& doc, const FzFont& font)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_cid_font()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_add_cid_font(doc.m_internal, font.m_internal);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_add_cjk_font()`.  */
FZ_FUNCTION PdfObj pdf_add_cjk_font(const PdfDocument& doc, const FzFont& font, int script, int wmode, int serif)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_cjk_font()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_add_cjk_font(doc.m_internal, font.m_internal, script, wmode, serif);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_add_codespace()`.  */
FZ_FUNCTION void pdf_add_codespace(const PdfCmap& cmap, unsigned int low, unsigned int high, size_t n)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_codespace()\n";
	}
	#endif
	mupdf::ll_pdf_add_codespace(cmap.m_internal, low, high, n);
}


/* Class-aware wrapper for `::pdf_add_embedded_file()`.  */
FZ_FUNCTION PdfObj pdf_add_embedded_file(const PdfDocument& doc, const char *filename, const char *mimetype, const FzBuffer& contents, int64_t created, int64_t modifed, int add_checksum)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_embedded_file()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_add_embedded_file(doc.m_internal, filename, mimetype, contents.m_internal, created, modifed, add_checksum);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_add_hmtx()`.  */
FZ_FUNCTION void pdf_add_hmtx(const PdfFontDesc& font, int lo, int hi, int w)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_hmtx()\n";
	}
	#endif
	mupdf::ll_pdf_add_hmtx(font.m_internal, lo, hi, w);
}


/* Class-aware wrapper for `::pdf_add_image()`.  */
FZ_FUNCTION PdfObj pdf_add_image(const PdfDocument& doc, const FzImage& image)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_image()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_add_image(doc.m_internal, image.m_internal);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_add_journal_fragment()`.  */
FZ_FUNCTION void pdf_add_journal_fragment(const PdfDocument& doc, int parent, const PdfObj& copy, const FzBuffer& copy_stream, int newobj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_journal_fragment()\n";
	}
	#endif
	mupdf::ll_pdf_add_journal_fragment(doc.m_internal, parent, copy.m_internal, copy_stream.m_internal, newobj);
}


/* Class-aware wrapper for `::pdf_add_new_array()`.  */
FZ_FUNCTION PdfObj pdf_add_new_array(const PdfDocument& doc, int initial)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_new_array()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_add_new_array(doc.m_internal, initial);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_add_new_dict()`.  */
FZ_FUNCTION PdfObj pdf_add_new_dict(const PdfDocument& doc, int initial)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_new_dict()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_add_new_dict(doc.m_internal, initial);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_add_object()`.  */
FZ_FUNCTION PdfObj pdf_add_object(const PdfDocument& doc, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_object()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_add_object(doc.m_internal, obj.m_internal);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_add_page()`.  */
FZ_FUNCTION PdfObj pdf_add_page(const PdfDocument& doc, const FzRect& mediabox, int rotate, const PdfObj& resources, const FzBuffer& contents)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_page()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_add_page(doc.m_internal, * mediabox.internal(), rotate, resources.m_internal, contents.m_internal);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_add_simple_font()`.  */
FZ_FUNCTION PdfObj pdf_add_simple_font(const PdfDocument& doc, const FzFont& font, int encoding)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_simple_font()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_add_simple_font(doc.m_internal, font.m_internal, encoding);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_add_stream()`.  */
FZ_FUNCTION PdfObj pdf_add_stream(const PdfDocument& doc, const FzBuffer& buf, const PdfObj& obj, int compressed)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_stream()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_add_stream(doc.m_internal, buf.m_internal, obj.m_internal, compressed);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_add_substitute_font()`.  */
FZ_FUNCTION PdfObj pdf_add_substitute_font(const PdfDocument& doc, const FzFont& font)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_substitute_font()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_add_substitute_font(doc.m_internal, font.m_internal);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_add_vmtx()`.  */
FZ_FUNCTION void pdf_add_vmtx(const PdfFontDesc& font, int lo, int hi, int x, int y, int w)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_add_vmtx()\n";
	}
	#endif
	mupdf::ll_pdf_add_vmtx(font.m_internal, lo, hi, x, y, w);
}


/* Class-aware wrapper for `::pdf_annot_MK_BC()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_annot_MK_BC(::pdf_annot *annot, float color[4])` => int n
	 */
FZ_FUNCTION void pdf_annot_MK_BC(const PdfAnnot& annot, int *n, float color[4])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_MK_BC()\n";
	}
	#endif
	mupdf::ll_pdf_annot_MK_BC(annot.m_internal, n, color);
}


/* Class-aware wrapper for `::pdf_annot_MK_BC_rgb()`.  */
FZ_FUNCTION int pdf_annot_MK_BC_rgb(const PdfAnnot& annot, float rgb[3])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_MK_BC_rgb()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_MK_BC_rgb(annot.m_internal, rgb);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_MK_BG()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_annot_MK_BG(::pdf_annot *annot, float color[4])` => int n
	 */
FZ_FUNCTION void pdf_annot_MK_BG(const PdfAnnot& annot, int *n, float color[4])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_MK_BG()\n";
	}
	#endif
	mupdf::ll_pdf_annot_MK_BG(annot.m_internal, n, color);
}


/* Class-aware wrapper for `::pdf_annot_MK_BG_rgb()`.  */
FZ_FUNCTION int pdf_annot_MK_BG_rgb(const PdfAnnot& annot, float rgb[3])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_MK_BG_rgb()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_MK_BG_rgb(annot.m_internal, rgb);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_active()`.  */
FZ_FUNCTION int pdf_annot_active(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_active()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_active(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_ap()`.  */
FZ_FUNCTION PdfObj pdf_annot_ap(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_ap()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_annot_ap(annot.m_internal);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_author()`.  */
FZ_FUNCTION const char *pdf_annot_author(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_author()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_author(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_border()`.  */
FZ_FUNCTION float pdf_annot_border(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_border()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_border(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_border_dash_count()`.  */
FZ_FUNCTION int pdf_annot_border_dash_count(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_border_dash_count()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_border_dash_count(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_border_dash_item()`.  */
FZ_FUNCTION float pdf_annot_border_dash_item(const PdfAnnot& annot, int i)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_border_dash_item()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_border_dash_item(annot.m_internal, i);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_border_effect()`.  */
FZ_FUNCTION enum pdf_border_effect pdf_annot_border_effect(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_border_effect()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_border_effect(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_border_effect_intensity()`.  */
FZ_FUNCTION float pdf_annot_border_effect_intensity(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_border_effect_intensity()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_border_effect_intensity(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_border_style()`.  */
FZ_FUNCTION enum pdf_border_style pdf_annot_border_style(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_border_style()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_border_style(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_border_width()`.  */
FZ_FUNCTION float pdf_annot_border_width(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_border_width()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_border_width(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_color()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_annot_color(::pdf_annot *annot, float color[4])` => int n
	 */
FZ_FUNCTION void pdf_annot_color(const PdfAnnot& annot, int *n, float color[4])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_color()\n";
	}
	#endif
	mupdf::ll_pdf_annot_color(annot.m_internal, n, color);
}


/* Class-aware wrapper for `::pdf_annot_contents()`.  */
FZ_FUNCTION const char *pdf_annot_contents(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_contents()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_contents(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_creation_date()`.  */
FZ_FUNCTION int64_t pdf_annot_creation_date(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_creation_date()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_creation_date(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_default_appearance()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_annot_default_appearance(::pdf_annot *annot, float color[4])` => `(const char *font, float size, int n)`
	 */
FZ_FUNCTION void pdf_annot_default_appearance(const PdfAnnot& annot, const char **font, float *size, int *n, float color[4])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_default_appearance()\n";
	}
	#endif
	mupdf::ll_pdf_annot_default_appearance(annot.m_internal, font, size, n, color);
}


/* Class-aware wrapper for `::pdf_annot_ensure_local_xref()`.  */
FZ_FUNCTION void pdf_annot_ensure_local_xref(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_ensure_local_xref()\n";
	}
	#endif
	mupdf::ll_pdf_annot_ensure_local_xref(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_annot_event_blur()`.  */
FZ_FUNCTION void pdf_annot_event_blur(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_event_blur()\n";
	}
	#endif
	mupdf::ll_pdf_annot_event_blur(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_annot_event_down()`.  */
FZ_FUNCTION void pdf_annot_event_down(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_event_down()\n";
	}
	#endif
	mupdf::ll_pdf_annot_event_down(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_annot_event_enter()`.  */
FZ_FUNCTION void pdf_annot_event_enter(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_event_enter()\n";
	}
	#endif
	mupdf::ll_pdf_annot_event_enter(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_annot_event_exit()`.  */
FZ_FUNCTION void pdf_annot_event_exit(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_event_exit()\n";
	}
	#endif
	mupdf::ll_pdf_annot_event_exit(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_annot_event_focus()`.  */
FZ_FUNCTION void pdf_annot_event_focus(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_event_focus()\n";
	}
	#endif
	mupdf::ll_pdf_annot_event_focus(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_annot_event_page_close()`.  */
FZ_FUNCTION void pdf_annot_event_page_close(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_event_page_close()\n";
	}
	#endif
	mupdf::ll_pdf_annot_event_page_close(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_annot_event_page_invisible()`.  */
FZ_FUNCTION void pdf_annot_event_page_invisible(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_event_page_invisible()\n";
	}
	#endif
	mupdf::ll_pdf_annot_event_page_invisible(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_annot_event_page_open()`.  */
FZ_FUNCTION void pdf_annot_event_page_open(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_event_page_open()\n";
	}
	#endif
	mupdf::ll_pdf_annot_event_page_open(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_annot_event_page_visible()`.  */
FZ_FUNCTION void pdf_annot_event_page_visible(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_event_page_visible()\n";
	}
	#endif
	mupdf::ll_pdf_annot_event_page_visible(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_annot_event_up()`.  */
FZ_FUNCTION void pdf_annot_event_up(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_event_up()\n";
	}
	#endif
	mupdf::ll_pdf_annot_event_up(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_annot_field_event_keystroke()`.  */
FZ_FUNCTION int pdf_annot_field_event_keystroke(const PdfDocument& doc, const PdfAnnot& annot, const PdfKeystrokeEvent& evt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_field_event_keystroke()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_field_event_keystroke(doc.m_internal, annot.m_internal, evt.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_field_flags()`.  */
FZ_FUNCTION int pdf_annot_field_flags(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_field_flags()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_field_flags(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_field_label()`.  */
FZ_FUNCTION const char *pdf_annot_field_label(const PdfAnnot& widget)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_field_label()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_field_label(widget.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_field_value()`.  */
FZ_FUNCTION const char *pdf_annot_field_value(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_field_value()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_field_value(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_filespec()`.  */
FZ_FUNCTION PdfObj pdf_annot_filespec(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_filespec()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_annot_filespec(annot.m_internal);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_flags()`.  */
FZ_FUNCTION int pdf_annot_flags(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_flags()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_flags(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_has_author()`.  */
FZ_FUNCTION int pdf_annot_has_author(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_author()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_has_author(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_has_border()`.  */
FZ_FUNCTION int pdf_annot_has_border(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_border()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_has_border(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_has_border_effect()`.  */
FZ_FUNCTION int pdf_annot_has_border_effect(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_border_effect()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_has_border_effect(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_has_filespec()`.  */
FZ_FUNCTION int pdf_annot_has_filespec(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_filespec()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_has_filespec(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_has_icon_name()`.  */
FZ_FUNCTION int pdf_annot_has_icon_name(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_icon_name()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_has_icon_name(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_has_ink_list()`.  */
FZ_FUNCTION int pdf_annot_has_ink_list(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_ink_list()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_has_ink_list(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_has_intent()`.  */
FZ_FUNCTION int pdf_annot_has_intent(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_intent()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_has_intent(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_has_interior_color()`.  */
FZ_FUNCTION int pdf_annot_has_interior_color(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_interior_color()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_has_interior_color(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_has_line()`.  */
FZ_FUNCTION int pdf_annot_has_line(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_line()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_has_line(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_has_line_ending_styles()`.  */
FZ_FUNCTION int pdf_annot_has_line_ending_styles(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_line_ending_styles()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_has_line_ending_styles(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_has_open()`.  */
FZ_FUNCTION int pdf_annot_has_open(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_open()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_has_open(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_has_quad_points()`.  */
FZ_FUNCTION int pdf_annot_has_quad_points(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_quad_points()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_has_quad_points(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_has_quadding()`.  */
FZ_FUNCTION int pdf_annot_has_quadding(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_quadding()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_has_quadding(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_has_rect()`.  */
FZ_FUNCTION int pdf_annot_has_rect(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_rect()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_has_rect(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_has_vertices()`.  */
FZ_FUNCTION int pdf_annot_has_vertices(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_has_vertices()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_has_vertices(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_hidden_for_editing()`.  */
FZ_FUNCTION int pdf_annot_hidden_for_editing(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_hidden_for_editing()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_hidden_for_editing(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_hot()`.  */
FZ_FUNCTION int pdf_annot_hot(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_hot()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_hot(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_icon_name()`.  */
FZ_FUNCTION const char *pdf_annot_icon_name(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_icon_name()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_icon_name(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_ink_list_count()`.  */
FZ_FUNCTION int pdf_annot_ink_list_count(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_ink_list_count()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_ink_list_count(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_ink_list_stroke_count()`.  */
FZ_FUNCTION int pdf_annot_ink_list_stroke_count(const PdfAnnot& annot, int i)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_ink_list_stroke_count()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_ink_list_stroke_count(annot.m_internal, i);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_ink_list_stroke_vertex()`.  */
FZ_FUNCTION FzPoint pdf_annot_ink_list_stroke_vertex(const PdfAnnot& annot, int i, int k)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_ink_list_stroke_vertex()\n";
	}
	#endif
	::fz_point temp = mupdf::ll_pdf_annot_ink_list_stroke_vertex(annot.m_internal, i, k);
	auto ret = FzPoint(&temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_intent()`.  */
FZ_FUNCTION enum pdf_intent pdf_annot_intent(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_intent()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_intent(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_interior_color()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_annot_interior_color(::pdf_annot *annot, float color[4])` => int n
	 */
FZ_FUNCTION void pdf_annot_interior_color(const PdfAnnot& annot, int *n, float color[4])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_interior_color()\n";
	}
	#endif
	mupdf::ll_pdf_annot_interior_color(annot.m_internal, n, color);
}


/* Class-aware wrapper for `::pdf_annot_is_open()`.  */
FZ_FUNCTION int pdf_annot_is_open(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_is_open()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_is_open(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_is_standard_stamp()`.  */
FZ_FUNCTION int pdf_annot_is_standard_stamp(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_is_standard_stamp()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_is_standard_stamp(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_language()`.  */
FZ_FUNCTION ::fz_text_language pdf_annot_language(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_language()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_language(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_line()`.  */
FZ_FUNCTION void pdf_annot_line(const PdfAnnot& annot, FzPoint& a, FzPoint& b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_line()\n";
	}
	#endif
	mupdf::ll_pdf_annot_line(annot.m_internal,  a.internal(),  b.internal());
}


/* Class-aware wrapper for `::pdf_annot_line_end_style()`.  */
FZ_FUNCTION enum pdf_line_ending pdf_annot_line_end_style(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_line_end_style()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_line_end_style(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_line_ending_styles()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_annot_line_ending_styles(::pdf_annot *annot)` => `(enum pdf_line_ending start_style, enum pdf_line_ending end_style)`
	 */
FZ_FUNCTION void pdf_annot_line_ending_styles(const PdfAnnot& annot, enum pdf_line_ending *start_style, enum pdf_line_ending *end_style)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_line_ending_styles()\n";
	}
	#endif
	mupdf::ll_pdf_annot_line_ending_styles(annot.m_internal, start_style, end_style);
}


/* Class-aware wrapper for `::pdf_annot_line_start_style()`.  */
FZ_FUNCTION enum pdf_line_ending pdf_annot_line_start_style(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_line_start_style()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_line_start_style(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_modification_date()`.  */
FZ_FUNCTION int64_t pdf_annot_modification_date(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_modification_date()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_modification_date(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_needs_resynthesis()`.  */
FZ_FUNCTION int pdf_annot_needs_resynthesis(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_needs_resynthesis()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_needs_resynthesis(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_obj()`.  */
FZ_FUNCTION PdfObj pdf_annot_obj(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_obj()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_annot_obj(annot.m_internal);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_opacity()`.  */
FZ_FUNCTION float pdf_annot_opacity(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_opacity()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_opacity(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_page()`.  */
FZ_FUNCTION PdfPage pdf_annot_page(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_page()\n";
	}
	#endif
	::pdf_page* temp = mupdf::ll_pdf_annot_page(annot.m_internal);
	ll_pdf_keep_page(temp);
	auto ret = PdfPage(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_pop_and_discard_local_xref()`.  */
FZ_FUNCTION void pdf_annot_pop_and_discard_local_xref(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_pop_and_discard_local_xref()\n";
	}
	#endif
	mupdf::ll_pdf_annot_pop_and_discard_local_xref(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_annot_pop_local_xref()`.  */
FZ_FUNCTION void pdf_annot_pop_local_xref(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_pop_local_xref()\n";
	}
	#endif
	mupdf::ll_pdf_annot_pop_local_xref(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_annot_popup()`.  */
FZ_FUNCTION FzRect pdf_annot_popup(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_popup()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_pdf_annot_popup(annot.m_internal);
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_push_local_xref()`.  */
FZ_FUNCTION void pdf_annot_push_local_xref(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_push_local_xref()\n";
	}
	#endif
	mupdf::ll_pdf_annot_push_local_xref(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_annot_quad_point()`.  */
FZ_FUNCTION FzQuad pdf_annot_quad_point(const PdfAnnot& annot, int i)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_quad_point()\n";
	}
	#endif
	::fz_quad temp = mupdf::ll_pdf_annot_quad_point(annot.m_internal, i);
	auto ret = FzQuad(&temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_quad_point_count()`.  */
FZ_FUNCTION int pdf_annot_quad_point_count(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_quad_point_count()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_quad_point_count(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_quadding()`.  */
FZ_FUNCTION int pdf_annot_quadding(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_quadding()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_quadding(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_rect()`.  */
FZ_FUNCTION FzRect pdf_annot_rect(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_rect()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_pdf_annot_rect(annot.m_internal);
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_request_resynthesis()`.  */
FZ_FUNCTION void pdf_annot_request_resynthesis(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_request_resynthesis()\n";
	}
	#endif
	mupdf::ll_pdf_annot_request_resynthesis(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_annot_request_synthesis()`.  */
FZ_FUNCTION void pdf_annot_request_synthesis(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_request_synthesis()\n";
	}
	#endif
	mupdf::ll_pdf_annot_request_synthesis(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_annot_transform()`.  */
FZ_FUNCTION FzMatrix pdf_annot_transform(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_transform()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_pdf_annot_transform(annot.m_internal);
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_type()`.  */
FZ_FUNCTION enum pdf_annot_type pdf_annot_type(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_type()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_type(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_type_from_string()`.  */
FZ_FUNCTION enum pdf_annot_type pdf_annot_type_from_string(const char *subtype)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_type_from_string()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_type_from_string(subtype);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_vertex()`.  */
FZ_FUNCTION FzPoint pdf_annot_vertex(const PdfAnnot& annot, int i)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_vertex()\n";
	}
	#endif
	::fz_point temp = mupdf::ll_pdf_annot_vertex(annot.m_internal, i);
	auto ret = FzPoint(&temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_annot_vertex_count()`.  */
FZ_FUNCTION int pdf_annot_vertex_count(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_annot_vertex_count()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_annot_vertex_count(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_append_explicit_dest_to_uri()`.  */
FZ_FUNCTION char *pdf_append_explicit_dest_to_uri(const char *url, const FzLinkDest& dest)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_append_explicit_dest_to_uri()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_append_explicit_dest_to_uri(url, *dest.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_append_named_dest_to_uri()`.  */
FZ_FUNCTION char *pdf_append_named_dest_to_uri(const char *url, const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_append_named_dest_to_uri()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_append_named_dest_to_uri(url, name);
	return ret;
}


/* Class-aware wrapper for `::pdf_append_token()`.  */
FZ_FUNCTION void pdf_append_token(const FzBuffer& buf, int tok, const PdfLexbuf& lex)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_append_token()\n";
	}
	#endif
	mupdf::ll_pdf_append_token(buf.m_internal, tok, lex.m_internal);
}


/* Class-aware wrapper for `::pdf_apply_redaction()`.  */
FZ_FUNCTION int pdf_apply_redaction(const PdfAnnot& annot, PdfRedactOptions& opts)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_apply_redaction()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_apply_redaction(annot.m_internal,  opts.internal());
	return ret;
}


/* Class-aware wrapper for `::pdf_array_contains()`.  */
FZ_FUNCTION int pdf_array_contains(const PdfObj& array, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_contains()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_array_contains(array.m_internal, obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_array_delete()`.  */
FZ_FUNCTION void pdf_array_delete(const PdfObj& array, int index)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_delete()\n";
	}
	#endif
	mupdf::ll_pdf_array_delete(array.m_internal, index);
}


/* Class-aware wrapper for `::pdf_array_find()`.  */
FZ_FUNCTION int pdf_array_find(const PdfObj& array, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_find()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_array_find(array.m_internal, obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_array_get()`.  */
FZ_FUNCTION PdfObj pdf_array_get(const PdfObj& array, int i)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_get()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_array_get(array.m_internal, i);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_array_get_bool()`.  */
FZ_FUNCTION int pdf_array_get_bool(const PdfObj& array, int index)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_get_bool()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_array_get_bool(array.m_internal, index);
	return ret;
}


/* Class-aware wrapper for `::pdf_array_get_int()`.  */
FZ_FUNCTION int pdf_array_get_int(const PdfObj& array, int index)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_get_int()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_array_get_int(array.m_internal, index);
	return ret;
}


/* Class-aware wrapper for `::pdf_array_get_matrix()`.  */
FZ_FUNCTION FzMatrix pdf_array_get_matrix(const PdfObj& array, int index)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_get_matrix()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_pdf_array_get_matrix(array.m_internal, index);
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_array_get_name()`.  */
FZ_FUNCTION const char *pdf_array_get_name(const PdfObj& array, int index)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_get_name()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_array_get_name(array.m_internal, index);
	return ret;
}


/* Class-aware wrapper for `::pdf_array_get_real()`.  */
FZ_FUNCTION float pdf_array_get_real(const PdfObj& array, int index)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_get_real()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_array_get_real(array.m_internal, index);
	return ret;
}


/* Class-aware wrapper for `::pdf_array_get_rect()`.  */
FZ_FUNCTION FzRect pdf_array_get_rect(const PdfObj& array, int index)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_get_rect()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_pdf_array_get_rect(array.m_internal, index);
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_array_get_string()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_array_get_string(::pdf_obj *array, int index)` => `(const char *, size_t sizep)`
	 */
FZ_FUNCTION const char *pdf_array_get_string(const PdfObj& array, int index, size_t *sizep)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_get_string()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_array_get_string(array.m_internal, index, sizep);
	return ret;
}


/* Class-aware wrapper for `::pdf_array_get_text_string()`.  */
FZ_FUNCTION const char *pdf_array_get_text_string(const PdfObj& array, int index)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_get_text_string()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_array_get_text_string(array.m_internal, index);
	return ret;
}


/* Class-aware wrapper for `::pdf_array_insert()`.  */
FZ_FUNCTION void pdf_array_insert(const PdfObj& array, const PdfObj& obj, int index)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_insert()\n";
	}
	#endif
	mupdf::ll_pdf_array_insert(array.m_internal, obj.m_internal, index);
}


/* Class-aware wrapper for `::pdf_array_len()`.  */
FZ_FUNCTION int pdf_array_len(const PdfObj& array)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_len()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_array_len(array.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_array_push()`.  */
FZ_FUNCTION void pdf_array_push(const PdfObj& array, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_push()\n";
	}
	#endif
	mupdf::ll_pdf_array_push(array.m_internal, obj.m_internal);
}


/* Class-aware wrapper for `::pdf_array_push_array()`.  */
FZ_FUNCTION PdfObj pdf_array_push_array(const PdfObj& array, int initial)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_push_array()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_array_push_array(array.m_internal, initial);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_array_push_bool()`.  */
FZ_FUNCTION void pdf_array_push_bool(const PdfObj& array, int x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_push_bool()\n";
	}
	#endif
	mupdf::ll_pdf_array_push_bool(array.m_internal, x);
}


/* Class-aware wrapper for `::pdf_array_push_dict()`.  */
FZ_FUNCTION PdfObj pdf_array_push_dict(const PdfObj& array, int initial)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_push_dict()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_array_push_dict(array.m_internal, initial);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_array_push_int()`.  */
FZ_FUNCTION void pdf_array_push_int(const PdfObj& array, int64_t x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_push_int()\n";
	}
	#endif
	mupdf::ll_pdf_array_push_int(array.m_internal, x);
}


/* Class-aware wrapper for `::pdf_array_push_name()`.  */
FZ_FUNCTION void pdf_array_push_name(const PdfObj& array, const char *x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_push_name()\n";
	}
	#endif
	mupdf::ll_pdf_array_push_name(array.m_internal, x);
}


/* Class-aware wrapper for `::pdf_array_push_real()`.  */
FZ_FUNCTION void pdf_array_push_real(const PdfObj& array, double x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_push_real()\n";
	}
	#endif
	mupdf::ll_pdf_array_push_real(array.m_internal, x);
}


/* Class-aware wrapper for `::pdf_array_push_string()`.  */
FZ_FUNCTION void pdf_array_push_string(const PdfObj& array, const char *x, size_t n)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_push_string()\n";
	}
	#endif
	mupdf::ll_pdf_array_push_string(array.m_internal, x, n);
}


/* Class-aware wrapper for `::pdf_array_push_text_string()`.  */
FZ_FUNCTION void pdf_array_push_text_string(const PdfObj& array, const char *x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_push_text_string()\n";
	}
	#endif
	mupdf::ll_pdf_array_push_text_string(array.m_internal, x);
}


/* Class-aware wrapper for `::pdf_array_put()`.  */
FZ_FUNCTION void pdf_array_put(const PdfObj& array, int i, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_put()\n";
	}
	#endif
	mupdf::ll_pdf_array_put(array.m_internal, i, obj.m_internal);
}


/* Class-aware wrapper for `::pdf_array_put_array()`.  */
FZ_FUNCTION PdfObj pdf_array_put_array(const PdfObj& array, int i, int initial)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_put_array()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_array_put_array(array.m_internal, i, initial);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_array_put_bool()`.  */
FZ_FUNCTION void pdf_array_put_bool(const PdfObj& array, int i, int x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_put_bool()\n";
	}
	#endif
	mupdf::ll_pdf_array_put_bool(array.m_internal, i, x);
}


/* Class-aware wrapper for `::pdf_array_put_dict()`.  */
FZ_FUNCTION PdfObj pdf_array_put_dict(const PdfObj& array, int i, int initial)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_put_dict()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_array_put_dict(array.m_internal, i, initial);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_array_put_int()`.  */
FZ_FUNCTION void pdf_array_put_int(const PdfObj& array, int i, int64_t x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_put_int()\n";
	}
	#endif
	mupdf::ll_pdf_array_put_int(array.m_internal, i, x);
}


/* Class-aware wrapper for `::pdf_array_put_name()`.  */
FZ_FUNCTION void pdf_array_put_name(const PdfObj& array, int i, const char *x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_put_name()\n";
	}
	#endif
	mupdf::ll_pdf_array_put_name(array.m_internal, i, x);
}


/* Class-aware wrapper for `::pdf_array_put_real()`.  */
FZ_FUNCTION void pdf_array_put_real(const PdfObj& array, int i, double x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_put_real()\n";
	}
	#endif
	mupdf::ll_pdf_array_put_real(array.m_internal, i, x);
}


/* Class-aware wrapper for `::pdf_array_put_string()`.  */
FZ_FUNCTION void pdf_array_put_string(const PdfObj& array, int i, const char *x, size_t n)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_put_string()\n";
	}
	#endif
	mupdf::ll_pdf_array_put_string(array.m_internal, i, x, n);
}


/* Class-aware wrapper for `::pdf_array_put_text_string()`.  */
FZ_FUNCTION void pdf_array_put_text_string(const PdfObj& array, int i, const char *x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_array_put_text_string()\n";
	}
	#endif
	mupdf::ll_pdf_array_put_text_string(array.m_internal, i, x);
}


/* Class-aware wrapper for `::pdf_authenticate_password()`.  */
FZ_FUNCTION int pdf_authenticate_password(const PdfDocument& doc, const char *pw)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_authenticate_password()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_authenticate_password(doc.m_internal, pw);
	return ret;
}


/* Class-aware wrapper for `::pdf_bake_document()`.  */
FZ_FUNCTION void pdf_bake_document(const PdfDocument& doc, int bake_annots, int bake_widgets)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_bake_document()\n";
	}
	#endif
	mupdf::ll_pdf_bake_document(doc.m_internal, bake_annots, bake_widgets);
}


/* Class-aware wrapper for `::pdf_begin_implicit_operation()`.  */
FZ_FUNCTION void pdf_begin_implicit_operation(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_begin_implicit_operation()\n";
	}
	#endif
	mupdf::ll_pdf_begin_implicit_operation(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_begin_operation()`.  */
FZ_FUNCTION void pdf_begin_operation(const PdfDocument& doc, const char *operation)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_begin_operation()\n";
	}
	#endif
	mupdf::ll_pdf_begin_operation(doc.m_internal, operation);
}


/* Class-aware wrapper for `::pdf_bound_annot()`.  */
FZ_FUNCTION FzRect pdf_bound_annot(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_bound_annot()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_pdf_bound_annot(annot.m_internal);
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_bound_page()`.  */
FZ_FUNCTION FzRect pdf_bound_page(const PdfPage& page, ::fz_box_type box)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_bound_page()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_pdf_bound_page(page.m_internal, box);
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_bound_widget()`.  */
FZ_FUNCTION FzRect pdf_bound_widget(const PdfAnnot& widget)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_bound_widget()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_pdf_bound_widget(widget.m_internal);
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_button_field_on_state()`.  */
FZ_FUNCTION PdfObj pdf_button_field_on_state(const PdfObj& field)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_button_field_on_state()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_button_field_on_state(field.m_internal);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_calculate_form()`.  */
FZ_FUNCTION void pdf_calculate_form(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_calculate_form()\n";
	}
	#endif
	mupdf::ll_pdf_calculate_form(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_can_be_saved_incrementally()`.  */
FZ_FUNCTION int pdf_can_be_saved_incrementally(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_can_be_saved_incrementally()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_can_be_saved_incrementally(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_can_redo()`.  */
FZ_FUNCTION int pdf_can_redo(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_can_redo()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_can_redo(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_can_undo()`.  */
FZ_FUNCTION int pdf_can_undo(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_can_undo()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_can_undo(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_check_certificate()`.  */
FZ_FUNCTION ::pdf_signature_error pdf_check_certificate(const PdfPkcs7Verifier& verifier, const PdfDocument& doc, const PdfObj& signature)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_check_certificate()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_check_certificate(verifier.m_internal, doc.m_internal, signature.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_check_digest()`.  */
FZ_FUNCTION ::pdf_signature_error pdf_check_digest(const PdfPkcs7Verifier& verifier, const PdfDocument& doc, const PdfObj& signature)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_check_digest()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_check_digest(verifier.m_internal, doc.m_internal, signature.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_check_widget_certificate()`.  */
FZ_FUNCTION ::pdf_signature_error pdf_check_widget_certificate(const PdfPkcs7Verifier& verifier, const PdfAnnot& widget)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_check_widget_certificate()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_check_widget_certificate(verifier.m_internal, widget.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_check_widget_digest()`.  */
FZ_FUNCTION ::pdf_signature_error pdf_check_widget_digest(const PdfPkcs7Verifier& verifier, const PdfAnnot& widget)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_check_widget_digest()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_check_widget_digest(verifier.m_internal, widget.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_choice_field_option()`.  */
FZ_FUNCTION const char *pdf_choice_field_option(const PdfObj& field, int exportval, int i)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_choice_field_option()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_choice_field_option(field.m_internal, exportval, i);
	return ret;
}


/* Class-aware wrapper for `::pdf_choice_field_option_count()`.  */
FZ_FUNCTION int pdf_choice_field_option_count(const PdfObj& field)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_choice_field_option_count()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_choice_field_option_count(field.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_choice_widget_is_multiselect()`.  */
FZ_FUNCTION int pdf_choice_widget_is_multiselect(const PdfAnnot& tw)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_choice_widget_is_multiselect()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_choice_widget_is_multiselect(tw.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_choice_widget_options()`.  */
FZ_FUNCTION int pdf_choice_widget_options(const PdfAnnot& tw, int exportval, const char *opts[])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_choice_widget_options()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_choice_widget_options(tw.m_internal, exportval, opts);
	return ret;
}


/* Class-aware wrapper for `::pdf_choice_widget_options2()`.  */
FZ_FUNCTION std::vector<std::string> pdf_choice_widget_options2(const PdfAnnot& tw, int exportval)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_choice_widget_options2()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_choice_widget_options2(tw.m_internal, exportval);
	return ret;
}


/* Class-aware wrapper for `::pdf_choice_widget_set_value()`.  */
FZ_FUNCTION void pdf_choice_widget_set_value(const PdfAnnot& tw, int n, const char *opts[])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_choice_widget_set_value()\n";
	}
	#endif
	mupdf::ll_pdf_choice_widget_set_value(tw.m_internal, n, opts);
}


/* Class-aware wrapper for `::pdf_choice_widget_value()`.  */
FZ_FUNCTION int pdf_choice_widget_value(const PdfAnnot& tw, const char *opts[])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_choice_widget_value()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_choice_widget_value(tw.m_internal, opts);
	return ret;
}


/* Class-aware wrapper for `::pdf_clean_file()`.  */
FZ_FUNCTION void pdf_clean_file(char *infile, char *outfile, char *password, PdfCleanOptions& opts, int retainlen, char *retainlist[])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_clean_file()\n";
	}
	#endif
	mupdf::ll_pdf_clean_file(infile, outfile, password,  opts.internal(), retainlen, retainlist);
}


/* Class-aware wrapper for `::pdf_clean_font_name()`.  */
FZ_FUNCTION const char *pdf_clean_font_name(const char *fontname)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_clean_font_name()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_clean_font_name(fontname);
	return ret;
}


/* Class-aware wrapper for `::pdf_clean_obj()`.  */
FZ_FUNCTION void pdf_clean_obj(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_clean_obj()\n";
	}
	#endif
	mupdf::ll_pdf_clean_obj(obj.m_internal);
}


/* Class-aware wrapper for `::pdf_clear_annot_border_dash()`.  */
FZ_FUNCTION void pdf_clear_annot_border_dash(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_clear_annot_border_dash()\n";
	}
	#endif
	mupdf::ll_pdf_clear_annot_border_dash(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_clear_annot_ink_list()`.  */
FZ_FUNCTION void pdf_clear_annot_ink_list(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_clear_annot_ink_list()\n";
	}
	#endif
	mupdf::ll_pdf_clear_annot_ink_list(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_clear_annot_quad_points()`.  */
FZ_FUNCTION void pdf_clear_annot_quad_points(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_clear_annot_quad_points()\n";
	}
	#endif
	mupdf::ll_pdf_clear_annot_quad_points(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_clear_annot_vertices()`.  */
FZ_FUNCTION void pdf_clear_annot_vertices(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_clear_annot_vertices()\n";
	}
	#endif
	mupdf::ll_pdf_clear_annot_vertices(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_clear_signature()`.  */
FZ_FUNCTION void pdf_clear_signature(const PdfAnnot& widget)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_clear_signature()\n";
	}
	#endif
	mupdf::ll_pdf_clear_signature(widget.m_internal);
}


/* Class-aware wrapper for `::pdf_clear_xref()`.  */
FZ_FUNCTION void pdf_clear_xref(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_clear_xref()\n";
	}
	#endif
	mupdf::ll_pdf_clear_xref(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_clear_xref_to_mark()`.  */
FZ_FUNCTION void pdf_clear_xref_to_mark(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_clear_xref_to_mark()\n";
	}
	#endif
	mupdf::ll_pdf_clear_xref_to_mark(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_close_processor()`.  */
FZ_FUNCTION void pdf_close_processor(const PdfProcessor& proc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_close_processor()\n";
	}
	#endif
	mupdf::ll_pdf_close_processor(proc.m_internal);
}


/* Class-aware wrapper for `::pdf_cmap_size()`.  */
FZ_FUNCTION size_t pdf_cmap_size(const PdfCmap& cmap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_cmap_size()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_cmap_size(cmap.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_cmap_wmode()`.  */
FZ_FUNCTION int pdf_cmap_wmode(const PdfCmap& cmap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_cmap_wmode()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_cmap_wmode(cmap.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_copy_array()`.  */
FZ_FUNCTION PdfObj pdf_copy_array(const PdfObj& array)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_copy_array()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_copy_array(array.m_internal);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_copy_dict()`.  */
FZ_FUNCTION PdfObj pdf_copy_dict(const PdfObj& dict)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_copy_dict()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_copy_dict(dict.m_internal);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_count_layer_config_ui()`.  */
FZ_FUNCTION int pdf_count_layer_config_ui(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_count_layer_config_ui()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_count_layer_config_ui(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_count_layer_configs()`.  */
FZ_FUNCTION int pdf_count_layer_configs(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_count_layer_configs()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_count_layer_configs(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_count_layers()`.  */
FZ_FUNCTION int pdf_count_layers(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_count_layers()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_count_layers(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_count_objects()`.  */
FZ_FUNCTION int pdf_count_objects(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_count_objects()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_count_objects(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_count_pages()`.  */
FZ_FUNCTION int pdf_count_pages(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_count_pages()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_count_pages(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_count_pages_imp()`.  */
FZ_FUNCTION int pdf_count_pages_imp(const FzDocument& doc, int chapter)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_count_pages_imp()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_count_pages_imp(doc.m_internal, chapter);
	return ret;
}


/* Class-aware wrapper for `::pdf_count_q_balance()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_count_q_balance(::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm)` => `(int prepend, int append)`
	 */
FZ_FUNCTION void pdf_count_q_balance(const PdfDocument& doc, const PdfObj& res, const PdfObj& stm, int *prepend, int *append)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_count_q_balance()\n";
	}
	#endif
	mupdf::ll_pdf_count_q_balance(doc.m_internal, res.m_internal, stm.m_internal, prepend, append);
}


/* Class-aware wrapper for `::pdf_count_signatures()`.  */
FZ_FUNCTION int pdf_count_signatures(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_count_signatures()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_count_signatures(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_count_unsaved_versions()`.  */
FZ_FUNCTION int pdf_count_unsaved_versions(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_count_unsaved_versions()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_count_unsaved_versions(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_count_versions()`.  */
FZ_FUNCTION int pdf_count_versions(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_count_versions()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_count_versions(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_create_annot()`.  */
FZ_FUNCTION PdfAnnot pdf_create_annot(const PdfPage& page, enum pdf_annot_type type)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_create_annot()\n";
	}
	#endif
	::pdf_annot* temp = mupdf::ll_pdf_create_annot(page.m_internal, type);
	auto ret = PdfAnnot(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_create_annot_raw()`.  */
FZ_FUNCTION PdfAnnot pdf_create_annot_raw(const PdfPage& page, enum pdf_annot_type type)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_create_annot_raw()\n";
	}
	#endif
	::pdf_annot* temp = mupdf::ll_pdf_create_annot_raw(page.m_internal, type);
	auto ret = PdfAnnot(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_create_document()`.  */
FZ_FUNCTION PdfDocument pdf_create_document()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_create_document()\n";
	}
	#endif
	::pdf_document* temp = mupdf::ll_pdf_create_document();
	auto ret = PdfDocument(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_create_field_name()`.  */
FZ_FUNCTION void pdf_create_field_name(const PdfDocument& doc, const char *prefix, char *buf, size_t len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_create_field_name()\n";
	}
	#endif
	mupdf::ll_pdf_create_field_name(doc.m_internal, prefix, buf, len);
}


/* Class-aware wrapper for `::pdf_create_link()`.  */
FZ_FUNCTION FzLink pdf_create_link(const PdfPage& page, const FzRect& bbox, const char *uri)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_create_link()\n";
	}
	#endif
	::fz_link* temp = mupdf::ll_pdf_create_link(page.m_internal, * bbox.internal(), uri);
	auto ret = FzLink(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_create_object()`.  */
FZ_FUNCTION int pdf_create_object(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_create_object()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_create_object(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_create_signature_widget()`.  */
FZ_FUNCTION PdfAnnot pdf_create_signature_widget(const PdfPage& page, char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_create_signature_widget()\n";
	}
	#endif
	::pdf_annot* temp = mupdf::ll_pdf_create_signature_widget(page.m_internal, name);
	auto ret = PdfAnnot(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_crypt_encrypt_metadata()`.  */
FZ_FUNCTION int pdf_crypt_encrypt_metadata(const PdfCrypt& crypt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_encrypt_metadata()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_crypt_encrypt_metadata(crypt.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_crypt_key()`.  */
FZ_FUNCTION unsigned char *pdf_crypt_key(const PdfCrypt& crypt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_key()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_crypt_key(crypt.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_crypt_length()`.  */
FZ_FUNCTION int pdf_crypt_length(const PdfCrypt& crypt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_length()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_crypt_length(crypt.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_crypt_method()`.  */
FZ_FUNCTION const char *pdf_crypt_method(const PdfCrypt& crypt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_method()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_crypt_method(crypt.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_crypt_obj()`.  */
FZ_FUNCTION void pdf_crypt_obj(const PdfCrypt& crypt, const PdfObj& obj, int num, int gen)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_obj()\n";
	}
	#endif
	mupdf::ll_pdf_crypt_obj(crypt.m_internal, obj.m_internal, num, gen);
}


/* Class-aware wrapper for `::pdf_crypt_owner_encryption()`.  */
FZ_FUNCTION unsigned char *pdf_crypt_owner_encryption(const PdfCrypt& crypt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_owner_encryption()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_crypt_owner_encryption(crypt.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_crypt_owner_password()`.  */
FZ_FUNCTION unsigned char *pdf_crypt_owner_password(const PdfCrypt& crypt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_owner_password()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_crypt_owner_password(crypt.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_crypt_permissions()`.  */
FZ_FUNCTION int pdf_crypt_permissions(const PdfCrypt& crypt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_permissions()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_crypt_permissions(crypt.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_crypt_permissions_encryption()`.  */
FZ_FUNCTION unsigned char *pdf_crypt_permissions_encryption(const PdfCrypt& crypt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_permissions_encryption()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_crypt_permissions_encryption(crypt.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_crypt_revision()`.  */
FZ_FUNCTION int pdf_crypt_revision(const PdfCrypt& crypt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_revision()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_crypt_revision(crypt.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_crypt_stream_method()`.  */
FZ_FUNCTION const char *pdf_crypt_stream_method(const PdfCrypt& crypt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_stream_method()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_crypt_stream_method(crypt.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_crypt_string_method()`.  */
FZ_FUNCTION const char *pdf_crypt_string_method(const PdfCrypt& crypt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_string_method()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_crypt_string_method(crypt.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_crypt_user_encryption()`.  */
FZ_FUNCTION unsigned char *pdf_crypt_user_encryption(const PdfCrypt& crypt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_user_encryption()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_crypt_user_encryption(crypt.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_crypt_user_password()`.  */
FZ_FUNCTION unsigned char *pdf_crypt_user_password(const PdfCrypt& crypt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_user_password()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_crypt_user_password(crypt.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_crypt_version()`.  */
FZ_FUNCTION int pdf_crypt_version(const PdfCrypt& crypt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_crypt_version()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_crypt_version(crypt.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_cycle()`.  */
FZ_FUNCTION int pdf_cycle(const PdfCycleList& here, const PdfCycleList& prev, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_cycle()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_cycle(here.m_internal, prev.m_internal, obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_debug_doc_changes()`.  */
FZ_FUNCTION void pdf_debug_doc_changes(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_debug_doc_changes()\n";
	}
	#endif
	mupdf::ll_pdf_debug_doc_changes(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_debug_obj()`.  */
FZ_FUNCTION void pdf_debug_obj(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_debug_obj()\n";
	}
	#endif
	mupdf::ll_pdf_debug_obj(obj.m_internal);
}


/* Class-aware wrapper for `::pdf_debug_ref()`.  */
FZ_FUNCTION void pdf_debug_ref(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_debug_ref()\n";
	}
	#endif
	mupdf::ll_pdf_debug_ref(obj.m_internal);
}


/* Class-aware wrapper for `::pdf_decode_cmap()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_decode_cmap(::pdf_cmap *cmap, unsigned char *s, unsigned char *e)` => `(int, unsigned int cpt)`
	 */
FZ_FUNCTION int pdf_decode_cmap(const PdfCmap& cmap, unsigned char *s, unsigned char *e, unsigned int *cpt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_decode_cmap()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_decode_cmap(cmap.m_internal, s, e, cpt);
	return ret;
}


/* Class-aware wrapper for `::pdf_deep_copy_obj()`.  */
FZ_FUNCTION PdfObj pdf_deep_copy_obj(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_deep_copy_obj()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_deep_copy_obj(obj.m_internal);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_delete_annot()`.  */
FZ_FUNCTION void pdf_delete_annot(const PdfPage& page, const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_delete_annot()\n";
	}
	#endif
	mupdf::ll_pdf_delete_annot(page.m_internal, annot.m_internal);
}


/* Class-aware wrapper for `::pdf_delete_link()`.  */
FZ_FUNCTION void pdf_delete_link(const PdfPage& page, const FzLink& link)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_delete_link()\n";
	}
	#endif
	mupdf::ll_pdf_delete_link(page.m_internal, link.m_internal);
}


/* Class-aware wrapper for `::pdf_delete_object()`.  */
FZ_FUNCTION void pdf_delete_object(const PdfDocument& doc, int num)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_delete_object()\n";
	}
	#endif
	mupdf::ll_pdf_delete_object(doc.m_internal, num);
}


/* Class-aware wrapper for `::pdf_delete_page()`.  */
FZ_FUNCTION void pdf_delete_page(const PdfDocument& doc, int number)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_delete_page()\n";
	}
	#endif
	mupdf::ll_pdf_delete_page(doc.m_internal, number);
}


/* Class-aware wrapper for `::pdf_delete_page_labels()`.  */
FZ_FUNCTION void pdf_delete_page_labels(const PdfDocument& doc, int index)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_delete_page_labels()\n";
	}
	#endif
	mupdf::ll_pdf_delete_page_labels(doc.m_internal, index);
}


/* Class-aware wrapper for `::pdf_delete_page_range()`.  */
FZ_FUNCTION void pdf_delete_page_range(const PdfDocument& doc, int start, int end)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_delete_page_range()\n";
	}
	#endif
	mupdf::ll_pdf_delete_page_range(doc.m_internal, start, end);
}


/* Class-aware wrapper for `::pdf_deselect_layer_config_ui()`.  */
FZ_FUNCTION void pdf_deselect_layer_config_ui(const PdfDocument& doc, int ui)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_deselect_layer_config_ui()\n";
	}
	#endif
	mupdf::ll_pdf_deselect_layer_config_ui(doc.m_internal, ui);
}


/* Class-aware wrapper for `::pdf_deserialise_journal()`.  */
FZ_FUNCTION void pdf_deserialise_journal(const PdfDocument& doc, const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_deserialise_journal()\n";
	}
	#endif
	mupdf::ll_pdf_deserialise_journal(doc.m_internal, stm.m_internal);
}


/* Class-aware wrapper for `::pdf_dict_del()`.  */
FZ_FUNCTION void pdf_dict_del(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_del()\n";
	}
	#endif
	mupdf::ll_pdf_dict_del(dict.m_internal, key.m_internal);
}


/* Class-aware wrapper for `::pdf_dict_dels()`.  */
FZ_FUNCTION void pdf_dict_dels(const PdfObj& dict, const char *key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_dels()\n";
	}
	#endif
	mupdf::ll_pdf_dict_dels(dict.m_internal, key);
}


/* Class-aware wrapper for `::pdf_dict_get()`.  */
FZ_FUNCTION PdfObj pdf_dict_get(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_dict_get(dict.m_internal, key.m_internal);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_bool()`.  */
FZ_FUNCTION int pdf_dict_get_bool(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_bool()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_dict_get_bool(dict.m_internal, key.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_bool_default()`.  */
FZ_FUNCTION int pdf_dict_get_bool_default(const PdfObj& dict, const PdfObj& key, int def)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_bool_default()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_dict_get_bool_default(dict.m_internal, key.m_internal, def);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_date()`.  */
FZ_FUNCTION int64_t pdf_dict_get_date(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_date()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_dict_get_date(dict.m_internal, key.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_inheritable()`.  */
FZ_FUNCTION PdfObj pdf_dict_get_inheritable(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_dict_get_inheritable(dict.m_internal, key.m_internal);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_inheritable_bool()`.  */
FZ_FUNCTION int pdf_dict_get_inheritable_bool(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable_bool()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_dict_get_inheritable_bool(dict.m_internal, key.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_inheritable_date()`.  */
FZ_FUNCTION int64_t pdf_dict_get_inheritable_date(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable_date()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_dict_get_inheritable_date(dict.m_internal, key.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_inheritable_int()`.  */
FZ_FUNCTION int pdf_dict_get_inheritable_int(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable_int()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_dict_get_inheritable_int(dict.m_internal, key.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_inheritable_int64()`.  */
FZ_FUNCTION int64_t pdf_dict_get_inheritable_int64(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable_int64()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_dict_get_inheritable_int64(dict.m_internal, key.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_inheritable_matrix()`.  */
FZ_FUNCTION FzMatrix pdf_dict_get_inheritable_matrix(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable_matrix()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_pdf_dict_get_inheritable_matrix(dict.m_internal, key.m_internal);
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_inheritable_name()`.  */
FZ_FUNCTION const char *pdf_dict_get_inheritable_name(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable_name()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_dict_get_inheritable_name(dict.m_internal, key.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_inheritable_real()`.  */
FZ_FUNCTION float pdf_dict_get_inheritable_real(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable_real()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_dict_get_inheritable_real(dict.m_internal, key.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_inheritable_rect()`.  */
FZ_FUNCTION FzRect pdf_dict_get_inheritable_rect(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable_rect()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_pdf_dict_get_inheritable_rect(dict.m_internal, key.m_internal);
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_inheritable_string()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_dict_get_inheritable_string(::pdf_obj *dict, ::pdf_obj *key)` => `(const char *, size_t sizep)`
	 */
FZ_FUNCTION const char *pdf_dict_get_inheritable_string(const PdfObj& dict, const PdfObj& key, size_t *sizep)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable_string()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_dict_get_inheritable_string(dict.m_internal, key.m_internal, sizep);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_inheritable_text_string()`.  */
FZ_FUNCTION const char *pdf_dict_get_inheritable_text_string(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_inheritable_text_string()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_dict_get_inheritable_text_string(dict.m_internal, key.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_int()`.  */
FZ_FUNCTION int pdf_dict_get_int(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_int()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_dict_get_int(dict.m_internal, key.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_int64()`.  */
FZ_FUNCTION int64_t pdf_dict_get_int64(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_int64()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_dict_get_int64(dict.m_internal, key.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_int_default()`.  */
FZ_FUNCTION int pdf_dict_get_int_default(const PdfObj& dict, const PdfObj& key, int def)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_int_default()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_dict_get_int_default(dict.m_internal, key.m_internal, def);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_key()`.  */
FZ_FUNCTION PdfObj pdf_dict_get_key(const PdfObj& dict, int idx)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_key()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_dict_get_key(dict.m_internal, idx);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_matrix()`.  */
FZ_FUNCTION FzMatrix pdf_dict_get_matrix(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_matrix()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_pdf_dict_get_matrix(dict.m_internal, key.m_internal);
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_name()`.  */
FZ_FUNCTION const char *pdf_dict_get_name(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_name()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_dict_get_name(dict.m_internal, key.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_real()`.  */
FZ_FUNCTION float pdf_dict_get_real(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_real()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_dict_get_real(dict.m_internal, key.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_real_default()`.  */
FZ_FUNCTION float pdf_dict_get_real_default(const PdfObj& dict, const PdfObj& key, float def)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_real_default()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_dict_get_real_default(dict.m_internal, key.m_internal, def);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_rect()`.  */
FZ_FUNCTION FzRect pdf_dict_get_rect(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_rect()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_pdf_dict_get_rect(dict.m_internal, key.m_internal);
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_string()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_dict_get_string(::pdf_obj *dict, ::pdf_obj *key)` => `(const char *, size_t sizep)`
	 */
FZ_FUNCTION const char *pdf_dict_get_string(const PdfObj& dict, const PdfObj& key, size_t *sizep)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_string()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_dict_get_string(dict.m_internal, key.m_internal, sizep);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_text_string()`.  */
FZ_FUNCTION const char *pdf_dict_get_text_string(const PdfObj& dict, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_text_string()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_dict_get_text_string(dict.m_internal, key.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_get_val()`.  */
FZ_FUNCTION PdfObj pdf_dict_get_val(const PdfObj& dict, int idx)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_get_val()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_dict_get_val(dict.m_internal, idx);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_geta()`.  */
FZ_FUNCTION PdfObj pdf_dict_geta(const PdfObj& dict, const PdfObj& key, const PdfObj& abbrev)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_geta()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_dict_geta(dict.m_internal, key.m_internal, abbrev.m_internal);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_getp()`.  */
FZ_FUNCTION PdfObj pdf_dict_getp(const PdfObj& dict, const char *path)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_getp()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_dict_getp(dict.m_internal, path);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_getp_inheritable()`.  */
FZ_FUNCTION PdfObj pdf_dict_getp_inheritable(const PdfObj& dict, const char *path)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_getp_inheritable()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_dict_getp_inheritable(dict.m_internal, path);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_gets()`.  */
FZ_FUNCTION PdfObj pdf_dict_gets(const PdfObj& dict, const char *key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_gets()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_dict_gets(dict.m_internal, key);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_gets_inheritable()`.  */
FZ_FUNCTION PdfObj pdf_dict_gets_inheritable(const PdfObj& dict, const char *key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_gets_inheritable()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_dict_gets_inheritable(dict.m_internal, key);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_getsa()`.  */
FZ_FUNCTION PdfObj pdf_dict_getsa(const PdfObj& dict, const char *key, const char *abbrev)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_getsa()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_dict_getsa(dict.m_internal, key, abbrev);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_len()`.  */
FZ_FUNCTION int pdf_dict_len(const PdfObj& dict)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_len()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_dict_len(dict.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_put()`.  */
FZ_FUNCTION void pdf_dict_put(const PdfObj& dict, const PdfObj& key, const PdfObj& val)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put()\n";
	}
	#endif
	mupdf::ll_pdf_dict_put(dict.m_internal, key.m_internal, val.m_internal);
}


/* Class-aware wrapper for `::pdf_dict_put_array()`.  */
FZ_FUNCTION PdfObj pdf_dict_put_array(const PdfObj& dict, const PdfObj& key, int initial)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_array()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_dict_put_array(dict.m_internal, key.m_internal, initial);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_put_bool()`.  */
FZ_FUNCTION void pdf_dict_put_bool(const PdfObj& dict, const PdfObj& key, int x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_bool()\n";
	}
	#endif
	mupdf::ll_pdf_dict_put_bool(dict.m_internal, key.m_internal, x);
}


/* Class-aware wrapper for `::pdf_dict_put_date()`.  */
FZ_FUNCTION void pdf_dict_put_date(const PdfObj& dict, const PdfObj& key, int64_t time)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_date()\n";
	}
	#endif
	mupdf::ll_pdf_dict_put_date(dict.m_internal, key.m_internal, time);
}


/* Class-aware wrapper for `::pdf_dict_put_dict()`.  */
FZ_FUNCTION PdfObj pdf_dict_put_dict(const PdfObj& dict, const PdfObj& key, int initial)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_dict()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_dict_put_dict(dict.m_internal, key.m_internal, initial);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_dict_put_int()`.  */
FZ_FUNCTION void pdf_dict_put_int(const PdfObj& dict, const PdfObj& key, int64_t x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_int()\n";
	}
	#endif
	mupdf::ll_pdf_dict_put_int(dict.m_internal, key.m_internal, x);
}


/* Class-aware wrapper for `::pdf_dict_put_matrix()`.  */
FZ_FUNCTION void pdf_dict_put_matrix(const PdfObj& dict, const PdfObj& key, const FzMatrix& x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_matrix()\n";
	}
	#endif
	mupdf::ll_pdf_dict_put_matrix(dict.m_internal, key.m_internal, * x.internal());
}


/* Class-aware wrapper for `::pdf_dict_put_name()`.  */
FZ_FUNCTION void pdf_dict_put_name(const PdfObj& dict, const PdfObj& key, const char *x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_name()\n";
	}
	#endif
	mupdf::ll_pdf_dict_put_name(dict.m_internal, key.m_internal, x);
}


/* Class-aware wrapper for `::pdf_dict_put_real()`.  */
FZ_FUNCTION void pdf_dict_put_real(const PdfObj& dict, const PdfObj& key, double x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_real()\n";
	}
	#endif
	mupdf::ll_pdf_dict_put_real(dict.m_internal, key.m_internal, x);
}


/* Class-aware wrapper for `::pdf_dict_put_rect()`.  */
FZ_FUNCTION void pdf_dict_put_rect(const PdfObj& dict, const PdfObj& key, const FzRect& x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_rect()\n";
	}
	#endif
	mupdf::ll_pdf_dict_put_rect(dict.m_internal, key.m_internal, * x.internal());
}


/* Class-aware wrapper for `::pdf_dict_put_string()`.  */
FZ_FUNCTION void pdf_dict_put_string(const PdfObj& dict, const PdfObj& key, const char *x, size_t n)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_string()\n";
	}
	#endif
	mupdf::ll_pdf_dict_put_string(dict.m_internal, key.m_internal, x, n);
}


/* Class-aware wrapper for `::pdf_dict_put_text_string()`.  */
FZ_FUNCTION void pdf_dict_put_text_string(const PdfObj& dict, const PdfObj& key, const char *x)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_text_string()\n";
	}
	#endif
	mupdf::ll_pdf_dict_put_text_string(dict.m_internal, key.m_internal, x);
}


/* Class-aware wrapper for `::pdf_dict_put_val_null()`.  */
FZ_FUNCTION void pdf_dict_put_val_null(const PdfObj& obj, int idx)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_put_val_null()\n";
	}
	#endif
	mupdf::ll_pdf_dict_put_val_null(obj.m_internal, idx);
}


/* Class-aware wrapper for `::pdf_dict_putp()`.  */
FZ_FUNCTION void pdf_dict_putp(const PdfObj& dict, const char *path, const PdfObj& val)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_putp()\n";
	}
	#endif
	mupdf::ll_pdf_dict_putp(dict.m_internal, path, val.m_internal);
}


/* Class-aware wrapper for `::pdf_dict_puts()`.  */
FZ_FUNCTION void pdf_dict_puts(const PdfObj& dict, const char *key, const PdfObj& val)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_puts()\n";
	}
	#endif
	mupdf::ll_pdf_dict_puts(dict.m_internal, key, val.m_internal);
}


/* Class-aware wrapper for `::pdf_dict_puts_dict()`.  */
FZ_FUNCTION PdfObj pdf_dict_puts_dict(const PdfObj& dict, const char *key, int initial)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dict_puts_dict()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_dict_puts_dict(dict.m_internal, key, initial);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_dirty_annot()`.  */
FZ_FUNCTION void pdf_dirty_annot(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dirty_annot()\n";
	}
	#endif
	mupdf::ll_pdf_dirty_annot(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_dirty_obj()`.  */
FZ_FUNCTION void pdf_dirty_obj(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_dirty_obj()\n";
	}
	#endif
	mupdf::ll_pdf_dirty_obj(obj.m_internal);
}


/* Class-aware wrapper for `::pdf_disable_js()`.  */
FZ_FUNCTION void pdf_disable_js(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_disable_js()\n";
	}
	#endif
	mupdf::ll_pdf_disable_js(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_discard_journal()`.  */
FZ_FUNCTION void pdf_discard_journal(const PdfJournal& journal)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_discard_journal()\n";
	}
	#endif
	mupdf::ll_pdf_discard_journal(journal.m_internal);
}


/* Class-aware wrapper for `::pdf_doc_was_linearized()`.  */
FZ_FUNCTION int pdf_doc_was_linearized(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_doc_was_linearized()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_doc_was_linearized(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_document_event_did_print()`.  */
FZ_FUNCTION void pdf_document_event_did_print(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_document_event_did_print()\n";
	}
	#endif
	mupdf::ll_pdf_document_event_did_print(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_document_event_did_save()`.  */
FZ_FUNCTION void pdf_document_event_did_save(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_document_event_did_save()\n";
	}
	#endif
	mupdf::ll_pdf_document_event_did_save(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_document_event_will_close()`.  */
FZ_FUNCTION void pdf_document_event_will_close(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_document_event_will_close()\n";
	}
	#endif
	mupdf::ll_pdf_document_event_will_close(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_document_event_will_print()`.  */
FZ_FUNCTION void pdf_document_event_will_print(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_document_event_will_print()\n";
	}
	#endif
	mupdf::ll_pdf_document_event_will_print(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_document_event_will_save()`.  */
FZ_FUNCTION void pdf_document_event_will_save(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_document_event_will_save()\n";
	}
	#endif
	mupdf::ll_pdf_document_event_will_save(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_document_from_fz_document()`.  */
FZ_FUNCTION PdfDocument pdf_document_from_fz_document(const FzDocument& ptr)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_document_from_fz_document()\n";
	}
	#endif
	::pdf_document* temp = mupdf::ll_pdf_document_from_fz_document(ptr.m_internal);
	ll_pdf_keep_document(temp);
	auto ret = PdfDocument(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_document_language()`.  */
FZ_FUNCTION ::fz_text_language pdf_document_language(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_document_language()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_document_language(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_document_output_intent()`.  */
FZ_FUNCTION FzColorspace pdf_document_output_intent(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_document_output_intent()\n";
	}
	#endif
	::fz_colorspace* temp = mupdf::ll_pdf_document_output_intent(doc.m_internal);
	ll_fz_keep_colorspace(temp);
	auto ret = FzColorspace(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_document_permissions()`.  */
FZ_FUNCTION int pdf_document_permissions(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_document_permissions()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_document_permissions(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_edit_text_field_value()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_edit_text_field_value(::pdf_annot *widget, const char *value, const char *change)` => `(int, int selStart, int selEnd, char *newvalue)`
	 */
FZ_FUNCTION int pdf_edit_text_field_value(const PdfAnnot& widget, const char *value, const char *change, int *selStart, int *selEnd, char **newvalue)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_edit_text_field_value()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_edit_text_field_value(widget.m_internal, value, change, selStart, selEnd, newvalue);
	return ret;
}


/* Class-aware wrapper for `::pdf_empty_store()`.  */
FZ_FUNCTION void pdf_empty_store(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_empty_store()\n";
	}
	#endif
	mupdf::ll_pdf_empty_store(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_enable_journal()`.  */
FZ_FUNCTION void pdf_enable_journal(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_enable_journal()\n";
	}
	#endif
	mupdf::ll_pdf_enable_journal(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_enable_js()`.  */
FZ_FUNCTION void pdf_enable_js(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_enable_js()\n";
	}
	#endif
	mupdf::ll_pdf_enable_js(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_enable_layer()`.  */
FZ_FUNCTION void pdf_enable_layer(const PdfDocument& doc, int layer, int enabled)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_enable_layer()\n";
	}
	#endif
	mupdf::ll_pdf_enable_layer(doc.m_internal, layer, enabled);
}


/* Class-aware wrapper for `::pdf_encrypt_data()`.  */
FZ_FUNCTION void pdf_encrypt_data(const PdfCrypt& crypt, int num, int gen, void (*fmt_str_out)(::fz_context *, void *, const unsigned char *, size_t ), void *arg, const unsigned char *s, size_t n)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_encrypt_data()\n";
	}
	#endif
	mupdf::ll_pdf_encrypt_data(crypt.m_internal, num, gen, fmt_str_out, arg, s, n);
}


/* Class-aware wrapper for `::pdf_encrypted_len()`.  */
FZ_FUNCTION size_t pdf_encrypted_len(const PdfCrypt& crypt, int num, int gen, size_t len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_encrypted_len()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_encrypted_len(crypt.m_internal, num, gen, len);
	return ret;
}


/* Class-aware wrapper for `::pdf_end_hmtx()`.  */
FZ_FUNCTION void pdf_end_hmtx(const PdfFontDesc& font)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_end_hmtx()\n";
	}
	#endif
	mupdf::ll_pdf_end_hmtx(font.m_internal);
}


/* Class-aware wrapper for `::pdf_end_operation()`.  */
FZ_FUNCTION void pdf_end_operation(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_end_operation()\n";
	}
	#endif
	mupdf::ll_pdf_end_operation(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_end_vmtx()`.  */
FZ_FUNCTION void pdf_end_vmtx(const PdfFontDesc& font)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_end_vmtx()\n";
	}
	#endif
	mupdf::ll_pdf_end_vmtx(font.m_internal);
}


/* Class-aware wrapper for `::pdf_ensure_solid_xref()`.  */
FZ_FUNCTION void pdf_ensure_solid_xref(const PdfDocument& doc, int num)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_ensure_solid_xref()\n";
	}
	#endif
	mupdf::ll_pdf_ensure_solid_xref(doc.m_internal, num);
}


/* Class-aware wrapper for `::pdf_eval_function()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_eval_function(::pdf_function *func, const float *in, int inlen, int outlen)` => float out
	 */
FZ_FUNCTION void pdf_eval_function(const PdfFunction& func, const float *in, int inlen, float *out, int outlen)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_eval_function()\n";
	}
	#endif
	mupdf::ll_pdf_eval_function(func.m_internal, in, inlen, out, outlen);
}


/* Class-aware wrapper for `::pdf_event_issue_alert()`.  */
FZ_FUNCTION void pdf_event_issue_alert(const PdfDocument& doc, const PdfAlertEvent& evt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_event_issue_alert()\n";
	}
	#endif
	mupdf::ll_pdf_event_issue_alert(doc.m_internal, evt.m_internal);
}


/* Class-aware wrapper for `::pdf_event_issue_exec_menu_item()`.  */
FZ_FUNCTION void pdf_event_issue_exec_menu_item(const PdfDocument& doc, const char *item)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_event_issue_exec_menu_item()\n";
	}
	#endif
	mupdf::ll_pdf_event_issue_exec_menu_item(doc.m_internal, item);
}


/* Class-aware wrapper for `::pdf_event_issue_launch_url()`.  */
FZ_FUNCTION void pdf_event_issue_launch_url(const PdfDocument& doc, const char *url, int new_frame)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_event_issue_launch_url()\n";
	}
	#endif
	mupdf::ll_pdf_event_issue_launch_url(doc.m_internal, url, new_frame);
}


/* Class-aware wrapper for `::pdf_event_issue_mail_doc()`.  */
FZ_FUNCTION void pdf_event_issue_mail_doc(const PdfDocument& doc, const PdfMailDocEvent& evt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_event_issue_mail_doc()\n";
	}
	#endif
	mupdf::ll_pdf_event_issue_mail_doc(doc.m_internal, evt.m_internal);
}


/* Class-aware wrapper for `::pdf_event_issue_print()`.  */
FZ_FUNCTION void pdf_event_issue_print(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_event_issue_print()\n";
	}
	#endif
	mupdf::ll_pdf_event_issue_print(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_field_border_style()`.  */
FZ_FUNCTION char *pdf_field_border_style(const PdfObj& field)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_border_style()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_field_border_style(field.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_field_display()`.  */
FZ_FUNCTION int pdf_field_display(const PdfObj& field)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_display()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_field_display(field.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_field_event_calculate()`.  */
FZ_FUNCTION void pdf_field_event_calculate(const PdfDocument& doc, const PdfObj& field)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_event_calculate()\n";
	}
	#endif
	mupdf::ll_pdf_field_event_calculate(doc.m_internal, field.m_internal);
}


/* Class-aware wrapper for `::pdf_field_event_format()`.  */
FZ_FUNCTION char *pdf_field_event_format(const PdfDocument& doc, const PdfObj& field)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_event_format()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_field_event_format(doc.m_internal, field.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_field_event_keystroke()`.  */
FZ_FUNCTION int pdf_field_event_keystroke(const PdfDocument& doc, const PdfObj& field, const PdfKeystrokeEvent& evt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_event_keystroke()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_field_event_keystroke(doc.m_internal, field.m_internal, evt.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_field_event_validate()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_field_event_validate(::pdf_document *doc, ::pdf_obj *field, const char *value)` => `(int, char *newvalue)`
	 */
FZ_FUNCTION int pdf_field_event_validate(const PdfDocument& doc, const PdfObj& field, const char *value, char **newvalue)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_event_validate()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_field_event_validate(doc.m_internal, field.m_internal, value, newvalue);
	return ret;
}


/* Class-aware wrapper for `::pdf_field_flags()`.  */
FZ_FUNCTION int pdf_field_flags(const PdfObj& field)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_flags()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_field_flags(field.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_field_label()`.  */
FZ_FUNCTION const char *pdf_field_label(const PdfObj& field)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_label()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_field_label(field.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_field_reset()`.  */
FZ_FUNCTION void pdf_field_reset(const PdfDocument& doc, const PdfObj& field)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_reset()\n";
	}
	#endif
	mupdf::ll_pdf_field_reset(doc.m_internal, field.m_internal);
}


/* Class-aware wrapper for `::pdf_field_set_border_style()`.  */
FZ_FUNCTION void pdf_field_set_border_style(const PdfObj& field, const char *text)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_set_border_style()\n";
	}
	#endif
	mupdf::ll_pdf_field_set_border_style(field.m_internal, text);
}


/* Class-aware wrapper for `::pdf_field_set_button_caption()`.  */
FZ_FUNCTION void pdf_field_set_button_caption(const PdfObj& field, const char *text)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_set_button_caption()\n";
	}
	#endif
	mupdf::ll_pdf_field_set_button_caption(field.m_internal, text);
}


/* Class-aware wrapper for `::pdf_field_set_display()`.  */
FZ_FUNCTION void pdf_field_set_display(const PdfObj& field, int d)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_set_display()\n";
	}
	#endif
	mupdf::ll_pdf_field_set_display(field.m_internal, d);
}


/* Class-aware wrapper for `::pdf_field_set_fill_color()`.  */
FZ_FUNCTION void pdf_field_set_fill_color(const PdfObj& field, const PdfObj& col)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_set_fill_color()\n";
	}
	#endif
	mupdf::ll_pdf_field_set_fill_color(field.m_internal, col.m_internal);
}


/* Class-aware wrapper for `::pdf_field_set_text_color()`.  */
FZ_FUNCTION void pdf_field_set_text_color(const PdfObj& field, const PdfObj& col)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_set_text_color()\n";
	}
	#endif
	mupdf::ll_pdf_field_set_text_color(field.m_internal, col.m_internal);
}


/* Class-aware wrapper for `::pdf_field_type()`.  */
FZ_FUNCTION int pdf_field_type(const PdfObj& field)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_type()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_field_type(field.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_field_type_string()`.  */
FZ_FUNCTION const char *pdf_field_type_string(const PdfObj& field)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_type_string()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_field_type_string(field.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_field_value()`.  */
FZ_FUNCTION const char *pdf_field_value(const PdfObj& field)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_field_value()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_field_value(field.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_filter_annot_contents()`.  */
FZ_FUNCTION void pdf_filter_annot_contents(const PdfDocument& doc, const PdfAnnot& annot, PdfFilterOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_filter_annot_contents()\n";
	}
	#endif
	mupdf::ll_pdf_filter_annot_contents(doc.m_internal, annot.m_internal,  options.internal());
}


/* Class-aware wrapper for `::pdf_filter_page_contents()`.  */
FZ_FUNCTION void pdf_filter_page_contents(const PdfDocument& doc, const PdfPage& page, PdfFilterOptions& options)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_filter_page_contents()\n";
	}
	#endif
	mupdf::ll_pdf_filter_page_contents(doc.m_internal, page.m_internal,  options.internal());
}


/* Class-aware wrapper for `::pdf_filter_xobject_instance()`.  */
FZ_FUNCTION PdfObj pdf_filter_xobject_instance(const PdfObj& old_xobj, const PdfObj& page_res, const FzMatrix& ctm, PdfFilterOptions& options, const PdfCycleList& cycle_up)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_filter_xobject_instance()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_filter_xobject_instance(old_xobj.m_internal, page_res.m_internal, * ctm.internal(),  options.internal(), cycle_up.m_internal);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_find_font_resource()`.  */
FZ_FUNCTION PdfObj pdf_find_font_resource(const PdfDocument& doc, int type, int encoding, const FzFont& item, const PdfFontResourceKey& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_find_font_resource()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_find_font_resource(doc.m_internal, type, encoding, item.m_internal, key.m_internal);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_find_item()`.  */
FZ_FUNCTION void *pdf_find_item(::fz_store_drop_fn *drop, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_find_item()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_find_item(drop, key.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_find_version_for_obj()`.  */
FZ_FUNCTION int pdf_find_version_for_obj(const PdfDocument& doc, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_find_version_for_obj()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_find_version_for_obj(doc.m_internal, obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_first_annot()`.  */
FZ_FUNCTION PdfAnnot pdf_first_annot(const PdfPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_first_annot()\n";
	}
	#endif
	::pdf_annot* temp = mupdf::ll_pdf_first_annot(page.m_internal);
	ll_pdf_keep_annot(temp);
	auto ret = PdfAnnot(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_first_widget()`.  */
FZ_FUNCTION PdfAnnot pdf_first_widget(const PdfPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_first_widget()\n";
	}
	#endif
	::pdf_annot* temp = mupdf::ll_pdf_first_widget(page.m_internal);
	ll_pdf_keep_annot(temp);
	auto ret = PdfAnnot(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_flatten_inheritable_page_items()`.  */
FZ_FUNCTION void pdf_flatten_inheritable_page_items(const PdfObj& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_flatten_inheritable_page_items()\n";
	}
	#endif
	mupdf::ll_pdf_flatten_inheritable_page_items(page.m_internal);
}


/* Class-aware wrapper for `::pdf_font_cid_to_gid()`.  */
FZ_FUNCTION int pdf_font_cid_to_gid(const PdfFontDesc& fontdesc, int cid)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_font_cid_to_gid()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_font_cid_to_gid(fontdesc.m_internal, cid);
	return ret;
}


/* Class-aware wrapper for `::pdf_font_writing_supported()`.  */
FZ_FUNCTION int pdf_font_writing_supported(const FzFont& font)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_font_writing_supported()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_font_writing_supported(font.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_forget_xref()`.  */
FZ_FUNCTION void pdf_forget_xref(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_forget_xref()\n";
	}
	#endif
	mupdf::ll_pdf_forget_xref(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_format_date()`.  */
FZ_FUNCTION char *pdf_format_date(int64_t time, char *s, size_t n)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_format_date()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_format_date(time, s, n);
	return ret;
}


/* Class-aware wrapper for `::pdf_format_write_options()`.  */
FZ_FUNCTION char *pdf_format_write_options(char *buffer, size_t buffer_len, PdfWriteOptions& opts)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_format_write_options()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_format_write_options(buffer, buffer_len,  opts.internal());
	return ret;
}


/* Class-aware wrapper for `::pdf_function_size()`.  */
FZ_FUNCTION size_t pdf_function_size(const PdfFunction& func)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_function_size()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_function_size(func.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_get_bound_document()`.  */
FZ_FUNCTION PdfDocument pdf_get_bound_document(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_get_bound_document()\n";
	}
	#endif
	::pdf_document* temp = mupdf::ll_pdf_get_bound_document(obj.m_internal);
	ll_pdf_keep_document(temp);
	auto ret = PdfDocument(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_get_doc_event_callback_data()`.  */
FZ_FUNCTION void *pdf_get_doc_event_callback_data(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_get_doc_event_callback_data()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_get_doc_event_callback_data(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_get_embedded_file_params()`.  */
FZ_FUNCTION void pdf_get_embedded_file_params(const PdfObj& fs, const PdfEmbeddedFileParams& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_get_embedded_file_params()\n";
	}
	#endif
	mupdf::ll_pdf_get_embedded_file_params(fs.m_internal, out.m_internal);
}


/* Class-aware wrapper for `::pdf_get_indirect_document()`.  */
FZ_FUNCTION PdfDocument pdf_get_indirect_document(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_get_indirect_document()\n";
	}
	#endif
	::pdf_document* temp = mupdf::ll_pdf_get_indirect_document(obj.m_internal);
	ll_pdf_keep_document(temp);
	auto ret = PdfDocument(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_get_widget_editing_state()`.  */
FZ_FUNCTION int pdf_get_widget_editing_state(const PdfAnnot& widget)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_get_widget_editing_state()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_get_widget_editing_state(widget.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_graft_mapped_object()`.  */
FZ_FUNCTION PdfObj pdf_graft_mapped_object(const PdfGraftMap& map, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_graft_mapped_object()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_graft_mapped_object(map.m_internal, obj.m_internal);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_graft_mapped_page()`.  */
FZ_FUNCTION void pdf_graft_mapped_page(const PdfGraftMap& map, int page_to, const PdfDocument& src, int page_from)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_graft_mapped_page()\n";
	}
	#endif
	mupdf::ll_pdf_graft_mapped_page(map.m_internal, page_to, src.m_internal, page_from);
}


/* Class-aware wrapper for `::pdf_graft_object()`.  */
FZ_FUNCTION PdfObj pdf_graft_object(const PdfDocument& dst, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_graft_object()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_graft_object(dst.m_internal, obj.m_internal);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_graft_page()`.  */
FZ_FUNCTION void pdf_graft_page(const PdfDocument& dst, int page_to, const PdfDocument& src, int page_from)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_graft_page()\n";
	}
	#endif
	mupdf::ll_pdf_graft_page(dst.m_internal, page_to, src.m_internal, page_from);
}


/* Class-aware wrapper for `::pdf_has_permission()`.  */
FZ_FUNCTION int pdf_has_permission(const PdfDocument& doc, ::fz_permission p)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_has_permission()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_has_permission(doc.m_internal, p);
	return ret;
}


/* Class-aware wrapper for `::pdf_has_unsaved_changes()`.  */
FZ_FUNCTION int pdf_has_unsaved_changes(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_has_unsaved_changes()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_has_unsaved_changes(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_has_unsaved_sigs()`.  */
FZ_FUNCTION int pdf_has_unsaved_sigs(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_has_unsaved_sigs()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_has_unsaved_sigs(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_insert_font_resource()`.  */
FZ_FUNCTION PdfObj pdf_insert_font_resource(const PdfDocument& doc, const PdfFontResourceKey& key, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_insert_font_resource()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_insert_font_resource(doc.m_internal, key.m_internal, obj.m_internal);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_insert_page()`.  */
FZ_FUNCTION void pdf_insert_page(const PdfDocument& doc, int at, const PdfObj& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_insert_page()\n";
	}
	#endif
	mupdf::ll_pdf_insert_page(doc.m_internal, at, page.m_internal);
}


/* Class-aware wrapper for `::pdf_intent_from_name()`.  */
FZ_FUNCTION enum pdf_intent pdf_intent_from_name(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_intent_from_name()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_intent_from_name(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_intent_from_string()`.  */
FZ_FUNCTION enum pdf_intent pdf_intent_from_string(const char *str)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_intent_from_string()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_intent_from_string(str);
	return ret;
}


/* Class-aware wrapper for `::pdf_invalidate_xfa()`.  */
FZ_FUNCTION void pdf_invalidate_xfa(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_invalidate_xfa()\n";
	}
	#endif
	mupdf::ll_pdf_invalidate_xfa(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_is_array()`.  */
FZ_FUNCTION int pdf_is_array(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_array()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_is_array(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_is_bool()`.  */
FZ_FUNCTION int pdf_is_bool(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_bool()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_is_bool(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_is_dict()`.  */
FZ_FUNCTION int pdf_is_dict(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_dict()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_is_dict(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_is_embedded_file()`.  */
FZ_FUNCTION int pdf_is_embedded_file(const PdfObj& fs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_embedded_file()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_is_embedded_file(fs.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_is_field_locked()`.  */
FZ_FUNCTION int pdf_is_field_locked(const PdfLockedFields& locked, const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_field_locked()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_is_field_locked(locked.m_internal, name);
	return ret;
}


/* Class-aware wrapper for `::pdf_is_indirect()`.  */
FZ_FUNCTION int pdf_is_indirect(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_indirect()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_is_indirect(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_is_int()`.  */
FZ_FUNCTION int pdf_is_int(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_int()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_is_int(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_is_jpx_image()`.  */
FZ_FUNCTION int pdf_is_jpx_image(const PdfObj& dict)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_jpx_image()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_is_jpx_image(dict.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_is_local_object()`.  */
FZ_FUNCTION int pdf_is_local_object(const PdfDocument& doc, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_local_object()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_is_local_object(doc.m_internal, obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_is_name()`.  */
FZ_FUNCTION int pdf_is_name(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_name()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_is_name(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_is_null()`.  */
FZ_FUNCTION int pdf_is_null(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_null()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_is_null(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_is_number()`.  */
FZ_FUNCTION int pdf_is_number(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_number()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_is_number(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_is_ocg_hidden()`.  */
FZ_FUNCTION int pdf_is_ocg_hidden(const PdfDocument& doc, const PdfObj& rdb, const char *usage, const PdfObj& ocg)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_ocg_hidden()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_is_ocg_hidden(doc.m_internal, rdb.m_internal, usage, ocg.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_is_real()`.  */
FZ_FUNCTION int pdf_is_real(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_real()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_is_real(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_is_stream()`.  */
FZ_FUNCTION int pdf_is_stream(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_stream()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_is_stream(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_is_string()`.  */
FZ_FUNCTION int pdf_is_string(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_string()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_is_string(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_is_tint_colorspace()`.  */
FZ_FUNCTION int pdf_is_tint_colorspace(const FzColorspace& cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_is_tint_colorspace()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_is_tint_colorspace(cs.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_js_event_init()`.  */
FZ_FUNCTION void pdf_js_event_init(const PdfJs& js, const PdfObj& target, const char *value, int willCommit)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_js_event_init()\n";
	}
	#endif
	mupdf::ll_pdf_js_event_init(js.m_internal, target.m_internal, value, willCommit);
}


/* Class-aware wrapper for `::pdf_js_event_init_keystroke()`.  */
FZ_FUNCTION void pdf_js_event_init_keystroke(const PdfJs& js, const PdfObj& target, const PdfKeystrokeEvent& evt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_js_event_init_keystroke()\n";
	}
	#endif
	mupdf::ll_pdf_js_event_init_keystroke(js.m_internal, target.m_internal, evt.m_internal);
}


/* Class-aware wrapper for `::pdf_js_event_result()`.  */
FZ_FUNCTION int pdf_js_event_result(const PdfJs& js)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_js_event_result()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_js_event_result(js.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_js_event_result_keystroke()`.  */
FZ_FUNCTION int pdf_js_event_result_keystroke(const PdfJs& js, const PdfKeystrokeEvent& evt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_js_event_result_keystroke()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_js_event_result_keystroke(js.m_internal, evt.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_js_event_result_validate()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_js_event_result_validate(::pdf_js *js)` => `(int, char *newvalue)`
	 */
FZ_FUNCTION int pdf_js_event_result_validate(const PdfJs& js, char **newvalue)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_js_event_result_validate()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_js_event_result_validate(js.m_internal, newvalue);
	return ret;
}


/* Class-aware wrapper for `::pdf_js_event_value()`.  */
FZ_FUNCTION char *pdf_js_event_value(const PdfJs& js)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_js_event_value()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_js_event_value(js.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_js_execute()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_js_execute(::pdf_js *js, const char *name, const char *code)` => char *result
	 */
FZ_FUNCTION void pdf_js_execute(const PdfJs& js, const char *name, const char *code, char **result)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_js_execute()\n";
	}
	#endif
	mupdf::ll_pdf_js_execute(js.m_internal, name, code, result);
}


/* Class-aware wrapper for `::pdf_js_set_console()`.  */
FZ_FUNCTION void pdf_js_set_console(const PdfDocument& doc, const PdfJsConsole& console, void *user)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_js_set_console()\n";
	}
	#endif
	mupdf::ll_pdf_js_set_console(doc.m_internal, console.m_internal, user);
}


/* Class-aware wrapper for `::pdf_js_supported()`.  */
FZ_FUNCTION int pdf_js_supported(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_js_supported()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_js_supported(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_layer_config_info()`.  */
FZ_FUNCTION void pdf_layer_config_info(const PdfDocument& doc, int config_num, PdfLayerConfig& info)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_layer_config_info()\n";
	}
	#endif
	mupdf::ll_pdf_layer_config_info(doc.m_internal, config_num,  info.internal());
}


/* Class-aware wrapper for `::pdf_layer_config_ui_info()`.  */
FZ_FUNCTION void pdf_layer_config_ui_info(const PdfDocument& doc, int ui, PdfLayerConfigUi& info)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_layer_config_ui_info()\n";
	}
	#endif
	mupdf::ll_pdf_layer_config_ui_info(doc.m_internal, ui,  info.internal());
}


/* Class-aware wrapper for `::pdf_layer_is_enabled()`.  */
FZ_FUNCTION int pdf_layer_is_enabled(const PdfDocument& doc, int layer)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_layer_is_enabled()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_layer_is_enabled(doc.m_internal, layer);
	return ret;
}


/* Class-aware wrapper for `::pdf_layer_name()`.  */
FZ_FUNCTION const char *pdf_layer_name(const PdfDocument& doc, int layer)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_layer_name()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_layer_name(doc.m_internal, layer);
	return ret;
}


/* Class-aware wrapper for `::pdf_layout_fit_text()`.  */
FZ_FUNCTION FzText pdf_layout_fit_text(const FzFont& font, ::fz_text_language lang, const char *str, const FzRect& bounds)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_layout_fit_text()\n";
	}
	#endif
	::fz_text* temp = mupdf::ll_pdf_layout_fit_text(font.m_internal, lang, str, * bounds.internal());
	ll_fz_keep_text(temp);
	auto ret = FzText(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_lex()`.  */
FZ_FUNCTION ::pdf_token pdf_lex(const FzStream& f, const PdfLexbuf& lexbuf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lex()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_lex(f.m_internal, lexbuf.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_lex_no_string()`.  */
FZ_FUNCTION ::pdf_token pdf_lex_no_string(const FzStream& f, const PdfLexbuf& lexbuf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lex_no_string()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_lex_no_string(f.m_internal, lexbuf.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_lexbuf_fin()`.  */
FZ_FUNCTION void pdf_lexbuf_fin(const PdfLexbuf& lexbuf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lexbuf_fin()\n";
	}
	#endif
	mupdf::ll_pdf_lexbuf_fin(lexbuf.m_internal);
}


/* Class-aware wrapper for `::pdf_lexbuf_grow()`.  */
FZ_FUNCTION int pdf_lexbuf_grow(const PdfLexbuf& lexbuf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lexbuf_grow()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_lexbuf_grow(lexbuf.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_lexbuf_init()`.  */
FZ_FUNCTION void pdf_lexbuf_init(const PdfLexbuf& lexbuf, int size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lexbuf_init()\n";
	}
	#endif
	mupdf::ll_pdf_lexbuf_init(lexbuf.m_internal, size);
}


/* Class-aware wrapper for `::pdf_line_ending_from_name()`.  */
FZ_FUNCTION enum pdf_line_ending pdf_line_ending_from_name(const PdfObj& end)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_line_ending_from_name()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_line_ending_from_name(end.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_line_ending_from_string()`.  */
FZ_FUNCTION enum pdf_line_ending pdf_line_ending_from_string(const char *end)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_line_ending_from_string()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_line_ending_from_string(end);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_builtin_cmap()`.  */
FZ_FUNCTION PdfCmap pdf_load_builtin_cmap(const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_builtin_cmap()\n";
	}
	#endif
	::pdf_cmap* temp = mupdf::ll_pdf_load_builtin_cmap(name);
	auto ret = PdfCmap(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_cmap()`.  */
FZ_FUNCTION PdfCmap pdf_load_cmap(const FzStream& file)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_cmap()\n";
	}
	#endif
	::pdf_cmap* temp = mupdf::ll_pdf_load_cmap(file.m_internal);
	auto ret = PdfCmap(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_colorspace()`.  */
FZ_FUNCTION FzColorspace pdf_load_colorspace(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_colorspace()\n";
	}
	#endif
	::fz_colorspace* temp = mupdf::ll_pdf_load_colorspace(obj.m_internal);
	auto ret = FzColorspace(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_compressed_inline_image()`.  */
FZ_FUNCTION void pdf_load_compressed_inline_image(const PdfDocument& doc, const PdfObj& dict, int length, const FzStream& cstm, int indexed, const FzCompressedImage& image)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_compressed_inline_image()\n";
	}
	#endif
	mupdf::ll_pdf_load_compressed_inline_image(doc.m_internal, dict.m_internal, length, cstm.m_internal, indexed, image.m_internal);
}


/* Class-aware wrapper for `::pdf_load_compressed_stream()`.  */
FZ_FUNCTION FzCompressedBuffer pdf_load_compressed_stream(const PdfDocument& doc, int num, size_t worst_case)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_compressed_stream()\n";
	}
	#endif
	::fz_compressed_buffer* temp = mupdf::ll_pdf_load_compressed_stream(doc.m_internal, num, worst_case);
	auto ret = FzCompressedBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_default_colorspaces()`.  */
FZ_FUNCTION FzDefaultColorspaces pdf_load_default_colorspaces(const PdfDocument& doc, const PdfPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_default_colorspaces()\n";
	}
	#endif
	::fz_default_colorspaces* temp = mupdf::ll_pdf_load_default_colorspaces(doc.m_internal, page.m_internal);
	auto ret = FzDefaultColorspaces(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_embedded_cmap()`.  */
FZ_FUNCTION PdfCmap pdf_load_embedded_cmap(const PdfDocument& doc, const PdfObj& ref)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_embedded_cmap()\n";
	}
	#endif
	::pdf_cmap* temp = mupdf::ll_pdf_load_embedded_cmap(doc.m_internal, ref.m_internal);
	auto ret = PdfCmap(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_embedded_file_contents()`.  */
FZ_FUNCTION FzBuffer pdf_load_embedded_file_contents(const PdfObj& fs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_embedded_file_contents()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_pdf_load_embedded_file_contents(fs.m_internal);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_encoding()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_load_encoding(const char *encoding)` => const char *estrings
	 */
FZ_FUNCTION void pdf_load_encoding(const char **estrings, const char *encoding)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_encoding()\n";
	}
	#endif
	mupdf::ll_pdf_load_encoding(estrings, encoding);
}


/* Class-aware wrapper for `::pdf_load_field_name()`.  */
FZ_FUNCTION char *pdf_load_field_name(const PdfObj& field)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_field_name()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_load_field_name(field.m_internal);
	return ret;
}


FZ_FUNCTION std::string pdf_load_field_name2(PdfObj& field)
{
	return ll_pdf_load_field_name2( field.m_internal);
}

/* Class-aware wrapper for `::pdf_load_function()`.  */
FZ_FUNCTION PdfFunction pdf_load_function(const PdfObj& ref, int in, int out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_function()\n";
	}
	#endif
	::pdf_function* temp = mupdf::ll_pdf_load_function(ref.m_internal, in, out);
	auto ret = PdfFunction(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_image()`.  */
FZ_FUNCTION FzImage pdf_load_image(const PdfDocument& doc, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_image()\n";
	}
	#endif
	::fz_image* temp = mupdf::ll_pdf_load_image(doc.m_internal, obj.m_internal);
	auto ret = FzImage(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_inline_image()`.  */
FZ_FUNCTION FzImage pdf_load_inline_image(const PdfDocument& doc, const PdfObj& rdb, const PdfObj& dict, const FzStream& file)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_inline_image()\n";
	}
	#endif
	::fz_image* temp = mupdf::ll_pdf_load_inline_image(doc.m_internal, rdb.m_internal, dict.m_internal, file.m_internal);
	auto ret = FzImage(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_journal()`.  */
FZ_FUNCTION void pdf_load_journal(const PdfDocument& doc, const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_journal()\n";
	}
	#endif
	mupdf::ll_pdf_load_journal(doc.m_internal, filename);
}


/* Class-aware wrapper for `::pdf_load_link_annots()`.  */
FZ_FUNCTION FzLink pdf_load_link_annots(const PdfDocument& arg_0, const PdfPage& arg_1, const PdfObj& annots, int pagenum, const FzMatrix& page_ctm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_link_annots()\n";
	}
	#endif
	::fz_link* temp = mupdf::ll_pdf_load_link_annots(arg_0.m_internal, arg_1.m_internal, annots.m_internal, pagenum, * page_ctm.internal());
	auto ret = FzLink(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_links()`.  */
FZ_FUNCTION FzLink pdf_load_links(const PdfPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_links()\n";
	}
	#endif
	::fz_link* temp = mupdf::ll_pdf_load_links(page.m_internal);
	auto ret = FzLink(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_name_tree()`.  */
FZ_FUNCTION PdfObj pdf_load_name_tree(const PdfDocument& doc, const PdfObj& which)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_name_tree()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_load_name_tree(doc.m_internal, which.m_internal);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_object()`.  */
FZ_FUNCTION PdfObj pdf_load_object(const PdfDocument& doc, int num)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_object()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_load_object(doc.m_internal, num);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_outline()`.  */
FZ_FUNCTION FzOutline pdf_load_outline(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_outline()\n";
	}
	#endif
	::fz_outline* temp = mupdf::ll_pdf_load_outline(doc.m_internal);
	auto ret = FzOutline(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_page()`.  */
FZ_FUNCTION PdfPage pdf_load_page(const PdfDocument& doc, int number)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_page()\n";
	}
	#endif
	::pdf_page* temp = mupdf::ll_pdf_load_page(doc.m_internal, number);
	auto ret = PdfPage(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_page_imp()`.  */
FZ_FUNCTION FzPage pdf_load_page_imp(const FzDocument& doc, int chapter, int number)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_page_imp()\n";
	}
	#endif
	::fz_page* temp = mupdf::ll_pdf_load_page_imp(doc.m_internal, chapter, number);
	auto ret = FzPage(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_page_tree()`.  */
FZ_FUNCTION void pdf_load_page_tree(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_page_tree()\n";
	}
	#endif
	mupdf::ll_pdf_load_page_tree(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_load_pattern()`.  */
FZ_FUNCTION PdfPattern pdf_load_pattern(const PdfDocument& doc, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_pattern()\n";
	}
	#endif
	::pdf_pattern* temp = mupdf::ll_pdf_load_pattern(doc.m_internal, obj.m_internal);
	auto ret = PdfPattern(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_raw_stream()`.  */
FZ_FUNCTION FzBuffer pdf_load_raw_stream(const PdfObj& ref)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_raw_stream()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_pdf_load_raw_stream(ref.m_internal);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_raw_stream_number()`.  */
FZ_FUNCTION FzBuffer pdf_load_raw_stream_number(const PdfDocument& doc, int num)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_raw_stream_number()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_pdf_load_raw_stream_number(doc.m_internal, num);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_shading()`.  */
FZ_FUNCTION FzShade pdf_load_shading(const PdfDocument& doc, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_shading()\n";
	}
	#endif
	::fz_shade* temp = mupdf::ll_pdf_load_shading(doc.m_internal, obj.m_internal);
	auto ret = FzShade(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_stream()`.  */
FZ_FUNCTION FzBuffer pdf_load_stream(const PdfObj& ref)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_stream()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_pdf_load_stream(ref.m_internal);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_stream_number()`.  */
FZ_FUNCTION FzBuffer pdf_load_stream_number(const PdfDocument& doc, int num)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_stream_number()\n";
	}
	#endif
	::fz_buffer* temp = mupdf::ll_pdf_load_stream_number(doc.m_internal, num);
	auto ret = FzBuffer(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_stream_or_string_as_utf8()`.  */
FZ_FUNCTION char *pdf_load_stream_or_string_as_utf8(const PdfObj& src)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_stream_or_string_as_utf8()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_load_stream_or_string_as_utf8(src.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_system_cmap()`.  */
FZ_FUNCTION PdfCmap pdf_load_system_cmap(const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_system_cmap()\n";
	}
	#endif
	::pdf_cmap* temp = mupdf::ll_pdf_load_system_cmap(name);
	auto ret = PdfCmap(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_load_to_unicode()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_load_to_unicode(::pdf_document *doc, ::pdf_font_desc *font, char *collection, ::pdf_obj *cmapstm)` => const char *strings
	 */
FZ_FUNCTION void pdf_load_to_unicode(const PdfDocument& doc, const PdfFontDesc& font, const char **strings, char *collection, const PdfObj& cmapstm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_to_unicode()\n";
	}
	#endif
	mupdf::ll_pdf_load_to_unicode(doc.m_internal, font.m_internal, strings, collection, cmapstm.m_internal);
}


/* Class-aware wrapper for `::pdf_load_type3_glyphs()`.  */
FZ_FUNCTION void pdf_load_type3_glyphs(const PdfDocument& doc, const PdfFontDesc& fontdesc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_type3_glyphs()\n";
	}
	#endif
	mupdf::ll_pdf_load_type3_glyphs(doc.m_internal, fontdesc.m_internal);
}


/* Class-aware wrapper for `::pdf_load_unencrypted_object()`.  */
FZ_FUNCTION PdfObj pdf_load_unencrypted_object(const PdfDocument& doc, int num)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_load_unencrypted_object()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_load_unencrypted_object(doc.m_internal, num);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_lookup_cmap()`.  */
FZ_FUNCTION int pdf_lookup_cmap(const PdfCmap& cmap, unsigned int cpt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_cmap()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_lookup_cmap(cmap.m_internal, cpt);
	return ret;
}


/* Class-aware wrapper for `::pdf_lookup_cmap_full()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_lookup_cmap_full(::pdf_cmap *cmap, unsigned int cpt)` => `(int, int out)`
	 */
FZ_FUNCTION int pdf_lookup_cmap_full(const PdfCmap& cmap, unsigned int cpt, int *out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_cmap_full()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_lookup_cmap_full(cmap.m_internal, cpt, out);
	return ret;
}


/* Class-aware wrapper for `::pdf_lookup_dest()`.  */
FZ_FUNCTION PdfObj pdf_lookup_dest(const PdfDocument& doc, const PdfObj& needle)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_dest()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_lookup_dest(doc.m_internal, needle.m_internal);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_lookup_field()`.  */
FZ_FUNCTION PdfObj pdf_lookup_field(const PdfObj& form, const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_field()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_lookup_field(form.m_internal, name);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_lookup_metadata()`.  */
FZ_FUNCTION int pdf_lookup_metadata(const PdfDocument& doc, const char *key, char *ptr, int size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_metadata()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_lookup_metadata(doc.m_internal, key, ptr, size);
	return ret;
}


/* Class-aware wrapper for `::pdf_lookup_metadata2()`.  */
FZ_FUNCTION std::string pdf_lookup_metadata2(const PdfDocument& doc, const char *key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_metadata2()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_lookup_metadata2(doc.m_internal, key);
	return ret;
}


/* Class-aware wrapper for `::pdf_lookup_name()`.  */
FZ_FUNCTION PdfObj pdf_lookup_name(const PdfDocument& doc, const PdfObj& which, const PdfObj& needle)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_name()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_lookup_name(doc.m_internal, which.m_internal, needle.m_internal);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_lookup_number()`.  */
FZ_FUNCTION PdfObj pdf_lookup_number(const PdfObj& root, int needle)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_number()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_lookup_number(root.m_internal, needle);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_lookup_page_loc()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_lookup_page_loc(::pdf_document *doc, int needle, ::pdf_obj **parentp)` => `(pdf_obj *, int indexp)`
	 */
FZ_FUNCTION PdfObj pdf_lookup_page_loc(const PdfDocument& doc, int needle, PdfObj& parentp, int *indexp)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_page_loc()\n";
	}
	#endif
	/* Out-param parentp.m_internal will be overwritten. */
	ll_pdf_drop_obj(parentp.m_internal);
	parentp.m_internal = nullptr;
	::pdf_obj* temp = mupdf::ll_pdf_lookup_page_loc(doc.m_internal, needle, &parentp.m_internal, indexp);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	/* We assume that out-param parentp.m_internal is a borrowed reference. */
	ll_pdf_keep_obj(parentp.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_lookup_page_number()`.  */
FZ_FUNCTION int pdf_lookup_page_number(const PdfDocument& doc, const PdfObj& pageobj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_page_number()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_lookup_page_number(doc.m_internal, pageobj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_lookup_page_obj()`.  */
FZ_FUNCTION PdfObj pdf_lookup_page_obj(const PdfDocument& doc, int needle)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_page_obj()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_lookup_page_obj(doc.m_internal, needle);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_lookup_substitute_font()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_lookup_substitute_font(int mono, int serif, int bold, int italic)` => `(const unsigned char *, int len)`
	 */
FZ_FUNCTION const unsigned char *pdf_lookup_substitute_font(int mono, int serif, int bold, int italic, int *len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_lookup_substitute_font()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_lookup_substitute_font(mono, serif, bold, italic, len);
	return ret;
}


/* Class-aware wrapper for `::pdf_map_one_to_many()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_map_one_to_many(::pdf_cmap *cmap, unsigned int one, size_t len)` => int many
	 */
FZ_FUNCTION void pdf_map_one_to_many(const PdfCmap& cmap, unsigned int one, int *many, size_t len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_map_one_to_many()\n";
	}
	#endif
	mupdf::ll_pdf_map_one_to_many(cmap.m_internal, one, many, len);
}


/* Class-aware wrapper for `::pdf_map_range_to_range()`.  */
FZ_FUNCTION void pdf_map_range_to_range(const PdfCmap& cmap, unsigned int srclo, unsigned int srchi, int dstlo)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_map_range_to_range()\n";
	}
	#endif
	mupdf::ll_pdf_map_range_to_range(cmap.m_internal, srclo, srchi, dstlo);
}


/* Class-aware wrapper for `::pdf_mark_bits_reset()`.  */
FZ_FUNCTION void pdf_mark_bits_reset(const PdfMarkBits& marks)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_mark_bits_reset()\n";
	}
	#endif
	mupdf::ll_pdf_mark_bits_reset(marks.m_internal);
}


/* Class-aware wrapper for `::pdf_mark_bits_set()`.  */
FZ_FUNCTION int pdf_mark_bits_set(const PdfMarkBits& marks, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_mark_bits_set()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_mark_bits_set(marks.m_internal, obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_mark_list_check()`.  */
FZ_FUNCTION int pdf_mark_list_check(const PdfMarkList& list, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_mark_list_check()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_mark_list_check(list.m_internal, obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_mark_list_free()`.  */
FZ_FUNCTION void pdf_mark_list_free(const PdfMarkList& list)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_mark_list_free()\n";
	}
	#endif
	mupdf::ll_pdf_mark_list_free(list.m_internal);
}


/* Class-aware wrapper for `::pdf_mark_list_init()`.  */
FZ_FUNCTION void pdf_mark_list_init(const PdfMarkList& list)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_mark_list_init()\n";
	}
	#endif
	mupdf::ll_pdf_mark_list_init(list.m_internal);
}


/* Class-aware wrapper for `::pdf_mark_list_pop()`.  */
FZ_FUNCTION void pdf_mark_list_pop(const PdfMarkList& list)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_mark_list_pop()\n";
	}
	#endif
	mupdf::ll_pdf_mark_list_pop(list.m_internal);
}


/* Class-aware wrapper for `::pdf_mark_list_push()`.  */
FZ_FUNCTION int pdf_mark_list_push(const PdfMarkList& list, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_mark_list_push()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_mark_list_push(list.m_internal, obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_mark_obj()`.  */
FZ_FUNCTION int pdf_mark_obj(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_mark_obj()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_mark_obj(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_mark_xref()`.  */
FZ_FUNCTION void pdf_mark_xref(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_mark_xref()\n";
	}
	#endif
	mupdf::ll_pdf_mark_xref(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_metadata()`.  */
FZ_FUNCTION PdfObj pdf_metadata(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_metadata()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_metadata(doc.m_internal);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_minimize_document()`.  */
FZ_FUNCTION void pdf_minimize_document(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_minimize_document()\n";
	}
	#endif
	mupdf::ll_pdf_minimize_document(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_name_eq()`.  */
FZ_FUNCTION int pdf_name_eq(const PdfObj& a, const PdfObj& b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_name_eq()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_name_eq(a.m_internal, b.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_name_from_intent()`.  */
FZ_FUNCTION PdfObj pdf_name_from_intent(enum pdf_intent intent)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_name_from_intent()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_name_from_intent(intent);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_name_from_line_ending()`.  */
FZ_FUNCTION PdfObj pdf_name_from_line_ending(enum pdf_line_ending end)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_name_from_line_ending()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_name_from_line_ending(end);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_needs_password()`.  */
FZ_FUNCTION int pdf_needs_password(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_needs_password()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_needs_password(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_action_from_link()`.  */
FZ_FUNCTION PdfObj pdf_new_action_from_link(const PdfDocument& doc, const char *uri)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_action_from_link()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_new_action_from_link(doc.m_internal, uri);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_array()`.  */
FZ_FUNCTION PdfObj pdf_new_array(const PdfDocument& doc, int initialcap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_array()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_new_array(doc.m_internal, initialcap);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_buffer_processor()`.  */
FZ_FUNCTION PdfProcessor pdf_new_buffer_processor(const FzBuffer& buffer, int ahxencode, int newlines)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_buffer_processor()\n";
	}
	#endif
	::pdf_processor* temp = mupdf::ll_pdf_new_buffer_processor(buffer.m_internal, ahxencode, newlines);
	auto ret = PdfProcessor(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_cmap()`.  */
FZ_FUNCTION PdfCmap pdf_new_cmap()
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_cmap()\n";
	}
	#endif
	::pdf_cmap* temp = mupdf::ll_pdf_new_cmap();
	auto ret = PdfCmap(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_color_filter()`.  */
FZ_FUNCTION PdfProcessor pdf_new_color_filter(const PdfDocument& doc, const PdfProcessor& chain, int struct_parents, const FzMatrix& transform, PdfFilterOptions& options, void *copts)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_color_filter()\n";
	}
	#endif
	::pdf_processor* temp = mupdf::ll_pdf_new_color_filter(doc.m_internal, chain.m_internal, struct_parents, * transform.internal(),  options.internal(), copts);
	auto ret = PdfProcessor(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_date()`.  */
FZ_FUNCTION PdfObj pdf_new_date(const PdfDocument& doc, int64_t time)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_date()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_new_date(doc.m_internal, time);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_dest_from_link()`.  */
FZ_FUNCTION PdfObj pdf_new_dest_from_link(const PdfDocument& doc, const char *uri, int is_remote)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_dest_from_link()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_new_dest_from_link(doc.m_internal, uri, is_remote);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_dict()`.  */
FZ_FUNCTION PdfObj pdf_new_dict(const PdfDocument& doc, int initialcap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_dict()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_new_dict(doc.m_internal, initialcap);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_display_list_from_annot()`.  */
FZ_FUNCTION FzDisplayList pdf_new_display_list_from_annot(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_display_list_from_annot()\n";
	}
	#endif
	::fz_display_list* temp = mupdf::ll_pdf_new_display_list_from_annot(annot.m_internal);
	auto ret = FzDisplayList(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_graft_map()`.  */
FZ_FUNCTION PdfGraftMap pdf_new_graft_map(const PdfDocument& dst)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_graft_map()\n";
	}
	#endif
	::pdf_graft_map* temp = mupdf::ll_pdf_new_graft_map(dst.m_internal);
	auto ret = PdfGraftMap(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_identity_cmap()`.  */
FZ_FUNCTION PdfCmap pdf_new_identity_cmap(int wmode, int bytes)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_identity_cmap()\n";
	}
	#endif
	::pdf_cmap* temp = mupdf::ll_pdf_new_identity_cmap(wmode, bytes);
	auto ret = PdfCmap(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_indirect()`.  */
FZ_FUNCTION PdfObj pdf_new_indirect(const PdfDocument& doc, int num, int gen)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_indirect()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_new_indirect(doc.m_internal, num, gen);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_int()`.  */
FZ_FUNCTION PdfObj pdf_new_int(int64_t i)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_int()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_new_int(i);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_link()`.  */
FZ_FUNCTION FzLink pdf_new_link(const PdfPage& page, const FzRect& rect, const char *uri, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_link()\n";
	}
	#endif
	::fz_link* temp = mupdf::ll_pdf_new_link(page.m_internal, * rect.internal(), uri, obj.m_internal);
	auto ret = FzLink(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_matrix()`.  */
FZ_FUNCTION PdfObj pdf_new_matrix(const PdfDocument& doc, const FzMatrix& mtx)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_matrix()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_new_matrix(doc.m_internal, * mtx.internal());
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_name()`.  */
FZ_FUNCTION PdfObj pdf_new_name(const char *str)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_name()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_new_name(str);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_output_processor()`.  */
FZ_FUNCTION PdfProcessor pdf_new_output_processor(const FzOutput& out, int ahxencode, int newlines)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_output_processor()\n";
	}
	#endif
	::pdf_processor* temp = mupdf::ll_pdf_new_output_processor(out.m_internal, ahxencode, newlines);
	auto ret = PdfProcessor(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_pdf_device()`.  */
FZ_FUNCTION FzDevice pdf_new_pdf_device(const PdfDocument& doc, const FzMatrix& topctm, const PdfObj& resources, const FzBuffer& contents)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_pdf_device()\n";
	}
	#endif
	::fz_device* temp = mupdf::ll_pdf_new_pdf_device(doc.m_internal, * topctm.internal(), resources.m_internal, contents.m_internal);
	auto ret = FzDevice(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_pixmap_from_annot()`.  */
FZ_FUNCTION FzPixmap pdf_new_pixmap_from_annot(const PdfAnnot& annot, const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_pixmap_from_annot()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_pdf_new_pixmap_from_annot(annot.m_internal, * ctm.internal(), cs.m_internal, seps.m_internal, alpha);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_pixmap_from_page_contents_with_separations_and_usage()`.  */
FZ_FUNCTION FzPixmap pdf_new_pixmap_from_page_contents_with_separations_and_usage(const PdfPage& page, const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha, const char *usage, ::fz_box_type box)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_pixmap_from_page_contents_with_separations_and_usage()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_pdf_new_pixmap_from_page_contents_with_separations_and_usage(page.m_internal, * ctm.internal(), cs.m_internal, seps.m_internal, alpha, usage, box);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_pixmap_from_page_contents_with_usage()`.  */
FZ_FUNCTION FzPixmap pdf_new_pixmap_from_page_contents_with_usage(const PdfPage& page, const FzMatrix& ctm, const FzColorspace& cs, int alpha, const char *usage, ::fz_box_type box)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_pixmap_from_page_contents_with_usage()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_pdf_new_pixmap_from_page_contents_with_usage(page.m_internal, * ctm.internal(), cs.m_internal, alpha, usage, box);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_pixmap_from_page_with_separations_and_usage()`.  */
FZ_FUNCTION FzPixmap pdf_new_pixmap_from_page_with_separations_and_usage(const PdfPage& page, const FzMatrix& ctm, const FzColorspace& cs, const FzSeparations& seps, int alpha, const char *usage, ::fz_box_type box)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_pixmap_from_page_with_separations_and_usage()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_pdf_new_pixmap_from_page_with_separations_and_usage(page.m_internal, * ctm.internal(), cs.m_internal, seps.m_internal, alpha, usage, box);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_pixmap_from_page_with_usage()`.  */
FZ_FUNCTION FzPixmap pdf_new_pixmap_from_page_with_usage(const PdfPage& page, const FzMatrix& ctm, const FzColorspace& cs, int alpha, const char *usage, ::fz_box_type box)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_pixmap_from_page_with_usage()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_pdf_new_pixmap_from_page_with_usage(page.m_internal, * ctm.internal(), cs.m_internal, alpha, usage, box);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_processor()`.  */
FZ_FUNCTION void *pdf_new_processor(int size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_processor()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_new_processor(size);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_real()`.  */
FZ_FUNCTION PdfObj pdf_new_real(float f)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_real()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_new_real(f);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_rect()`.  */
FZ_FUNCTION PdfObj pdf_new_rect(const PdfDocument& doc, const FzRect& rect)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_rect()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_new_rect(doc.m_internal, * rect.internal());
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_run_processor()`.  */
FZ_FUNCTION PdfProcessor pdf_new_run_processor(const PdfDocument& doc, const FzDevice& dev, const FzMatrix& ctm, int struct_parent, const char *usage, const PdfGstate& gstate, const FzDefaultColorspaces& default_cs, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_run_processor()\n";
	}
	#endif
	::pdf_processor* temp = mupdf::ll_pdf_new_run_processor(doc.m_internal, dev.m_internal, * ctm.internal(), struct_parent, usage, gstate.m_internal, default_cs.m_internal, &cookie.m_internal);
	auto ret = PdfProcessor(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_sanitize_filter()`.  */
FZ_FUNCTION PdfProcessor pdf_new_sanitize_filter(const PdfDocument& doc, const PdfProcessor& chain, int struct_parents, const FzMatrix& transform, PdfFilterOptions& options, void *sopts)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_sanitize_filter()\n";
	}
	#endif
	::pdf_processor* temp = mupdf::ll_pdf_new_sanitize_filter(doc.m_internal, chain.m_internal, struct_parents, * transform.internal(),  options.internal(), sopts);
	auto ret = PdfProcessor(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_string()`.  */
FZ_FUNCTION PdfObj pdf_new_string(const char *str, size_t len)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_string()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_new_string(str, len);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_text_string()`.  */
FZ_FUNCTION PdfObj pdf_new_text_string(const char *s)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_text_string()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_new_text_string(s);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_uri_from_explicit_dest()`.  */
FZ_FUNCTION char *pdf_new_uri_from_explicit_dest(const FzLinkDest& dest)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_uri_from_explicit_dest()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_new_uri_from_explicit_dest(*dest.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_uri_from_path_and_explicit_dest()`.  */
FZ_FUNCTION char *pdf_new_uri_from_path_and_explicit_dest(const char *path, const FzLinkDest& dest)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_uri_from_path_and_explicit_dest()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_new_uri_from_path_and_explicit_dest(path, *dest.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_uri_from_path_and_named_dest()`.  */
FZ_FUNCTION char *pdf_new_uri_from_path_and_named_dest(const char *path, const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_uri_from_path_and_named_dest()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_new_uri_from_path_and_named_dest(path, name);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_utf8_from_pdf_stream_obj()`.  */
FZ_FUNCTION char *pdf_new_utf8_from_pdf_stream_obj(const PdfObj& src)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_utf8_from_pdf_stream_obj()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_new_utf8_from_pdf_stream_obj(src.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_utf8_from_pdf_string()`.  */
FZ_FUNCTION char *pdf_new_utf8_from_pdf_string(const char *srcptr, size_t srclen)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_utf8_from_pdf_string()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_new_utf8_from_pdf_string(srcptr, srclen);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_utf8_from_pdf_string_obj()`.  */
FZ_FUNCTION char *pdf_new_utf8_from_pdf_string_obj(const PdfObj& src)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_utf8_from_pdf_string_obj()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_new_utf8_from_pdf_string_obj(src.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_new_xobject()`.  */
FZ_FUNCTION PdfObj pdf_new_xobject(const PdfDocument& doc, const FzRect& bbox, const FzMatrix& matrix, const PdfObj& res, const FzBuffer& buffer)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_new_xobject()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_new_xobject(doc.m_internal, * bbox.internal(), * matrix.internal(), res.m_internal, buffer.m_internal);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_next_annot()`.  */
FZ_FUNCTION PdfAnnot pdf_next_annot(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_next_annot()\n";
	}
	#endif
	::pdf_annot* temp = mupdf::ll_pdf_next_annot(annot.m_internal);
	ll_pdf_keep_annot(temp);
	auto ret = PdfAnnot(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_next_widget()`.  */
FZ_FUNCTION PdfAnnot pdf_next_widget(const PdfAnnot& previous)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_next_widget()\n";
	}
	#endif
	::pdf_annot* temp = mupdf::ll_pdf_next_widget(previous.m_internal);
	ll_pdf_keep_annot(temp);
	auto ret = PdfAnnot(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_obj_is_dirty()`.  */
FZ_FUNCTION int pdf_obj_is_dirty(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_obj_is_dirty()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_obj_is_dirty(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_obj_is_incremental()`.  */
FZ_FUNCTION int pdf_obj_is_incremental(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_obj_is_incremental()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_obj_is_incremental(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_obj_marked()`.  */
FZ_FUNCTION int pdf_obj_marked(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_obj_marked()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_obj_marked(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_obj_memo()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_obj_memo(::pdf_obj *obj, int bit)` => `(int, int memo)`
	 */
FZ_FUNCTION int pdf_obj_memo(const PdfObj& obj, int bit, int *memo)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_obj_memo()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_obj_memo(obj.m_internal, bit, memo);
	return ret;
}


/* Class-aware wrapper for `::pdf_obj_num_is_stream()`.  */
FZ_FUNCTION int pdf_obj_num_is_stream(const PdfDocument& doc, int num)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_obj_num_is_stream()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_obj_num_is_stream(doc.m_internal, num);
	return ret;
}


/* Class-aware wrapper for `::pdf_obj_parent_num()`.  */
FZ_FUNCTION int pdf_obj_parent_num(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_obj_parent_num()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_obj_parent_num(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_obj_refs()`.  */
FZ_FUNCTION int pdf_obj_refs(const PdfObj& ref)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_obj_refs()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_obj_refs(ref.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_objcmp()`.  */
FZ_FUNCTION int pdf_objcmp(const PdfObj& a, const PdfObj& b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_objcmp()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_objcmp(a.m_internal, b.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_objcmp_deep()`.  */
FZ_FUNCTION int pdf_objcmp_deep(const PdfObj& a, const PdfObj& b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_objcmp_deep()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_objcmp_deep(a.m_internal, b.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_objcmp_resolve()`.  */
FZ_FUNCTION int pdf_objcmp_resolve(const PdfObj& a, const PdfObj& b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_objcmp_resolve()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_objcmp_resolve(a.m_internal, b.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_open_contents_stream()`.  */
FZ_FUNCTION FzStream pdf_open_contents_stream(const PdfDocument& doc, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_contents_stream()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_pdf_open_contents_stream(doc.m_internal, obj.m_internal);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_open_crypt()`.  */
FZ_FUNCTION FzStream pdf_open_crypt(const FzStream& chain, const PdfCrypt& crypt, int num, int gen)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_crypt()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_pdf_open_crypt(chain.m_internal, crypt.m_internal, num, gen);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_open_crypt_with_filter()`.  */
FZ_FUNCTION FzStream pdf_open_crypt_with_filter(const FzStream& chain, const PdfCrypt& crypt, const PdfObj& name, int num, int gen)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_crypt_with_filter()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_pdf_open_crypt_with_filter(chain.m_internal, crypt.m_internal, name.m_internal, num, gen);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_open_document()`.  */
FZ_FUNCTION PdfDocument pdf_open_document(const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_document()\n";
	}
	#endif
	::pdf_document* temp = mupdf::ll_pdf_open_document(filename);
	auto ret = PdfDocument(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_open_document_with_stream()`.  */
FZ_FUNCTION PdfDocument pdf_open_document_with_stream(const FzStream& file)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_document_with_stream()\n";
	}
	#endif
	::pdf_document* temp = mupdf::ll_pdf_open_document_with_stream(file.m_internal);
	auto ret = PdfDocument(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_open_inline_stream()`.  */
FZ_FUNCTION FzStream pdf_open_inline_stream(const PdfDocument& doc, const PdfObj& stmobj, int length, const FzStream& chain, const FzCompressionParams& params)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_inline_stream()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_pdf_open_inline_stream(doc.m_internal, stmobj.m_internal, length, chain.m_internal, params.m_internal);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_open_raw_stream()`.  */
FZ_FUNCTION FzStream pdf_open_raw_stream(const PdfObj& ref)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_raw_stream()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_pdf_open_raw_stream(ref.m_internal);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_open_raw_stream_number()`.  */
FZ_FUNCTION FzStream pdf_open_raw_stream_number(const PdfDocument& doc, int num)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_raw_stream_number()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_pdf_open_raw_stream_number(doc.m_internal, num);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_open_stream()`.  */
FZ_FUNCTION FzStream pdf_open_stream(const PdfObj& ref)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_stream()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_pdf_open_stream(ref.m_internal);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_open_stream_number()`.  */
FZ_FUNCTION FzStream pdf_open_stream_number(const PdfDocument& doc, int num)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_stream_number()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_pdf_open_stream_number(doc.m_internal, num);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_open_stream_with_offset()`.  */
FZ_FUNCTION FzStream pdf_open_stream_with_offset(const PdfDocument& doc, int num, const PdfObj& dict, int64_t stm_ofs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_open_stream_with_offset()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_pdf_open_stream_with_offset(doc.m_internal, num, dict.m_internal, stm_ofs);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_page_contents()`.  */
FZ_FUNCTION PdfObj pdf_page_contents(const PdfPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_contents()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_page_contents(page.m_internal);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_page_event_close()`.  */
FZ_FUNCTION void pdf_page_event_close(const PdfPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_event_close()\n";
	}
	#endif
	mupdf::ll_pdf_page_event_close(page.m_internal);
}


/* Class-aware wrapper for `::pdf_page_event_open()`.  */
FZ_FUNCTION void pdf_page_event_open(const PdfPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_event_open()\n";
	}
	#endif
	mupdf::ll_pdf_page_event_open(page.m_internal);
}


/* Class-aware wrapper for `::pdf_page_from_fz_page()`.  */
FZ_FUNCTION PdfPage pdf_page_from_fz_page(const FzPage& ptr)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_from_fz_page()\n";
	}
	#endif
	::pdf_page* temp = mupdf::ll_pdf_page_from_fz_page(ptr.m_internal);
	ll_pdf_keep_page(temp);
	auto ret = PdfPage(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_page_group()`.  */
FZ_FUNCTION PdfObj pdf_page_group(const PdfPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_group()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_page_group(page.m_internal);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_page_has_transparency()`.  */
FZ_FUNCTION int pdf_page_has_transparency(const PdfPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_has_transparency()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_page_has_transparency(page.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_page_label()`.  */
FZ_FUNCTION void pdf_page_label(const PdfDocument& doc, int page, char *buf, size_t size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_label()\n";
	}
	#endif
	mupdf::ll_pdf_page_label(doc.m_internal, page, buf, size);
}


/* Class-aware wrapper for `::pdf_page_label_imp()`.  */
FZ_FUNCTION void pdf_page_label_imp(const FzDocument& doc, int chapter, int page, char *buf, size_t size)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_label_imp()\n";
	}
	#endif
	mupdf::ll_pdf_page_label_imp(doc.m_internal, chapter, page, buf, size);
}


/* Class-aware wrapper for `::pdf_page_obj_transform()`.  */
FZ_FUNCTION void pdf_page_obj_transform(const PdfObj& pageobj, FzRect& outbox, FzMatrix& outctm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_obj_transform()\n";
	}
	#endif
	mupdf::ll_pdf_page_obj_transform(pageobj.m_internal,  outbox.internal(),  outctm.internal());
}


/* Class-aware wrapper for `::pdf_page_obj_transform_box()`.  */
FZ_FUNCTION void pdf_page_obj_transform_box(const PdfObj& pageobj, FzRect& outbox, FzMatrix& out, ::fz_box_type box)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_obj_transform_box()\n";
	}
	#endif
	mupdf::ll_pdf_page_obj_transform_box(pageobj.m_internal,  outbox.internal(),  out.internal(), box);
}


/* Class-aware wrapper for `::pdf_page_presentation()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_page_presentation(::pdf_page *page, ::fz_transition *transition)` => `(fz_transition *, float duration)`
	 */
FZ_FUNCTION FzTransition pdf_page_presentation(const PdfPage& page, FzTransition& transition, float *duration)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_presentation()\n";
	}
	#endif
	::fz_transition* temp = mupdf::ll_pdf_page_presentation(page.m_internal,  transition.internal(), duration);
	auto ret = FzTransition(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_page_resources()`.  */
FZ_FUNCTION PdfObj pdf_page_resources(const PdfPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_resources()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_page_resources(page.m_internal);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_page_separations()`.  */
FZ_FUNCTION FzSeparations pdf_page_separations(const PdfPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_separations()\n";
	}
	#endif
	::fz_separations* temp = mupdf::ll_pdf_page_separations(page.m_internal);
	ll_fz_keep_separations(temp);
	auto ret = FzSeparations(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_page_transform()`.  */
FZ_FUNCTION void pdf_page_transform(const PdfPage& page, FzRect& mediabox, FzMatrix& ctm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_transform()\n";
	}
	#endif
	mupdf::ll_pdf_page_transform(page.m_internal,  mediabox.internal(),  ctm.internal());
}


/* Class-aware wrapper for `::pdf_page_transform_box()`.  */
FZ_FUNCTION void pdf_page_transform_box(const PdfPage& page, FzRect& mediabox, FzMatrix& ctm, ::fz_box_type box)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_transform_box()\n";
	}
	#endif
	mupdf::ll_pdf_page_transform_box(page.m_internal,  mediabox.internal(),  ctm.internal(), box);
}


/* Class-aware wrapper for `::pdf_page_write()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_page_write(::pdf_document *doc, ::fz_rect mediabox, ::pdf_obj **presources, ::fz_buffer **pcontents)` => `(fz_device *)`
	 */
FZ_FUNCTION FzDevice pdf_page_write(const PdfDocument& doc, const FzRect& mediabox, PdfObj& presources, FzBuffer& pcontents)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_page_write()\n";
	}
	#endif
	/* Out-param presources.m_internal will be overwritten. */
	ll_pdf_drop_obj(presources.m_internal);
	presources.m_internal = nullptr;
	/* Out-param pcontents.m_internal will be overwritten. */
	ll_fz_drop_buffer(pcontents.m_internal);
	pcontents.m_internal = nullptr;
	::fz_device* temp = mupdf::ll_pdf_page_write(doc.m_internal, * mediabox.internal(), &presources.m_internal, &pcontents.m_internal);
	auto ret = FzDevice(temp);
	/* We assume that out-param presources.m_internal is a kept reference. */
	/* We assume that out-param pcontents.m_internal is a kept reference. */
	return ret;
}


/* Class-aware wrapper for `::pdf_parse_array()`.  */
FZ_FUNCTION PdfObj pdf_parse_array(const PdfDocument& doc, const FzStream& f, const PdfLexbuf& buf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_parse_array()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_parse_array(doc.m_internal, f.m_internal, buf.m_internal);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_parse_date()`.  */
FZ_FUNCTION int64_t pdf_parse_date(const char *s)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_parse_date()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_parse_date(s);
	return ret;
}


/* Class-aware wrapper for `::pdf_parse_default_appearance()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_parse_default_appearance(const char *da, float color[4])` => `(const char *font, float size, int n)`
	 */
FZ_FUNCTION void pdf_parse_default_appearance(const char *da, const char **font, float *size, int *n, float color[4])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_parse_default_appearance()\n";
	}
	#endif
	mupdf::ll_pdf_parse_default_appearance(da, font, size, n, color);
}


/* Class-aware wrapper for `::pdf_parse_dict()`.  */
FZ_FUNCTION PdfObj pdf_parse_dict(const PdfDocument& doc, const FzStream& f, const PdfLexbuf& buf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_parse_dict()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_parse_dict(doc.m_internal, f.m_internal, buf.m_internal);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_parse_ind_obj()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_parse_ind_obj(::pdf_document *doc, ::fz_stream *f)` => `(pdf_obj *, int num, int gen, int64_t stm_ofs, int try_repair)`
	 */
FZ_FUNCTION PdfObj pdf_parse_ind_obj(const PdfDocument& doc, const FzStream& f, int *num, int *gen, int64_t *stm_ofs, int *try_repair)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_parse_ind_obj()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_parse_ind_obj(doc.m_internal, f.m_internal, num, gen, stm_ofs, try_repair);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_parse_journal_obj()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_parse_journal_obj(::pdf_document *doc, ::fz_stream *stm, ::fz_buffer **ostm)` => `(pdf_obj *, int onum, int newobj)`
	 */
FZ_FUNCTION PdfObj pdf_parse_journal_obj(const PdfDocument& doc, const FzStream& stm, int *onum, FzBuffer& ostm, int *newobj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_parse_journal_obj()\n";
	}
	#endif
	/* Out-param ostm.m_internal will be overwritten. */
	ll_fz_drop_buffer(ostm.m_internal);
	ostm.m_internal = nullptr;
	::pdf_obj* temp = mupdf::ll_pdf_parse_journal_obj(doc.m_internal, stm.m_internal, onum, &ostm.m_internal, newobj);
	auto ret = PdfObj(temp);
	/* We assume that out-param ostm.m_internal is a kept reference. */
	return ret;
}


/* Class-aware wrapper for `::pdf_parse_stm_obj()`.  */
FZ_FUNCTION PdfObj pdf_parse_stm_obj(const PdfDocument& doc, const FzStream& f, const PdfLexbuf& buf)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_parse_stm_obj()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_parse_stm_obj(doc.m_internal, f.m_internal, buf.m_internal);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_parse_write_options()`.  */
FZ_FUNCTION PdfWriteOptions pdf_parse_write_options(PdfWriteOptions& opts, const char *args)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_parse_write_options()\n";
	}
	#endif
	::pdf_write_options* temp = mupdf::ll_pdf_parse_write_options( opts.internal(), args);
	auto ret = PdfWriteOptions(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_pin_document()`.  */
FZ_FUNCTION PdfDocument pdf_pin_document(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_pin_document()\n";
	}
	#endif
	::pdf_document* temp = mupdf::ll_pdf_pin_document(obj.m_internal);
	ll_pdf_keep_document(temp);
	auto ret = PdfDocument(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_preview_signature_as_display_list()`.  */
FZ_FUNCTION FzDisplayList pdf_preview_signature_as_display_list(float w, float h, ::fz_text_language lang, const PdfPkcs7Signer& signer, int appearance_flags, const FzImage& graphic, const char *reason, const char *location)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_preview_signature_as_display_list()\n";
	}
	#endif
	::fz_display_list* temp = mupdf::ll_pdf_preview_signature_as_display_list(w, h, lang, signer.m_internal, appearance_flags, graphic.m_internal, reason, location);
	ll_fz_keep_display_list(temp);
	auto ret = FzDisplayList(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_preview_signature_as_pixmap()`.  */
FZ_FUNCTION FzPixmap pdf_preview_signature_as_pixmap(int w, int h, ::fz_text_language lang, const PdfPkcs7Signer& signer, int appearance_flags, const FzImage& graphic, const char *reason, const char *location)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_preview_signature_as_pixmap()\n";
	}
	#endif
	::fz_pixmap* temp = mupdf::ll_pdf_preview_signature_as_pixmap(w, h, lang, signer.m_internal, appearance_flags, graphic.m_internal, reason, location);
	ll_fz_keep_pixmap(temp);
	auto ret = FzPixmap(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_print_crypt()`.  */
FZ_FUNCTION void pdf_print_crypt(const FzOutput& out, const PdfCrypt& crypt)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_print_crypt()\n";
	}
	#endif
	mupdf::ll_pdf_print_crypt(out.m_internal, crypt.m_internal);
}


/* Class-aware wrapper for `::pdf_print_default_appearance()`.  */
FZ_FUNCTION void pdf_print_default_appearance(char *buf, int nbuf, const char *font, float size, int n, const float *color)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_print_default_appearance()\n";
	}
	#endif
	mupdf::ll_pdf_print_default_appearance(buf, nbuf, font, size, n, color);
}


/* Class-aware wrapper for `::pdf_print_encrypted_obj()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_print_encrypted_obj(::fz_output *out, ::pdf_obj *obj, int tight, int ascii, ::pdf_crypt *crypt, int num, int gen)` => int sep
	 */
FZ_FUNCTION void pdf_print_encrypted_obj(const FzOutput& out, const PdfObj& obj, int tight, int ascii, const PdfCrypt& crypt, int num, int gen, int *sep)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_print_encrypted_obj()\n";
	}
	#endif
	mupdf::ll_pdf_print_encrypted_obj(out.m_internal, obj.m_internal, tight, ascii, crypt.m_internal, num, gen, sep);
}


/* Class-aware wrapper for `::pdf_print_font()`.  */
FZ_FUNCTION void pdf_print_font(const FzOutput& out, const PdfFontDesc& fontdesc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_print_font()\n";
	}
	#endif
	mupdf::ll_pdf_print_font(out.m_internal, fontdesc.m_internal);
}


/* Class-aware wrapper for `::pdf_print_obj()`.  */
FZ_FUNCTION void pdf_print_obj(const FzOutput& out, const PdfObj& obj, int tight, int ascii)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_print_obj()\n";
	}
	#endif
	mupdf::ll_pdf_print_obj(out.m_internal, obj.m_internal, tight, ascii);
}


/* Class-aware wrapper for `::pdf_process_annot()`.  */
FZ_FUNCTION void pdf_process_annot(const PdfProcessor& proc, const PdfAnnot& annot, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_process_annot()\n";
	}
	#endif
	mupdf::ll_pdf_process_annot(proc.m_internal, annot.m_internal, &cookie.m_internal);
}


/* Class-aware wrapper for `::pdf_process_contents()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_process_contents(::pdf_processor *proc, ::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm, ::fz_cookie *cookie, ::pdf_obj **out_res)` => 
	 */
FZ_FUNCTION void pdf_process_contents(const PdfProcessor& proc, const PdfDocument& doc, const PdfObj& res, const PdfObj& stm, FzCookie& cookie, PdfObj& out_res)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_process_contents()\n";
	}
	#endif
	/* Out-param out_res.m_internal will be overwritten. */
	ll_pdf_drop_obj(out_res.m_internal);
	out_res.m_internal = nullptr;
	mupdf::ll_pdf_process_contents(proc.m_internal, doc.m_internal, res.m_internal, stm.m_internal, &cookie.m_internal, &out_res.m_internal);
	/* We assume that out-param out_res.m_internal is a borrowed reference. */
	ll_pdf_keep_obj(out_res.m_internal);
}


/* Class-aware wrapper for `::pdf_process_glyph()`.  */
FZ_FUNCTION void pdf_process_glyph(const PdfProcessor& proc, const PdfDocument& doc, const PdfObj& resources, const FzBuffer& contents)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_process_glyph()\n";
	}
	#endif
	mupdf::ll_pdf_process_glyph(proc.m_internal, doc.m_internal, resources.m_internal, contents.m_internal);
}


/* Class-aware wrapper for `::pdf_process_raw_contents()`.  */
FZ_FUNCTION void pdf_process_raw_contents(const PdfProcessor& proc, const PdfDocument& doc, const PdfObj& rdb, const PdfObj& stmobj, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_process_raw_contents()\n";
	}
	#endif
	mupdf::ll_pdf_process_raw_contents(proc.m_internal, doc.m_internal, rdb.m_internal, stmobj.m_internal, &cookie.m_internal);
}


/* Class-aware wrapper for `::pdf_processor_pop_resources()`.  */
FZ_FUNCTION PdfObj pdf_processor_pop_resources(const PdfProcessor& proc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_processor_pop_resources()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_processor_pop_resources(proc.m_internal);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_processor_push_resources()`.  */
FZ_FUNCTION void pdf_processor_push_resources(const PdfProcessor& proc, const PdfObj& res)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_processor_push_resources()\n";
	}
	#endif
	mupdf::ll_pdf_processor_push_resources(proc.m_internal, res.m_internal);
}


/* Class-aware wrapper for `::pdf_progressive_advance()`.  */
FZ_FUNCTION PdfObj pdf_progressive_advance(const PdfDocument& doc, int pagenum)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_progressive_advance()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_progressive_advance(doc.m_internal, pagenum);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_purge_local_font_resources()`.  */
FZ_FUNCTION void pdf_purge_local_font_resources(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_purge_local_font_resources()\n";
	}
	#endif
	mupdf::ll_pdf_purge_local_font_resources(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_purge_locals_from_store()`.  */
FZ_FUNCTION void pdf_purge_locals_from_store(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_purge_locals_from_store()\n";
	}
	#endif
	mupdf::ll_pdf_purge_locals_from_store(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_read_journal()`.  */
FZ_FUNCTION void pdf_read_journal(const PdfDocument& doc, const FzStream& stm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_read_journal()\n";
	}
	#endif
	mupdf::ll_pdf_read_journal(doc.m_internal, stm.m_internal);
}


/* Class-aware wrapper for `::pdf_rearrange_pages()`.  */
FZ_FUNCTION void pdf_rearrange_pages(const PdfDocument& doc, int count, const int *pages)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_rearrange_pages()\n";
	}
	#endif
	mupdf::ll_pdf_rearrange_pages(doc.m_internal, count, pages);
}


/* Class-aware wrapper for `::pdf_rearrange_pages2()`.  */
FZ_FUNCTION void pdf_rearrange_pages2(const PdfDocument& doc, const std::vector<int> &pages)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_rearrange_pages2()\n";
	}
	#endif
	mupdf::ll_pdf_rearrange_pages2(doc.m_internal, pages);
}


/* Class-aware wrapper for `::pdf_recolor_shade()`.  */
FZ_FUNCTION PdfObj pdf_recolor_shade(const PdfObj& shade, ::pdf_shade_recolorer *reshade, void *opaque)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_recolor_shade()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_recolor_shade(shade.m_internal, reshade, opaque);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_redact_page()`.  */
FZ_FUNCTION int pdf_redact_page(const PdfDocument& doc, const PdfPage& page, PdfRedactOptions& opts)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_redact_page()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_redact_page(doc.m_internal, page.m_internal,  opts.internal());
	return ret;
}


/* Class-aware wrapper for `::pdf_redo()`.  */
FZ_FUNCTION void pdf_redo(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_redo()\n";
	}
	#endif
	mupdf::ll_pdf_redo(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_remove_item()`.  */
FZ_FUNCTION void pdf_remove_item(::fz_store_drop_fn *drop, const PdfObj& key)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_remove_item()\n";
	}
	#endif
	mupdf::ll_pdf_remove_item(drop, key.m_internal);
}


/* Class-aware wrapper for `::pdf_repair_obj()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_repair_obj(::pdf_document *doc, ::pdf_lexbuf *buf, ::pdf_obj **encrypt, ::pdf_obj **id, ::pdf_obj **page, ::pdf_obj **root)` => `(int, int64_t stmofsp, int64_t stmlenp, int64_t tmpofs)`
	 */
FZ_FUNCTION int pdf_repair_obj(const PdfDocument& doc, const PdfLexbuf& buf, int64_t *stmofsp, int64_t *stmlenp, PdfObj& encrypt, PdfObj& id, PdfObj& page, int64_t *tmpofs, PdfObj& root)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_repair_obj()\n";
	}
	#endif
	/* Out-param encrypt.m_internal will be overwritten. */
	ll_pdf_drop_obj(encrypt.m_internal);
	encrypt.m_internal = nullptr;
	/* Out-param id.m_internal will be overwritten. */
	ll_pdf_drop_obj(id.m_internal);
	id.m_internal = nullptr;
	/* Out-param page.m_internal will be overwritten. */
	ll_pdf_drop_obj(page.m_internal);
	page.m_internal = nullptr;
	/* Out-param root.m_internal will be overwritten. */
	ll_pdf_drop_obj(root.m_internal);
	root.m_internal = nullptr;
	auto ret = mupdf::ll_pdf_repair_obj(doc.m_internal, buf.m_internal, stmofsp, stmlenp, &encrypt.m_internal, &id.m_internal, &page.m_internal, tmpofs, &root.m_internal);
	/* We assume that out-param encrypt.m_internal is a borrowed reference. */
	ll_pdf_keep_obj(encrypt.m_internal);
	/* We assume that out-param id.m_internal is a borrowed reference. */
	ll_pdf_keep_obj(id.m_internal);
	/* We assume that out-param page.m_internal is a borrowed reference. */
	ll_pdf_keep_obj(page.m_internal);
	/* We assume that out-param root.m_internal is a borrowed reference. */
	ll_pdf_keep_obj(root.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_repair_obj_stms()`.  */
FZ_FUNCTION void pdf_repair_obj_stms(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_repair_obj_stms()\n";
	}
	#endif
	mupdf::ll_pdf_repair_obj_stms(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_repair_trailer()`.  */
FZ_FUNCTION void pdf_repair_trailer(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_repair_trailer()\n";
	}
	#endif
	mupdf::ll_pdf_repair_trailer(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_repair_xref()`.  */
FZ_FUNCTION void pdf_repair_xref(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_repair_xref()\n";
	}
	#endif
	mupdf::ll_pdf_repair_xref(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_replace_xref()`.  */
FZ_FUNCTION void pdf_replace_xref(const PdfDocument& doc, const PdfXrefEntry& entries, int n)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_replace_xref()\n";
	}
	#endif
	mupdf::ll_pdf_replace_xref(doc.m_internal, entries.m_internal, n);
}


/* Class-aware wrapper for `::pdf_reset_form()`.  */
FZ_FUNCTION void pdf_reset_form(const PdfDocument& doc, const PdfObj& fields, int exclude)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_reset_form()\n";
	}
	#endif
	mupdf::ll_pdf_reset_form(doc.m_internal, fields.m_internal, exclude);
}


/* Class-aware wrapper for `::pdf_reset_processor()`.  */
FZ_FUNCTION void pdf_reset_processor(const PdfProcessor& proc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_reset_processor()\n";
	}
	#endif
	mupdf::ll_pdf_reset_processor(proc.m_internal);
}


/* Class-aware wrapper for `::pdf_resolve_indirect()`.  */
FZ_FUNCTION PdfObj pdf_resolve_indirect(const PdfObj& ref)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_resolve_indirect()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_resolve_indirect(ref.m_internal);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_resolve_indirect_chain()`.  */
FZ_FUNCTION PdfObj pdf_resolve_indirect_chain(const PdfObj& ref)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_resolve_indirect_chain()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_resolve_indirect_chain(ref.m_internal);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_resolve_link()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_resolve_link(::pdf_document *doc, const char *uri)` => `(int, float xp, float yp)`
	 */
FZ_FUNCTION int pdf_resolve_link(const PdfDocument& doc, const char *uri, float *xp, float *yp)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_resolve_link()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_resolve_link(doc.m_internal, uri, xp, yp);
	return ret;
}


/* Class-aware wrapper for `::pdf_rewrite_images()`.  */
FZ_FUNCTION void pdf_rewrite_images(const PdfDocument& doc, PdfImageRewriterOptions& opts)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_rewrite_images()\n";
	}
	#endif
	mupdf::ll_pdf_rewrite_images(doc.m_internal,  opts.internal());
}


/* Class-aware wrapper for `::pdf_run_annot()`.  */
FZ_FUNCTION void pdf_run_annot(const PdfAnnot& annot, const FzDevice& dev, const FzMatrix& ctm, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_annot()\n";
	}
	#endif
	mupdf::ll_pdf_run_annot(annot.m_internal, dev.m_internal, * ctm.internal(), &cookie.m_internal);
}


/* Class-aware wrapper for `::pdf_run_document_structure()`.  */
FZ_FUNCTION void pdf_run_document_structure(const PdfDocument& doc, const FzDevice& dev, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_document_structure()\n";
	}
	#endif
	mupdf::ll_pdf_run_document_structure(doc.m_internal, dev.m_internal, &cookie.m_internal);
}


/* Class-aware wrapper for `::pdf_run_glyph()`.  */
FZ_FUNCTION void pdf_run_glyph(const PdfDocument& doc, const PdfObj& resources, const FzBuffer& contents, const FzDevice& dev, const FzMatrix& ctm, void *gstate, const FzDefaultColorspaces& default_cs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_glyph()\n";
	}
	#endif
	mupdf::ll_pdf_run_glyph(doc.m_internal, resources.m_internal, contents.m_internal, dev.m_internal, * ctm.internal(), gstate, default_cs.m_internal);
}


/* Class-aware wrapper for `::pdf_run_page()`.  */
FZ_FUNCTION void pdf_run_page(const PdfPage& page, const FzDevice& dev, const FzMatrix& ctm, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_page()\n";
	}
	#endif
	mupdf::ll_pdf_run_page(page.m_internal, dev.m_internal, * ctm.internal(), &cookie.m_internal);
}


/* Class-aware wrapper for `::pdf_run_page_annots()`.  */
FZ_FUNCTION void pdf_run_page_annots(const PdfPage& page, const FzDevice& dev, const FzMatrix& ctm, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_page_annots()\n";
	}
	#endif
	mupdf::ll_pdf_run_page_annots(page.m_internal, dev.m_internal, * ctm.internal(), &cookie.m_internal);
}


/* Class-aware wrapper for `::pdf_run_page_annots_with_usage()`.  */
FZ_FUNCTION void pdf_run_page_annots_with_usage(const PdfPage& page, const FzDevice& dev, const FzMatrix& ctm, const char *usage, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_page_annots_with_usage()\n";
	}
	#endif
	mupdf::ll_pdf_run_page_annots_with_usage(page.m_internal, dev.m_internal, * ctm.internal(), usage, &cookie.m_internal);
}


/* Class-aware wrapper for `::pdf_run_page_contents()`.  */
FZ_FUNCTION void pdf_run_page_contents(const PdfPage& page, const FzDevice& dev, const FzMatrix& ctm, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_page_contents()\n";
	}
	#endif
	mupdf::ll_pdf_run_page_contents(page.m_internal, dev.m_internal, * ctm.internal(), &cookie.m_internal);
}


/* Class-aware wrapper for `::pdf_run_page_contents_with_usage()`.  */
FZ_FUNCTION void pdf_run_page_contents_with_usage(const PdfPage& page, const FzDevice& dev, const FzMatrix& ctm, const char *usage, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_page_contents_with_usage()\n";
	}
	#endif
	mupdf::ll_pdf_run_page_contents_with_usage(page.m_internal, dev.m_internal, * ctm.internal(), usage, &cookie.m_internal);
}


/* Class-aware wrapper for `::pdf_run_page_widgets()`.  */
FZ_FUNCTION void pdf_run_page_widgets(const PdfPage& page, const FzDevice& dev, const FzMatrix& ctm, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_page_widgets()\n";
	}
	#endif
	mupdf::ll_pdf_run_page_widgets(page.m_internal, dev.m_internal, * ctm.internal(), &cookie.m_internal);
}


/* Class-aware wrapper for `::pdf_run_page_widgets_with_usage()`.  */
FZ_FUNCTION void pdf_run_page_widgets_with_usage(const PdfPage& page, const FzDevice& dev, const FzMatrix& ctm, const char *usage, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_page_widgets_with_usage()\n";
	}
	#endif
	mupdf::ll_pdf_run_page_widgets_with_usage(page.m_internal, dev.m_internal, * ctm.internal(), usage, &cookie.m_internal);
}


/* Class-aware wrapper for `::pdf_run_page_with_usage()`.  */
FZ_FUNCTION void pdf_run_page_with_usage(const PdfPage& page, const FzDevice& dev, const FzMatrix& ctm, const char *usage, FzCookie& cookie)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_run_page_with_usage()\n";
	}
	#endif
	mupdf::ll_pdf_run_page_with_usage(page.m_internal, dev.m_internal, * ctm.internal(), usage, &cookie.m_internal);
}


/* Class-aware wrapper for `::pdf_sample_shade_function()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_sample_shade_function(float shade[256][33], int n, int funcs, ::pdf_function **func, float t0, float t1)` => 
	 */
FZ_FUNCTION void pdf_sample_shade_function(float shade[256][33], int n, int funcs, PdfFunction& func, float t0, float t1)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_sample_shade_function()\n";
	}
	#endif
	/* Out-param func.m_internal will be overwritten. */
	ll_pdf_drop_function(func.m_internal);
	func.m_internal = nullptr;
	mupdf::ll_pdf_sample_shade_function(shade, n, funcs, &func.m_internal, t0, t1);
	/* We assume that out-param func.m_internal is a borrowed reference. */
	ll_pdf_keep_function(func.m_internal);
}


/* Class-aware wrapper for `::pdf_save_document()`.  */
FZ_FUNCTION void pdf_save_document(const PdfDocument& doc, const char *filename, PdfWriteOptions& opts)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_save_document()\n";
	}
	#endif
	mupdf::ll_pdf_save_document(doc.m_internal, filename,  opts.internal());
}


/* Class-aware wrapper for `::pdf_save_journal()`.  */
FZ_FUNCTION void pdf_save_journal(const PdfDocument& doc, const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_save_journal()\n";
	}
	#endif
	mupdf::ll_pdf_save_journal(doc.m_internal, filename);
}


/* Class-aware wrapper for `::pdf_save_snapshot()`.  */
FZ_FUNCTION void pdf_save_snapshot(const PdfDocument& doc, const char *filename)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_save_snapshot()\n";
	}
	#endif
	mupdf::ll_pdf_save_snapshot(doc.m_internal, filename);
}


/* Class-aware wrapper for `::pdf_select_layer_config()`.  */
FZ_FUNCTION void pdf_select_layer_config(const PdfDocument& doc, int config_num)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_select_layer_config()\n";
	}
	#endif
	mupdf::ll_pdf_select_layer_config(doc.m_internal, config_num);
}


/* Class-aware wrapper for `::pdf_select_layer_config_ui()`.  */
FZ_FUNCTION void pdf_select_layer_config_ui(const PdfDocument& doc, int ui)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_select_layer_config_ui()\n";
	}
	#endif
	mupdf::ll_pdf_select_layer_config_ui(doc.m_internal, ui);
}


/* Class-aware wrapper for `::pdf_serialise_journal()`.  */
FZ_FUNCTION void pdf_serialise_journal(const PdfDocument& doc, const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_serialise_journal()\n";
	}
	#endif
	mupdf::ll_pdf_serialise_journal(doc.m_internal, out.m_internal);
}


/* Class-aware wrapper for `::pdf_set_annot_active()`.  */
FZ_FUNCTION void pdf_set_annot_active(const PdfAnnot& annot, int active)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_active()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_active(annot.m_internal, active);
}


/* Class-aware wrapper for `::pdf_set_annot_appearance()`.  */
FZ_FUNCTION void pdf_set_annot_appearance(const PdfAnnot& annot, const char *appearance, const char *state, const FzMatrix& ctm, const FzRect& bbox, const PdfObj& res, const FzBuffer& contents)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_appearance()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_appearance(annot.m_internal, appearance, state, * ctm.internal(), * bbox.internal(), res.m_internal, contents.m_internal);
}


/* Class-aware wrapper for `::pdf_set_annot_appearance_from_display_list()`.  */
FZ_FUNCTION void pdf_set_annot_appearance_from_display_list(const PdfAnnot& annot, const char *appearance, const char *state, const FzMatrix& ctm, const FzDisplayList& list)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_appearance_from_display_list()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_appearance_from_display_list(annot.m_internal, appearance, state, * ctm.internal(), list.m_internal);
}


/* Class-aware wrapper for `::pdf_set_annot_author()`.  */
FZ_FUNCTION void pdf_set_annot_author(const PdfAnnot& annot, const char *author)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_author()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_author(annot.m_internal, author);
}


/* Class-aware wrapper for `::pdf_set_annot_border()`.  */
FZ_FUNCTION void pdf_set_annot_border(const PdfAnnot& annot, float width)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_border()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_border(annot.m_internal, width);
}


/* Class-aware wrapper for `::pdf_set_annot_border_effect()`.  */
FZ_FUNCTION void pdf_set_annot_border_effect(const PdfAnnot& annot, enum pdf_border_effect effect)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_border_effect()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_border_effect(annot.m_internal, effect);
}


/* Class-aware wrapper for `::pdf_set_annot_border_effect_intensity()`.  */
FZ_FUNCTION void pdf_set_annot_border_effect_intensity(const PdfAnnot& annot, float intensity)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_border_effect_intensity()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_border_effect_intensity(annot.m_internal, intensity);
}


/* Class-aware wrapper for `::pdf_set_annot_border_style()`.  */
FZ_FUNCTION void pdf_set_annot_border_style(const PdfAnnot& annot, enum pdf_border_style style)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_border_style()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_border_style(annot.m_internal, style);
}


/* Class-aware wrapper for `::pdf_set_annot_border_width()`.  */
FZ_FUNCTION void pdf_set_annot_border_width(const PdfAnnot& annot, float width)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_border_width()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_border_width(annot.m_internal, width);
}


/* Class-aware wrapper for `::pdf_set_annot_color()`.  */
FZ_FUNCTION void pdf_set_annot_color(const PdfAnnot& annot, int n, const float *color)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_color()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_color(annot.m_internal, n, color);
}


/* Class-aware wrapper for `::pdf_set_annot_contents()`.  */
FZ_FUNCTION void pdf_set_annot_contents(const PdfAnnot& annot, const char *text)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_contents()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_contents(annot.m_internal, text);
}


/* Class-aware wrapper for `::pdf_set_annot_creation_date()`.  */
FZ_FUNCTION void pdf_set_annot_creation_date(const PdfAnnot& annot, int64_t time)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_creation_date()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_creation_date(annot.m_internal, time);
}


/* Class-aware wrapper for `::pdf_set_annot_default_appearance()`.  */
FZ_FUNCTION void pdf_set_annot_default_appearance(const PdfAnnot& annot, const char *font, float size, int n, const float *color)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_default_appearance()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_default_appearance(annot.m_internal, font, size, n, color);
}


/* Class-aware wrapper for `::pdf_set_annot_field_value()`.  */
FZ_FUNCTION int pdf_set_annot_field_value(const PdfDocument& doc, const PdfAnnot& widget, const char *text, int ignore_trigger_events)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_field_value()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_set_annot_field_value(doc.m_internal, widget.m_internal, text, ignore_trigger_events);
	return ret;
}


/* Class-aware wrapper for `::pdf_set_annot_filespec()`.  */
FZ_FUNCTION void pdf_set_annot_filespec(const PdfAnnot& annot, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_filespec()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_filespec(annot.m_internal, obj.m_internal);
}


/* Class-aware wrapper for `::pdf_set_annot_flags()`.  */
FZ_FUNCTION void pdf_set_annot_flags(const PdfAnnot& annot, int flags)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_flags()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_flags(annot.m_internal, flags);
}


/* Class-aware wrapper for `::pdf_set_annot_hidden_for_editing()`.  */
FZ_FUNCTION void pdf_set_annot_hidden_for_editing(const PdfAnnot& annot, int hidden)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_hidden_for_editing()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_hidden_for_editing(annot.m_internal, hidden);
}


/* Class-aware wrapper for `::pdf_set_annot_hot()`.  */
FZ_FUNCTION void pdf_set_annot_hot(const PdfAnnot& annot, int hot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_hot()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_hot(annot.m_internal, hot);
}


/* Class-aware wrapper for `::pdf_set_annot_icon_name()`.  */
FZ_FUNCTION void pdf_set_annot_icon_name(const PdfAnnot& annot, const char *name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_icon_name()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_icon_name(annot.m_internal, name);
}


/* Class-aware wrapper for `::pdf_set_annot_ink_list()`.  */
FZ_FUNCTION void pdf_set_annot_ink_list(const PdfAnnot& annot, int n, const int *count, FzPoint& v)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_ink_list()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_ink_list(annot.m_internal, n, count,  v.internal());
}


/* Class-aware wrapper for `::pdf_set_annot_intent()`.  */
FZ_FUNCTION void pdf_set_annot_intent(const PdfAnnot& annot, enum pdf_intent it)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_intent()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_intent(annot.m_internal, it);
}


/* Class-aware wrapper for `::pdf_set_annot_interior_color()`.  */
FZ_FUNCTION void pdf_set_annot_interior_color(const PdfAnnot& annot, int n, const float *color)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_interior_color()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_interior_color(annot.m_internal, n, color);
}


/* Class-aware wrapper for `::pdf_set_annot_is_open()`.  */
FZ_FUNCTION void pdf_set_annot_is_open(const PdfAnnot& annot, int is_open)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_is_open()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_is_open(annot.m_internal, is_open);
}


/* Class-aware wrapper for `::pdf_set_annot_language()`.  */
FZ_FUNCTION void pdf_set_annot_language(const PdfAnnot& annot, ::fz_text_language lang)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_language()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_language(annot.m_internal, lang);
}


/* Class-aware wrapper for `::pdf_set_annot_line()`.  */
FZ_FUNCTION void pdf_set_annot_line(const PdfAnnot& annot, const FzPoint& a, const FzPoint& b)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_line()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_line(annot.m_internal, * a.internal(), * b.internal());
}


/* Class-aware wrapper for `::pdf_set_annot_line_end_style()`.  */
FZ_FUNCTION void pdf_set_annot_line_end_style(const PdfAnnot& annot, enum pdf_line_ending e)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_line_end_style()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_line_end_style(annot.m_internal, e);
}


/* Class-aware wrapper for `::pdf_set_annot_line_ending_styles()`.  */
FZ_FUNCTION void pdf_set_annot_line_ending_styles(const PdfAnnot& annot, enum pdf_line_ending start_style, enum pdf_line_ending end_style)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_line_ending_styles()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_line_ending_styles(annot.m_internal, start_style, end_style);
}


/* Class-aware wrapper for `::pdf_set_annot_line_start_style()`.  */
FZ_FUNCTION void pdf_set_annot_line_start_style(const PdfAnnot& annot, enum pdf_line_ending s)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_line_start_style()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_line_start_style(annot.m_internal, s);
}


/* Class-aware wrapper for `::pdf_set_annot_modification_date()`.  */
FZ_FUNCTION void pdf_set_annot_modification_date(const PdfAnnot& annot, int64_t time)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_modification_date()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_modification_date(annot.m_internal, time);
}


/* Class-aware wrapper for `::pdf_set_annot_opacity()`.  */
FZ_FUNCTION void pdf_set_annot_opacity(const PdfAnnot& annot, float opacity)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_opacity()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_opacity(annot.m_internal, opacity);
}


/* Class-aware wrapper for `::pdf_set_annot_popup()`.  */
FZ_FUNCTION void pdf_set_annot_popup(const PdfAnnot& annot, const FzRect& rect)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_popup()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_popup(annot.m_internal, * rect.internal());
}


/* Class-aware wrapper for `::pdf_set_annot_quad_points()`.  */
FZ_FUNCTION void pdf_set_annot_quad_points(const PdfAnnot& annot, int n, FzQuad& qv)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_quad_points()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_quad_points(annot.m_internal, n,  qv.internal());
}


/* Class-aware wrapper for `::pdf_set_annot_quadding()`.  */
FZ_FUNCTION void pdf_set_annot_quadding(const PdfAnnot& annot, int q)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_quadding()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_quadding(annot.m_internal, q);
}


/* Class-aware wrapper for `::pdf_set_annot_rect()`.  */
FZ_FUNCTION void pdf_set_annot_rect(const PdfAnnot& annot, const FzRect& rect)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_rect()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_rect(annot.m_internal, * rect.internal());
}


/* Class-aware wrapper for `::pdf_set_annot_resynthesised()`.  */
FZ_FUNCTION void pdf_set_annot_resynthesised(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_resynthesised()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_resynthesised(annot.m_internal);
}


/* Class-aware wrapper for `::pdf_set_annot_stamp_image()`.  */
FZ_FUNCTION void pdf_set_annot_stamp_image(const PdfAnnot& annot, const FzImage& image)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_stamp_image()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_stamp_image(annot.m_internal, image.m_internal);
}


/* Class-aware wrapper for `::pdf_set_annot_vertex()`.  */
FZ_FUNCTION void pdf_set_annot_vertex(const PdfAnnot& annot, int i, const FzPoint& p)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_vertex()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_vertex(annot.m_internal, i, * p.internal());
}


/* Class-aware wrapper for `::pdf_set_annot_vertices()`.  */
FZ_FUNCTION void pdf_set_annot_vertices(const PdfAnnot& annot, int n, FzPoint& v)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_annot_vertices()\n";
	}
	#endif
	mupdf::ll_pdf_set_annot_vertices(annot.m_internal, n,  v.internal());
}


/* Class-aware wrapper for `::pdf_set_choice_field_value()`.  */
FZ_FUNCTION int pdf_set_choice_field_value(const PdfAnnot& widget, const char *value)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_choice_field_value()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_set_choice_field_value(widget.m_internal, value);
	return ret;
}


/* Class-aware wrapper for `::pdf_set_cmap_wmode()`.  */
FZ_FUNCTION void pdf_set_cmap_wmode(const PdfCmap& cmap, int wmode)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_cmap_wmode()\n";
	}
	#endif
	mupdf::ll_pdf_set_cmap_wmode(cmap.m_internal, wmode);
}


/* Class-aware wrapper for `::pdf_set_default_hmtx()`.  */
FZ_FUNCTION void pdf_set_default_hmtx(const PdfFontDesc& font, int w)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_default_hmtx()\n";
	}
	#endif
	mupdf::ll_pdf_set_default_hmtx(font.m_internal, w);
}


/* Class-aware wrapper for `::pdf_set_default_vmtx()`.  */
FZ_FUNCTION void pdf_set_default_vmtx(const PdfFontDesc& font, int y, int w)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_default_vmtx()\n";
	}
	#endif
	mupdf::ll_pdf_set_default_vmtx(font.m_internal, y, w);
}


/* Class-aware wrapper for `::pdf_set_doc_event_callback()`.  */
FZ_FUNCTION void pdf_set_doc_event_callback(const PdfDocument& doc, ::pdf_doc_event_cb *event_cb, ::pdf_free_doc_event_data_cb *free_event_data_cb, void *data)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_doc_event_callback()\n";
	}
	#endif
	mupdf::ll_pdf_set_doc_event_callback(doc.m_internal, event_cb, free_event_data_cb, data);
}


/* Class-aware wrapper for `::pdf_set_document_language()`.  */
FZ_FUNCTION void pdf_set_document_language(const PdfDocument& doc, ::fz_text_language lang)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_document_language()\n";
	}
	#endif
	mupdf::ll_pdf_set_document_language(doc.m_internal, lang);
}


/* Class-aware wrapper for `::pdf_set_field_value()`.  */
FZ_FUNCTION int pdf_set_field_value(const PdfDocument& doc, const PdfObj& field, const char *text, int ignore_trigger_events)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_field_value()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_set_field_value(doc.m_internal, field.m_internal, text, ignore_trigger_events);
	return ret;
}


/* Class-aware wrapper for `::pdf_set_font_wmode()`.  */
FZ_FUNCTION void pdf_set_font_wmode(const PdfFontDesc& font, int wmode)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_font_wmode()\n";
	}
	#endif
	mupdf::ll_pdf_set_font_wmode(font.m_internal, wmode);
}


/* Class-aware wrapper for `::pdf_set_int()`.  */
FZ_FUNCTION void pdf_set_int(const PdfObj& obj, int64_t i)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_int()\n";
	}
	#endif
	mupdf::ll_pdf_set_int(obj.m_internal, i);
}


/* Class-aware wrapper for `::pdf_set_layer_config_as_default()`.  */
FZ_FUNCTION void pdf_set_layer_config_as_default(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_layer_config_as_default()\n";
	}
	#endif
	mupdf::ll_pdf_set_layer_config_as_default(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_set_obj_memo()`.  */
FZ_FUNCTION void pdf_set_obj_memo(const PdfObj& obj, int bit, int memo)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_obj_memo()\n";
	}
	#endif
	mupdf::ll_pdf_set_obj_memo(obj.m_internal, bit, memo);
}


/* Class-aware wrapper for `::pdf_set_obj_parent()`.  */
FZ_FUNCTION void pdf_set_obj_parent(const PdfObj& obj, int num)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_obj_parent()\n";
	}
	#endif
	mupdf::ll_pdf_set_obj_parent(obj.m_internal, num);
}


/* Class-aware wrapper for `::pdf_set_page_box()`.  */
FZ_FUNCTION void pdf_set_page_box(const PdfPage& page, ::fz_box_type box, const FzRect& rect)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_page_box()\n";
	}
	#endif
	mupdf::ll_pdf_set_page_box(page.m_internal, box, * rect.internal());
}


/* Class-aware wrapper for `::pdf_set_page_labels()`.  */
FZ_FUNCTION void pdf_set_page_labels(const PdfDocument& doc, int index, ::pdf_page_label_style style, const char *prefix, int start)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_page_labels()\n";
	}
	#endif
	mupdf::ll_pdf_set_page_labels(doc.m_internal, index, style, prefix, start);
}


/* Class-aware wrapper for `::pdf_set_populating_xref_trailer()`.  */
FZ_FUNCTION void pdf_set_populating_xref_trailer(const PdfDocument& doc, const PdfObj& trailer)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_populating_xref_trailer()\n";
	}
	#endif
	mupdf::ll_pdf_set_populating_xref_trailer(doc.m_internal, trailer.m_internal);
}


/* Class-aware wrapper for `::pdf_set_str_len()`.  */
FZ_FUNCTION void pdf_set_str_len(const PdfObj& obj, size_t newlen)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_str_len()\n";
	}
	#endif
	mupdf::ll_pdf_set_str_len(obj.m_internal, newlen);
}


/* Class-aware wrapper for `::pdf_set_text_field_value()`.  */
FZ_FUNCTION int pdf_set_text_field_value(const PdfAnnot& widget, const char *value)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_text_field_value()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_set_text_field_value(widget.m_internal, value);
	return ret;
}


/* Class-aware wrapper for `::pdf_set_usecmap()`.  */
FZ_FUNCTION void pdf_set_usecmap(const PdfCmap& cmap, const PdfCmap& usecmap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_usecmap()\n";
	}
	#endif
	mupdf::ll_pdf_set_usecmap(cmap.m_internal, usecmap.m_internal);
}


/* Class-aware wrapper for `::pdf_set_widget_editing_state()`.  */
FZ_FUNCTION void pdf_set_widget_editing_state(const PdfAnnot& widget, int editing)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_set_widget_editing_state()\n";
	}
	#endif
	mupdf::ll_pdf_set_widget_editing_state(widget.m_internal, editing);
}


/* Class-aware wrapper for `::pdf_sign_signature()`.  */
FZ_FUNCTION void pdf_sign_signature(const PdfAnnot& widget, const PdfPkcs7Signer& signer, int appearance_flags, const FzImage& graphic, const char *reason, const char *location)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_sign_signature()\n";
	}
	#endif
	mupdf::ll_pdf_sign_signature(widget.m_internal, signer.m_internal, appearance_flags, graphic.m_internal, reason, location);
}


/* Class-aware wrapper for `::pdf_sign_signature_with_appearance()`.  */
FZ_FUNCTION void pdf_sign_signature_with_appearance(const PdfAnnot& widget, const PdfPkcs7Signer& signer, int64_t date, const FzDisplayList& disp_list)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_sign_signature_with_appearance()\n";
	}
	#endif
	mupdf::ll_pdf_sign_signature_with_appearance(widget.m_internal, signer.m_internal, date, disp_list.m_internal);
}


/* Class-aware wrapper for `::pdf_signature_appearance_signed()`.  */
FZ_FUNCTION FzDisplayList pdf_signature_appearance_signed(const FzRect& rect, ::fz_text_language lang, const FzImage& img, const char *left_text, const char *right_text, int include_logo)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_appearance_signed()\n";
	}
	#endif
	::fz_display_list* temp = mupdf::ll_pdf_signature_appearance_signed(* rect.internal(), lang, img.m_internal, left_text, right_text, include_logo);
	ll_fz_keep_display_list(temp);
	auto ret = FzDisplayList(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_signature_appearance_unsigned()`.  */
FZ_FUNCTION FzDisplayList pdf_signature_appearance_unsigned(const FzRect& rect, ::fz_text_language lang)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_appearance_unsigned()\n";
	}
	#endif
	::fz_display_list* temp = mupdf::ll_pdf_signature_appearance_unsigned(* rect.internal(), lang);
	ll_fz_keep_display_list(temp);
	auto ret = FzDisplayList(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_signature_byte_range()`.  */
FZ_FUNCTION int pdf_signature_byte_range(const PdfDocument& doc, const PdfObj& signature, const FzRange& byte_range)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_byte_range()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_signature_byte_range(doc.m_internal, signature.m_internal, byte_range.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_signature_contents()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_signature_contents(::pdf_document *doc, ::pdf_obj *signature)` => `(size_t, char *contents)`
	 */
FZ_FUNCTION size_t pdf_signature_contents(const PdfDocument& doc, const PdfObj& signature, char **contents)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_contents()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_signature_contents(doc.m_internal, signature.m_internal, contents);
	return ret;
}


/* Class-aware wrapper for `::pdf_signature_drop_distinguished_name()`.  */
FZ_FUNCTION void pdf_signature_drop_distinguished_name(const PdfPkcs7DistinguishedName& name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_drop_distinguished_name()\n";
	}
	#endif
	mupdf::ll_pdf_signature_drop_distinguished_name(name.m_internal);
}


/* Class-aware wrapper for `::pdf_signature_error_description()`.  */
FZ_FUNCTION char *pdf_signature_error_description(::pdf_signature_error err)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_error_description()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_signature_error_description(err);
	return ret;
}


/* Class-aware wrapper for `::pdf_signature_format_distinguished_name()`.  */
FZ_FUNCTION char *pdf_signature_format_distinguished_name(const PdfPkcs7DistinguishedName& name)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_format_distinguished_name()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_signature_format_distinguished_name(name.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_signature_hash_bytes()`.  */
FZ_FUNCTION FzStream pdf_signature_hash_bytes(const PdfDocument& doc, const PdfObj& signature)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_hash_bytes()\n";
	}
	#endif
	::fz_stream* temp = mupdf::ll_pdf_signature_hash_bytes(doc.m_internal, signature.m_internal);
	ll_fz_keep_stream(temp);
	auto ret = FzStream(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_signature_incremental_change_since_signing()`.  */
FZ_FUNCTION int pdf_signature_incremental_change_since_signing(const PdfDocument& doc, const PdfObj& signature)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_incremental_change_since_signing()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_signature_incremental_change_since_signing(doc.m_internal, signature.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_signature_info()`.  */
FZ_FUNCTION char *pdf_signature_info(const char *name, const PdfPkcs7DistinguishedName& dn, const char *reason, const char *location, int64_t date, int include_labels)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_info()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_signature_info(name, dn.m_internal, reason, location, date, include_labels);
	return ret;
}


/* Class-aware wrapper for `::pdf_signature_is_signed()`.  */
FZ_FUNCTION int pdf_signature_is_signed(const PdfDocument& doc, const PdfObj& field)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_is_signed()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_signature_is_signed(doc.m_internal, field.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_signature_set_value()`.  */
FZ_FUNCTION void pdf_signature_set_value(const PdfDocument& doc, const PdfObj& field, const PdfPkcs7Signer& signer, int64_t stime)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_signature_set_value()\n";
	}
	#endif
	mupdf::ll_pdf_signature_set_value(doc.m_internal, field.m_internal, signer.m_internal, stime);
}


/* Class-aware wrapper for `::pdf_sort_cmap()`.  */
FZ_FUNCTION void pdf_sort_cmap(const PdfCmap& cmap)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_sort_cmap()\n";
	}
	#endif
	mupdf::ll_pdf_sort_cmap(cmap.m_internal);
}


/* Class-aware wrapper for `::pdf_sort_dict()`.  */
FZ_FUNCTION void pdf_sort_dict(const PdfObj& dict)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_sort_dict()\n";
	}
	#endif
	mupdf::ll_pdf_sort_dict(dict.m_internal);
}


/* Class-aware wrapper for `::pdf_specifics()`.  */
FZ_FUNCTION PdfDocument pdf_specifics(const FzDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_specifics()\n";
	}
	#endif
	::pdf_document* temp = mupdf::ll_pdf_specifics(doc.m_internal);
	ll_pdf_keep_document(temp);
	auto ret = PdfDocument(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_sprint_obj()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_sprint_obj(char *buf, size_t cap, ::pdf_obj *obj, int tight, int ascii)` => `(char *, size_t len)`
	 */
FZ_FUNCTION char *pdf_sprint_obj(char *buf, size_t cap, size_t *len, const PdfObj& obj, int tight, int ascii)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_sprint_obj()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_sprint_obj(buf, cap, len, obj.m_internal, tight, ascii);
	return ret;
}


/* Class-aware wrapper for `::pdf_store_item()`.  */
FZ_FUNCTION void pdf_store_item(const PdfObj& key, void *val, size_t itemsize)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_store_item()\n";
	}
	#endif
	mupdf::ll_pdf_store_item(key.m_internal, val, itemsize);
}


/* Class-aware wrapper for `::pdf_string_from_annot_type()`.  */
FZ_FUNCTION const char *pdf_string_from_annot_type(enum pdf_annot_type type)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_string_from_annot_type()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_string_from_annot_type(type);
	return ret;
}


/* Class-aware wrapper for `::pdf_string_from_intent()`.  */
FZ_FUNCTION const char *pdf_string_from_intent(enum pdf_intent intent)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_string_from_intent()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_string_from_intent(intent);
	return ret;
}


/* Class-aware wrapper for `::pdf_string_from_line_ending()`.  */
FZ_FUNCTION const char *pdf_string_from_line_ending(enum pdf_line_ending end)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_string_from_line_ending()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_string_from_line_ending(end);
	return ret;
}


/* Class-aware wrapper for `::pdf_structure_type()`.  */
FZ_FUNCTION ::fz_structure pdf_structure_type(const PdfObj& role_map, const PdfObj& tag)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_structure_type()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_structure_type(role_map.m_internal, tag.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_subset_fonts()`.  */
FZ_FUNCTION void pdf_subset_fonts(const PdfDocument& doc, int pages_len, const int *pages)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_subset_fonts()\n";
	}
	#endif
	mupdf::ll_pdf_subset_fonts(doc.m_internal, pages_len, pages);
}


/* Class-aware wrapper for `::pdf_subset_fonts2()`.  */
FZ_FUNCTION void pdf_subset_fonts2(const PdfDocument& doc, const std::vector<int> &pages)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_subset_fonts2()\n";
	}
	#endif
	mupdf::ll_pdf_subset_fonts2(doc.m_internal, pages);
}


/* Class-aware wrapper for `::pdf_text_widget_format()`.  */
FZ_FUNCTION int pdf_text_widget_format(const PdfAnnot& tw)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_text_widget_format()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_text_widget_format(tw.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_text_widget_max_len()`.  */
FZ_FUNCTION int pdf_text_widget_max_len(const PdfAnnot& tw)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_text_widget_max_len()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_text_widget_max_len(tw.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_to_bool()`.  */
FZ_FUNCTION int pdf_to_bool(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_bool()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_to_bool(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_to_bool_default()`.  */
FZ_FUNCTION int pdf_to_bool_default(const PdfObj& obj, int def)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_bool_default()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_to_bool_default(obj.m_internal, def);
	return ret;
}


/* Class-aware wrapper for `::pdf_to_date()`.  */
FZ_FUNCTION int64_t pdf_to_date(const PdfObj& time)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_date()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_to_date(time.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_to_gen()`.  */
FZ_FUNCTION int pdf_to_gen(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_gen()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_to_gen(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_to_int()`.  */
FZ_FUNCTION int pdf_to_int(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_int()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_to_int(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_to_int64()`.  */
FZ_FUNCTION int64_t pdf_to_int64(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_int64()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_to_int64(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_to_int_default()`.  */
FZ_FUNCTION int pdf_to_int_default(const PdfObj& obj, int def)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_int_default()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_to_int_default(obj.m_internal, def);
	return ret;
}


/* Class-aware wrapper for `::pdf_to_matrix()`.  */
FZ_FUNCTION FzMatrix pdf_to_matrix(const PdfObj& array)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_matrix()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_pdf_to_matrix(array.m_internal);
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_to_name()`.  */
FZ_FUNCTION const char *pdf_to_name(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_name()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_to_name(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_to_num()`.  */
FZ_FUNCTION int pdf_to_num(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_num()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_to_num(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_to_quad()`.  */
FZ_FUNCTION FzQuad pdf_to_quad(const PdfObj& array, int offset)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_quad()\n";
	}
	#endif
	::fz_quad temp = mupdf::ll_pdf_to_quad(array.m_internal, offset);
	auto ret = FzQuad(&temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_to_real()`.  */
FZ_FUNCTION float pdf_to_real(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_real()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_to_real(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_to_real_default()`.  */
FZ_FUNCTION float pdf_to_real_default(const PdfObj& obj, float def)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_real_default()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_to_real_default(obj.m_internal, def);
	return ret;
}


/* Class-aware wrapper for `::pdf_to_rect()`.  */
FZ_FUNCTION FzRect pdf_to_rect(const PdfObj& array)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_rect()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_pdf_to_rect(array.m_internal);
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_to_str_buf()`.  */
FZ_FUNCTION char *pdf_to_str_buf(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_str_buf()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_to_str_buf(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_to_str_len()`.  */
FZ_FUNCTION size_t pdf_to_str_len(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_str_len()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_to_str_len(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_to_string()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_to_string(::pdf_obj *obj)` => `(const char *, size_t sizep)`
	 */
FZ_FUNCTION const char *pdf_to_string(const PdfObj& obj, size_t *sizep)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_string()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_to_string(obj.m_internal, sizep);
	return ret;
}


/* Class-aware wrapper for `::pdf_to_text_string()`.  */
FZ_FUNCTION const char *pdf_to_text_string(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_to_text_string()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_to_text_string(obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_toggle_layer_config_ui()`.  */
FZ_FUNCTION void pdf_toggle_layer_config_ui(const PdfDocument& doc, int ui)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_toggle_layer_config_ui()\n";
	}
	#endif
	mupdf::ll_pdf_toggle_layer_config_ui(doc.m_internal, ui);
}


/* Class-aware wrapper for `::pdf_toggle_widget()`.  */
FZ_FUNCTION int pdf_toggle_widget(const PdfAnnot& widget)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_toggle_widget()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_toggle_widget(widget.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_tos_get_text()`.  */
FZ_FUNCTION FzText pdf_tos_get_text(const PdfTextObjectState& tos)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_tos_get_text()\n";
	}
	#endif
	::fz_text* temp = mupdf::ll_pdf_tos_get_text(tos.m_internal);
	ll_fz_keep_text(temp);
	auto ret = FzText(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_tos_make_trm()`.  */
FZ_FUNCTION int pdf_tos_make_trm(const PdfTextObjectState& tos, const PdfTextState& text, const PdfFontDesc& fontdesc, int cid, FzMatrix& trm)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_tos_make_trm()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_tos_make_trm(tos.m_internal, text.m_internal, fontdesc.m_internal, cid,  trm.internal());
	return ret;
}


/* Class-aware wrapper for `::pdf_tos_move_after_char()`.  */
FZ_FUNCTION void pdf_tos_move_after_char(const PdfTextObjectState& tos)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_tos_move_after_char()\n";
	}
	#endif
	mupdf::ll_pdf_tos_move_after_char(tos.m_internal);
}


/* Class-aware wrapper for `::pdf_tos_newline()`.  */
FZ_FUNCTION void pdf_tos_newline(const PdfTextObjectState& tos, float leading)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_tos_newline()\n";
	}
	#endif
	mupdf::ll_pdf_tos_newline(tos.m_internal, leading);
}


/* Class-aware wrapper for `::pdf_tos_reset()`.  */
FZ_FUNCTION void pdf_tos_reset(const PdfTextObjectState& tos, int render)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_tos_reset()\n";
	}
	#endif
	mupdf::ll_pdf_tos_reset(tos.m_internal, render);
}


/* Class-aware wrapper for `::pdf_tos_restore()`.  */
FZ_FUNCTION void pdf_tos_restore(const PdfTextObjectState& tos, ::fz_matrix save[2])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_tos_restore()\n";
	}
	#endif
	mupdf::ll_pdf_tos_restore(tos.m_internal, save);
}


/* Class-aware wrapper for `::pdf_tos_save()`.  */
FZ_FUNCTION void pdf_tos_save(const PdfTextObjectState& tos, ::fz_matrix save[2])
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_tos_save()\n";
	}
	#endif
	mupdf::ll_pdf_tos_save(tos.m_internal, save);
}


/* Class-aware wrapper for `::pdf_tos_set_matrix()`.  */
FZ_FUNCTION void pdf_tos_set_matrix(const PdfTextObjectState& tos, float a, float b, float c, float d, float e, float f)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_tos_set_matrix()\n";
	}
	#endif
	mupdf::ll_pdf_tos_set_matrix(tos.m_internal, a, b, c, d, e, f);
}


/* Class-aware wrapper for `::pdf_tos_translate()`.  */
FZ_FUNCTION void pdf_tos_translate(const PdfTextObjectState& tos, float tx, float ty)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_tos_translate()\n";
	}
	#endif
	mupdf::ll_pdf_tos_translate(tos.m_internal, tx, ty);
}


/* Class-aware wrapper for `::pdf_trailer()`.  */
FZ_FUNCTION PdfObj pdf_trailer(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_trailer()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_trailer(doc.m_internal);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_undo()`.  */
FZ_FUNCTION void pdf_undo(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_undo()\n";
	}
	#endif
	mupdf::ll_pdf_undo(doc.m_internal);
}


/* Class-aware wrapper for `::pdf_undoredo_state()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_undoredo_state(::pdf_document *doc)` => `(int, int steps)`
	 */
FZ_FUNCTION int pdf_undoredo_state(const PdfDocument& doc, int *steps)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_undoredo_state()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_undoredo_state(doc.m_internal, steps);
	return ret;
}


/* Class-aware wrapper for `::pdf_undoredo_step()`.  */
FZ_FUNCTION const char *pdf_undoredo_step(const PdfDocument& doc, int step)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_undoredo_step()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_undoredo_step(doc.m_internal, step);
	return ret;
}


/* Class-aware wrapper for `::pdf_unmark_obj()`.  */
FZ_FUNCTION void pdf_unmark_obj(const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_unmark_obj()\n";
	}
	#endif
	mupdf::ll_pdf_unmark_obj(obj.m_internal);
}


/* Class-aware wrapper for `::pdf_update_annot()`.  */
FZ_FUNCTION int pdf_update_annot(const PdfAnnot& annot)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_update_annot()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_update_annot(annot.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_update_default_colorspaces()`.  */
FZ_FUNCTION FzDefaultColorspaces pdf_update_default_colorspaces(const FzDefaultColorspaces& old_cs, const PdfObj& res)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_update_default_colorspaces()\n";
	}
	#endif
	::fz_default_colorspaces* temp = mupdf::ll_pdf_update_default_colorspaces(old_cs.m_internal, res.m_internal);
	ll_fz_keep_default_colorspaces(temp);
	auto ret = FzDefaultColorspaces(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_update_object()`.  */
FZ_FUNCTION void pdf_update_object(const PdfDocument& doc, int num, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_update_object()\n";
	}
	#endif
	mupdf::ll_pdf_update_object(doc.m_internal, num, obj.m_internal);
}


/* Class-aware wrapper for `::pdf_update_page()`.  */
FZ_FUNCTION int pdf_update_page(const PdfPage& page)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_update_page()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_update_page(page.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_update_stream()`.  */
FZ_FUNCTION void pdf_update_stream(const PdfDocument& doc, const PdfObj& ref, const FzBuffer& buf, int compressed)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_update_stream()\n";
	}
	#endif
	mupdf::ll_pdf_update_stream(doc.m_internal, ref.m_internal, buf.m_internal, compressed);
}


/* Class-aware wrapper for `::pdf_update_widget()`.  */
FZ_FUNCTION int pdf_update_widget(const PdfAnnot& widget)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_update_widget()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_update_widget(widget.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_update_xobject()`.  */
FZ_FUNCTION void pdf_update_xobject(const PdfDocument& doc, const PdfObj& xobj, const FzRect& bbox, const FzMatrix& mat, const PdfObj& res, const FzBuffer& buffer)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_update_xobject()\n";
	}
	#endif
	mupdf::ll_pdf_update_xobject(doc.m_internal, xobj.m_internal, * bbox.internal(), * mat.internal(), res.m_internal, buffer.m_internal);
}


/* Class-aware wrapper for `::pdf_validate_change_history()`.  */
FZ_FUNCTION int pdf_validate_change_history(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_validate_change_history()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_validate_change_history(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_validate_changes()`.  */
FZ_FUNCTION int pdf_validate_changes(const PdfDocument& doc, int version)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_validate_changes()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_validate_changes(doc.m_internal, version);
	return ret;
}


/* Class-aware wrapper for `::pdf_validate_signature()`.  */
FZ_FUNCTION int pdf_validate_signature(const PdfAnnot& widget)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_validate_signature()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_validate_signature(widget.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_verify_embedded_file_checksum()`.  */
FZ_FUNCTION int pdf_verify_embedded_file_checksum(const PdfObj& fs)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_verify_embedded_file_checksum()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_verify_embedded_file_checksum(fs.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_version()`.  */
FZ_FUNCTION int pdf_version(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_version()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_version(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_walk_tree()`.
	
	This function has out-params. Python/C# wrappers look like:
		`pdf_walk_tree(::pdf_obj *tree, ::pdf_obj *kid_name, void (*arrive)(::fz_context *, ::pdf_obj *, void *, ::pdf_obj **), void (*leave)(::fz_context *, ::pdf_obj *, void *), void *arg, ::pdf_obj **names, ::pdf_obj **values)` => `()`
	 */
FZ_FUNCTION void pdf_walk_tree(const PdfObj& tree, const PdfObj& kid_name, void (*arrive)(::fz_context *, ::pdf_obj *, void *, ::pdf_obj **), void (*leave)(::fz_context *, ::pdf_obj *, void *), void *arg, PdfObj& names, PdfObj& values)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_walk_tree()\n";
	}
	#endif
	/* Out-param names.m_internal will be overwritten. */
	ll_pdf_drop_obj(names.m_internal);
	names.m_internal = nullptr;
	/* Out-param values.m_internal will be overwritten. */
	ll_pdf_drop_obj(values.m_internal);
	values.m_internal = nullptr;
	mupdf::ll_pdf_walk_tree(tree.m_internal, kid_name.m_internal, arrive, leave, arg, &names.m_internal, &values.m_internal);
	/* We assume that out-param names.m_internal is a borrowed reference. */
	ll_pdf_keep_obj(names.m_internal);
	/* We assume that out-param values.m_internal is a borrowed reference. */
	ll_pdf_keep_obj(values.m_internal);
}


/* Class-aware wrapper for `::pdf_was_pure_xfa()`.  */
FZ_FUNCTION int pdf_was_pure_xfa(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_was_pure_xfa()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_was_pure_xfa(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_was_repaired()`.  */
FZ_FUNCTION int pdf_was_repaired(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_was_repaired()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_was_repaired(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_widget_is_readonly()`.  */
FZ_FUNCTION int pdf_widget_is_readonly(const PdfAnnot& widget)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_widget_is_readonly()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_widget_is_readonly(widget.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_widget_is_signed()`.  */
FZ_FUNCTION int pdf_widget_is_signed(const PdfAnnot& widget)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_widget_is_signed()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_widget_is_signed(widget.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_widget_type()`.  */
FZ_FUNCTION enum pdf_widget_type pdf_widget_type(const PdfAnnot& widget)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_widget_type()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_widget_type(widget.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_write_digest()`.  */
FZ_FUNCTION void pdf_write_digest(const FzOutput& out, const PdfObj& byte_range, const PdfObj& field, size_t digest_offset, size_t digest_length, const PdfPkcs7Signer& signer)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_write_digest()\n";
	}
	#endif
	mupdf::ll_pdf_write_digest(out.m_internal, byte_range.m_internal, field.m_internal, digest_offset, digest_length, signer.m_internal);
}


/* Class-aware wrapper for `::pdf_write_document()`.  */
FZ_FUNCTION void pdf_write_document(const PdfDocument& doc, const FzOutput& out, PdfWriteOptions& opts)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_write_document()\n";
	}
	#endif
	mupdf::ll_pdf_write_document(doc.m_internal, out.m_internal,  opts.internal());
}


/* Class-aware wrapper for `::pdf_write_journal()`.  */
FZ_FUNCTION void pdf_write_journal(const PdfDocument& doc, const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_write_journal()\n";
	}
	#endif
	mupdf::ll_pdf_write_journal(doc.m_internal, out.m_internal);
}


/* Class-aware wrapper for `::pdf_write_snapshot()`.  */
FZ_FUNCTION void pdf_write_snapshot(const PdfDocument& doc, const FzOutput& out)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_write_snapshot()\n";
	}
	#endif
	mupdf::ll_pdf_write_snapshot(doc.m_internal, out.m_internal);
}


/* Class-aware wrapper for `::pdf_xobject_bbox()`.  */
FZ_FUNCTION FzRect pdf_xobject_bbox(const PdfObj& xobj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xobject_bbox()\n";
	}
	#endif
	::fz_rect temp = mupdf::ll_pdf_xobject_bbox(xobj.m_internal);
	auto ret = FzRect(&temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_xobject_colorspace()`.  */
FZ_FUNCTION FzColorspace pdf_xobject_colorspace(const PdfObj& xobj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xobject_colorspace()\n";
	}
	#endif
	::fz_colorspace* temp = mupdf::ll_pdf_xobject_colorspace(xobj.m_internal);
	ll_fz_keep_colorspace(temp);
	auto ret = FzColorspace(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_xobject_isolated()`.  */
FZ_FUNCTION int pdf_xobject_isolated(const PdfObj& xobj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xobject_isolated()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_xobject_isolated(xobj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_xobject_knockout()`.  */
FZ_FUNCTION int pdf_xobject_knockout(const PdfObj& xobj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xobject_knockout()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_xobject_knockout(xobj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_xobject_matrix()`.  */
FZ_FUNCTION FzMatrix pdf_xobject_matrix(const PdfObj& xobj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xobject_matrix()\n";
	}
	#endif
	::fz_matrix temp = mupdf::ll_pdf_xobject_matrix(xobj.m_internal);
	auto ret = FzMatrix(&temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_xobject_resources()`.  */
FZ_FUNCTION PdfObj pdf_xobject_resources(const PdfObj& xobj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xobject_resources()\n";
	}
	#endif
	::pdf_obj* temp = mupdf::ll_pdf_xobject_resources(xobj.m_internal);
	ll_pdf_keep_obj(temp);
	auto ret = PdfObj(temp);
	return ret;
}


/* Class-aware wrapper for `::pdf_xobject_transparency()`.  */
FZ_FUNCTION int pdf_xobject_transparency(const PdfObj& xobj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xobject_transparency()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_xobject_transparency(xobj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_xref_ensure_incremental_object()`.  */
FZ_FUNCTION int pdf_xref_ensure_incremental_object(const PdfDocument& doc, int num)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xref_ensure_incremental_object()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_xref_ensure_incremental_object(doc.m_internal, num);
	return ret;
}


/* Class-aware wrapper for `::pdf_xref_ensure_local_object()`.  */
FZ_FUNCTION void pdf_xref_ensure_local_object(const PdfDocument& doc, int num)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xref_ensure_local_object()\n";
	}
	#endif
	mupdf::ll_pdf_xref_ensure_local_object(doc.m_internal, num);
}


/* Class-aware wrapper for `::pdf_xref_entry_map()`.  */
FZ_FUNCTION void pdf_xref_entry_map(const PdfDocument& doc, void (*fn)(::fz_context *, ::pdf_xref_entry *, int , ::pdf_document *, void *), void *arg)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xref_entry_map()\n";
	}
	#endif
	mupdf::ll_pdf_xref_entry_map(doc.m_internal, fn, arg);
}


/* Class-aware wrapper for `::pdf_xref_is_incremental()`.  */
FZ_FUNCTION int pdf_xref_is_incremental(const PdfDocument& doc, int num)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xref_is_incremental()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_xref_is_incremental(doc.m_internal, num);
	return ret;
}


/* Class-aware wrapper for `::pdf_xref_len()`.  */
FZ_FUNCTION int pdf_xref_len(const PdfDocument& doc)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xref_len()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_xref_len(doc.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_xref_obj_is_unsaved_signature()`.  */
FZ_FUNCTION int pdf_xref_obj_is_unsaved_signature(const PdfDocument& doc, const PdfObj& obj)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xref_obj_is_unsaved_signature()\n";
	}
	#endif
	auto ret = mupdf::ll_pdf_xref_obj_is_unsaved_signature(doc.m_internal, obj.m_internal);
	return ret;
}


/* Class-aware wrapper for `::pdf_xref_remove_unsaved_signature()`.  */
FZ_FUNCTION void pdf_xref_remove_unsaved_signature(const PdfDocument& doc, const PdfObj& field)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xref_remove_unsaved_signature()\n";
	}
	#endif
	mupdf::ll_pdf_xref_remove_unsaved_signature(doc.m_internal, field.m_internal);
}


/* Class-aware wrapper for `::pdf_xref_store_unsaved_signature()`.  */
FZ_FUNCTION void pdf_xref_store_unsaved_signature(const PdfDocument& doc, const PdfObj& field, const PdfPkcs7Signer& signer)
{
	#ifndef NDEBUG
	if (s_trace) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():"
				<< " calling mupdf::ll_pdf_xref_store_unsaved_signature()\n";
	}
	#endif
	mupdf::ll_pdf_xref_store_unsaved_signature(doc.m_internal, field.m_internal, signer.m_internal);
}


FZ_FUNCTION PdfObj pdf_dict_getlv( PdfObj& dict, va_list keys)
{
	pdf_obj* ret = ll_pdf_dict_getlv( dict.m_internal, keys);
	return PdfObj( ll_pdf_keep_obj( ret));
}

FZ_FUNCTION PdfObj pdf_dict_getl( PdfObj* dict, ...)
{
	va_list keys;
	va_start(keys, dict);
	try
	{
		PdfObj ret = pdf_dict_getlv( *dict, keys);
		va_end( keys);
		return ret;
	}
	catch (std::exception&)
	{
		va_end( keys);
		throw;
	}
}

} /* End of namespace mupdf. */
