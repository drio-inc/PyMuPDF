/**
This file was auto-generated by mupdfwrap.py.
*/


#include "mupdf/exceptions.h"
#include "mupdf/fitz.h"
#include "mupdf/internal.h"

#include <iostream>

#include <string.h>

#ifndef NDEBUG
	static const bool   s_trace_exceptions = mupdf::internal_env_flag("MUPDF_trace_exceptions");
#else
	static const bool   s_trace_exceptions_dummy = mupdf::internal_env_flag_check_unset("#ifndef NDEBUG", "MUPDF_trace_exceptions");
#endif

namespace mupdf
{

FZ_FUNCTION FzErrorBase::FzErrorBase(int code, const char* text)
:
m_code(code),
m_text(text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorBase: " << m_text << "\n";
	}
	#endif
};

FZ_FUNCTION const char* FzErrorBase::what() const throw()
{
	m_what = "code=" + std::to_string(m_code) + ": " + m_text;
	return m_what.c_str();
};


FZ_FUNCTION FzErrorNone::FzErrorNone(const char* text)
: FzErrorBase(FZ_ERROR_NONE, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorNone constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION FzErrorGeneric::FzErrorGeneric(const char* text)
: FzErrorBase(FZ_ERROR_GENERIC, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorGeneric constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION FzErrorSystem::FzErrorSystem(const char* text)
: FzErrorBase(FZ_ERROR_SYSTEM, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorSystem constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION FzErrorLibrary::FzErrorLibrary(const char* text)
: FzErrorBase(FZ_ERROR_LIBRARY, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorLibrary constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION FzErrorArgument::FzErrorArgument(const char* text)
: FzErrorBase(FZ_ERROR_ARGUMENT, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorArgument constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION FzErrorLimit::FzErrorLimit(const char* text)
: FzErrorBase(FZ_ERROR_LIMIT, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorLimit constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION FzErrorUnsupported::FzErrorUnsupported(const char* text)
: FzErrorBase(FZ_ERROR_UNSUPPORTED, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorUnsupported constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION FzErrorFormat::FzErrorFormat(const char* text)
: FzErrorBase(FZ_ERROR_FORMAT, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorFormat constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION FzErrorSyntax::FzErrorSyntax(const char* text)
: FzErrorBase(FZ_ERROR_SYNTAX, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorSyntax constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION FzErrorTrylater::FzErrorTrylater(const char* text)
: FzErrorBase(FZ_ERROR_TRYLATER, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorTrylater constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION FzErrorAbort::FzErrorAbort(const char* text)
: FzErrorBase(FZ_ERROR_ABORT, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorAbort constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION FzErrorRepaired::FzErrorRepaired(const char* text)
: FzErrorBase(FZ_ERROR_REPAIRED, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorRepaired constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION void internal_throw_exception(fz_context* ctx)
{
	int code;
	const char* text = fz_convert_error(ctx, &code);
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): code=" << code << "\n";
	}
	#endif
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): text=" << text << "\n";
	}
	#endif
	if (code == FZ_ERROR_NONE)        throw FzErrorNone       (text);
	if (code == FZ_ERROR_GENERIC)     throw FzErrorGeneric    (text);
	if (code == FZ_ERROR_SYSTEM)      throw FzErrorSystem     (text);
	if (code == FZ_ERROR_LIBRARY)     throw FzErrorLibrary    (text);
	if (code == FZ_ERROR_ARGUMENT)    throw FzErrorArgument   (text);
	if (code == FZ_ERROR_LIMIT)       throw FzErrorLimit      (text);
	if (code == FZ_ERROR_UNSUPPORTED) throw FzErrorUnsupported(text);
	if (code == FZ_ERROR_FORMAT)      throw FzErrorFormat     (text);
	if (code == FZ_ERROR_SYNTAX)      throw FzErrorSyntax     (text);
	if (code == FZ_ERROR_TRYLATER)    throw FzErrorTrylater   (text);
	if (code == FZ_ERROR_ABORT)       throw FzErrorAbort      (text);
	if (code == FZ_ERROR_REPAIRED)    throw FzErrorRepaired   (text);
	throw FzErrorBase(code, text);
}


} /* End of namespace mupdf. */
