/**
This file was auto-generated by mupdfwrap.py.
*/


#include "mupdf/extra.h"



FZ_FUNCTION std::string fz_lookup_metadata2( fz_context* ctx, fz_document* doc, const char* key)
{
	/* Find length first. */
	int e = fz_lookup_metadata(ctx, doc, key, NULL /*buf*/, 0 /*size*/);
	if (e < 0)
	{
		fz_throw(ctx, FZ_ERROR_GENERIC, "key not found: %s", key);
	}
	assert(e != 0);
	char* buf = (char*) fz_malloc(ctx, e);
	int e2 = fz_lookup_metadata(ctx, doc, key, buf, e);
	assert(e2 = e);
	std::string ret = buf;
	free(buf);
	return ret;
}

FZ_FUNCTION std::string pdf_lookup_metadata2( fz_context* ctx, pdf_document* doc, const char* key)
{
	/* Find length first. */
	int e = pdf_lookup_metadata(ctx, doc, key, NULL /*buf*/, 0 /*size*/);
	if (e < 0)
	{
		fz_throw(ctx, FZ_ERROR_GENERIC, "key not found: %s", key);
	}
	assert(e != 0);
	char* buf = (char*) fz_malloc(ctx, e);
	int e2 = pdf_lookup_metadata(ctx, doc, key, buf, e);
	assert(e2 = e);
	std::string ret = buf;
	free(buf);
	return ret;
}

FZ_FUNCTION std::vector<unsigned char> fz_md5_pixmap2(fz_context* ctx, fz_pixmap* pixmap)
{
	std::vector<unsigned char>  ret(16);
	fz_md5_pixmap( ctx, pixmap, &ret[0]);
	return ret;
}

FZ_FUNCTION long long fz_pixmap_samples_int(fz_context* ctx, fz_pixmap* pixmap)
{
	long long ret = (intptr_t) pixmap->samples;
	return ret;
}

FZ_FUNCTION int fz_samples_get(fz_pixmap* pixmap, int offset)
{
	return pixmap->samples[offset];
}

FZ_FUNCTION void fz_samples_set(fz_pixmap* pixmap, int offset, int value)
{
	pixmap->samples[offset] = value;
}

FZ_FUNCTION std::vector<unsigned char> fz_md5_final2(fz_md5* md5)
{
	std::vector<unsigned char>  ret(16);
	fz_md5_final( md5, &ret[0]);
	return ret;
}

FZ_FUNCTION std::vector<fz_quad> fz_highlight_selection2(fz_context* ctx, fz_stext_page* page, fz_point a, fz_point b, int max_quads)
{
	{
		std::vector<fz_quad>    ret(max_quads);
		int n;
		fz_try(ctx)
		{
			n = fz_highlight_selection(ctx, page, a, b, &ret[0], max_quads);
		}
		fz_catch(ctx)
		{
			n = -1;
		}
		if (n >= 0)
		{
			ret.resize(n);
			return ret;
		}
	}
	/* We are careful to only call `fz_throw()` after `ret`'s
	destructor has been called. */
	fz_throw(ctx, FZ_ERROR_GENERIC, "fz_highlight_selection() failed");
}

FZ_FUNCTION std::vector<fz_search_page2_hit> fz_search_page2(fz_context* ctx, fz_document* doc, int number, const char* needle, int hit_max)
{
	std::vector<fz_quad>    quads(hit_max);
	std::vector<int>        marks(hit_max);
	int n = fz_search_page_number(ctx, doc, number, needle, &marks[0], &quads[0], hit_max);
	std::vector<fz_search_page2_hit>    ret(n);
	for (int i=0; i<n; ++i)
	{
		ret[i].quad = quads[i];
		ret[i].mark = marks[i];
	}
	return ret;
}

FZ_FUNCTION std::string fz_string_from_text_language2(fz_text_language lang)
{
	char    str[8];
	fz_string_from_text_language(str, lang);
	return std::string(str);
}

FZ_FUNCTION std::string fz_get_glyph_name2(fz_context* ctx, fz_font* font, int glyph)
{
	char name[32];
	fz_get_glyph_name(ctx, font, glyph, name, sizeof(name));
	return std::string(name);
}

void fz_install_load_system_font_funcs2(fz_context* ctx, fz_install_load_system_font_funcs_args* args)
{
	fz_install_load_system_font_funcs(ctx, args->f, args->f_cjk, args->f_fallback);
}

void* fz_install_load_system_font_funcs2_state = nullptr;

FZ_FUNCTION fz_document* fz_document_open_fn_call(fz_context* ctx, fz_document_open_fn fn, fz_stream* stream, fz_stream* accel, fz_archive* dir)
{
	return fn(ctx, stream, accel, dir);
}

FZ_FUNCTION int fz_document_recognize_content_fn_call(fz_context* ctx, fz_document_recognize_content_fn fn, fz_stream* stream, fz_archive* dir)
{
	return fn(ctx, stream, dir);
}

FZ_FUNCTION std::vector<std::string> pdf_choice_widget_options2(fz_context* ctx, pdf_annot* tw, int exportval)
{
	int n = pdf_choice_widget_options(ctx, tw, exportval, nullptr);
	std::vector<const char*> opts(n);
	int n2 = pdf_choice_widget_options(ctx, tw, exportval, &opts[0]);
	assert(n2 == n);
	std::vector<std::string> ret(n);
	for (int i=0; i<n; ++i)
	{
		ret[i] = opts[i];
	}
	return ret;
}

FZ_FUNCTION fz_image* fz_new_image_from_compressed_buffer2(
		fz_context* ctx,
		int w,
		int h,
		int bpc,
		fz_colorspace* colorspace,
		int xres,
		int yres,
		int interpolate,
		int imagemask,
		const std::vector<float>& decode,
		const std::vector<int>& colorkey,
		fz_compressed_buffer* buffer,
		fz_image* mask
		)
{
	int n = fz_colorspace_n(ctx, colorspace);
	assert(decode.empty() || decode.size() == 2 * n);
	assert(colorkey.empty() || colorkey.size() == 2 * n);
	const float* decode2 = decode.empty() ? nullptr : &decode[0];
	const int* colorkey2 = colorkey.empty() ? nullptr : &colorkey[0];
	fz_image* ret = fz_new_image_from_compressed_buffer(
			ctx,
			w,
			h,
			bpc,
			colorspace,
			xres,
			yres,
			interpolate,
			imagemask,
			decode2,
			colorkey2,
			fz_keep_compressed_buffer(ctx, buffer),
			mask
			);
	return ret;
}

void pdf_rearrange_pages2(fz_context* ctx, pdf_document* doc, const std::vector<int>& pages)
{
	return pdf_rearrange_pages(ctx, doc, pages.size(), &pages[0]);
}

void pdf_subset_fonts2(fz_context *ctx, pdf_document *doc, const std::vector<int>& pages)
{
	return pdf_subset_fonts(ctx, doc, pages.size(), &pages[0]);
}

static void s_format_check(fz_context* ctx, const char* fmt, const char* specifiers)
{
	int length = strlen(fmt);
	if (!length || !strchr(specifiers, fmt[length-1]))
	{
		fz_throw(ctx, FZ_ERROR_ARGUMENT, "Incorrect fmt '%s' should end with one of '%s'.", fmt, specifiers);
	}
}

std::string fz_format_double(fz_context* ctx, const char* fmt, double value)
{
	char buffer[256];
	s_format_check(ctx, fmt, "efg");
	fz_snprintf(buffer, sizeof(buffer), fmt, value);
	return buffer;
}
