/**
This file was auto-generated by mupdfwrap.py.
*/


#include "mupdf/exceptions.h"
#include "mupdf/functions.h"
#include "mupdf/internal.h"
#include "mupdf/extra.h"

#include <assert.h>
#include <sstream>

#include <string.h>


namespace mupdf
{

FZ_FUNCTION const std::vector<std::string> metadata_keys = {
		"format",
		"encryption",
		"info:Title",
		"info:Author",
		"info:Subject",
		"info:Keywords",
		"info:Creator",
		"info:Producer",
		"info:CreationDate",
		"info:ModDate",
};

#ifndef NDEBUG
	static const int    s_trace = internal_env_flag("MUPDF_trace");
	static const bool   s_trace_keepdrop = internal_env_flag("MUPDF_trace_keepdrop");
	static const bool   s_trace_exceptions = internal_env_flag("MUPDF_trace_exceptions");
	static const bool   s_check_error_stack = internal_env_flag("MUPDF_check_error_stack");
#else
	static const int    s_trace = internal_env_flag_check_unset("#ifndef NDEBUG", "MUPDF_trace");
	static const bool   s_trace_keepdrop = internal_env_flag_check_unset("#ifndef NDEBUG", "MUPDF_trace_keepdrop");
	static const bool   s_trace_exceptions = internal_env_flag_check_unset("#ifndef NDEBUG", "MUPDF_trace_exceptions");
	static const bool   s_check_error_stack = internal_env_flag_check_unset("#ifndef NDEBUG", "MUPDF_check_error_stack");
#endif

/** Low-level wrapper for `::fz_aa_level()`. */
FZ_FUNCTION int ll_fz_aa_level()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_aa_level():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_aa_level(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_aa_level(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_abs()`. */
FZ_FUNCTION float ll_fz_abs(float f)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_abs():";
		std::cerr << " f=" << f;
		std::cerr << "\n";
	}
	#endif
	float ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_abs(f);
	return ret;
}

/** Low-level wrapper for `::fz_absi()`. */
FZ_FUNCTION int ll_fz_absi(int i)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_absi():";
		std::cerr << " i=" << i;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_absi(i);
	return ret;
}

/** Low-level wrapper for `::fz_add_layout_char()`. */
FZ_FUNCTION void ll_fz_add_layout_char(::fz_layout_block *block, float x, float w, const char *p)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_add_layout_char():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " block=" << block;
		std::cerr << " x=" << x;
		std::cerr << " w=" << w;
		if (p) std::cerr << " p='" << p << "'";
		else std::cerr << " p:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_add_layout_char(auto_ctx, block, x, w, p);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_add_layout_char(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_add_layout_line()`. */
FZ_FUNCTION void ll_fz_add_layout_line(::fz_layout_block *block, float x, float y, float h, const char *p)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_add_layout_line():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " block=" << block;
		std::cerr << " x=" << x;
		std::cerr << " y=" << y;
		std::cerr << " h=" << h;
		if (p) std::cerr << " p='" << p << "'";
		else std::cerr << " p:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_add_layout_line(auto_ctx, block, x, y, h, p);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_add_layout_line(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_add_separation()`. */
FZ_FUNCTION void ll_fz_add_separation(::fz_separations *sep, const char *name, ::fz_colorspace *cs, int cs_channel)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_add_separation():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " sep=" << sep;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << " cs_channel=" << cs_channel;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_add_separation(auto_ctx, sep, name, cs, cs_channel);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_add_separation(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_add_separation_equivalents()`. */
FZ_FUNCTION void ll_fz_add_separation_equivalents(::fz_separations *sep, uint32_t rgba, uint32_t cmyk, const char *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_add_separation_equivalents():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " sep=" << sep;
		std::cerr << " rgba=" << rgba;
		std::cerr << " cmyk=" << cmyk;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_add_separation_equivalents(auto_ctx, sep, rgba, cmyk, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_add_separation_equivalents(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_adjust_rect_for_stroke()`. */
FZ_FUNCTION ::fz_rect ll_fz_adjust_rect_for_stroke(::fz_rect rect, const ::fz_stroke_state *stroke, ::fz_matrix ctm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_adjust_rect_for_stroke():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " rect=" << rect;
		if (s_trace > 1) std::cerr << " stroke=" << stroke;
		std::cerr << " ctm=" << ctm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_rect ret;
	fz_try(auto_ctx) {
		ret = ::fz_adjust_rect_for_stroke(auto_ctx, rect, stroke, ctm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_adjust_rect_for_stroke(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_advance_glyph()`. */
FZ_FUNCTION float ll_fz_advance_glyph(::fz_font *font, int glyph, int wmode)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_advance_glyph():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " glyph=" << glyph;
		std::cerr << " wmode=" << wmode;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	float ret;
	fz_try(auto_ctx) {
		ret = ::fz_advance_glyph(auto_ctx, font, glyph, wmode);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_advance_glyph(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_aes_crypt_cbc()`. */
FZ_FUNCTION void ll_fz_aes_crypt_cbc(::fz_aes *ctx, int mode, size_t length, unsigned char iv[16], const unsigned char *input, unsigned char *output)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_aes_crypt_cbc():";
		if (s_trace > 1) std::cerr << " ctx=" << ctx;
		std::cerr << " mode=" << mode;
		std::cerr << " length=" << length;
		std::cerr << " iv=" << iv;
		std::cerr << " input=" << ((void*) input);
		std::cerr << " output=" << ((void*) output);
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_aes_crypt_cbc(ctx, mode, length, iv, input, output);
}

/** Low-level wrapper for `::fz_aes_setkey_dec()`. */
FZ_FUNCTION int ll_fz_aes_setkey_dec(::fz_aes *ctx, const unsigned char *key, int keysize)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_aes_setkey_dec():";
		if (s_trace > 1) std::cerr << " ctx=" << ctx;
		std::cerr << " key=" << ((void*) key);
		std::cerr << " keysize=" << keysize;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_aes_setkey_dec(ctx, key, keysize);
	return ret;
}

/** Low-level wrapper for `::fz_aes_setkey_enc()`. */
FZ_FUNCTION int ll_fz_aes_setkey_enc(::fz_aes *ctx, const unsigned char *key, int keysize)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_aes_setkey_enc():";
		if (s_trace > 1) std::cerr << " ctx=" << ctx;
		std::cerr << " key=" << ((void*) key);
		std::cerr << " keysize=" << keysize;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_aes_setkey_enc(ctx, key, keysize);
	return ret;
}

/** Low-level wrapper for `::fz_alpha_from_gray()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_alpha_from_gray(::fz_pixmap *gray)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_alpha_from_gray():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " gray=" << gray;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_alpha_from_gray(auto_ctx, gray);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_alpha_from_gray(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_append_base64()`. */
FZ_FUNCTION void ll_fz_append_base64(::fz_buffer *out, const unsigned char *data, size_t size, int newline)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_append_base64():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " data=" << ((void*) data);
		std::cerr << " size=" << size;
		std::cerr << " newline=" << newline;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_append_base64(auto_ctx, out, data, size, newline);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_append_base64(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_append_base64_buffer()`. */
FZ_FUNCTION void ll_fz_append_base64_buffer(::fz_buffer *out, ::fz_buffer *data, int newline)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_append_base64_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " data=" << data;
		std::cerr << " newline=" << newline;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_append_base64_buffer(auto_ctx, out, data, newline);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_append_base64_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_append_bits()`. */
FZ_FUNCTION void ll_fz_append_bits(::fz_buffer *buf, int value, int count)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_append_bits():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << " value=" << value;
		std::cerr << " count=" << count;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_append_bits(auto_ctx, buf, value, count);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_append_bits(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_append_bits_pad()`. */
FZ_FUNCTION void ll_fz_append_bits_pad(::fz_buffer *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_append_bits_pad():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_append_bits_pad(auto_ctx, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_append_bits_pad(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_append_buffer()`. */
FZ_FUNCTION void ll_fz_append_buffer(::fz_buffer *destination, ::fz_buffer *source)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_append_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " destination=" << destination;
		if (s_trace > 1) std::cerr << " source=" << source;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_append_buffer(auto_ctx, destination, source);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_append_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_append_byte()`. */
FZ_FUNCTION void ll_fz_append_byte(::fz_buffer *buf, int c)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_append_byte():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << " c=" << c;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_append_byte(auto_ctx, buf, c);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_append_byte(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_append_data()`. */
FZ_FUNCTION void ll_fz_append_data(::fz_buffer *buf, const void *data, size_t len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_append_data():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		if (s_trace > 1) std::cerr << " data=" << (void*) data;
		std::cerr << " len=" << len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_append_data(auto_ctx, buf, data, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_append_data(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_append_image_as_data_uri()`. */
FZ_FUNCTION void ll_fz_append_image_as_data_uri(::fz_buffer *out, ::fz_image *image)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_append_image_as_data_uri():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_append_image_as_data_uri(auto_ctx, out, image);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_append_image_as_data_uri(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_append_int16_be()`. */
FZ_FUNCTION void ll_fz_append_int16_be(::fz_buffer *buf, int x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_append_int16_be():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_append_int16_be(auto_ctx, buf, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_append_int16_be(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_append_int16_le()`. */
FZ_FUNCTION void ll_fz_append_int16_le(::fz_buffer *buf, int x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_append_int16_le():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_append_int16_le(auto_ctx, buf, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_append_int16_le(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_append_int32_be()`. */
FZ_FUNCTION void ll_fz_append_int32_be(::fz_buffer *buf, int x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_append_int32_be():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_append_int32_be(auto_ctx, buf, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_append_int32_be(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_append_int32_le()`. */
FZ_FUNCTION void ll_fz_append_int32_le(::fz_buffer *buf, int x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_append_int32_le():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_append_int32_le(auto_ctx, buf, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_append_int32_le(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_append_pdf_string()`. */
FZ_FUNCTION void ll_fz_append_pdf_string(::fz_buffer *buffer, const char *text)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_append_pdf_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buffer=" << buffer;
		if (text) std::cerr << " text='" << text << "'";
		else std::cerr << " text:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_append_pdf_string(auto_ctx, buffer, text);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_append_pdf_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_append_pixmap_as_data_uri()`. */
FZ_FUNCTION void ll_fz_append_pixmap_as_data_uri(::fz_buffer *out, ::fz_pixmap *pixmap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_append_pixmap_as_data_uri():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_append_pixmap_as_data_uri(auto_ctx, out, pixmap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_append_pixmap_as_data_uri(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_append_rune()`. */
FZ_FUNCTION void ll_fz_append_rune(::fz_buffer *buf, int c)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_append_rune():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << " c=" << c;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_append_rune(auto_ctx, buf, c);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_append_rune(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_append_string()`. */
FZ_FUNCTION void ll_fz_append_string(::fz_buffer *buf, const char *data)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_append_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		if (data) std::cerr << " data='" << data << "'";
		else std::cerr << " data:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_append_string(auto_ctx, buf, data);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_append_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_append_vprintf()`. */
FZ_FUNCTION void ll_fz_append_vprintf(::fz_buffer *buffer, const char *fmt, va_list args)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_append_vprintf():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buffer=" << buffer;
		if (fmt) std::cerr << " fmt='" << fmt << "'";
		else std::cerr << " fmt:null";
		std::cerr << " args:va_list";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_append_vprintf(auto_ctx, buffer, fmt, args);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_append_vprintf(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_arc4_encrypt()`. */
FZ_FUNCTION void ll_fz_arc4_encrypt(::fz_arc4 *state, unsigned char *dest, const unsigned char *src, size_t len)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_arc4_encrypt():";
		if (s_trace > 1) std::cerr << " state=" << state;
		std::cerr << " dest=" << ((void*) dest);
		std::cerr << " src=" << ((void*) src);
		std::cerr << " len=" << len;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_arc4_encrypt(state, dest, src, len);
}

/** Low-level wrapper for `::fz_arc4_final()`. */
FZ_FUNCTION void ll_fz_arc4_final(::fz_arc4 *state)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_arc4_final():";
		if (s_trace > 1) std::cerr << " state=" << state;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_arc4_final(state);
}

/** Low-level wrapper for `::fz_arc4_init()`. */
FZ_FUNCTION void ll_fz_arc4_init(::fz_arc4 *state, const unsigned char *key, size_t len)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_arc4_init():";
		if (s_trace > 1) std::cerr << " state=" << state;
		std::cerr << " key=" << ((void*) key);
		std::cerr << " len=" << len;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_arc4_init(state, key, len);
}

/** Low-level wrapper for `::fz_archive_format()`. */
FZ_FUNCTION const char *ll_fz_archive_format(::fz_archive *arch)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_archive_format():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " arch=" << arch;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_archive_format(auto_ctx, arch);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_archive_format(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_atof()`. */
FZ_FUNCTION float ll_fz_atof(const char *s)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_atof():";
		if (s) std::cerr << " s='" << s << "'";
		else std::cerr << " s:null";
		std::cerr << "\n";
	}
	#endif
	float ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_atof(s);
	return ret;
}

/** Low-level wrapper for `::fz_atoi()`. */
FZ_FUNCTION int ll_fz_atoi(const char *s)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_atoi():";
		if (s) std::cerr << " s='" << s << "'";
		else std::cerr << " s:null";
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_atoi(s);
	return ret;
}

/** Low-level wrapper for `::fz_atoi64()`. */
FZ_FUNCTION int64_t ll_fz_atoi64(const char *s)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_atoi64():";
		if (s) std::cerr << " s='" << s << "'";
		else std::cerr << " s:null";
		std::cerr << "\n";
	}
	#endif
	int64_t ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_atoi64(s);
	return ret;
}

/** Low-level wrapper for `::fz_authenticate_password()`. */
FZ_FUNCTION int ll_fz_authenticate_password(::fz_document *doc, const char *password)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_authenticate_password():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (password) std::cerr << " password='" << password << "'";
		else std::cerr << " password:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_authenticate_password(auto_ctx, doc, password);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_authenticate_password(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_available()`. */
FZ_FUNCTION size_t ll_fz_available(::fz_stream *stm, size_t max)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_available():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << " max=" << max;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	size_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_available(auto_ctx, stm, max);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_available(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_base_colorspace()`. */
FZ_FUNCTION ::fz_colorspace *ll_fz_base_colorspace(::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_base_colorspace():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::fz_base_colorspace(auto_ctx, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_base_colorspace(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_basename()`. */
FZ_FUNCTION const char *ll_fz_basename(const char *path)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_basename():";
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		std::cerr << "\n";
	}
	#endif
	const char * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_basename(path);
	return ret;
}

/** Low-level wrapper for `::fz_begin_group()`. */
FZ_FUNCTION void ll_fz_begin_group(::fz_device *dev, ::fz_rect area, ::fz_colorspace *cs, int isolated, int knockout, int blendmode, float alpha)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_begin_group():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " area=" << area;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << " isolated=" << isolated;
		std::cerr << " knockout=" << knockout;
		std::cerr << " blendmode=" << blendmode;
		std::cerr << " alpha=" << alpha;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_begin_group(auto_ctx, dev, area, cs, isolated, knockout, blendmode, alpha);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_begin_group(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_begin_layer()`. */
FZ_FUNCTION void ll_fz_begin_layer(::fz_device *dev, const char *layer_name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_begin_layer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		if (layer_name) std::cerr << " layer_name='" << layer_name << "'";
		else std::cerr << " layer_name:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_begin_layer(auto_ctx, dev, layer_name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_begin_layer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_begin_mask()`. */
FZ_FUNCTION void ll_fz_begin_mask(::fz_device *dev, ::fz_rect area, int luminosity, ::fz_colorspace *colorspace, const float *bc, ::fz_color_params color_params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_begin_mask():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " area=" << area;
		std::cerr << " luminosity=" << luminosity;
		if (s_trace > 1) std::cerr << " colorspace=" << colorspace;
		if (s_trace > 1) std::cerr << " bc=" << (void*) bc;
		std::cerr << " color_params=" << color_params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_begin_mask(auto_ctx, dev, area, luminosity, colorspace, bc, color_params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_begin_mask(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_begin_metatext()`. */
FZ_FUNCTION void ll_fz_begin_metatext(::fz_device *dev, ::fz_metatext meta, const char *text)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_begin_metatext():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " meta=" << meta;
		if (text) std::cerr << " text='" << text << "'";
		else std::cerr << " text:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_begin_metatext(auto_ctx, dev, meta, text);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_begin_metatext(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_begin_page()`. */
FZ_FUNCTION ::fz_device *ll_fz_begin_page(::fz_document_writer *wri, ::fz_rect mediabox)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_begin_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " wri=" << wri;
		std::cerr << " mediabox=" << mediabox;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_device * ret;
	fz_try(auto_ctx) {
		ret = ::fz_begin_page(auto_ctx, wri, mediabox);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_begin_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_begin_structure()`. */
FZ_FUNCTION void ll_fz_begin_structure(::fz_device *dev, ::fz_structure standard, const char *raw, int idx)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_begin_structure():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " standard=" << standard;
		if (raw) std::cerr << " raw='" << raw << "'";
		else std::cerr << " raw:null";
		std::cerr << " idx=" << idx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_begin_structure(auto_ctx, dev, standard, raw, idx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_begin_structure(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_begin_tile()`. */
FZ_FUNCTION void ll_fz_begin_tile(::fz_device *dev, ::fz_rect area, ::fz_rect view, float xstep, float ystep, ::fz_matrix ctm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_begin_tile():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " area=" << area;
		std::cerr << " view=" << view;
		std::cerr << " xstep=" << xstep;
		std::cerr << " ystep=" << ystep;
		std::cerr << " ctm=" << ctm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_begin_tile(auto_ctx, dev, area, view, xstep, ystep, ctm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_begin_tile(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_begin_tile_id()`. */
FZ_FUNCTION int ll_fz_begin_tile_id(::fz_device *dev, ::fz_rect area, ::fz_rect view, float xstep, float ystep, ::fz_matrix ctm, int id)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_begin_tile_id():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " area=" << area;
		std::cerr << " view=" << view;
		std::cerr << " xstep=" << xstep;
		std::cerr << " ystep=" << ystep;
		std::cerr << " ctm=" << ctm;
		std::cerr << " id=" << id;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_begin_tile_id(auto_ctx, dev, area, view, xstep, ystep, ctm, id);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_begin_tile_id(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_bidi_fragment_text()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_bidi_fragment_text(const uint32_t *text, size_t textlen, ::fz_bidi_fragment_fn *callback, void *arg, int flags)` => ::fz_bidi_direction baseDir
*/
FZ_FUNCTION void ll_fz_bidi_fragment_text(const uint32_t *text, size_t textlen, ::fz_bidi_direction *baseDir, ::fz_bidi_fragment_fn *callback, void *arg, int flags)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_bidi_fragment_text():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " text=" << (void*) text;
		std::cerr << " textlen=" << textlen;
		if (s_trace > 1) std::cerr << " baseDir=" << (void*) baseDir;
		if (s_trace > 1) std::cerr << " callback=" << (void*) callback;
		if (s_trace > 1) std::cerr << " arg=" << (void*) arg;
		std::cerr << " flags=" << flags;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_bidi_fragment_text(auto_ctx, text, textlen, baseDir, callback, arg, flags);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_bidi_fragment_text(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_bitmap_details()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_bitmap_details(::fz_bitmap *bitmap)` => `(int w, int h, int n, int stride)`
*/
FZ_FUNCTION void ll_fz_bitmap_details(::fz_bitmap *bitmap, int *w, int *h, int *n, int *stride)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_bitmap_details():";
		if (s_trace > 1) std::cerr << " bitmap=" << bitmap;
		if (s_trace > 1) std::cerr << " w=" << (void*) w;
		if (s_trace > 1) std::cerr << " h=" << (void*) h;
		if (s_trace > 1) std::cerr << " n=" << (void*) n;
		if (s_trace > 1) std::cerr << " stride=" << (void*) stride;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_bitmap_details(bitmap, w, h, n, stride);
}

/** Low-level wrapper for `::fz_blendmode_name()`. */
FZ_FUNCTION const char *ll_fz_blendmode_name(int blendmode)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_blendmode_name():";
		std::cerr << " blendmode=" << blendmode;
		std::cerr << "\n";
	}
	#endif
	const char * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_blendmode_name(blendmode);
	return ret;
}

/** Low-level wrapper for `::fz_bound_display_list()`. */
FZ_FUNCTION ::fz_rect ll_fz_bound_display_list(::fz_display_list *list)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_bound_display_list():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " list=" << list;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_rect ret;
	fz_try(auto_ctx) {
		ret = ::fz_bound_display_list(auto_ctx, list);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_bound_display_list(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_bound_glyph()`. */
FZ_FUNCTION ::fz_rect ll_fz_bound_glyph(::fz_font *font, int gid, ::fz_matrix trm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_bound_glyph():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " gid=" << gid;
		std::cerr << " trm=" << trm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_rect ret;
	fz_try(auto_ctx) {
		ret = ::fz_bound_glyph(auto_ctx, font, gid, trm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_bound_glyph(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_bound_page()`. */
FZ_FUNCTION ::fz_rect ll_fz_bound_page(::fz_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_bound_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_rect ret;
	fz_try(auto_ctx) {
		ret = ::fz_bound_page(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_bound_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_bound_page_box()`. */
FZ_FUNCTION ::fz_rect ll_fz_bound_page_box(::fz_page *page, ::fz_box_type box)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_bound_page_box():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " box=" << box;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_rect ret;
	fz_try(auto_ctx) {
		ret = ::fz_bound_page_box(auto_ctx, page, box);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_bound_page_box(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_bound_path()`. */
FZ_FUNCTION ::fz_rect ll_fz_bound_path(const ::fz_path *path, const ::fz_stroke_state *stroke, ::fz_matrix ctm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_bound_path():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " path=" << path;
		if (s_trace > 1) std::cerr << " stroke=" << stroke;
		std::cerr << " ctm=" << ctm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_rect ret;
	fz_try(auto_ctx) {
		ret = ::fz_bound_path(auto_ctx, path, stroke, ctm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_bound_path(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_bound_shade()`. */
FZ_FUNCTION ::fz_rect ll_fz_bound_shade(::fz_shade *shade, ::fz_matrix ctm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_bound_shade():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " shade=" << shade;
		std::cerr << " ctm=" << ctm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_rect ret;
	fz_try(auto_ctx) {
		ret = ::fz_bound_shade(auto_ctx, shade, ctm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_bound_shade(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_bound_text()`. */
FZ_FUNCTION ::fz_rect ll_fz_bound_text(const ::fz_text *text, const ::fz_stroke_state *stroke, ::fz_matrix ctm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_bound_text():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " text=" << text;
		if (s_trace > 1) std::cerr << " stroke=" << stroke;
		std::cerr << " ctm=" << ctm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_rect ret;
	fz_try(auto_ctx) {
		ret = ::fz_bound_text(auto_ctx, text, stroke, ctm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_bound_text(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_box_type_from_string()`. */
FZ_FUNCTION ::fz_box_type ll_fz_box_type_from_string(const char *name)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_box_type_from_string():";
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	fz_box_type ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_box_type_from_string(name);
	return ret;
}

/** Low-level wrapper for `::fz_buffer_extract()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_buffer_extract(::fz_buffer *buf)` => `(size_t, unsigned char *data)`
*/
FZ_FUNCTION size_t ll_fz_buffer_extract(::fz_buffer *buf, unsigned char **data)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_buffer_extract():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		if (s_trace > 1) std::cerr << " data=" << (void*) data;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	size_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_buffer_extract(auto_ctx, buf, data);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_buffer_extract(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_buffer_storage()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_buffer_storage(::fz_buffer *buf)` => `(size_t, unsigned char *datap)`
*/
FZ_FUNCTION size_t ll_fz_buffer_storage(::fz_buffer *buf, unsigned char **datap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_buffer_storage():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		if (s_trace > 1) std::cerr << " datap=" << (void*) datap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	size_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_buffer_storage(auto_ctx, buf, datap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_buffer_storage(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_calloc()`. */
FZ_FUNCTION void *ll_fz_calloc(size_t count, size_t size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_calloc():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " count=" << count;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_calloc(auto_ctx, count, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_calloc(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_calloc_no_throw()`. */
FZ_FUNCTION void *ll_fz_calloc_no_throw(size_t count, size_t size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_calloc_no_throw():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " count=" << count;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_calloc_no_throw(auto_ctx, count, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_calloc_no_throw(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_caught()`. */
FZ_FUNCTION int ll_fz_caught()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_caught():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_caught(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_caught(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_caught_errno()`. */
FZ_FUNCTION int ll_fz_caught_errno()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_caught_errno():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_caught_errno(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_caught_errno(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_caught_message()`. */
FZ_FUNCTION const char *ll_fz_caught_message()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_caught_message():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_caught_message(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_caught_message(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_chartorune()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_chartorune(const char *str)` => `(int, int rune)`
*/
FZ_FUNCTION int ll_fz_chartorune(int *rune, const char *str)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_chartorune():";
		if (s_trace > 1) std::cerr << " rune=" << (void*) rune;
		if (str) std::cerr << " str='" << str << "'";
		else std::cerr << " str:null";
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_chartorune(rune, str);
	return ret;
}

/** Low-level wrapper for `::fz_clamp()`. */
FZ_FUNCTION float ll_fz_clamp(float x, float min, float max)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clamp():";
		std::cerr << " x=" << x;
		std::cerr << " min=" << min;
		std::cerr << " max=" << max;
		std::cerr << "\n";
	}
	#endif
	float ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_clamp(x, min, max);
	return ret;
}

/** Low-level wrapper for `::fz_clamp64()`. */
FZ_FUNCTION int64_t ll_fz_clamp64(int64_t x, int64_t min, int64_t max)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clamp64():";
		std::cerr << " x=" << x;
		std::cerr << " min=" << min;
		std::cerr << " max=" << max;
		std::cerr << "\n";
	}
	#endif
	int64_t ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_clamp64(x, min, max);
	return ret;
}

/** Low-level wrapper for `::fz_clamp_color()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_clamp_color(::fz_colorspace *cs, const float *in)` => float out
*/
FZ_FUNCTION void ll_fz_clamp_color(::fz_colorspace *cs, const float *in, float *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clamp_color():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		if (s_trace > 1) std::cerr << " in=" << (void*) in;
		if (s_trace > 1) std::cerr << " out=" << (void*) out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_clamp_color(auto_ctx, cs, in, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_clamp_color(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_clamp_location()`. */
FZ_FUNCTION ::fz_location ll_fz_clamp_location(::fz_document *doc, ::fz_location loc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clamp_location():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " loc=" << loc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_location ret;
	fz_try(auto_ctx) {
		ret = ::fz_clamp_location(auto_ctx, doc, loc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_clamp_location(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_clampd()`. */
FZ_FUNCTION double ll_fz_clampd(double x, double min, double max)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clampd():";
		std::cerr << " x=" << x;
		std::cerr << " min=" << min;
		std::cerr << " max=" << max;
		std::cerr << "\n";
	}
	#endif
	double ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_clampd(x, min, max);
	return ret;
}

/** Low-level wrapper for `::fz_clampi()`. */
FZ_FUNCTION int ll_fz_clampi(int x, int min, int max)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clampi():";
		std::cerr << " x=" << x;
		std::cerr << " min=" << min;
		std::cerr << " max=" << max;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_clampi(x, min, max);
	return ret;
}

/** Low-level wrapper for `::fz_clampp()`. */
FZ_FUNCTION void *ll_fz_clampp(void *x, void *min, void *max)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clampp():";
		if (s_trace > 1) std::cerr << " x=" << (void*) x;
		if (s_trace > 1) std::cerr << " min=" << (void*) min;
		if (s_trace > 1) std::cerr << " max=" << (void*) max;
		std::cerr << "\n";
	}
	#endif
	void * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_clampp(x, min, max);
	return ret;
}

/** Low-level wrapper for `::fz_cleanname()`. */
FZ_FUNCTION char *ll_fz_cleanname(char *name)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_cleanname():";
		if (s_trace > 1) std::cerr << " name=" << (void*) name;
		std::cerr << "\n";
	}
	#endif
	char * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_cleanname(name);
	return ret;
}

/** Low-level wrapper for `::fz_cleanname_strdup()`. */
FZ_FUNCTION char *ll_fz_cleanname_strdup(const char *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_cleanname_strdup():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_cleanname_strdup(auto_ctx, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_cleanname_strdup(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_clear_bitmap()`. */
FZ_FUNCTION void ll_fz_clear_bitmap(::fz_bitmap *bit)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clear_bitmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " bit=" << bit;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_clear_bitmap(auto_ctx, bit);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_clear_bitmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_clear_buffer()`. */
FZ_FUNCTION void ll_fz_clear_buffer(::fz_buffer *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clear_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_clear_buffer(auto_ctx, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_clear_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_clear_pixmap()`. */
FZ_FUNCTION void ll_fz_clear_pixmap(::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clear_pixmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_clear_pixmap(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_clear_pixmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_clear_pixmap_rect_with_value()`. */
FZ_FUNCTION void ll_fz_clear_pixmap_rect_with_value(::fz_pixmap *pix, int value, ::fz_irect r)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clear_pixmap_rect_with_value():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << " value=" << value;
		std::cerr << " r=" << r;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_clear_pixmap_rect_with_value(auto_ctx, pix, value, r);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_clear_pixmap_rect_with_value(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_clear_pixmap_with_value()`. */
FZ_FUNCTION void ll_fz_clear_pixmap_with_value(::fz_pixmap *pix, int value)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clear_pixmap_with_value():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << " value=" << value;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_clear_pixmap_with_value(auto_ctx, pix, value);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_clear_pixmap_with_value(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_clip_image_mask()`. */
FZ_FUNCTION void ll_fz_clip_image_mask(::fz_device *dev, ::fz_image *image, ::fz_matrix ctm, ::fz_rect scissor)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clip_image_mask():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << " ctm=" << ctm;
		std::cerr << " scissor=" << scissor;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_clip_image_mask(auto_ctx, dev, image, ctm, scissor);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_clip_image_mask(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_clip_path()`. */
FZ_FUNCTION void ll_fz_clip_path(::fz_device *dev, const ::fz_path *path, int even_odd, ::fz_matrix ctm, ::fz_rect scissor)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clip_path():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		if (s_trace > 1) std::cerr << " path=" << path;
		std::cerr << " even_odd=" << even_odd;
		std::cerr << " ctm=" << ctm;
		std::cerr << " scissor=" << scissor;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_clip_path(auto_ctx, dev, path, even_odd, ctm, scissor);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_clip_path(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_clip_stroke_path()`. */
FZ_FUNCTION void ll_fz_clip_stroke_path(::fz_device *dev, const ::fz_path *path, const ::fz_stroke_state *stroke, ::fz_matrix ctm, ::fz_rect scissor)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clip_stroke_path():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		if (s_trace > 1) std::cerr << " path=" << path;
		if (s_trace > 1) std::cerr << " stroke=" << stroke;
		std::cerr << " ctm=" << ctm;
		std::cerr << " scissor=" << scissor;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_clip_stroke_path(auto_ctx, dev, path, stroke, ctm, scissor);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_clip_stroke_path(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_clip_stroke_text()`. */
FZ_FUNCTION void ll_fz_clip_stroke_text(::fz_device *dev, const ::fz_text *text, const ::fz_stroke_state *stroke, ::fz_matrix ctm, ::fz_rect scissor)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clip_stroke_text():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		if (s_trace > 1) std::cerr << " text=" << text;
		if (s_trace > 1) std::cerr << " stroke=" << stroke;
		std::cerr << " ctm=" << ctm;
		std::cerr << " scissor=" << scissor;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_clip_stroke_text(auto_ctx, dev, text, stroke, ctm, scissor);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_clip_stroke_text(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_clip_text()`. */
FZ_FUNCTION void ll_fz_clip_text(::fz_device *dev, const ::fz_text *text, ::fz_matrix ctm, ::fz_rect scissor)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clip_text():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		if (s_trace > 1) std::cerr << " text=" << text;
		std::cerr << " ctm=" << ctm;
		std::cerr << " scissor=" << scissor;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_clip_text(auto_ctx, dev, text, ctm, scissor);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_clip_text(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_clone_buffer()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_clone_buffer(::fz_buffer *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clone_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_clone_buffer(auto_ctx, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_clone_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_clone_context()`. */
FZ_FUNCTION ::fz_context *ll_fz_clone_context()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clone_context():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_context * ret;
	fz_try(auto_ctx) {
		ret = ::fz_clone_context(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_clone_context(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_clone_default_colorspaces()`. */
FZ_FUNCTION ::fz_default_colorspaces *ll_fz_clone_default_colorspaces(::fz_default_colorspaces *base)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clone_default_colorspaces():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " base=" << base;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_default_colorspaces * ret;
	fz_try(auto_ctx) {
		ret = ::fz_clone_default_colorspaces(auto_ctx, base);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_clone_default_colorspaces(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_clone_path()`. */
FZ_FUNCTION ::fz_path *ll_fz_clone_path(::fz_path *path)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clone_path():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " path=" << path;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_path * ret;
	fz_try(auto_ctx) {
		ret = ::fz_clone_path(auto_ctx, path);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_clone_path(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_clone_pixmap()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_clone_pixmap(const ::fz_pixmap *old)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clone_pixmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " old=" << old;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_clone_pixmap(auto_ctx, old);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_clone_pixmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_clone_pixmap_area_with_different_seps()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_clone_pixmap_area_with_different_seps(::fz_pixmap *src, const ::fz_irect *bbox, ::fz_colorspace *dcs, ::fz_separations *seps, ::fz_color_params color_params, ::fz_default_colorspaces *default_cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clone_pixmap_area_with_different_seps():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " src=" << src;
		std::cerr << " bbox=" << bbox;
		if (s_trace > 1) std::cerr << " dcs=" << dcs;
		if (s_trace > 1) std::cerr << " seps=" << seps;
		std::cerr << " color_params=" << color_params;
		if (s_trace > 1) std::cerr << " default_cs=" << default_cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_clone_pixmap_area_with_different_seps(auto_ctx, src, bbox, dcs, seps, color_params, default_cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_clone_pixmap_area_with_different_seps(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_clone_separations_for_overprint()`. */
FZ_FUNCTION ::fz_separations *ll_fz_clone_separations_for_overprint(::fz_separations *seps)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clone_separations_for_overprint():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " seps=" << seps;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_separations * ret;
	fz_try(auto_ctx) {
		ret = ::fz_clone_separations_for_overprint(auto_ctx, seps);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_clone_separations_for_overprint(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_clone_stroke_state()`. */
FZ_FUNCTION ::fz_stroke_state *ll_fz_clone_stroke_state(::fz_stroke_state *stroke)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_clone_stroke_state():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stroke=" << stroke;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stroke_state * ret;
	fz_try(auto_ctx) {
		ret = ::fz_clone_stroke_state(auto_ctx, stroke);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_clone_stroke_state(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_close_band_writer()`. */
FZ_FUNCTION void ll_fz_close_band_writer(::fz_band_writer *writer)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_close_band_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " writer=" << writer;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_close_band_writer(auto_ctx, writer);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_close_band_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_close_device()`. */
FZ_FUNCTION void ll_fz_close_device(::fz_device *dev)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_close_device():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_close_device(auto_ctx, dev);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_close_device(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_close_document_writer()`. */
FZ_FUNCTION void ll_fz_close_document_writer(::fz_document_writer *wri)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_close_document_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " wri=" << wri;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_close_document_writer(auto_ctx, wri);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_close_document_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_close_output()`. */
FZ_FUNCTION void ll_fz_close_output(::fz_output *arg_1)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_close_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " arg_1=" << arg_1;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_close_output(auto_ctx, arg_1);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_close_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_close_zip_writer()`. */
FZ_FUNCTION void ll_fz_close_zip_writer(::fz_zip_writer *zip)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_close_zip_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " zip=" << zip;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_close_zip_writer(auto_ctx, zip);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_close_zip_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_closepath()`. */
FZ_FUNCTION void ll_fz_closepath(::fz_path *path)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_closepath():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " path=" << path;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_closepath(auto_ctx, path);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_closepath(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_colorspace_colorant()`. */
FZ_FUNCTION const char *ll_fz_colorspace_colorant(::fz_colorspace *cs, int n)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_colorspace_colorant():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << " n=" << n;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_colorspace_colorant(auto_ctx, cs, n);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_colorspace_colorant(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_colorspace_device_n_has_cmyk()`. */
FZ_FUNCTION int ll_fz_colorspace_device_n_has_cmyk(::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_colorspace_device_n_has_cmyk():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_colorspace_device_n_has_cmyk(auto_ctx, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_colorspace_device_n_has_cmyk(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_colorspace_device_n_has_only_cmyk()`. */
FZ_FUNCTION int ll_fz_colorspace_device_n_has_only_cmyk(::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_colorspace_device_n_has_only_cmyk():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_colorspace_device_n_has_only_cmyk(auto_ctx, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_colorspace_device_n_has_only_cmyk(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_colorspace_is_cmyk()`. */
FZ_FUNCTION int ll_fz_colorspace_is_cmyk(::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_colorspace_is_cmyk():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_colorspace_is_cmyk(auto_ctx, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_colorspace_is_cmyk(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_colorspace_is_device()`. */
FZ_FUNCTION int ll_fz_colorspace_is_device(::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_colorspace_is_device():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_colorspace_is_device(auto_ctx, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_colorspace_is_device(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_colorspace_is_device_cmyk()`. */
FZ_FUNCTION int ll_fz_colorspace_is_device_cmyk(::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_colorspace_is_device_cmyk():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_colorspace_is_device_cmyk(auto_ctx, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_colorspace_is_device_cmyk(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_colorspace_is_device_gray()`. */
FZ_FUNCTION int ll_fz_colorspace_is_device_gray(::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_colorspace_is_device_gray():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_colorspace_is_device_gray(auto_ctx, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_colorspace_is_device_gray(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_colorspace_is_device_n()`. */
FZ_FUNCTION int ll_fz_colorspace_is_device_n(::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_colorspace_is_device_n():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_colorspace_is_device_n(auto_ctx, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_colorspace_is_device_n(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_colorspace_is_gray()`. */
FZ_FUNCTION int ll_fz_colorspace_is_gray(::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_colorspace_is_gray():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_colorspace_is_gray(auto_ctx, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_colorspace_is_gray(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_colorspace_is_indexed()`. */
FZ_FUNCTION int ll_fz_colorspace_is_indexed(::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_colorspace_is_indexed():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_colorspace_is_indexed(auto_ctx, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_colorspace_is_indexed(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_colorspace_is_lab()`. */
FZ_FUNCTION int ll_fz_colorspace_is_lab(::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_colorspace_is_lab():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_colorspace_is_lab(auto_ctx, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_colorspace_is_lab(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_colorspace_is_lab_icc()`. */
FZ_FUNCTION int ll_fz_colorspace_is_lab_icc(::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_colorspace_is_lab_icc():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_colorspace_is_lab_icc(auto_ctx, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_colorspace_is_lab_icc(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_colorspace_is_rgb()`. */
FZ_FUNCTION int ll_fz_colorspace_is_rgb(::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_colorspace_is_rgb():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_colorspace_is_rgb(auto_ctx, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_colorspace_is_rgb(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_colorspace_is_subtractive()`. */
FZ_FUNCTION int ll_fz_colorspace_is_subtractive(::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_colorspace_is_subtractive():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_colorspace_is_subtractive(auto_ctx, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_colorspace_is_subtractive(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_colorspace_n()`. */
FZ_FUNCTION int ll_fz_colorspace_n(::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_colorspace_n():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_colorspace_n(auto_ctx, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_colorspace_n(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_colorspace_name()`. */
FZ_FUNCTION const char *ll_fz_colorspace_name(::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_colorspace_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_colorspace_name(auto_ctx, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_colorspace_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_colorspace_name_colorant()`. */
FZ_FUNCTION void ll_fz_colorspace_name_colorant(::fz_colorspace *cs, int n, const char *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_colorspace_name_colorant():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << " n=" << n;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_colorspace_name_colorant(auto_ctx, cs, n, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_colorspace_name_colorant(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_colorspace_type()`. */
FZ_FUNCTION enum fz_colorspace_type ll_fz_colorspace_type(::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_colorspace_type():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	enum fz_colorspace_type ret;
	fz_try(auto_ctx) {
		ret = ::fz_colorspace_type(auto_ctx, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_colorspace_type(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_compare_separations()`. */
FZ_FUNCTION int ll_fz_compare_separations(const ::fz_separations *sep1, const ::fz_separations *sep2)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_compare_separations():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " sep1=" << sep1;
		if (s_trace > 1) std::cerr << " sep2=" << sep2;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_compare_separations(auto_ctx, sep1, sep2);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_compare_separations(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_compress_ccitt_fax_g3()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_compress_ccitt_fax_g3(const unsigned char *data, int columns, int rows, int stride)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_compress_ccitt_fax_g3():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " data=" << ((void*) data);
		std::cerr << " columns=" << columns;
		std::cerr << " rows=" << rows;
		std::cerr << " stride=" << stride;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_compress_ccitt_fax_g3(auto_ctx, data, columns, rows, stride);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_compress_ccitt_fax_g3(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_compress_ccitt_fax_g4()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_compress_ccitt_fax_g4(const unsigned char *data, int columns, int rows, int stride)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_compress_ccitt_fax_g4():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " data=" << ((void*) data);
		std::cerr << " columns=" << columns;
		std::cerr << " rows=" << rows;
		std::cerr << " stride=" << stride;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_compress_ccitt_fax_g4(auto_ctx, data, columns, rows, stride);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_compress_ccitt_fax_g4(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_compressed_buffer_size()`. */
FZ_FUNCTION size_t ll_fz_compressed_buffer_size(::fz_compressed_buffer *buffer)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_compressed_buffer_size():";
		if (s_trace > 1) std::cerr << " buffer=" << buffer;
		std::cerr << "\n";
	}
	#endif
	size_t ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_compressed_buffer_size(buffer);
	return ret;
}

/** Low-level wrapper for `::fz_compressed_image_buffer()`. */
FZ_FUNCTION ::fz_compressed_buffer *ll_fz_compressed_image_buffer(::fz_image *image)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_compressed_image_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_compressed_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_compressed_image_buffer(auto_ctx, image);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_compressed_image_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_compressed_image_type()`. */
FZ_FUNCTION int ll_fz_compressed_image_type(::fz_image *image)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_compressed_image_type():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_compressed_image_type(auto_ctx, image);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_compressed_image_type(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_concat()`. */
FZ_FUNCTION ::fz_matrix ll_fz_concat(::fz_matrix left, ::fz_matrix right)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_concat():";
		std::cerr << " left=" << left;
		std::cerr << " right=" << right;
		std::cerr << "\n";
	}
	#endif
	fz_matrix ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_concat(left, right);
	return ret;
}

/** Low-level wrapper for `::fz_concat_push_drop()`. */
FZ_FUNCTION void ll_fz_concat_push_drop(::fz_stream *concat, ::fz_stream *chain)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_concat_push_drop():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " concat=" << concat;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_concat_push_drop(auto_ctx, concat, chain);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_concat_push_drop(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_contains_rect()`. */
FZ_FUNCTION int ll_fz_contains_rect(::fz_rect a, ::fz_rect b)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_contains_rect():";
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_contains_rect(a, b);
	return ret;
}

/** Low-level wrapper for `::fz_convert_color()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_convert_color(::fz_colorspace *ss, const float *sv, ::fz_colorspace *ds, ::fz_colorspace *is, ::fz_color_params params)` => float dv
*/
FZ_FUNCTION void ll_fz_convert_color(::fz_colorspace *ss, const float *sv, ::fz_colorspace *ds, float *dv, ::fz_colorspace *is, ::fz_color_params params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_convert_color():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " ss=" << ss;
		if (s_trace > 1) std::cerr << " sv=" << (void*) sv;
		if (s_trace > 1) std::cerr << " ds=" << ds;
		if (s_trace > 1) std::cerr << " dv=" << (void*) dv;
		if (s_trace > 1) std::cerr << " is=" << is;
		std::cerr << " params=" << params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_convert_color(auto_ctx, ss, sv, ds, dv, is, params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_convert_color(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_convert_error()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_convert_error()` => `(const char *, int code)`
*/
FZ_FUNCTION const char *ll_fz_convert_error(int *code)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_convert_error():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " code=" << (void*) code;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_convert_error(auto_ctx, code);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_convert_error(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_convert_indexed_pixmap_to_base()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_convert_indexed_pixmap_to_base(const ::fz_pixmap *src)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_convert_indexed_pixmap_to_base():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " src=" << src;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_convert_indexed_pixmap_to_base(auto_ctx, src);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_convert_indexed_pixmap_to_base(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_convert_pixmap()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_convert_pixmap(const ::fz_pixmap *pix, ::fz_colorspace *cs_des, ::fz_colorspace *prf, ::fz_default_colorspaces *default_cs, ::fz_color_params color_params, int keep_alpha)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_convert_pixmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		if (s_trace > 1) std::cerr << " cs_des=" << cs_des;
		if (s_trace > 1) std::cerr << " prf=" << prf;
		if (s_trace > 1) std::cerr << " default_cs=" << default_cs;
		std::cerr << " color_params=" << color_params;
		std::cerr << " keep_alpha=" << keep_alpha;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_convert_pixmap(auto_ctx, pix, cs_des, prf, default_cs, color_params, keep_alpha);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_convert_pixmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_convert_separation_colors()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_convert_separation_colors(::fz_colorspace *src_cs, const float *src_color, ::fz_separations *dst_seps, ::fz_colorspace *dst_cs, ::fz_color_params color_params)` => float dst_color
*/
FZ_FUNCTION void ll_fz_convert_separation_colors(::fz_colorspace *src_cs, const float *src_color, ::fz_separations *dst_seps, ::fz_colorspace *dst_cs, float *dst_color, ::fz_color_params color_params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_convert_separation_colors():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " src_cs=" << src_cs;
		if (s_trace > 1) std::cerr << " src_color=" << (void*) src_color;
		if (s_trace > 1) std::cerr << " dst_seps=" << dst_seps;
		if (s_trace > 1) std::cerr << " dst_cs=" << dst_cs;
		if (s_trace > 1) std::cerr << " dst_color=" << (void*) dst_color;
		std::cerr << " color_params=" << color_params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_convert_separation_colors(auto_ctx, src_cs, src_color, dst_seps, dst_cs, dst_color, color_params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_convert_separation_colors(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_convert_separation_pixmap_to_base()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_convert_separation_pixmap_to_base(const ::fz_pixmap *src)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_convert_separation_pixmap_to_base():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " src=" << src;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_convert_separation_pixmap_to_base(auto_ctx, src);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_convert_separation_pixmap_to_base(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_copy_option()`. */
FZ_FUNCTION size_t ll_fz_copy_option(const char *val, char *dest, size_t maxlen)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_copy_option():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (val) std::cerr << " val='" << val << "'";
		else std::cerr << " val:null";
		if (s_trace > 1) std::cerr << " dest=" << (void*) dest;
		std::cerr << " maxlen=" << maxlen;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	size_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_copy_option(auto_ctx, val, dest, maxlen);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_copy_option(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_copy_pixmap_rect()`. */
FZ_FUNCTION void ll_fz_copy_pixmap_rect(::fz_pixmap *dest, ::fz_pixmap *src, ::fz_irect r, const ::fz_default_colorspaces *default_cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_copy_pixmap_rect():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dest=" << dest;
		if (s_trace > 1) std::cerr << " src=" << src;
		std::cerr << " r=" << r;
		if (s_trace > 1) std::cerr << " default_cs=" << default_cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_copy_pixmap_rect(auto_ctx, dest, src, r, default_cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_copy_pixmap_rect(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_copy_rectangle()`. */
FZ_FUNCTION char *ll_fz_copy_rectangle(::fz_stext_page *page, ::fz_rect area, int crlf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_copy_rectangle():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " area=" << area;
		std::cerr << " crlf=" << crlf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_copy_rectangle(auto_ctx, page, area, crlf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_copy_rectangle(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_copy_selection()`. */
FZ_FUNCTION char *ll_fz_copy_selection(::fz_stext_page *page, ::fz_point a, ::fz_point b, int crlf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_copy_selection():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << " crlf=" << crlf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_copy_selection(auto_ctx, page, a, b, crlf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_copy_selection(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_count_active_separations()`. */
FZ_FUNCTION int ll_fz_count_active_separations(const ::fz_separations *seps)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_count_active_separations():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " seps=" << seps;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_count_active_separations(auto_ctx, seps);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_count_active_separations(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_count_archive_entries()`. */
FZ_FUNCTION int ll_fz_count_archive_entries(::fz_archive *arch)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_count_archive_entries():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " arch=" << arch;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_count_archive_entries(auto_ctx, arch);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_count_archive_entries(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_count_chapter_pages()`. */
FZ_FUNCTION int ll_fz_count_chapter_pages(::fz_document *doc, int chapter)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_count_chapter_pages():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " chapter=" << chapter;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_count_chapter_pages(auto_ctx, doc, chapter);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_count_chapter_pages(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_count_chapters()`. */
FZ_FUNCTION int ll_fz_count_chapters(::fz_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_count_chapters():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_count_chapters(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_count_chapters(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_count_pages()`. */
FZ_FUNCTION int ll_fz_count_pages(::fz_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_count_pages():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_count_pages(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_count_pages(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_count_separations()`. */
FZ_FUNCTION int ll_fz_count_separations(const ::fz_separations *sep)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_count_separations():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " sep=" << sep;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_count_separations(auto_ctx, sep);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_count_separations(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_create_link()`. */
FZ_FUNCTION ::fz_link *ll_fz_create_link(::fz_page *page, ::fz_rect bbox, const char *uri)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_create_link():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " bbox=" << bbox;
		if (uri) std::cerr << " uri='" << uri << "'";
		else std::cerr << " uri:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_link * ret;
	fz_try(auto_ctx) {
		ret = ::fz_create_link(auto_ctx, page, bbox, uri);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_create_link(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_currentpoint()`. */
FZ_FUNCTION ::fz_point ll_fz_currentpoint(::fz_path *path)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_currentpoint():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " path=" << path;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_point ret;
	fz_try(auto_ctx) {
		ret = ::fz_currentpoint(auto_ctx, path);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_currentpoint(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_curveto()`. */
FZ_FUNCTION void ll_fz_curveto(::fz_path *path, float x0, float y0, float x1, float y1, float x2, float y2)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_curveto():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " path=" << path;
		std::cerr << " x0=" << x0;
		std::cerr << " y0=" << y0;
		std::cerr << " x1=" << x1;
		std::cerr << " y1=" << y1;
		std::cerr << " x2=" << x2;
		std::cerr << " y2=" << y2;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_curveto(auto_ctx, path, x0, y0, x1, y1, x2, y2);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_curveto(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_curvetov()`. */
FZ_FUNCTION void ll_fz_curvetov(::fz_path *path, float x1, float y1, float x2, float y2)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_curvetov():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " path=" << path;
		std::cerr << " x1=" << x1;
		std::cerr << " y1=" << y1;
		std::cerr << " x2=" << x2;
		std::cerr << " y2=" << y2;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_curvetov(auto_ctx, path, x1, y1, x2, y2);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_curvetov(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_curvetoy()`. */
FZ_FUNCTION void ll_fz_curvetoy(::fz_path *path, float x0, float y0, float x2, float y2)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_curvetoy():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " path=" << path;
		std::cerr << " x0=" << x0;
		std::cerr << " y0=" << y0;
		std::cerr << " x2=" << x2;
		std::cerr << " y2=" << y2;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_curvetoy(auto_ctx, path, x0, y0, x2, y2);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_curvetoy(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_debug_store()`. */
FZ_FUNCTION void ll_fz_debug_store(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_debug_store():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_debug_store(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_debug_store(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_debug_xml()`. */
FZ_FUNCTION void ll_fz_debug_xml(::fz_xml *item, int level)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_debug_xml():";
		if (s_trace > 1) std::cerr << " item=" << item;
		std::cerr << " level=" << level;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_debug_xml(item, level);
}

/** Low-level wrapper for `::fz_decode_tile()`. */
FZ_FUNCTION void ll_fz_decode_tile(::fz_pixmap *pix, const float *decode)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_decode_tile():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		if (s_trace > 1) std::cerr << " decode=" << (void*) decode;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_decode_tile(auto_ctx, pix, decode);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_decode_tile(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_decode_uri()`. */
FZ_FUNCTION char *ll_fz_decode_uri(const char *s)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_decode_uri():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s) std::cerr << " s='" << s << "'";
		else std::cerr << " s:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_decode_uri(auto_ctx, s);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_decode_uri(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_decode_uri_component()`. */
FZ_FUNCTION char *ll_fz_decode_uri_component(const char *s)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_decode_uri_component():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s) std::cerr << " s='" << s << "'";
		else std::cerr << " s:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_decode_uri_component(auto_ctx, s);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_decode_uri_component(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_decomp_image_from_stream()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_decomp_image_from_stream(::fz_stream *stm, ::fz_compressed_image *image, ::fz_irect *subarea, int indexed, int l2factor)` => `(fz_pixmap *, int l2extra)`
*/
FZ_FUNCTION ::fz_pixmap *ll_fz_decomp_image_from_stream(::fz_stream *stm, ::fz_compressed_image *image, ::fz_irect *subarea, int indexed, int l2factor, int *l2extra)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_decomp_image_from_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << " subarea=" << subarea;
		std::cerr << " indexed=" << indexed;
		std::cerr << " l2factor=" << l2factor;
		if (s_trace > 1) std::cerr << " l2extra=" << (void*) l2extra;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_decomp_image_from_stream(auto_ctx, stm, image, subarea, indexed, l2factor, l2extra);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_decomp_image_from_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_decouple_type3_font()`. */
FZ_FUNCTION void ll_fz_decouple_type3_font(::fz_font *font, void *t3doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_decouple_type3_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		if (s_trace > 1) std::cerr << " t3doc=" << (void*) t3doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_decouple_type3_font(auto_ctx, font, t3doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_decouple_type3_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_default_cmyk()`. */
FZ_FUNCTION ::fz_colorspace *ll_fz_default_cmyk(const ::fz_default_colorspaces *default_cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_default_cmyk():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " default_cs=" << default_cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::fz_default_cmyk(auto_ctx, default_cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_default_cmyk(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_default_error_callback()`. */
FZ_FUNCTION void ll_fz_default_error_callback(void *user, const char *message)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_default_error_callback():";
		if (s_trace > 1) std::cerr << " user=" << (void*) user;
		if (message) std::cerr << " message='" << message << "'";
		else std::cerr << " message:null";
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_default_error_callback(user, message);
}

/** Low-level wrapper for `::fz_default_gray()`. */
FZ_FUNCTION ::fz_colorspace *ll_fz_default_gray(const ::fz_default_colorspaces *default_cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_default_gray():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " default_cs=" << default_cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::fz_default_gray(auto_ctx, default_cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_default_gray(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_default_halftone()`. */
FZ_FUNCTION ::fz_halftone *ll_fz_default_halftone(int num_comps)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_default_halftone():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " num_comps=" << num_comps;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_halftone * ret;
	fz_try(auto_ctx) {
		ret = ::fz_default_halftone(auto_ctx, num_comps);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_default_halftone(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_default_output_intent()`. */
FZ_FUNCTION ::fz_colorspace *ll_fz_default_output_intent(const ::fz_default_colorspaces *default_cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_default_output_intent():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " default_cs=" << default_cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::fz_default_output_intent(auto_ctx, default_cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_default_output_intent(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_default_rgb()`. */
FZ_FUNCTION ::fz_colorspace *ll_fz_default_rgb(const ::fz_default_colorspaces *default_cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_default_rgb():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " default_cs=" << default_cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::fz_default_rgb(auto_ctx, default_cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_default_rgb(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_default_warning_callback()`. */
FZ_FUNCTION void ll_fz_default_warning_callback(void *user, const char *message)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_default_warning_callback():";
		if (s_trace > 1) std::cerr << " user=" << (void*) user;
		if (message) std::cerr << " message='" << message << "'";
		else std::cerr << " message:null";
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_default_warning_callback(user, message);
}

/** Low-level wrapper for `::fz_defer_reap_end()`. */
FZ_FUNCTION void ll_fz_defer_reap_end()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_defer_reap_end():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_defer_reap_end(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_defer_reap_end(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_defer_reap_start()`. */
FZ_FUNCTION void ll_fz_defer_reap_start()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_defer_reap_start():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_defer_reap_start(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_defer_reap_start(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_deflate()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_deflate(unsigned char *dest, const unsigned char *source, size_t source_length, ::fz_deflate_level level)` => size_t compressed_length
*/
FZ_FUNCTION void ll_fz_deflate(unsigned char *dest, size_t *compressed_length, const unsigned char *source, size_t source_length, ::fz_deflate_level level)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_deflate():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " dest=" << ((void*) dest);
		if (s_trace > 1) std::cerr << " compressed_length=" << (void*) compressed_length;
		std::cerr << " source=" << ((void*) source);
		std::cerr << " source_length=" << source_length;
		std::cerr << " level=" << level;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_deflate(auto_ctx, dest, compressed_length, source, source_length, level);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_deflate(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_deflate_bound()`. */
FZ_FUNCTION size_t ll_fz_deflate_bound(size_t size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_deflate_bound():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	size_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_deflate_bound(auto_ctx, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_deflate_bound(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_delete_link()`. */
FZ_FUNCTION void ll_fz_delete_link(::fz_page *page, ::fz_link *link)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_delete_link():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		if (s_trace > 1) std::cerr << " link=" << link;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_delete_link(auto_ctx, page, link);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_delete_link(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_detach_xml()`. */
FZ_FUNCTION void ll_fz_detach_xml(::fz_xml *node)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_detach_xml():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " node=" << node;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_detach_xml(auto_ctx, node);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_detach_xml(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_device_bgr()`. */
FZ_FUNCTION ::fz_colorspace *ll_fz_device_bgr()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_device_bgr():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::fz_device_bgr(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_device_bgr(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_device_cmyk()`. */
FZ_FUNCTION ::fz_colorspace *ll_fz_device_cmyk()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_device_cmyk():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::fz_device_cmyk(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_device_cmyk(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_device_current_scissor()`. */
FZ_FUNCTION ::fz_rect ll_fz_device_current_scissor(::fz_device *dev)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_device_current_scissor():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_rect ret;
	fz_try(auto_ctx) {
		ret = ::fz_device_current_scissor(auto_ctx, dev);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_device_current_scissor(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_device_gray()`. */
FZ_FUNCTION ::fz_colorspace *ll_fz_device_gray()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_device_gray():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::fz_device_gray(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_device_gray(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_device_lab()`. */
FZ_FUNCTION ::fz_colorspace *ll_fz_device_lab()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_device_lab():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::fz_device_lab(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_device_lab(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_device_rgb()`. */
FZ_FUNCTION ::fz_colorspace *ll_fz_device_rgb()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_device_rgb():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::fz_device_rgb(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_device_rgb(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_dirname()`. */
FZ_FUNCTION void ll_fz_dirname(char *dir, const char *path, size_t dirsize)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dirname():";
		if (s_trace > 1) std::cerr << " dir=" << (void*) dir;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		std::cerr << " dirsize=" << dirsize;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_dirname(dir, path, dirsize);
}

/** Low-level wrapper for `::fz_disable_device_hints()`. */
FZ_FUNCTION void ll_fz_disable_device_hints(::fz_device *dev, int hints)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_disable_device_hints():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " hints=" << hints;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_disable_device_hints(auto_ctx, dev, hints);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_disable_device_hints(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_disable_icc()`. */
FZ_FUNCTION void ll_fz_disable_icc()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_disable_icc():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_disable_icc(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_disable_icc(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_display_list_is_empty()`. */
FZ_FUNCTION int ll_fz_display_list_is_empty(const ::fz_display_list *list)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_display_list_is_empty():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " list=" << list;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_display_list_is_empty(auto_ctx, list);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_display_list_is_empty(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_div255()`. */
FZ_FUNCTION int ll_fz_div255(int c, int a)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_div255():";
		std::cerr << " c=" << c;
		std::cerr << " a=" << a;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_div255(c, a);
	return ret;
}

/** Low-level wrapper for `::fz_do_always()`. */
FZ_FUNCTION int ll_fz_do_always()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_do_always():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_do_always(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_do_always(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_do_catch()`. */
FZ_FUNCTION int ll_fz_do_catch()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_do_catch():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_do_catch(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_do_catch(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_do_try()`. */
FZ_FUNCTION int ll_fz_do_try()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_do_try():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_do_try(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_do_try(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_document_open_fn_call()`. */
FZ_FUNCTION ::fz_document *ll_fz_document_open_fn_call(::fz_document_open_fn fn, ::fz_stream *stream, ::fz_stream *accel, ::fz_archive *dir)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_document_open_fn_call():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " fn=" << fn;
		if (s_trace > 1) std::cerr << " stream=" << stream;
		if (s_trace > 1) std::cerr << " accel=" << accel;
		if (s_trace > 1) std::cerr << " dir=" << dir;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document * ret;
	fz_try(auto_ctx) {
		ret = ::fz_document_open_fn_call(auto_ctx, fn, stream, accel, dir);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_document_open_fn_call(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_document_output_intent()`. */
FZ_FUNCTION ::fz_colorspace *ll_fz_document_output_intent(::fz_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_document_output_intent():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::fz_document_output_intent(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_document_output_intent(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_document_recognize_content_fn_call()`. */
FZ_FUNCTION int ll_fz_document_recognize_content_fn_call(::fz_document_recognize_content_fn fn, ::fz_stream *stream, ::fz_archive *dir)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_document_recognize_content_fn_call():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " fn=" << fn;
		if (s_trace > 1) std::cerr << " stream=" << stream;
		if (s_trace > 1) std::cerr << " dir=" << dir;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_document_recognize_content_fn_call(auto_ctx, fn, stream, dir);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_document_recognize_content_fn_call(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_document_supports_accelerator()`. */
FZ_FUNCTION int ll_fz_document_supports_accelerator(::fz_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_document_supports_accelerator():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_document_supports_accelerator(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_document_supports_accelerator(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_dom_add_attribute()`. */
FZ_FUNCTION void ll_fz_dom_add_attribute(::fz_xml *elt, const char *att, const char *value)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dom_add_attribute():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " elt=" << elt;
		if (att) std::cerr << " att='" << att << "'";
		else std::cerr << " att:null";
		if (value) std::cerr << " value='" << value << "'";
		else std::cerr << " value:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_dom_add_attribute(auto_ctx, elt, att, value);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_dom_add_attribute(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_dom_append_child()`. */
FZ_FUNCTION void ll_fz_dom_append_child(::fz_xml *parent, ::fz_xml *child)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dom_append_child():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " parent=" << parent;
		if (s_trace > 1) std::cerr << " child=" << child;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_dom_append_child(auto_ctx, parent, child);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_dom_append_child(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_dom_attribute()`. */
FZ_FUNCTION const char *ll_fz_dom_attribute(::fz_xml *elt, const char *att)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dom_attribute():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " elt=" << elt;
		if (att) std::cerr << " att='" << att << "'";
		else std::cerr << " att:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_dom_attribute(auto_ctx, elt, att);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_dom_attribute(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_dom_body()`. */
FZ_FUNCTION ::fz_xml *ll_fz_dom_body(::fz_xml *dom)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dom_body():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dom=" << dom;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_xml * ret;
	fz_try(auto_ctx) {
		ret = ::fz_dom_body(auto_ctx, dom);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_dom_body(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_dom_clone()`. */
FZ_FUNCTION ::fz_xml *ll_fz_dom_clone(::fz_xml *elt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dom_clone():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " elt=" << elt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_xml * ret;
	fz_try(auto_ctx) {
		ret = ::fz_dom_clone(auto_ctx, elt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_dom_clone(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_dom_create_element()`. */
FZ_FUNCTION ::fz_xml *ll_fz_dom_create_element(::fz_xml *dom, const char *tag)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dom_create_element():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dom=" << dom;
		if (tag) std::cerr << " tag='" << tag << "'";
		else std::cerr << " tag:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_xml * ret;
	fz_try(auto_ctx) {
		ret = ::fz_dom_create_element(auto_ctx, dom, tag);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_dom_create_element(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_dom_create_text_node()`. */
FZ_FUNCTION ::fz_xml *ll_fz_dom_create_text_node(::fz_xml *dom, const char *text)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dom_create_text_node():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dom=" << dom;
		if (text) std::cerr << " text='" << text << "'";
		else std::cerr << " text:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_xml * ret;
	fz_try(auto_ctx) {
		ret = ::fz_dom_create_text_node(auto_ctx, dom, text);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_dom_create_text_node(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_dom_document_element()`. */
FZ_FUNCTION ::fz_xml *ll_fz_dom_document_element(::fz_xml *dom)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dom_document_element():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dom=" << dom;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_xml * ret;
	fz_try(auto_ctx) {
		ret = ::fz_dom_document_element(auto_ctx, dom);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_dom_document_element(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_dom_find()`. */
FZ_FUNCTION ::fz_xml *ll_fz_dom_find(::fz_xml *elt, const char *tag, const char *att, const char *match)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dom_find():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " elt=" << elt;
		if (tag) std::cerr << " tag='" << tag << "'";
		else std::cerr << " tag:null";
		if (att) std::cerr << " att='" << att << "'";
		else std::cerr << " att:null";
		if (match) std::cerr << " match='" << match << "'";
		else std::cerr << " match:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_xml * ret;
	fz_try(auto_ctx) {
		ret = ::fz_dom_find(auto_ctx, elt, tag, att, match);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_dom_find(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_dom_find_next()`. */
FZ_FUNCTION ::fz_xml *ll_fz_dom_find_next(::fz_xml *elt, const char *tag, const char *att, const char *match)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dom_find_next():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " elt=" << elt;
		if (tag) std::cerr << " tag='" << tag << "'";
		else std::cerr << " tag:null";
		if (att) std::cerr << " att='" << att << "'";
		else std::cerr << " att:null";
		if (match) std::cerr << " match='" << match << "'";
		else std::cerr << " match:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_xml * ret;
	fz_try(auto_ctx) {
		ret = ::fz_dom_find_next(auto_ctx, elt, tag, att, match);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_dom_find_next(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_dom_first_child()`. */
FZ_FUNCTION ::fz_xml *ll_fz_dom_first_child(::fz_xml *elt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dom_first_child():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " elt=" << elt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_xml * ret;
	fz_try(auto_ctx) {
		ret = ::fz_dom_first_child(auto_ctx, elt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_dom_first_child(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_dom_get_attribute()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_dom_get_attribute(::fz_xml *elt, int i)` => `(const char *, const char *att)`
*/
FZ_FUNCTION const char *ll_fz_dom_get_attribute(::fz_xml *elt, int i, const char **att)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dom_get_attribute():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " elt=" << elt;
		std::cerr << " i=" << i;
		if (s_trace > 1) std::cerr << " att=" << (void*) att;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_dom_get_attribute(auto_ctx, elt, i, att);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_dom_get_attribute(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_dom_insert_after()`. */
FZ_FUNCTION void ll_fz_dom_insert_after(::fz_xml *node, ::fz_xml *new_elt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dom_insert_after():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " node=" << node;
		if (s_trace > 1) std::cerr << " new_elt=" << new_elt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_dom_insert_after(auto_ctx, node, new_elt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_dom_insert_after(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_dom_insert_before()`. */
FZ_FUNCTION void ll_fz_dom_insert_before(::fz_xml *node, ::fz_xml *new_elt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dom_insert_before():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " node=" << node;
		if (s_trace > 1) std::cerr << " new_elt=" << new_elt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_dom_insert_before(auto_ctx, node, new_elt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_dom_insert_before(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_dom_next()`. */
FZ_FUNCTION ::fz_xml *ll_fz_dom_next(::fz_xml *elt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dom_next():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " elt=" << elt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_xml * ret;
	fz_try(auto_ctx) {
		ret = ::fz_dom_next(auto_ctx, elt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_dom_next(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_dom_parent()`. */
FZ_FUNCTION ::fz_xml *ll_fz_dom_parent(::fz_xml *elt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dom_parent():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " elt=" << elt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_xml * ret;
	fz_try(auto_ctx) {
		ret = ::fz_dom_parent(auto_ctx, elt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_dom_parent(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_dom_previous()`. */
FZ_FUNCTION ::fz_xml *ll_fz_dom_previous(::fz_xml *elt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dom_previous():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " elt=" << elt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_xml * ret;
	fz_try(auto_ctx) {
		ret = ::fz_dom_previous(auto_ctx, elt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_dom_previous(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_dom_remove()`. */
FZ_FUNCTION void ll_fz_dom_remove(::fz_xml *elt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dom_remove():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " elt=" << elt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_dom_remove(auto_ctx, elt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_dom_remove(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_dom_remove_attribute()`. */
FZ_FUNCTION void ll_fz_dom_remove_attribute(::fz_xml *elt, const char *att)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dom_remove_attribute():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " elt=" << elt;
		if (att) std::cerr << " att='" << att << "'";
		else std::cerr << " att:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_dom_remove_attribute(auto_ctx, elt, att);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_dom_remove_attribute(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_draw_story()`. */
FZ_FUNCTION void ll_fz_draw_story(::fz_story *story, ::fz_device *dev, ::fz_matrix ctm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_draw_story():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " story=" << story;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " ctm=" << ctm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_draw_story(auto_ctx, story, dev, ctm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_draw_story(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_archive()`. */
FZ_FUNCTION void ll_fz_drop_archive(::fz_archive *arch)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_archive():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " arch=" << arch;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_archive(auto_ctx, arch);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_archive(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_band_writer()`. */
FZ_FUNCTION void ll_fz_drop_band_writer(::fz_band_writer *writer)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_band_writer():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " writer=" << writer;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_band_writer(auto_ctx, writer);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_band_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_bitmap()`. */
FZ_FUNCTION void ll_fz_drop_bitmap(::fz_bitmap *bit)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_bitmap():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " bit=" << bit;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_bitmap(auto_ctx, bit);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_bitmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_buffer()`. */
FZ_FUNCTION void ll_fz_drop_buffer(::fz_buffer *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_buffer():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_buffer(auto_ctx, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_colorspace()`. */
FZ_FUNCTION void ll_fz_drop_colorspace(::fz_colorspace *colorspace)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_colorspace():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " colorspace=" << colorspace;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_colorspace(auto_ctx, colorspace);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_colorspace(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_colorspace_imp()`. */
FZ_FUNCTION void ll_fz_drop_colorspace_imp(::fz_storable *cs_)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_colorspace_imp():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " cs_=" << cs_;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_colorspace_imp(auto_ctx, cs_);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_colorspace_imp(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_compressed_buffer()`. */
FZ_FUNCTION void ll_fz_drop_compressed_buffer(::fz_compressed_buffer *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_compressed_buffer():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_compressed_buffer(auto_ctx, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_compressed_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_context()`. */
FZ_FUNCTION void ll_fz_drop_context()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_context():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_context(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_context(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_default_colorspaces()`. */
FZ_FUNCTION void ll_fz_drop_default_colorspaces(::fz_default_colorspaces *default_cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_default_colorspaces():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " default_cs=" << default_cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_default_colorspaces(auto_ctx, default_cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_default_colorspaces(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_device()`. */
FZ_FUNCTION void ll_fz_drop_device(::fz_device *dev)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_device():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " dev=" << dev;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_device(auto_ctx, dev);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_device(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_display_list()`. */
FZ_FUNCTION void ll_fz_drop_display_list(::fz_display_list *list)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_display_list():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " list=" << list;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_display_list(auto_ctx, list);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_display_list(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_document()`. */
FZ_FUNCTION void ll_fz_drop_document(::fz_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_document():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_document(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_document_writer()`. */
FZ_FUNCTION void ll_fz_drop_document_writer(::fz_document_writer *wri)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_document_writer():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " wri=" << wri;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_document_writer(auto_ctx, wri);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_document_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_font()`. */
FZ_FUNCTION void ll_fz_drop_font(::fz_font *font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_font():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_font(auto_ctx, font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_function()`. */
FZ_FUNCTION void ll_fz_drop_function(::fz_function *func)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_function():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " func=" << func;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_function(auto_ctx, func);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_function(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_glyph()`. */
FZ_FUNCTION void ll_fz_drop_glyph(::fz_glyph *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_glyph():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_glyph(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_glyph(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_halftone()`. */
FZ_FUNCTION void ll_fz_drop_halftone(::fz_halftone *ht)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_halftone():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " ht=" << ht;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_halftone(auto_ctx, ht);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_halftone(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_hash_table()`. */
FZ_FUNCTION void ll_fz_drop_hash_table(::fz_hash_table *table)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_hash_table():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " table=" << table;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_hash_table(auto_ctx, table);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_hash_table(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_image()`. */
FZ_FUNCTION void ll_fz_drop_image(::fz_image *image)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_image():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " image=" << image;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_image(auto_ctx, image);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_image(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_image_base()`. */
FZ_FUNCTION void ll_fz_drop_image_base(::fz_image *image)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_image_base():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " image=" << image;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_image_base(auto_ctx, image);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_image_base(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_image_imp()`. */
FZ_FUNCTION void ll_fz_drop_image_imp(::fz_storable *image)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_image_imp():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " image=" << image;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_image_imp(auto_ctx, image);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_image_imp(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_image_store_key()`. */
FZ_FUNCTION void ll_fz_drop_image_store_key(::fz_image *image)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_image_store_key():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " image=" << image;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_image_store_key(auto_ctx, image);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_image_store_key(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_imp()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_drop_imp(void *p)` => `(int, int refs)`
*/
FZ_FUNCTION int ll_fz_drop_imp(void *p, int *refs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_imp():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " p=" << (void*) p;
		if (s_trace_keepdrop) std::cerr << " refs=" << (void*) refs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_drop_imp(auto_ctx, p, refs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_imp(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_drop_imp16()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_drop_imp16(void *p)` => `(int, int16_t refs)`
*/
FZ_FUNCTION int ll_fz_drop_imp16(void *p, int16_t *refs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_imp16():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " p=" << (void*) p;
		if (s_trace_keepdrop) std::cerr << " refs=" << (void*) refs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_drop_imp16(auto_ctx, p, refs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_imp16(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_drop_imp8()`. */
FZ_FUNCTION int ll_fz_drop_imp8(void *p, int8_t *refs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_imp8():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " p=" << (void*) p;
		if (s_trace_keepdrop) std::cerr << " refs=" << (void*) refs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_drop_imp8(auto_ctx, p, refs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_imp8(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_drop_jbig2_globals()`. */
FZ_FUNCTION void ll_fz_drop_jbig2_globals(::fz_jbig2_globals *globals)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_jbig2_globals():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " globals=" << globals;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_jbig2_globals(auto_ctx, globals);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_jbig2_globals(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_jbig2_globals_imp()`. */
FZ_FUNCTION void ll_fz_drop_jbig2_globals_imp(::fz_storable *globals)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_jbig2_globals_imp():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " globals=" << globals;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_jbig2_globals_imp(auto_ctx, globals);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_jbig2_globals_imp(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_key_storable()`. */
FZ_FUNCTION void ll_fz_drop_key_storable(const ::fz_key_storable *arg_1)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_key_storable():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " arg_1=" << arg_1;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_key_storable(auto_ctx, arg_1);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_key_storable(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_key_storable_key()`. */
FZ_FUNCTION void ll_fz_drop_key_storable_key(const ::fz_key_storable *arg_1)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_key_storable_key():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " arg_1=" << arg_1;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_key_storable_key(auto_ctx, arg_1);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_key_storable_key(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_layout()`. */
FZ_FUNCTION void ll_fz_drop_layout(::fz_layout_block *block)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_layout():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " block=" << block;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_layout(auto_ctx, block);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_layout(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_link()`. */
FZ_FUNCTION void ll_fz_drop_link(::fz_link *link)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_link():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " link=" << link;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_link(auto_ctx, link);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_link(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_outline()`. */
FZ_FUNCTION void ll_fz_drop_outline(::fz_outline *outline)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_outline():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " outline=" << outline;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_outline(auto_ctx, outline);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_outline(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_outline_iterator()`. */
FZ_FUNCTION void ll_fz_drop_outline_iterator(::fz_outline_iterator *iter)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_outline_iterator():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " iter=" << iter;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_outline_iterator(auto_ctx, iter);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_outline_iterator(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_output()`. */
FZ_FUNCTION void ll_fz_drop_output(::fz_output *arg_1)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_output():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " arg_1=" << arg_1;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_output(auto_ctx, arg_1);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_page()`. */
FZ_FUNCTION void ll_fz_drop_page(::fz_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_page():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_page(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_path()`. */
FZ_FUNCTION void ll_fz_drop_path(const ::fz_path *path)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_path():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " path=" << path;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_path(auto_ctx, path);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_path(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_pixmap()`. */
FZ_FUNCTION void ll_fz_drop_pixmap(::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_pixmap():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_pixmap(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_pixmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_pool()`. */
FZ_FUNCTION void ll_fz_drop_pool(::fz_pool *pool)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_pool():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " pool=" << pool;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_pool(auto_ctx, pool);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_pool(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_separations()`. */
FZ_FUNCTION void ll_fz_drop_separations(::fz_separations *sep)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_separations():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " sep=" << sep;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_separations(auto_ctx, sep);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_separations(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_shade()`. */
FZ_FUNCTION void ll_fz_drop_shade(::fz_shade *shade)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_shade():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " shade=" << shade;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_shade(auto_ctx, shade);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_shade(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_shade_color_cache()`. */
FZ_FUNCTION void ll_fz_drop_shade_color_cache(::fz_shade_color_cache *cache)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_shade_color_cache():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " cache=" << cache;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_shade_color_cache(auto_ctx, cache);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_shade_color_cache(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_shade_imp()`. */
FZ_FUNCTION void ll_fz_drop_shade_imp(::fz_storable *shade)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_shade_imp():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " shade=" << shade;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_shade_imp(auto_ctx, shade);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_shade_imp(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_stext_page()`. */
FZ_FUNCTION void ll_fz_drop_stext_page(::fz_stext_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_stext_page():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_stext_page(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_stext_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_storable()`. */
FZ_FUNCTION void ll_fz_drop_storable(const ::fz_storable *arg_1)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_storable():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " arg_1=" << arg_1;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_storable(auto_ctx, arg_1);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_storable(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_store_context()`. */
FZ_FUNCTION void ll_fz_drop_store_context()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_store_context():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_store_context(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_store_context(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_story()`. */
FZ_FUNCTION void ll_fz_drop_story(::fz_story *story)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_story():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " story=" << story;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_story(auto_ctx, story);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_story(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_stream()`. */
FZ_FUNCTION void ll_fz_drop_stream(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_stream():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_stream(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_string()`. */
FZ_FUNCTION void ll_fz_drop_string(::fz_string *str)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_string():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " str=" << str;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_string(auto_ctx, str);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_stroke_state()`. */
FZ_FUNCTION void ll_fz_drop_stroke_state(const ::fz_stroke_state *stroke)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_stroke_state():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " stroke=" << stroke;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_stroke_state(auto_ctx, stroke);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_stroke_state(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_text()`. */
FZ_FUNCTION void ll_fz_drop_text(const ::fz_text *text)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_text():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " text=" << text;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_text(auto_ctx, text);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_text(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_tree()`. */
FZ_FUNCTION void ll_fz_drop_tree(::fz_tree *node, void (*dropfunc)(::fz_context *, void *))
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_tree():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " node=" << node;
		if (s_trace_keepdrop) std::cerr << " dropfunc=" << (void*) dropfunc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_tree(auto_ctx, node, dropfunc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_tree(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_xml()`. */
FZ_FUNCTION void ll_fz_drop_xml(::fz_xml *xml)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_xml():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " xml=" << xml;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_xml(auto_ctx, xml);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_xml(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_drop_zip_writer()`. */
FZ_FUNCTION void ll_fz_drop_zip_writer(::fz_zip_writer *zip)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_drop_zip_writer():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " zip=" << zip;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_drop_zip_writer(auto_ctx, zip);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_drop_zip_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_dump_glyph_cache_stats()`. */
FZ_FUNCTION void ll_fz_dump_glyph_cache_stats(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_dump_glyph_cache_stats():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_dump_glyph_cache_stats(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_dump_glyph_cache_stats(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_duplicate_glyph_names_from_unicode()`. */
FZ_FUNCTION const char **ll_fz_duplicate_glyph_names_from_unicode(int unicode)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_duplicate_glyph_names_from_unicode():";
		std::cerr << " unicode=" << unicode;
		std::cerr << "\n";
	}
	#endif
	const char ** ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_duplicate_glyph_names_from_unicode(unicode);
	return ret;
}

/** Low-level wrapper for `::fz_empty_store()`. */
FZ_FUNCTION void ll_fz_empty_store()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_empty_store():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_empty_store(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_empty_store(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_enable_device_hints()`. */
FZ_FUNCTION void ll_fz_enable_device_hints(::fz_device *dev, int hints)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_enable_device_hints():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " hints=" << hints;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_enable_device_hints(auto_ctx, dev, hints);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_enable_device_hints(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_enable_icc()`. */
FZ_FUNCTION void ll_fz_enable_icc()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_enable_icc():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_enable_icc(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_enable_icc(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_encode_character()`. */
FZ_FUNCTION int ll_fz_encode_character(::fz_font *font, int unicode)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_encode_character():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " unicode=" << unicode;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_encode_character(auto_ctx, font, unicode);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_encode_character(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_encode_character_by_glyph_name()`. */
FZ_FUNCTION int ll_fz_encode_character_by_glyph_name(::fz_font *font, const char *glyphname)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_encode_character_by_glyph_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		if (glyphname) std::cerr << " glyphname='" << glyphname << "'";
		else std::cerr << " glyphname:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_encode_character_by_glyph_name(auto_ctx, font, glyphname);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_encode_character_by_glyph_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_encode_character_sc()`. */
FZ_FUNCTION int ll_fz_encode_character_sc(::fz_font *font, int unicode)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_encode_character_sc():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " unicode=" << unicode;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_encode_character_sc(auto_ctx, font, unicode);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_encode_character_sc(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_encode_character_with_fallback()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_encode_character_with_fallback(::fz_font *font, int unicode, int script, int language, ::fz_font **out_font)` => `(int)`
*/
FZ_FUNCTION int ll_fz_encode_character_with_fallback(::fz_font *font, int unicode, int script, int language, ::fz_font **out_font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_encode_character_with_fallback():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " unicode=" << unicode;
		std::cerr << " script=" << script;
		std::cerr << " language=" << language;
		if (s_trace > 1) std::cerr << " out_font=" << (void*) out_font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_encode_character_with_fallback(auto_ctx, font, unicode, script, language, out_font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_encode_character_with_fallback(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_encode_uri()`. */
FZ_FUNCTION char *ll_fz_encode_uri(const char *s)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_encode_uri():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s) std::cerr << " s='" << s << "'";
		else std::cerr << " s:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_encode_uri(auto_ctx, s);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_encode_uri(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_encode_uri_component()`. */
FZ_FUNCTION char *ll_fz_encode_uri_component(const char *s)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_encode_uri_component():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s) std::cerr << " s='" << s << "'";
		else std::cerr << " s:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_encode_uri_component(auto_ctx, s);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_encode_uri_component(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_encode_uri_pathname()`. */
FZ_FUNCTION char *ll_fz_encode_uri_pathname(const char *s)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_encode_uri_pathname():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s) std::cerr << " s='" << s << "'";
		else std::cerr << " s:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_encode_uri_pathname(auto_ctx, s);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_encode_uri_pathname(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_end_group()`. */
FZ_FUNCTION void ll_fz_end_group(::fz_device *dev)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_end_group():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_end_group(auto_ctx, dev);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_end_group(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_end_layer()`. */
FZ_FUNCTION void ll_fz_end_layer(::fz_device *dev)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_end_layer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_end_layer(auto_ctx, dev);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_end_layer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_end_mask()`. */
FZ_FUNCTION void ll_fz_end_mask(::fz_device *dev)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_end_mask():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_end_mask(auto_ctx, dev);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_end_mask(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_end_mask_tr()`. */
FZ_FUNCTION void ll_fz_end_mask_tr(::fz_device *dev, ::fz_function *fn)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_end_mask_tr():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		if (s_trace > 1) std::cerr << " fn=" << fn;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_end_mask_tr(auto_ctx, dev, fn);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_end_mask_tr(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_end_metatext()`. */
FZ_FUNCTION void ll_fz_end_metatext(::fz_device *dev)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_end_metatext():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_end_metatext(auto_ctx, dev);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_end_metatext(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_end_page()`. */
FZ_FUNCTION void ll_fz_end_page(::fz_document_writer *wri)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_end_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " wri=" << wri;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_end_page(auto_ctx, wri);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_end_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_end_structure()`. */
FZ_FUNCTION void ll_fz_end_structure(::fz_device *dev)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_end_structure():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_end_structure(auto_ctx, dev);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_end_structure(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_end_throw_on_repair()`. */
FZ_FUNCTION void ll_fz_end_throw_on_repair()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_end_throw_on_repair():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_end_throw_on_repair(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_end_throw_on_repair(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_end_tile()`. */
FZ_FUNCTION void ll_fz_end_tile(::fz_device *dev)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_end_tile():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_end_tile(auto_ctx, dev);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_end_tile(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_error_callback()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_error_callback()` => `(fz_error_cb *, void *user)`
*/
FZ_FUNCTION ::fz_error_cb *ll_fz_error_callback(void **user)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_error_callback():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " user=" << (void*) user;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_error_cb * ret;
	fz_try(auto_ctx) {
		ret = ::fz_error_callback(auto_ctx, user);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_error_callback(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_eval_function()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_eval_function(::fz_function *func, const float *in, int inlen, int outlen)` => float out
*/
FZ_FUNCTION void ll_fz_eval_function(::fz_function *func, const float *in, int inlen, float *out, int outlen)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_eval_function():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " func=" << func;
		if (s_trace > 1) std::cerr << " in=" << (void*) in;
		std::cerr << " inlen=" << inlen;
		if (s_trace > 1) std::cerr << " out=" << (void*) out;
		std::cerr << " outlen=" << outlen;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_eval_function(auto_ctx, func, in, inlen, out, outlen);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_eval_function(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_expand_irect()`. */
FZ_FUNCTION ::fz_irect ll_fz_expand_irect(::fz_irect a, int expand)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_expand_irect():";
		std::cerr << " a=" << a;
		std::cerr << " expand=" << expand;
		std::cerr << "\n";
	}
	#endif
	fz_irect ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_expand_irect(a, expand);
	return ret;
}

/** Low-level wrapper for `::fz_expand_rect()`. */
FZ_FUNCTION ::fz_rect ll_fz_expand_rect(::fz_rect b, float expand)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_expand_rect():";
		std::cerr << " b=" << b;
		std::cerr << " expand=" << expand;
		std::cerr << "\n";
	}
	#endif
	fz_rect ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_expand_rect(b, expand);
	return ret;
}

/** Low-level wrapper for `::fz_extract_ttf_from_ttc()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_extract_ttf_from_ttc(::fz_font *font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_extract_ttf_from_ttc():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_extract_ttf_from_ttc(auto_ctx, font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_extract_ttf_from_ttc(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_file_exists()`. */
FZ_FUNCTION int ll_fz_file_exists(const char *path)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_file_exists():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_file_exists(auto_ctx, path);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_file_exists(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_fill_image()`. */
FZ_FUNCTION void ll_fz_fill_image(::fz_device *dev, ::fz_image *image, ::fz_matrix ctm, float alpha, ::fz_color_params color_params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_fill_image():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << " ctm=" << ctm;
		std::cerr << " alpha=" << alpha;
		std::cerr << " color_params=" << color_params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_fill_image(auto_ctx, dev, image, ctm, alpha, color_params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_fill_image(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_fill_image_mask()`. */
FZ_FUNCTION void ll_fz_fill_image_mask(::fz_device *dev, ::fz_image *image, ::fz_matrix ctm, ::fz_colorspace *colorspace, const float *color, float alpha, ::fz_color_params color_params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_fill_image_mask():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " colorspace=" << colorspace;
		if (s_trace > 1) std::cerr << " color=" << (void*) color;
		std::cerr << " alpha=" << alpha;
		std::cerr << " color_params=" << color_params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_fill_image_mask(auto_ctx, dev, image, ctm, colorspace, color, alpha, color_params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_fill_image_mask(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_fill_path()`. */
FZ_FUNCTION void ll_fz_fill_path(::fz_device *dev, const ::fz_path *path, int even_odd, ::fz_matrix ctm, ::fz_colorspace *colorspace, const float *color, float alpha, ::fz_color_params color_params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_fill_path():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		if (s_trace > 1) std::cerr << " path=" << path;
		std::cerr << " even_odd=" << even_odd;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " colorspace=" << colorspace;
		if (s_trace > 1) std::cerr << " color=" << (void*) color;
		std::cerr << " alpha=" << alpha;
		std::cerr << " color_params=" << color_params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_fill_path(auto_ctx, dev, path, even_odd, ctm, colorspace, color, alpha, color_params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_fill_path(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_fill_pixmap_from_display_list()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_fill_pixmap_from_display_list(::fz_display_list *list, ::fz_matrix ctm, ::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_fill_pixmap_from_display_list():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " list=" << list;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_fill_pixmap_from_display_list(auto_ctx, list, ctm, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_fill_pixmap_from_display_list(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_fill_pixmap_with_color()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_fill_pixmap_with_color(::fz_pixmap *pix, ::fz_colorspace *colorspace, ::fz_color_params color_params)` => float color
*/
FZ_FUNCTION void ll_fz_fill_pixmap_with_color(::fz_pixmap *pix, ::fz_colorspace *colorspace, float *color, ::fz_color_params color_params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_fill_pixmap_with_color():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		if (s_trace > 1) std::cerr << " colorspace=" << colorspace;
		if (s_trace > 1) std::cerr << " color=" << (void*) color;
		std::cerr << " color_params=" << color_params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_fill_pixmap_with_color(auto_ctx, pix, colorspace, color, color_params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_fill_pixmap_with_color(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_fill_shade()`. */
FZ_FUNCTION void ll_fz_fill_shade(::fz_device *dev, ::fz_shade *shade, ::fz_matrix ctm, float alpha, ::fz_color_params color_params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_fill_shade():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		if (s_trace > 1) std::cerr << " shade=" << shade;
		std::cerr << " ctm=" << ctm;
		std::cerr << " alpha=" << alpha;
		std::cerr << " color_params=" << color_params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_fill_shade(auto_ctx, dev, shade, ctm, alpha, color_params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_fill_shade(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_fill_text()`. */
FZ_FUNCTION void ll_fz_fill_text(::fz_device *dev, const ::fz_text *text, ::fz_matrix ctm, ::fz_colorspace *colorspace, const float *color, float alpha, ::fz_color_params color_params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_fill_text():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		if (s_trace > 1) std::cerr << " text=" << text;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " colorspace=" << colorspace;
		if (s_trace > 1) std::cerr << " color=" << (void*) color;
		std::cerr << " alpha=" << alpha;
		std::cerr << " color_params=" << color_params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_fill_text(auto_ctx, dev, text, ctm, colorspace, color, alpha, color_params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_fill_text(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_filter_store()`. */
FZ_FUNCTION void ll_fz_filter_store(::fz_store_filter_fn *fn, void *arg, const ::fz_store_type *type)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_filter_store():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " fn=" << (void*) fn;
		if (s_trace > 1) std::cerr << " arg=" << (void*) arg;
		if (s_trace > 1) std::cerr << " type=" << type;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_filter_store(auto_ctx, fn, arg, type);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_filter_store(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_find_item()`. */
FZ_FUNCTION void *ll_fz_find_item(::fz_store_drop_fn *drop, void *key, const ::fz_store_type *type)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_find_item():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " drop=" << (void*) drop;
		if (s_trace > 1) std::cerr << " key=" << (void*) key;
		if (s_trace > 1) std::cerr << " type=" << type;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_find_item(auto_ctx, drop, key, type);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_find_item(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_flush_output()`. */
FZ_FUNCTION void ll_fz_flush_output(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_flush_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_flush_output(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_flush_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_flush_warnings()`. */
FZ_FUNCTION void ll_fz_flush_warnings()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_flush_warnings():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_flush_warnings(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_flush_warnings(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_font_ascender()`. */
FZ_FUNCTION float ll_fz_font_ascender(::fz_font *font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_font_ascender():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	float ret;
	fz_try(auto_ctx) {
		ret = ::fz_font_ascender(auto_ctx, font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_font_ascender(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_font_bbox()`. */
FZ_FUNCTION ::fz_rect ll_fz_font_bbox(::fz_font *font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_font_bbox():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_rect ret;
	fz_try(auto_ctx) {
		ret = ::fz_font_bbox(auto_ctx, font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_font_bbox(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_font_descender()`. */
FZ_FUNCTION float ll_fz_font_descender(::fz_font *font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_font_descender():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	float ret;
	fz_try(auto_ctx) {
		ret = ::fz_font_descender(auto_ctx, font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_font_descender(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_font_digest()`. */
FZ_FUNCTION void ll_fz_font_digest(::fz_font *font, unsigned char digest[16])
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_font_digest():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " digest=" << digest;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_font_digest(auto_ctx, font, digest);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_font_digest(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_font_flags()`. */
FZ_FUNCTION ::fz_font_flags_t *ll_fz_font_flags(::fz_font *font)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_font_flags():";
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	fz_font_flags_t * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_font_flags(font);
	return ret;
}

/** Low-level wrapper for `::fz_font_ft_face()`. */
FZ_FUNCTION void *ll_fz_font_ft_face(::fz_font *font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_font_ft_face():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_font_ft_face(auto_ctx, font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_font_ft_face(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_font_is_bold()`. */
FZ_FUNCTION int ll_fz_font_is_bold(::fz_font *font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_font_is_bold():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_font_is_bold(auto_ctx, font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_font_is_bold(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_font_is_italic()`. */
FZ_FUNCTION int ll_fz_font_is_italic(::fz_font *font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_font_is_italic():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_font_is_italic(auto_ctx, font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_font_is_italic(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_font_is_monospaced()`. */
FZ_FUNCTION int ll_fz_font_is_monospaced(::fz_font *font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_font_is_monospaced():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_font_is_monospaced(auto_ctx, font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_font_is_monospaced(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_font_is_serif()`. */
FZ_FUNCTION int ll_fz_font_is_serif(::fz_font *font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_font_is_serif():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_font_is_serif(auto_ctx, font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_font_is_serif(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_font_name()`. */
FZ_FUNCTION const char *ll_fz_font_name(::fz_font *font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_font_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_font_name(auto_ctx, font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_font_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_font_shaper_data()`. */
FZ_FUNCTION ::fz_shaper_data_t *ll_fz_font_shaper_data(::fz_font *font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_font_shaper_data():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_shaper_data_t * ret;
	fz_try(auto_ctx) {
		ret = ::fz_font_shaper_data(auto_ctx, font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_font_shaper_data(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_font_t3_procs()`. */
FZ_FUNCTION ::fz_buffer **ll_fz_font_t3_procs(::fz_font *font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_font_t3_procs():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer ** ret;
	fz_try(auto_ctx) {
		ret = ::fz_font_t3_procs(auto_ctx, font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_font_t3_procs(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_format_double()`. */
FZ_FUNCTION std::string ll_fz_format_double(const char *fmt, double value)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_format_double():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (fmt) std::cerr << " fmt='" << fmt << "'";
		else std::cerr << " fmt:null";
		std::cerr << " value=" << value;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	std::string ret;
	fz_try(auto_ctx) {
		ret = ::fz_format_double(auto_ctx, fmt, value);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_format_double(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_format_link_uri()`. */
FZ_FUNCTION char *ll_fz_format_link_uri(::fz_document *doc, ::fz_link_dest dest)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_format_link_uri():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " &dest=" << &dest;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_format_link_uri(auto_ctx, doc, dest);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_format_link_uri(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_format_output_path()`. */
FZ_FUNCTION void ll_fz_format_output_path(char *path, size_t size, const char *fmt, int page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_format_output_path():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " path=" << (void*) path;
		std::cerr << " size=" << size;
		if (fmt) std::cerr << " fmt='" << fmt << "'";
		else std::cerr << " fmt:null";
		std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_format_output_path(auto_ctx, path, size, fmt, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_format_output_path(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_format_string()`. */
FZ_FUNCTION void ll_fz_format_string(void *user, void (*emit)(::fz_context *, void *, int ), const char *fmt, va_list args)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_format_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " user=" << (void*) user;
		if (s_trace > 1) std::cerr << " emit=" << (void*) emit;
		if (fmt) std::cerr << " fmt='" << fmt << "'";
		else std::cerr << " fmt:null";
		std::cerr << " args:va_list";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_format_string(auto_ctx, user, emit, fmt, args);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_format_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_free()`. */
FZ_FUNCTION void ll_fz_free(void *p)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_free():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " p=" << (void*) p;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_free(auto_ctx, p);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_free(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_ft_lock()`. */
FZ_FUNCTION void ll_fz_ft_lock()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_ft_lock():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_ft_lock(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_ft_lock(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_ft_lock_held()`. */
FZ_FUNCTION int ll_fz_ft_lock_held()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_ft_lock_held():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_ft_lock_held(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_ft_lock_held(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_ft_unlock()`. */
FZ_FUNCTION void ll_fz_ft_unlock()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_ft_unlock():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_ft_unlock(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_ft_unlock(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_function_size()`. */
FZ_FUNCTION size_t ll_fz_function_size(::fz_function *func)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_function_size():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " func=" << func;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	size_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_function_size(auto_ctx, func);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_function_size(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_gamma_pixmap()`. */
FZ_FUNCTION void ll_fz_gamma_pixmap(::fz_pixmap *pix, float gamma)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_gamma_pixmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << " gamma=" << gamma;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_gamma_pixmap(auto_ctx, pix, gamma);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_gamma_pixmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_generate_transition()`. */
FZ_FUNCTION int ll_fz_generate_transition(::fz_pixmap *tpix, ::fz_pixmap *opix, ::fz_pixmap *npix, int time, ::fz_transition *trans)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_generate_transition():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " tpix=" << tpix;
		if (s_trace > 1) std::cerr << " opix=" << opix;
		if (s_trace > 1) std::cerr << " npix=" << npix;
		std::cerr << " time=" << time;
		std::cerr << " trans=" << trans;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_generate_transition(auto_ctx, tpix, opix, npix, time, trans);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_generate_transition(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_get_glyph_name()`. */
FZ_FUNCTION void ll_fz_get_glyph_name(::fz_font *font, int glyph, char *buf, int size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_get_glyph_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " glyph=" << glyph;
		if (s_trace > 1) std::cerr << " buf=" << (void*) buf;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_get_glyph_name(auto_ctx, font, glyph, buf, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_get_glyph_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_get_glyph_name2()`. */
FZ_FUNCTION std::string ll_fz_get_glyph_name2(::fz_font *font, int glyph)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_get_glyph_name2():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " glyph=" << glyph;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	std::string ret;
	fz_try(auto_ctx) {
		ret = ::fz_get_glyph_name2(auto_ctx, font, glyph);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_get_glyph_name2(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_get_pixmap_from_image()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_get_pixmap_from_image(::fz_image *image, const ::fz_irect *subarea, ::fz_matrix *ctm)` => `(fz_pixmap *, int w, int h)`
*/
FZ_FUNCTION ::fz_pixmap *ll_fz_get_pixmap_from_image(::fz_image *image, const ::fz_irect *subarea, ::fz_matrix *ctm, int *w, int *h)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_get_pixmap_from_image():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << " subarea=" << subarea;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " w=" << (void*) w;
		if (s_trace > 1) std::cerr << " h=" << (void*) h;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_get_pixmap_from_image(auto_ctx, image, subarea, ctm, w, h);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_get_pixmap_from_image(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_get_unscaled_pixmap_from_image()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_get_unscaled_pixmap_from_image(::fz_image *image)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_get_unscaled_pixmap_from_image():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_get_unscaled_pixmap_from_image(auto_ctx, image);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_get_unscaled_pixmap_from_image(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_getopt()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_getopt(int nargc, const char *ostr)` => `(int, char *nargv)`
*/
FZ_FUNCTION int ll_fz_getopt(int nargc, char **nargv, const char *ostr)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_getopt():";
		std::cerr << " nargc=" << nargc;
		if (s_trace > 1) std::cerr << " nargv=" << (void*) nargv;
		if (ostr) std::cerr << " ostr='" << ostr << "'";
		else std::cerr << " ostr:null";
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_getopt(nargc, nargv, ostr);
	return ret;
}

/** Low-level wrapper for `::fz_getopt_long()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_getopt_long(int nargc, const char *ostr, const ::fz_getopt_long_options *longopts)` => `(int, char *nargv)`
*/
FZ_FUNCTION int ll_fz_getopt_long(int nargc, char **nargv, const char *ostr, const ::fz_getopt_long_options *longopts)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_getopt_long():";
		std::cerr << " nargc=" << nargc;
		if (s_trace > 1) std::cerr << " nargv=" << (void*) nargv;
		if (ostr) std::cerr << " ostr='" << ostr << "'";
		else std::cerr << " ostr:null";
		if (s_trace > 1) std::cerr << " longopts=" << longopts;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_getopt_long(nargc, nargv, ostr, longopts);
	return ret;
}

/** Low-level wrapper for `::fz_glyph_bbox()`. */
FZ_FUNCTION ::fz_irect ll_fz_glyph_bbox(::fz_glyph *glyph)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_glyph_bbox():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " glyph=" << glyph;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_irect ret;
	fz_try(auto_ctx) {
		ret = ::fz_glyph_bbox(auto_ctx, glyph);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_glyph_bbox(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_glyph_bbox_no_ctx()`. */
FZ_FUNCTION ::fz_irect ll_fz_glyph_bbox_no_ctx(::fz_glyph *src)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_glyph_bbox_no_ctx():";
		if (s_trace > 1) std::cerr << " src=" << src;
		std::cerr << "\n";
	}
	#endif
	fz_irect ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_glyph_bbox_no_ctx(src);
	return ret;
}

/** Low-level wrapper for `::fz_glyph_cacheable()`. */
FZ_FUNCTION int ll_fz_glyph_cacheable(::fz_font *font, int gid)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_glyph_cacheable():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " gid=" << gid;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_glyph_cacheable(auto_ctx, font, gid);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_glyph_cacheable(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_glyph_height()`. */
FZ_FUNCTION int ll_fz_glyph_height(::fz_glyph *glyph)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_glyph_height():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " glyph=" << glyph;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_glyph_height(auto_ctx, glyph);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_glyph_height(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_glyph_name_from_unicode_sc()`. */
FZ_FUNCTION const char *ll_fz_glyph_name_from_unicode_sc(int unicode)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_glyph_name_from_unicode_sc():";
		std::cerr << " unicode=" << unicode;
		std::cerr << "\n";
	}
	#endif
	const char * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_glyph_name_from_unicode_sc(unicode);
	return ret;
}

/** Low-level wrapper for `::fz_glyph_width()`. */
FZ_FUNCTION int ll_fz_glyph_width(::fz_glyph *glyph)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_glyph_width():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " glyph=" << glyph;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_glyph_width(auto_ctx, glyph);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_glyph_width(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_graphics_aa_level()`. */
FZ_FUNCTION int ll_fz_graphics_aa_level()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_graphics_aa_level():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_graphics_aa_level(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_graphics_aa_level(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_graphics_min_line_width()`. */
FZ_FUNCTION float ll_fz_graphics_min_line_width()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_graphics_min_line_width():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	float ret;
	fz_try(auto_ctx) {
		ret = ::fz_graphics_min_line_width(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_graphics_min_line_width(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_gridfit_matrix()`. */
FZ_FUNCTION ::fz_matrix ll_fz_gridfit_matrix(int as_tiled, ::fz_matrix m)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_gridfit_matrix():";
		std::cerr << " as_tiled=" << as_tiled;
		std::cerr << " m=" << m;
		std::cerr << "\n";
	}
	#endif
	fz_matrix ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_gridfit_matrix(as_tiled, m);
	return ret;
}

/** Low-level wrapper for `::fz_grisu()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_grisu(float f, char *s)` => `(int, int exp)`
*/
FZ_FUNCTION int ll_fz_grisu(float f, char *s, int *exp)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_grisu():";
		std::cerr << " f=" << f;
		if (s_trace > 1) std::cerr << " s=" << (void*) s;
		if (s_trace > 1) std::cerr << " exp=" << (void*) exp;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_grisu(f, s, exp);
	return ret;
}

/** Low-level wrapper for `::fz_grow_buffer()`. */
FZ_FUNCTION void ll_fz_grow_buffer(::fz_buffer *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_grow_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_grow_buffer(auto_ctx, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_grow_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_has_archive_entry()`. */
FZ_FUNCTION int ll_fz_has_archive_entry(::fz_archive *arch, const char *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_has_archive_entry():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " arch=" << arch;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_has_archive_entry(auto_ctx, arch, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_has_archive_entry(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_has_option()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_has_option(const char *opts, const char *key)` => `(int, const char *val)`
*/
FZ_FUNCTION int ll_fz_has_option(const char *opts, const char *key, const char **val)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_has_option():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (opts) std::cerr << " opts='" << opts << "'";
		else std::cerr << " opts:null";
		if (key) std::cerr << " key='" << key << "'";
		else std::cerr << " key:null";
		if (s_trace > 1) std::cerr << " val=" << (void*) val;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_has_option(auto_ctx, opts, key, val);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_has_option(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_has_permission()`. */
FZ_FUNCTION int ll_fz_has_permission(::fz_document *doc, ::fz_permission p)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_has_permission():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " p=" << p;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_has_permission(auto_ctx, doc, p);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_has_permission(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_hash_filter()`. */
FZ_FUNCTION void ll_fz_hash_filter(::fz_hash_table *table, void *state, ::fz_hash_table_filter_fn *callback)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_hash_filter():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " table=" << table;
		if (s_trace > 1) std::cerr << " state=" << (void*) state;
		if (s_trace > 1) std::cerr << " callback=" << (void*) callback;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_hash_filter(auto_ctx, table, state, callback);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_hash_filter(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_hash_find()`. */
FZ_FUNCTION void *ll_fz_hash_find(::fz_hash_table *table, const void *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_hash_find():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " table=" << table;
		if (s_trace > 1) std::cerr << " key=" << (void*) key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_hash_find(auto_ctx, table, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_hash_find(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_hash_for_each()`. */
FZ_FUNCTION void ll_fz_hash_for_each(::fz_hash_table *table, void *state, ::fz_hash_table_for_each_fn *callback)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_hash_for_each():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " table=" << table;
		if (s_trace > 1) std::cerr << " state=" << (void*) state;
		if (s_trace > 1) std::cerr << " callback=" << (void*) callback;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_hash_for_each(auto_ctx, table, state, callback);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_hash_for_each(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_hash_insert()`. */
FZ_FUNCTION void *ll_fz_hash_insert(::fz_hash_table *table, const void *key, void *val)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_hash_insert():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " table=" << table;
		if (s_trace > 1) std::cerr << " key=" << (void*) key;
		if (s_trace > 1) std::cerr << " val=" << (void*) val;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_hash_insert(auto_ctx, table, key, val);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_hash_insert(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_hash_remove()`. */
FZ_FUNCTION void ll_fz_hash_remove(::fz_hash_table *table, const void *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_hash_remove():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " table=" << table;
		if (s_trace > 1) std::cerr << " key=" << (void*) key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_hash_remove(auto_ctx, table, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_hash_remove(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_hb_lock()`. */
FZ_FUNCTION void ll_fz_hb_lock()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_hb_lock():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_hb_lock(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_hb_lock(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_hb_unlock()`. */
FZ_FUNCTION void ll_fz_hb_unlock()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_hb_unlock():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_hb_unlock(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_hb_unlock(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_highlight_selection()`. */
FZ_FUNCTION int ll_fz_highlight_selection(::fz_stext_page *page, ::fz_point a, ::fz_point b, ::fz_quad *quads, int max_quads)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_highlight_selection():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << " quads=" << quads;
		std::cerr << " max_quads=" << max_quads;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_highlight_selection(auto_ctx, page, a, b, quads, max_quads);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_highlight_selection(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_highlight_selection2()`. */
FZ_FUNCTION std::vector<fz_quad> ll_fz_highlight_selection2(::fz_stext_page *page, ::fz_point a, ::fz_point b, int max_quads)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_highlight_selection2():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << " max_quads=" << max_quads;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	std::vector<fz_quad> ret;
	fz_try(auto_ctx) {
		ret = ::fz_highlight_selection2(auto_ctx, page, a, b, max_quads);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_highlight_selection2(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_ignore_error()`. */
FZ_FUNCTION void ll_fz_ignore_error()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_ignore_error():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_ignore_error(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_ignore_error(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_ignore_text()`. */
FZ_FUNCTION void ll_fz_ignore_text(::fz_device *dev, const ::fz_text *text, ::fz_matrix ctm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_ignore_text():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		if (s_trace > 1) std::cerr << " text=" << text;
		std::cerr << " ctm=" << ctm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_ignore_text(auto_ctx, dev, text, ctm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_ignore_text(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_image_orientation()`. */
FZ_FUNCTION uint8_t ll_fz_image_orientation(::fz_image *image)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_image_orientation():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	uint8_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_image_orientation(auto_ctx, image);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_image_orientation(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_image_orientation_matrix()`. */
FZ_FUNCTION ::fz_matrix ll_fz_image_orientation_matrix(::fz_image *image)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_image_orientation_matrix():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_matrix ret;
	fz_try(auto_ctx) {
		ret = ::fz_image_orientation_matrix(auto_ctx, image);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_image_orientation_matrix(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_image_resolution()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_image_resolution(::fz_image *image)` => `(int xres, int yres)`
*/
FZ_FUNCTION void ll_fz_image_resolution(::fz_image *image, int *xres, int *yres)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_image_resolution():";
		if (s_trace > 1) std::cerr << " image=" << image;
		if (s_trace > 1) std::cerr << " xres=" << (void*) xres;
		if (s_trace > 1) std::cerr << " yres=" << (void*) yres;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_image_resolution(image, xres, yres);
}

/** Low-level wrapper for `::fz_image_size()`. */
FZ_FUNCTION size_t ll_fz_image_size(::fz_image *im)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_image_size():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " im=" << im;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	size_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_image_size(auto_ctx, im);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_image_size(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_image_type_name()`. */
FZ_FUNCTION const char *ll_fz_image_type_name(int type)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_image_type_name():";
		std::cerr << " type=" << type;
		std::cerr << "\n";
	}
	#endif
	const char * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_image_type_name(type);
	return ret;
}

/** Low-level wrapper for `::fz_include_point_in_rect()`. */
FZ_FUNCTION ::fz_rect ll_fz_include_point_in_rect(::fz_rect r, ::fz_point p)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_include_point_in_rect():";
		std::cerr << " r=" << r;
		std::cerr << " p=" << p;
		std::cerr << "\n";
	}
	#endif
	fz_rect ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_include_point_in_rect(r, p);
	return ret;
}

/** Low-level wrapper for `::fz_init_text_decoder()`. */
FZ_FUNCTION void ll_fz_init_text_decoder(::fz_text_decoder *dec, const char *encoding)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_init_text_decoder():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dec=" << dec;
		if (encoding) std::cerr << " encoding='" << encoding << "'";
		else std::cerr << " encoding:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_init_text_decoder(auto_ctx, dec, encoding);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_init_text_decoder(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_install_load_system_font_funcs()`. */
FZ_FUNCTION void ll_fz_install_load_system_font_funcs(::fz_load_system_font_fn *f, ::fz_load_system_cjk_font_fn *f_cjk, ::fz_load_system_fallback_font_fn *f_fallback)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_install_load_system_font_funcs():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " f=" << (void*) f;
		if (s_trace > 1) std::cerr << " f_cjk=" << (void*) f_cjk;
		if (s_trace > 1) std::cerr << " f_fallback=" << (void*) f_fallback;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_install_load_system_font_funcs(auto_ctx, f, f_cjk, f_fallback);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_install_load_system_font_funcs(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_install_load_system_font_funcs2()`. */
FZ_FUNCTION void ll_fz_install_load_system_font_funcs2(::fz_install_load_system_font_funcs_args *args)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_install_load_system_font_funcs2():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " args=" << args;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_install_load_system_font_funcs2(auto_ctx, args);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_install_load_system_font_funcs2(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_int2_heap_insert()`. */
FZ_FUNCTION void ll_fz_int2_heap_insert(::fz_int2_heap *heap, ::fz_int2 v)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_int2_heap_insert():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " heap=" << heap;
		std::cerr << " &v=" << &v;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_int2_heap_insert(auto_ctx, heap, v);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_int2_heap_insert(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_int2_heap_sort()`. */
FZ_FUNCTION void ll_fz_int2_heap_sort(::fz_int2_heap *heap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_int2_heap_sort():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " heap=" << heap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_int2_heap_sort(auto_ctx, heap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_int2_heap_sort(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_int2_heap_uniq()`. */
FZ_FUNCTION void ll_fz_int2_heap_uniq(::fz_int2_heap *heap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_int2_heap_uniq():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " heap=" << heap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_int2_heap_uniq(auto_ctx, heap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_int2_heap_uniq(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_int_heap_insert()`. */
FZ_FUNCTION void ll_fz_int_heap_insert(::fz_int_heap *heap, int v)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_int_heap_insert():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " heap=" << heap;
		std::cerr << " v=" << v;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_int_heap_insert(auto_ctx, heap, v);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_int_heap_insert(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_int_heap_sort()`. */
FZ_FUNCTION void ll_fz_int_heap_sort(::fz_int_heap *heap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_int_heap_sort():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " heap=" << heap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_int_heap_sort(auto_ctx, heap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_int_heap_sort(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_int_heap_uniq()`. */
FZ_FUNCTION void ll_fz_int_heap_uniq(::fz_int_heap *heap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_int_heap_uniq():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " heap=" << heap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_int_heap_uniq(auto_ctx, heap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_int_heap_uniq(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_intersect_irect()`. */
FZ_FUNCTION ::fz_irect ll_fz_intersect_irect(::fz_irect a, ::fz_irect b)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_intersect_irect():";
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << "\n";
	}
	#endif
	fz_irect ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_intersect_irect(a, b);
	return ret;
}

/** Low-level wrapper for `::fz_intersect_rect()`. */
FZ_FUNCTION ::fz_rect ll_fz_intersect_rect(::fz_rect a, ::fz_rect b)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_intersect_rect():";
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << "\n";
	}
	#endif
	fz_rect ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_intersect_rect(a, b);
	return ret;
}

/** Low-level wrapper for `::fz_intptr_heap_insert()`. */
FZ_FUNCTION void ll_fz_intptr_heap_insert(::fz_intptr_heap *heap, ::fz_intptr v)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_intptr_heap_insert():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " heap=" << heap;
		std::cerr << " &v=" << &v;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_intptr_heap_insert(auto_ctx, heap, v);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_intptr_heap_insert(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_intptr_heap_sort()`. */
FZ_FUNCTION void ll_fz_intptr_heap_sort(::fz_intptr_heap *heap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_intptr_heap_sort():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " heap=" << heap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_intptr_heap_sort(auto_ctx, heap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_intptr_heap_sort(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_intptr_heap_uniq()`. */
FZ_FUNCTION void ll_fz_intptr_heap_uniq(::fz_intptr_heap *heap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_intptr_heap_uniq():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " heap=" << heap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_intptr_heap_uniq(auto_ctx, heap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_intptr_heap_uniq(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_invert_bitmap()`. */
FZ_FUNCTION void ll_fz_invert_bitmap(::fz_bitmap *bmp)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_invert_bitmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " bmp=" << bmp;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_invert_bitmap(auto_ctx, bmp);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_invert_bitmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_invert_matrix()`. */
FZ_FUNCTION ::fz_matrix ll_fz_invert_matrix(::fz_matrix matrix)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_invert_matrix():";
		std::cerr << " matrix=" << matrix;
		std::cerr << "\n";
	}
	#endif
	fz_matrix ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_invert_matrix(matrix);
	return ret;
}

/** Low-level wrapper for `::fz_invert_pixmap()`. */
FZ_FUNCTION void ll_fz_invert_pixmap(::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_invert_pixmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_invert_pixmap(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_invert_pixmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_invert_pixmap_alpha()`. */
FZ_FUNCTION void ll_fz_invert_pixmap_alpha(::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_invert_pixmap_alpha():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_invert_pixmap_alpha(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_invert_pixmap_alpha(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_invert_pixmap_luminance()`. */
FZ_FUNCTION void ll_fz_invert_pixmap_luminance(::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_invert_pixmap_luminance():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_invert_pixmap_luminance(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_invert_pixmap_luminance(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_invert_pixmap_raw()`. */
FZ_FUNCTION void ll_fz_invert_pixmap_raw(::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_invert_pixmap_raw():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_invert_pixmap_raw(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_invert_pixmap_raw(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_invert_pixmap_rect()`. */
FZ_FUNCTION void ll_fz_invert_pixmap_rect(::fz_pixmap *image, ::fz_irect rect)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_invert_pixmap_rect():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << " rect=" << rect;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_invert_pixmap_rect(auto_ctx, image, rect);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_invert_pixmap_rect(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_irect_from_rect()`. */
FZ_FUNCTION ::fz_irect ll_fz_irect_from_rect(::fz_rect rect)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_irect_from_rect():";
		std::cerr << " rect=" << rect;
		std::cerr << "\n";
	}
	#endif
	fz_irect ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_irect_from_rect(rect);
	return ret;
}

/** Low-level wrapper for `::fz_irect_height()`. */
FZ_FUNCTION int ll_fz_irect_height(::fz_irect r)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_irect_height():";
		std::cerr << " r=" << r;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_irect_height(r);
	return ret;
}

/** Low-level wrapper for `::fz_irect_width()`. */
FZ_FUNCTION unsigned int ll_fz_irect_width(::fz_irect r)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_irect_width():";
		std::cerr << " r=" << r;
		std::cerr << "\n";
	}
	#endif
	unsigned int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_irect_width(r);
	return ret;
}

/** Low-level wrapper for `::fz_is_cfb_archive()`. */
FZ_FUNCTION int ll_fz_is_cfb_archive(::fz_stream *file)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_cfb_archive():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " file=" << file;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_is_cfb_archive(auto_ctx, file);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_is_cfb_archive(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_is_directory()`. */
FZ_FUNCTION int ll_fz_is_directory(const char *path)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_directory():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_is_directory(auto_ctx, path);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_is_directory(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_is_document_reflowable()`. */
FZ_FUNCTION int ll_fz_is_document_reflowable(::fz_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_document_reflowable():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_is_document_reflowable(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_is_document_reflowable(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_is_empty_irect()`. */
FZ_FUNCTION int ll_fz_is_empty_irect(::fz_irect r)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_empty_irect():";
		std::cerr << " r=" << r;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_is_empty_irect(r);
	return ret;
}

/** Low-level wrapper for `::fz_is_empty_rect()`. */
FZ_FUNCTION int ll_fz_is_empty_rect(::fz_rect r)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_empty_rect():";
		std::cerr << " r=" << r;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_is_empty_rect(r);
	return ret;
}

/** Low-level wrapper for `::fz_is_eof()`. */
FZ_FUNCTION int ll_fz_is_eof(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_eof():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_is_eof(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_is_eof(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_is_eof_bits()`. */
FZ_FUNCTION int ll_fz_is_eof_bits(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_eof_bits():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_is_eof_bits(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_is_eof_bits(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_is_external_link()`. */
FZ_FUNCTION int ll_fz_is_external_link(const char *uri)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_external_link():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (uri) std::cerr << " uri='" << uri << "'";
		else std::cerr << " uri:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_is_external_link(auto_ctx, uri);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_is_external_link(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_is_identity()`. */
FZ_FUNCTION int ll_fz_is_identity(::fz_matrix m)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_identity():";
		std::cerr << " m=" << m;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_is_identity(m);
	return ret;
}

/** Low-level wrapper for `::fz_is_infinite_irect()`. */
FZ_FUNCTION int ll_fz_is_infinite_irect(::fz_irect r)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_infinite_irect():";
		std::cerr << " r=" << r;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_is_infinite_irect(r);
	return ret;
}

/** Low-level wrapper for `::fz_is_infinite_rect()`. */
FZ_FUNCTION int ll_fz_is_infinite_rect(::fz_rect r)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_infinite_rect():";
		std::cerr << " r=" << r;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_is_infinite_rect(r);
	return ret;
}

/** Low-level wrapper for `::fz_is_libarchive_archive()`. */
FZ_FUNCTION int ll_fz_is_libarchive_archive(::fz_stream *file)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_libarchive_archive():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " file=" << file;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_is_libarchive_archive(auto_ctx, file);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_is_libarchive_archive(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_is_page_range()`. */
FZ_FUNCTION int ll_fz_is_page_range(const char *s)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_page_range():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s) std::cerr << " s='" << s << "'";
		else std::cerr << " s:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_is_page_range(auto_ctx, s);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_is_page_range(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_is_pixmap_monochrome()`. */
FZ_FUNCTION int ll_fz_is_pixmap_monochrome(::fz_pixmap *pixmap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_pixmap_monochrome():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_is_pixmap_monochrome(auto_ctx, pixmap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_is_pixmap_monochrome(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_is_point_inside_irect()`. */
FZ_FUNCTION int ll_fz_is_point_inside_irect(int x, int y, ::fz_irect r)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_point_inside_irect():";
		std::cerr << " x=" << x;
		std::cerr << " y=" << y;
		std::cerr << " r=" << r;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_is_point_inside_irect(x, y, r);
	return ret;
}

/** Low-level wrapper for `::fz_is_point_inside_quad()`. */
FZ_FUNCTION int ll_fz_is_point_inside_quad(::fz_point p, ::fz_quad q)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_point_inside_quad():";
		std::cerr << " p=" << p;
		std::cerr << " q=" << q;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_is_point_inside_quad(p, q);
	return ret;
}

/** Low-level wrapper for `::fz_is_point_inside_rect()`. */
FZ_FUNCTION int ll_fz_is_point_inside_rect(::fz_point p, ::fz_rect r)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_point_inside_rect():";
		std::cerr << " p=" << p;
		std::cerr << " r=" << r;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_is_point_inside_rect(p, r);
	return ret;
}

/** Low-level wrapper for `::fz_is_pow2()`. */
FZ_FUNCTION int ll_fz_is_pow2(int a)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_pow2():";
		std::cerr << " a=" << a;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_is_pow2(a);
	return ret;
}

/** Low-level wrapper for `::fz_is_quad_inside_quad()`. */
FZ_FUNCTION int ll_fz_is_quad_inside_quad(::fz_quad needle, ::fz_quad haystack)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_quad_inside_quad():";
		std::cerr << " needle=" << needle;
		std::cerr << " haystack=" << haystack;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_is_quad_inside_quad(needle, haystack);
	return ret;
}

/** Low-level wrapper for `::fz_is_quad_intersecting_quad()`. */
FZ_FUNCTION int ll_fz_is_quad_intersecting_quad(::fz_quad a, ::fz_quad b)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_quad_intersecting_quad():";
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_is_quad_intersecting_quad(a, b);
	return ret;
}

/** Low-level wrapper for `::fz_is_rectilinear()`. */
FZ_FUNCTION int ll_fz_is_rectilinear(::fz_matrix m)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_rectilinear():";
		std::cerr << " m=" << m;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_is_rectilinear(m);
	return ret;
}

/** Low-level wrapper for `::fz_is_tar_archive()`. */
FZ_FUNCTION int ll_fz_is_tar_archive(::fz_stream *file)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_tar_archive():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " file=" << file;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_is_tar_archive(auto_ctx, file);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_is_tar_archive(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_is_valid_blend_colorspace()`. */
FZ_FUNCTION int ll_fz_is_valid_blend_colorspace(::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_valid_blend_colorspace():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_is_valid_blend_colorspace(auto_ctx, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_is_valid_blend_colorspace(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_is_valid_irect()`. */
FZ_FUNCTION int ll_fz_is_valid_irect(::fz_irect r)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_valid_irect():";
		std::cerr << " r=" << r;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_is_valid_irect(r);
	return ret;
}

/** Low-level wrapper for `::fz_is_valid_rect()`. */
FZ_FUNCTION int ll_fz_is_valid_rect(::fz_rect r)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_valid_rect():";
		std::cerr << " r=" << r;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_is_valid_rect(r);
	return ret;
}

/** Low-level wrapper for `::fz_is_zip_archive()`. */
FZ_FUNCTION int ll_fz_is_zip_archive(::fz_stream *file)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_is_zip_archive():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " file=" << file;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_is_zip_archive(auto_ctx, file);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_is_zip_archive(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_iso8859_1_from_unicode()`. */
FZ_FUNCTION int ll_fz_iso8859_1_from_unicode(int u)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_iso8859_1_from_unicode():";
		std::cerr << " u=" << u;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_iso8859_1_from_unicode(u);
	return ret;
}

/** Low-level wrapper for `::fz_iso8859_7_from_unicode()`. */
FZ_FUNCTION int ll_fz_iso8859_7_from_unicode(int u)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_iso8859_7_from_unicode():";
		std::cerr << " u=" << u;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_iso8859_7_from_unicode(u);
	return ret;
}

/** Low-level wrapper for `::fz_jbig2_globals_data()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_jbig2_globals_data(::fz_jbig2_globals *globals)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_jbig2_globals_data():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " globals=" << globals;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_jbig2_globals_data(auto_ctx, globals);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_jbig2_globals_data(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_archive()`. */
FZ_FUNCTION ::fz_archive *ll_fz_keep_archive(::fz_archive *arch)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_archive():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " arch=" << arch;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_archive * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_archive(auto_ctx, arch);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_archive(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_bitmap()`. */
FZ_FUNCTION ::fz_bitmap *ll_fz_keep_bitmap(::fz_bitmap *bit)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_bitmap():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " bit=" << bit;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_bitmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_bitmap(auto_ctx, bit);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_bitmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_buffer()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_keep_buffer(::fz_buffer *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_buffer():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_buffer(auto_ctx, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_colorspace()`. */
FZ_FUNCTION ::fz_colorspace *ll_fz_keep_colorspace(::fz_colorspace *colorspace)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_colorspace():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " colorspace=" << colorspace;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_colorspace(auto_ctx, colorspace);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_colorspace(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_compressed_buffer()`. */
FZ_FUNCTION ::fz_compressed_buffer *ll_fz_keep_compressed_buffer(::fz_compressed_buffer *cbuf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_compressed_buffer():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " cbuf=" << cbuf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_compressed_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_compressed_buffer(auto_ctx, cbuf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_compressed_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_default_colorspaces()`. */
FZ_FUNCTION ::fz_default_colorspaces *ll_fz_keep_default_colorspaces(::fz_default_colorspaces *default_cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_default_colorspaces():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " default_cs=" << default_cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_default_colorspaces * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_default_colorspaces(auto_ctx, default_cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_default_colorspaces(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_device()`. */
FZ_FUNCTION ::fz_device *ll_fz_keep_device(::fz_device *dev)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_device():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " dev=" << dev;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_device * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_device(auto_ctx, dev);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_device(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_display_list()`. */
FZ_FUNCTION ::fz_display_list *ll_fz_keep_display_list(::fz_display_list *list)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_display_list():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " list=" << list;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_display_list * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_display_list(auto_ctx, list);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_display_list(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_document()`. */
FZ_FUNCTION ::fz_document *ll_fz_keep_document(::fz_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_document():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_document(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_font()`. */
FZ_FUNCTION ::fz_font *ll_fz_keep_font(::fz_font *font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_font():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_font * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_font(auto_ctx, font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_function()`. */
FZ_FUNCTION ::fz_function *ll_fz_keep_function(::fz_function *func)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_function():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " func=" << func;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_function * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_function(auto_ctx, func);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_function(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_glyph()`. */
FZ_FUNCTION ::fz_glyph *ll_fz_keep_glyph(::fz_glyph *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_glyph():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_glyph * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_glyph(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_glyph(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_halftone()`. */
FZ_FUNCTION ::fz_halftone *ll_fz_keep_halftone(::fz_halftone *half)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_halftone():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " half=" << half;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_halftone * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_halftone(auto_ctx, half);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_halftone(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_image()`. */
FZ_FUNCTION ::fz_image *ll_fz_keep_image(::fz_image *image)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_image():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " image=" << image;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_image * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_image(auto_ctx, image);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_image(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_image_store_key()`. */
FZ_FUNCTION ::fz_image *ll_fz_keep_image_store_key(::fz_image *image)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_image_store_key():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " image=" << image;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_image * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_image_store_key(auto_ctx, image);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_image_store_key(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_imp()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_keep_imp(void *p)` => `(void *, int refs)`
*/
FZ_FUNCTION void *ll_fz_keep_imp(void *p, int *refs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_imp():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " p=" << (void*) p;
		if (s_trace_keepdrop) std::cerr << " refs=" << (void*) refs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_imp(auto_ctx, p, refs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_imp(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_imp16()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_keep_imp16(void *p)` => `(void *, int16_t refs)`
*/
FZ_FUNCTION void *ll_fz_keep_imp16(void *p, int16_t *refs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_imp16():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " p=" << (void*) p;
		if (s_trace_keepdrop) std::cerr << " refs=" << (void*) refs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_imp16(auto_ctx, p, refs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_imp16(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_imp8()`. */
FZ_FUNCTION void *ll_fz_keep_imp8(void *p, int8_t *refs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_imp8():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " p=" << (void*) p;
		if (s_trace_keepdrop) std::cerr << " refs=" << (void*) refs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_imp8(auto_ctx, p, refs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_imp8(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_imp8_locked()`. */
FZ_FUNCTION void *ll_fz_keep_imp8_locked(void *p, int8_t *refs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_imp8_locked():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " p=" << (void*) p;
		if (s_trace_keepdrop) std::cerr << " refs=" << (void*) refs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_imp8_locked(auto_ctx, p, refs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_imp8_locked(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_imp_locked()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_keep_imp_locked(void *p)` => `(void *, int refs)`
*/
FZ_FUNCTION void *ll_fz_keep_imp_locked(void *p, int *refs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_imp_locked():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " p=" << (void*) p;
		if (s_trace_keepdrop) std::cerr << " refs=" << (void*) refs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_imp_locked(auto_ctx, p, refs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_imp_locked(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_jbig2_globals()`. */
FZ_FUNCTION ::fz_jbig2_globals *ll_fz_keep_jbig2_globals(::fz_jbig2_globals *globals)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_jbig2_globals():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " globals=" << globals;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_jbig2_globals * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_jbig2_globals(auto_ctx, globals);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_jbig2_globals(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_key_storable()`. */
FZ_FUNCTION void *ll_fz_keep_key_storable(const ::fz_key_storable *arg_1)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_key_storable():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " arg_1=" << arg_1;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_key_storable(auto_ctx, arg_1);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_key_storable(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_key_storable_key()`. */
FZ_FUNCTION void *ll_fz_keep_key_storable_key(const ::fz_key_storable *arg_1)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_key_storable_key():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " arg_1=" << arg_1;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_key_storable_key(auto_ctx, arg_1);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_key_storable_key(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_link()`. */
FZ_FUNCTION ::fz_link *ll_fz_keep_link(::fz_link *link)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_link():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " link=" << link;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_link * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_link(auto_ctx, link);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_link(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_outline()`. */
FZ_FUNCTION ::fz_outline *ll_fz_keep_outline(::fz_outline *outline)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_outline():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " outline=" << outline;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_outline * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_outline(auto_ctx, outline);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_outline(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_page()`. */
FZ_FUNCTION ::fz_page *ll_fz_keep_page(::fz_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_page():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_page * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_page(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_page_locked()`. */
FZ_FUNCTION ::fz_page *ll_fz_keep_page_locked(::fz_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_page_locked():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_page * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_page_locked(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_page_locked(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_path()`. */
FZ_FUNCTION ::fz_path *ll_fz_keep_path(const ::fz_path *path)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_path():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " path=" << path;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_path * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_path(auto_ctx, path);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_path(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_pixmap()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_keep_pixmap(::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_pixmap():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_pixmap(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_pixmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_separations()`. */
FZ_FUNCTION ::fz_separations *ll_fz_keep_separations(::fz_separations *sep)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_separations():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " sep=" << sep;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_separations * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_separations(auto_ctx, sep);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_separations(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_shade()`. */
FZ_FUNCTION ::fz_shade *ll_fz_keep_shade(::fz_shade *shade)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_shade():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " shade=" << shade;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_shade * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_shade(auto_ctx, shade);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_shade(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_storable()`. */
FZ_FUNCTION void *ll_fz_keep_storable(const ::fz_storable *arg_1)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_storable():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " arg_1=" << arg_1;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_storable(auto_ctx, arg_1);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_storable(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_store_context()`. */
FZ_FUNCTION ::fz_store *ll_fz_keep_store_context()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_store_context():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_store * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_store_context(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_store_context(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_stream()`. */
FZ_FUNCTION ::fz_stream *ll_fz_keep_stream(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_stream():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_stream(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_string()`. */
FZ_FUNCTION ::fz_string *ll_fz_keep_string(::fz_string *str)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_string():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " str=" << str;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_string * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_string(auto_ctx, str);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_stroke_state()`. */
FZ_FUNCTION ::fz_stroke_state *ll_fz_keep_stroke_state(const ::fz_stroke_state *stroke)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_stroke_state():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " stroke=" << stroke;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stroke_state * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_stroke_state(auto_ctx, stroke);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_stroke_state(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_text()`. */
FZ_FUNCTION ::fz_text *ll_fz_keep_text(const ::fz_text *text)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_text():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " text=" << text;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_text * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_text(auto_ctx, text);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_text(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_keep_xml()`. */
FZ_FUNCTION ::fz_xml *ll_fz_keep_xml(::fz_xml *xml)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_keep_xml():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " xml=" << xml;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_xml * ret;
	fz_try(auto_ctx) {
		ret = ::fz_keep_xml(auto_ctx, xml);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_keep_xml(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_koi8u_from_unicode()`. */
FZ_FUNCTION int ll_fz_koi8u_from_unicode(int u)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_koi8u_from_unicode():";
		std::cerr << " u=" << u;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_koi8u_from_unicode(u);
	return ret;
}

/** Low-level wrapper for `::fz_last_page()`. */
FZ_FUNCTION ::fz_location ll_fz_last_page(::fz_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_last_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_location ret;
	fz_try(auto_ctx) {
		ret = ::fz_last_page(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_last_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_layout_document()`. */
FZ_FUNCTION void ll_fz_layout_document(::fz_document *doc, float w, float h, float em)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_layout_document():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " w=" << w;
		std::cerr << " h=" << h;
		std::cerr << " em=" << em;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_layout_document(auto_ctx, doc, w, h, em);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_layout_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_lineto()`. */
FZ_FUNCTION void ll_fz_lineto(::fz_path *path, float x, float y)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_lineto():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " path=" << path;
		std::cerr << " x=" << x;
		std::cerr << " y=" << y;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_lineto(auto_ctx, path, x, y);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_lineto(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_list_archive_entry()`. */
FZ_FUNCTION const char *ll_fz_list_archive_entry(::fz_archive *arch, int idx)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_list_archive_entry():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " arch=" << arch;
		std::cerr << " idx=" << idx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_list_archive_entry(auto_ctx, arch, idx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_list_archive_entry(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_load_bmp_subimage()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_load_bmp_subimage(const unsigned char *buf, size_t len, int subimage)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_load_bmp_subimage():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " buf=" << ((void*) buf);
		std::cerr << " len=" << len;
		std::cerr << " subimage=" << subimage;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_load_bmp_subimage(auto_ctx, buf, len, subimage);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_load_bmp_subimage(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_load_bmp_subimage_count()`. */
FZ_FUNCTION int ll_fz_load_bmp_subimage_count(const unsigned char *buf, size_t len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_load_bmp_subimage_count():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " buf=" << ((void*) buf);
		std::cerr << " len=" << len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_load_bmp_subimage_count(auto_ctx, buf, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_load_bmp_subimage_count(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_load_chapter_page()`. */
FZ_FUNCTION ::fz_page *ll_fz_load_chapter_page(::fz_document *doc, int chapter, int page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_load_chapter_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " chapter=" << chapter;
		std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_page * ret;
	fz_try(auto_ctx) {
		ret = ::fz_load_chapter_page(auto_ctx, doc, chapter, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_load_chapter_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_load_fallback_font()`. */
FZ_FUNCTION ::fz_font *ll_fz_load_fallback_font(int script, int language, int serif, int bold, int italic)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_load_fallback_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " script=" << script;
		std::cerr << " language=" << language;
		std::cerr << " serif=" << serif;
		std::cerr << " bold=" << bold;
		std::cerr << " italic=" << italic;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_font * ret;
	fz_try(auto_ctx) {
		ret = ::fz_load_fallback_font(auto_ctx, script, language, serif, bold, italic);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_load_fallback_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_load_jbig2_globals()`. */
FZ_FUNCTION ::fz_jbig2_globals *ll_fz_load_jbig2_globals(::fz_buffer *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_load_jbig2_globals():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_jbig2_globals * ret;
	fz_try(auto_ctx) {
		ret = ::fz_load_jbig2_globals(auto_ctx, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_load_jbig2_globals(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_load_jbig2_subimage()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_load_jbig2_subimage(const unsigned char *buf, size_t len, int subimage)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_load_jbig2_subimage():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " buf=" << ((void*) buf);
		std::cerr << " len=" << len;
		std::cerr << " subimage=" << subimage;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_load_jbig2_subimage(auto_ctx, buf, len, subimage);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_load_jbig2_subimage(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_load_jbig2_subimage_count()`. */
FZ_FUNCTION int ll_fz_load_jbig2_subimage_count(const unsigned char *buf, size_t len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_load_jbig2_subimage_count():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " buf=" << ((void*) buf);
		std::cerr << " len=" << len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_load_jbig2_subimage_count(auto_ctx, buf, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_load_jbig2_subimage_count(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_load_jpx()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_load_jpx(const unsigned char *data, size_t size, ::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_load_jpx():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " data=" << ((void*) data);
		std::cerr << " size=" << size;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_load_jpx(auto_ctx, data, size, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_load_jpx(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_load_links()`. */
FZ_FUNCTION ::fz_link *ll_fz_load_links(::fz_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_load_links():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_link * ret;
	fz_try(auto_ctx) {
		ret = ::fz_load_links(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_load_links(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_load_outline()`. */
FZ_FUNCTION ::fz_outline *ll_fz_load_outline(::fz_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_load_outline():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_outline * ret;
	fz_try(auto_ctx) {
		ret = ::fz_load_outline(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_load_outline(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_load_outline_from_iterator()`. */
FZ_FUNCTION ::fz_outline *ll_fz_load_outline_from_iterator(::fz_outline_iterator *iter)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_load_outline_from_iterator():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " iter=" << iter;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_outline * ret;
	fz_try(auto_ctx) {
		ret = ::fz_load_outline_from_iterator(auto_ctx, iter);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_load_outline_from_iterator(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_load_page()`. */
FZ_FUNCTION ::fz_page *ll_fz_load_page(::fz_document *doc, int number)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_load_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " number=" << number;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_page * ret;
	fz_try(auto_ctx) {
		ret = ::fz_load_page(auto_ctx, doc, number);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_load_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_load_pnm_subimage()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_load_pnm_subimage(const unsigned char *buf, size_t len, int subimage)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_load_pnm_subimage():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " buf=" << ((void*) buf);
		std::cerr << " len=" << len;
		std::cerr << " subimage=" << subimage;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_load_pnm_subimage(auto_ctx, buf, len, subimage);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_load_pnm_subimage(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_load_pnm_subimage_count()`. */
FZ_FUNCTION int ll_fz_load_pnm_subimage_count(const unsigned char *buf, size_t len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_load_pnm_subimage_count():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " buf=" << ((void*) buf);
		std::cerr << " len=" << len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_load_pnm_subimage_count(auto_ctx, buf, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_load_pnm_subimage_count(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_load_system_cjk_font()`. */
FZ_FUNCTION ::fz_font *ll_fz_load_system_cjk_font(const char *name, int ordering, int serif)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_load_system_cjk_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << " ordering=" << ordering;
		std::cerr << " serif=" << serif;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_font * ret;
	fz_try(auto_ctx) {
		ret = ::fz_load_system_cjk_font(auto_ctx, name, ordering, serif);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_load_system_cjk_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_load_system_font()`. */
FZ_FUNCTION ::fz_font *ll_fz_load_system_font(const char *name, int bold, int italic, int needs_exact_metrics)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_load_system_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << " bold=" << bold;
		std::cerr << " italic=" << italic;
		std::cerr << " needs_exact_metrics=" << needs_exact_metrics;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_font * ret;
	fz_try(auto_ctx) {
		ret = ::fz_load_system_font(auto_ctx, name, bold, italic, needs_exact_metrics);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_load_system_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_load_tiff_subimage()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_load_tiff_subimage(const unsigned char *buf, size_t len, int subimage)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_load_tiff_subimage():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " buf=" << ((void*) buf);
		std::cerr << " len=" << len;
		std::cerr << " subimage=" << subimage;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_load_tiff_subimage(auto_ctx, buf, len, subimage);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_load_tiff_subimage(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_load_tiff_subimage_count()`. */
FZ_FUNCTION int ll_fz_load_tiff_subimage_count(const unsigned char *buf, size_t len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_load_tiff_subimage_count():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " buf=" << ((void*) buf);
		std::cerr << " len=" << len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_load_tiff_subimage_count(auto_ctx, buf, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_load_tiff_subimage_count(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_location_from_page_number()`. */
FZ_FUNCTION ::fz_location ll_fz_location_from_page_number(::fz_document *doc, int number)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_location_from_page_number():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " number=" << number;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_location ret;
	fz_try(auto_ctx) {
		ret = ::fz_location_from_page_number(auto_ctx, doc, number);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_location_from_page_number(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_lock()`. */
FZ_FUNCTION void ll_fz_lock(int lock)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_lock():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " lock=" << lock;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_lock(auto_ctx, lock);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_lock(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_log_error()`. */
FZ_FUNCTION void ll_fz_log_error(const char *str)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_log_error():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (str) std::cerr << " str='" << str << "'";
		else std::cerr << " str:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_log_error(auto_ctx, str);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_log_error(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_lookup_base14_font()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_lookup_base14_font(const char *name)` => `(const unsigned char *, int len)`
*/
FZ_FUNCTION const unsigned char *ll_fz_lookup_base14_font(const char *name, int *len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_lookup_base14_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		if (s_trace > 1) std::cerr << " len=" << (void*) len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_lookup_base14_font(auto_ctx, name, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_lookup_base14_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_lookup_blendmode()`. */
FZ_FUNCTION int ll_fz_lookup_blendmode(const char *name)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_lookup_blendmode():";
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_lookup_blendmode(name);
	return ret;
}

/** Low-level wrapper for `::fz_lookup_bookmark()`. */
FZ_FUNCTION ::fz_location ll_fz_lookup_bookmark(::fz_document *doc, ::fz_bookmark mark)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_lookup_bookmark():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " mark=" << mark;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_location ret;
	fz_try(auto_ctx) {
		ret = ::fz_lookup_bookmark(auto_ctx, doc, mark);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_lookup_bookmark(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_lookup_builtin_font()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_lookup_builtin_font(const char *name, int bold, int italic)` => `(const unsigned char *, int len)`
*/
FZ_FUNCTION const unsigned char *ll_fz_lookup_builtin_font(const char *name, int bold, int italic, int *len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_lookup_builtin_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << " bold=" << bold;
		std::cerr << " italic=" << italic;
		if (s_trace > 1) std::cerr << " len=" << (void*) len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_lookup_builtin_font(auto_ctx, name, bold, italic, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_lookup_builtin_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_lookup_cjk_font()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_lookup_cjk_font(int ordering)` => `(const unsigned char *, int len, int index)`
*/
FZ_FUNCTION const unsigned char *ll_fz_lookup_cjk_font(int ordering, int *len, int *index)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_lookup_cjk_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " ordering=" << ordering;
		if (s_trace > 1) std::cerr << " len=" << (void*) len;
		if (s_trace > 1) std::cerr << " index=" << (void*) index;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_lookup_cjk_font(auto_ctx, ordering, len, index);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_lookup_cjk_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_lookup_cjk_font_by_language()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_lookup_cjk_font_by_language(const char *lang)` => `(const unsigned char *, int len, int subfont)`
*/
FZ_FUNCTION const unsigned char *ll_fz_lookup_cjk_font_by_language(const char *lang, int *len, int *subfont)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_lookup_cjk_font_by_language():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (lang) std::cerr << " lang='" << lang << "'";
		else std::cerr << " lang:null";
		if (s_trace > 1) std::cerr << " len=" << (void*) len;
		if (s_trace > 1) std::cerr << " subfont=" << (void*) subfont;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_lookup_cjk_font_by_language(auto_ctx, lang, len, subfont);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_lookup_cjk_font_by_language(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_lookup_cjk_ordering_by_language()`. */
FZ_FUNCTION int ll_fz_lookup_cjk_ordering_by_language(const char *name)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_lookup_cjk_ordering_by_language():";
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_lookup_cjk_ordering_by_language(name);
	return ret;
}

/** Low-level wrapper for `::fz_lookup_image_type()`. */
FZ_FUNCTION int ll_fz_lookup_image_type(const char *type)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_lookup_image_type():";
		if (type) std::cerr << " type='" << type << "'";
		else std::cerr << " type:null";
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_lookup_image_type(type);
	return ret;
}

/** Low-level wrapper for `::fz_lookup_metadata()`. */
FZ_FUNCTION int ll_fz_lookup_metadata(::fz_document *doc, const char *key, char *buf, int size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_lookup_metadata():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (key) std::cerr << " key='" << key << "'";
		else std::cerr << " key:null";
		if (s_trace > 1) std::cerr << " buf=" << (void*) buf;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_lookup_metadata(auto_ctx, doc, key, buf, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_lookup_metadata(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_lookup_metadata2()`. */
FZ_FUNCTION std::string ll_fz_lookup_metadata2(::fz_document *doc, const char *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_lookup_metadata2():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (key) std::cerr << " key='" << key << "'";
		else std::cerr << " key:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	std::string ret;
	fz_try(auto_ctx) {
		ret = ::fz_lookup_metadata2(auto_ctx, doc, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_lookup_metadata2(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_lookup_noto_boxes_font()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_lookup_noto_boxes_font()` => `(const unsigned char *, int len)`
*/
FZ_FUNCTION const unsigned char *ll_fz_lookup_noto_boxes_font(int *len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_lookup_noto_boxes_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " len=" << (void*) len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_lookup_noto_boxes_font(auto_ctx, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_lookup_noto_boxes_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_lookup_noto_emoji_font()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_lookup_noto_emoji_font()` => `(const unsigned char *, int len)`
*/
FZ_FUNCTION const unsigned char *ll_fz_lookup_noto_emoji_font(int *len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_lookup_noto_emoji_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " len=" << (void*) len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_lookup_noto_emoji_font(auto_ctx, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_lookup_noto_emoji_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_lookup_noto_font()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_lookup_noto_font(int script, int lang)` => `(const unsigned char *, int len, int subfont)`
*/
FZ_FUNCTION const unsigned char *ll_fz_lookup_noto_font(int script, int lang, int *len, int *subfont)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_lookup_noto_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " script=" << script;
		std::cerr << " lang=" << lang;
		if (s_trace > 1) std::cerr << " len=" << (void*) len;
		if (s_trace > 1) std::cerr << " subfont=" << (void*) subfont;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_lookup_noto_font(auto_ctx, script, lang, len, subfont);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_lookup_noto_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_lookup_noto_math_font()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_lookup_noto_math_font()` => `(const unsigned char *, int len)`
*/
FZ_FUNCTION const unsigned char *ll_fz_lookup_noto_math_font(int *len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_lookup_noto_math_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " len=" << (void*) len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_lookup_noto_math_font(auto_ctx, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_lookup_noto_math_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_lookup_noto_music_font()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_lookup_noto_music_font()` => `(const unsigned char *, int len)`
*/
FZ_FUNCTION const unsigned char *ll_fz_lookup_noto_music_font(int *len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_lookup_noto_music_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " len=" << (void*) len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_lookup_noto_music_font(auto_ctx, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_lookup_noto_music_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_lookup_noto_symbol1_font()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_lookup_noto_symbol1_font()` => `(const unsigned char *, int len)`
*/
FZ_FUNCTION const unsigned char *ll_fz_lookup_noto_symbol1_font(int *len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_lookup_noto_symbol1_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " len=" << (void*) len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_lookup_noto_symbol1_font(auto_ctx, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_lookup_noto_symbol1_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_lookup_noto_symbol2_font()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_lookup_noto_symbol2_font()` => `(const unsigned char *, int len)`
*/
FZ_FUNCTION const unsigned char *ll_fz_lookup_noto_symbol2_font(int *len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_lookup_noto_symbol2_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " len=" << (void*) len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_lookup_noto_symbol2_font(auto_ctx, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_lookup_noto_symbol2_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_lookup_rendering_intent()`. */
FZ_FUNCTION int ll_fz_lookup_rendering_intent(const char *name)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_lookup_rendering_intent():";
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_lookup_rendering_intent(name);
	return ret;
}

/** Low-level wrapper for `::fz_make_bookmark()`. */
FZ_FUNCTION ::fz_bookmark ll_fz_make_bookmark(::fz_document *doc, ::fz_location loc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_make_bookmark():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " loc=" << loc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_bookmark ret;
	fz_try(auto_ctx) {
		ret = ::fz_make_bookmark(auto_ctx, doc, loc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_make_bookmark(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_make_irect()`. */
FZ_FUNCTION ::fz_irect ll_fz_make_irect(int x0, int y0, int x1, int y1)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_make_irect():";
		std::cerr << " x0=" << x0;
		std::cerr << " y0=" << y0;
		std::cerr << " x1=" << x1;
		std::cerr << " y1=" << y1;
		std::cerr << "\n";
	}
	#endif
	fz_irect ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_make_irect(x0, y0, x1, y1);
	return ret;
}

/** Low-level wrapper for `::fz_make_link_dest_none()`. */
FZ_FUNCTION ::fz_link_dest ll_fz_make_link_dest_none()
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_make_link_dest_none():";
		std::cerr << "\n";
	}
	#endif
	fz_link_dest ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_make_link_dest_none();
	return ret;
}

/** Low-level wrapper for `::fz_make_link_dest_xyz()`. */
FZ_FUNCTION ::fz_link_dest ll_fz_make_link_dest_xyz(int chapter, int page, float x, float y, float z)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_make_link_dest_xyz():";
		std::cerr << " chapter=" << chapter;
		std::cerr << " page=" << page;
		std::cerr << " x=" << x;
		std::cerr << " y=" << y;
		std::cerr << " z=" << z;
		std::cerr << "\n";
	}
	#endif
	fz_link_dest ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_make_link_dest_xyz(chapter, page, x, y, z);
	return ret;
}

/** Low-level wrapper for `::fz_make_location()`. */
FZ_FUNCTION ::fz_location ll_fz_make_location(int chapter, int page)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_make_location():";
		std::cerr << " chapter=" << chapter;
		std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	fz_location ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_make_location(chapter, page);
	return ret;
}

/** Low-level wrapper for `::fz_make_matrix()`. */
FZ_FUNCTION ::fz_matrix ll_fz_make_matrix(float a, float b, float c, float d, float e, float f)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_make_matrix():";
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << " c=" << c;
		std::cerr << " d=" << d;
		std::cerr << " e=" << e;
		std::cerr << " f=" << f;
		std::cerr << "\n";
	}
	#endif
	fz_matrix ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_make_matrix(a, b, c, d, e, f);
	return ret;
}

/** Low-level wrapper for `::fz_make_point()`. */
FZ_FUNCTION ::fz_point ll_fz_make_point(float x, float y)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_make_point():";
		std::cerr << " x=" << x;
		std::cerr << " y=" << y;
		std::cerr << "\n";
	}
	#endif
	fz_point ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_make_point(x, y);
	return ret;
}

/** Low-level wrapper for `::fz_make_quad()`. */
FZ_FUNCTION ::fz_quad ll_fz_make_quad(float ul_x, float ul_y, float ur_x, float ur_y, float ll_x, float ll_y, float lr_x, float lr_y)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_make_quad():";
		std::cerr << " ul_x=" << ul_x;
		std::cerr << " ul_y=" << ul_y;
		std::cerr << " ur_x=" << ur_x;
		std::cerr << " ur_y=" << ur_y;
		std::cerr << " ll_x=" << ll_x;
		std::cerr << " ll_y=" << ll_y;
		std::cerr << " lr_x=" << lr_x;
		std::cerr << " lr_y=" << lr_y;
		std::cerr << "\n";
	}
	#endif
	fz_quad ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_make_quad(ul_x, ul_y, ur_x, ur_y, ll_x, ll_y, lr_x, lr_y);
	return ret;
}

/** Low-level wrapper for `::fz_make_rect()`. */
FZ_FUNCTION ::fz_rect ll_fz_make_rect(float x0, float y0, float x1, float y1)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_make_rect():";
		std::cerr << " x0=" << x0;
		std::cerr << " y0=" << y0;
		std::cerr << " x1=" << x1;
		std::cerr << " y1=" << y1;
		std::cerr << "\n";
	}
	#endif
	fz_rect ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_make_rect(x0, y0, x1, y1);
	return ret;
}

/** Low-level wrapper for `::fz_malloc()`. */
FZ_FUNCTION void *ll_fz_malloc(size_t size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_malloc():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_malloc(auto_ctx, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_malloc(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_malloc_no_throw()`. */
FZ_FUNCTION void *ll_fz_malloc_no_throw(size_t size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_malloc_no_throw():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_malloc_no_throw(auto_ctx, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_malloc_no_throw(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_matrix_expansion()`. */
FZ_FUNCTION float ll_fz_matrix_expansion(::fz_matrix m)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_matrix_expansion():";
		std::cerr << " m=" << m;
		std::cerr << "\n";
	}
	#endif
	float ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_matrix_expansion(m);
	return ret;
}

/** Low-level wrapper for `::fz_matrix_max_expansion()`. */
FZ_FUNCTION float ll_fz_matrix_max_expansion(::fz_matrix m)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_matrix_max_expansion():";
		std::cerr << " m=" << m;
		std::cerr << "\n";
	}
	#endif
	float ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_matrix_max_expansion(m);
	return ret;
}

/** Low-level wrapper for `::fz_max()`. */
FZ_FUNCTION float ll_fz_max(float a, float b)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_max():";
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << "\n";
	}
	#endif
	float ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_max(a, b);
	return ret;
}

/** Low-level wrapper for `::fz_maxi()`. */
FZ_FUNCTION int ll_fz_maxi(int a, int b)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_maxi():";
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_maxi(a, b);
	return ret;
}

/** Low-level wrapper for `::fz_maxi64()`. */
FZ_FUNCTION int64_t ll_fz_maxi64(int64_t a, int64_t b)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_maxi64():";
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << "\n";
	}
	#endif
	int64_t ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_maxi64(a, b);
	return ret;
}

/** Low-level wrapper for `::fz_maxz()`. */
FZ_FUNCTION size_t ll_fz_maxz(size_t a, size_t b)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_maxz():";
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << "\n";
	}
	#endif
	size_t ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_maxz(a, b);
	return ret;
}

/** Low-level wrapper for `::fz_md5_buffer()`. */
FZ_FUNCTION void ll_fz_md5_buffer(::fz_buffer *buffer, unsigned char digest[16])
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_md5_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buffer=" << buffer;
		std::cerr << " digest=" << digest;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_md5_buffer(auto_ctx, buffer, digest);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_md5_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_md5_final()`. */
FZ_FUNCTION void ll_fz_md5_final(::fz_md5 *state, unsigned char digest[16])
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_md5_final():";
		std::cerr << " state=" << state;
		std::cerr << " digest=" << digest;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_md5_final(state, digest);
}

/** Low-level wrapper for `::fz_md5_final2()`. */
FZ_FUNCTION std::vector<unsigned char> ll_fz_md5_final2(::fz_md5 *md5)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_md5_final2():";
		std::cerr << " md5=" << md5;
		std::cerr << "\n";
	}
	#endif
	std::vector<unsigned char> ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_md5_final2(md5);
	return ret;
}

/** Low-level wrapper for `::fz_md5_init()`. */
FZ_FUNCTION void ll_fz_md5_init(::fz_md5 *state)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_md5_init():";
		std::cerr << " state=" << state;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_md5_init(state);
}

/** Low-level wrapper for `::fz_md5_pixmap()`. */
FZ_FUNCTION void ll_fz_md5_pixmap(::fz_pixmap *pixmap, unsigned char digest[16])
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_md5_pixmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << " digest=" << digest;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_md5_pixmap(auto_ctx, pixmap, digest);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_md5_pixmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_md5_pixmap2()`. */
FZ_FUNCTION std::vector<unsigned char> ll_fz_md5_pixmap2(::fz_pixmap *pixmap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_md5_pixmap2():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	std::vector<unsigned char> ret;
	fz_try(auto_ctx) {
		ret = ::fz_md5_pixmap2(auto_ctx, pixmap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_md5_pixmap2(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_md5_update()`. */
FZ_FUNCTION void ll_fz_md5_update(::fz_md5 *state, const unsigned char *input, size_t inlen)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_md5_update():";
		std::cerr << " state=" << state;
		std::cerr << " input=" << ((void*) input);
		std::cerr << " inlen=" << inlen;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_md5_update(state, input, inlen);
}

/** Low-level wrapper for `::fz_md5_update_int64()`. */
FZ_FUNCTION void ll_fz_md5_update_int64(::fz_md5 *state, int64_t i)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_md5_update_int64():";
		std::cerr << " state=" << state;
		std::cerr << " i=" << i;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_md5_update_int64(state, i);
}

/** Low-level wrapper for `::fz_measure_string()`. */
FZ_FUNCTION ::fz_matrix ll_fz_measure_string(::fz_font *user_font, ::fz_matrix trm, const char *s, int wmode, int bidi_level, ::fz_bidi_direction markup_dir, ::fz_text_language language)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_measure_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " user_font=" << user_font;
		std::cerr << " trm=" << trm;
		if (s) std::cerr << " s='" << s << "'";
		else std::cerr << " s:null";
		std::cerr << " wmode=" << wmode;
		std::cerr << " bidi_level=" << bidi_level;
		std::cerr << " markup_dir=" << markup_dir;
		std::cerr << " language=" << language;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_matrix ret;
	fz_try(auto_ctx) {
		ret = ::fz_measure_string(auto_ctx, user_font, trm, s, wmode, bidi_level, markup_dir, language);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_measure_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_memmem()`. */
FZ_FUNCTION void *ll_fz_memmem(const void *haystack, size_t haystacklen, const void *needle, size_t needlelen)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_memmem():";
		if (s_trace > 1) std::cerr << " haystack=" << (void*) haystack;
		std::cerr << " haystacklen=" << haystacklen;
		if (s_trace > 1) std::cerr << " needle=" << (void*) needle;
		std::cerr << " needlelen=" << needlelen;
		std::cerr << "\n";
	}
	#endif
	void * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_memmem(haystack, haystacklen, needle, needlelen);
	return ret;
}

/** Low-level wrapper for `::fz_memrnd()`. */
FZ_FUNCTION void ll_fz_memrnd(uint8_t *block, int len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_memrnd():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " block=" << (void*) block;
		std::cerr << " len=" << len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_memrnd(auto_ctx, block, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_memrnd(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_min()`. */
FZ_FUNCTION float ll_fz_min(float a, float b)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_min():";
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << "\n";
	}
	#endif
	float ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_min(a, b);
	return ret;
}

/** Low-level wrapper for `::fz_mini()`. */
FZ_FUNCTION int ll_fz_mini(int a, int b)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_mini():";
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_mini(a, b);
	return ret;
}

/** Low-level wrapper for `::fz_mini64()`. */
FZ_FUNCTION int64_t ll_fz_mini64(int64_t a, int64_t b)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_mini64():";
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << "\n";
	}
	#endif
	int64_t ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_mini64(a, b);
	return ret;
}

/** Low-level wrapper for `::fz_minz()`. */
FZ_FUNCTION size_t ll_fz_minz(size_t a, size_t b)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_minz():";
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << "\n";
	}
	#endif
	size_t ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_minz(a, b);
	return ret;
}

/** Low-level wrapper for `::fz_mkdir()`. */
FZ_FUNCTION int ll_fz_mkdir(char *path)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_mkdir():";
		if (s_trace > 1) std::cerr << " path=" << (void*) path;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_mkdir(path);
	return ret;
}

/** Low-level wrapper for `::fz_morph_error()`. */
FZ_FUNCTION void ll_fz_morph_error(int fromcode, int tocode)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_morph_error():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " fromcode=" << fromcode;
		std::cerr << " tocode=" << tocode;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_morph_error(auto_ctx, fromcode, tocode);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_morph_error(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_mount_multi_archive()`. */
FZ_FUNCTION void ll_fz_mount_multi_archive(::fz_archive *arch_, ::fz_archive *sub, const char *path)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_mount_multi_archive():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " arch_=" << arch_;
		if (s_trace > 1) std::cerr << " sub=" << sub;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_mount_multi_archive(auto_ctx, arch_, sub, path);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_mount_multi_archive(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_moveto()`. */
FZ_FUNCTION void ll_fz_moveto(::fz_path *path, float x, float y)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_moveto():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " path=" << path;
		std::cerr << " x=" << x;
		std::cerr << " y=" << y;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_moveto(auto_ctx, path, x, y);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_moveto(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_mul255()`. */
FZ_FUNCTION int ll_fz_mul255(int a, int b)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_mul255():";
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_mul255(a, b);
	return ret;
}

/** Low-level wrapper for `::fz_needs_password()`. */
FZ_FUNCTION int ll_fz_needs_password(::fz_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_needs_password():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_needs_password(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_needs_password(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_arc4_output()`. */
FZ_FUNCTION ::fz_output *ll_fz_new_arc4_output(::fz_output *chain, unsigned char *key, size_t keylen)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_arc4_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << " key=" << ((void*) key);
		std::cerr << " keylen=" << keylen;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_output * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_arc4_output(auto_ctx, chain, key, keylen);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_arc4_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_archive_of_size()`. */
FZ_FUNCTION ::fz_archive *ll_fz_new_archive_of_size(::fz_stream *file, int size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_archive_of_size():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " file=" << file;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_archive * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_archive_of_size(auto_ctx, file, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_archive_of_size(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_ascii85_output()`. */
FZ_FUNCTION ::fz_output *ll_fz_new_ascii85_output(::fz_output *chain)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_ascii85_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_output * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_ascii85_output(auto_ctx, chain);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_ascii85_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_asciihex_output()`. */
FZ_FUNCTION ::fz_output *ll_fz_new_asciihex_output(::fz_output *chain)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_asciihex_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_output * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_asciihex_output(auto_ctx, chain);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_asciihex_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_band_writer_of_size()`. */
FZ_FUNCTION ::fz_band_writer *ll_fz_new_band_writer_of_size(size_t size, ::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_band_writer_of_size():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " size=" << size;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_band_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_band_writer_of_size(auto_ctx, size, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_band_writer_of_size(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_base14_font()`. */
FZ_FUNCTION ::fz_font *ll_fz_new_base14_font(const char *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_base14_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_font * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_base14_font(auto_ctx, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_base14_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_bbox_device()`. */
FZ_FUNCTION ::fz_device *ll_fz_new_bbox_device(::fz_rect *rectp)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_bbox_device():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " rectp=" << rectp;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_device * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_bbox_device(auto_ctx, rectp);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_bbox_device(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_bitmap()`. */
FZ_FUNCTION ::fz_bitmap *ll_fz_new_bitmap(int w, int h, int n, int xres, int yres)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_bitmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " w=" << w;
		std::cerr << " h=" << h;
		std::cerr << " n=" << n;
		std::cerr << " xres=" << xres;
		std::cerr << " yres=" << yres;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_bitmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_bitmap(auto_ctx, w, h, n, xres, yres);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_bitmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_bitmap_from_pixmap()`. */
FZ_FUNCTION ::fz_bitmap *ll_fz_new_bitmap_from_pixmap(::fz_pixmap *pix, ::fz_halftone *ht)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_bitmap_from_pixmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		if (s_trace > 1) std::cerr << " ht=" << ht;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_bitmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_bitmap_from_pixmap(auto_ctx, pix, ht);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_bitmap_from_pixmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_bitmap_from_pixmap_band()`. */
FZ_FUNCTION ::fz_bitmap *ll_fz_new_bitmap_from_pixmap_band(::fz_pixmap *pix, ::fz_halftone *ht, int band_start)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_bitmap_from_pixmap_band():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		if (s_trace > 1) std::cerr << " ht=" << ht;
		std::cerr << " band_start=" << band_start;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_bitmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_bitmap_from_pixmap_band(auto_ctx, pix, ht, band_start);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_bitmap_from_pixmap_band(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer(size_t capacity)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " capacity=" << capacity;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer(auto_ctx, capacity);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_base64()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_base64(const char *data, size_t size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_base64():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (data) std::cerr << " data='" << data << "'";
		else std::cerr << " data:null";
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_base64(auto_ctx, data, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_base64(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_copied_data()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_copied_data(const unsigned char *data, size_t size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_copied_data():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " data=" << ((void*) data);
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_copied_data(auto_ctx, data, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_copied_data(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_data()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_data(unsigned char *data, size_t size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_data():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " data=" << ((void*) data);
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_data(auto_ctx, data, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_data(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_display_list()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_display_list(::fz_display_list *list, const ::fz_stext_options *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_display_list():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " list=" << list;
		std::cerr << " options=" << options;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_display_list(auto_ctx, list, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_display_list(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_image_as_jpeg()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_image_as_jpeg(::fz_image *image, ::fz_color_params color_params, int quality, int invert_cmyk)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_image_as_jpeg():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << " color_params=" << color_params;
		std::cerr << " quality=" << quality;
		std::cerr << " invert_cmyk=" << invert_cmyk;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_image_as_jpeg(auto_ctx, image, color_params, quality, invert_cmyk);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_image_as_jpeg(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_image_as_jpx()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_image_as_jpx(::fz_image *image, ::fz_color_params color_params, int quality)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_image_as_jpx():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << " color_params=" << color_params;
		std::cerr << " quality=" << quality;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_image_as_jpx(auto_ctx, image, color_params, quality);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_image_as_jpx(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_image_as_pam()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_image_as_pam(::fz_image *image, ::fz_color_params color_params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_image_as_pam():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << " color_params=" << color_params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_image_as_pam(auto_ctx, image, color_params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_image_as_pam(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_image_as_png()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_image_as_png(::fz_image *image, ::fz_color_params color_params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_image_as_png():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << " color_params=" << color_params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_image_as_png(auto_ctx, image, color_params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_image_as_png(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_image_as_pnm()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_image_as_pnm(::fz_image *image, ::fz_color_params color_params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_image_as_pnm():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << " color_params=" << color_params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_image_as_pnm(auto_ctx, image, color_params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_image_as_pnm(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_image_as_psd()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_image_as_psd(::fz_image *image, ::fz_color_params color_params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_image_as_psd():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << " color_params=" << color_params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_image_as_psd(auto_ctx, image, color_params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_image_as_psd(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_page()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_page(::fz_page *page, const ::fz_stext_options *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " options=" << options;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_page(auto_ctx, page, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_page_number()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_page_number(::fz_document *doc, int number, const ::fz_stext_options *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_page_number():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " number=" << number;
		std::cerr << " options=" << options;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_page_number(auto_ctx, doc, number, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_page_number(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_page_with_format()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_page_with_format(::fz_page *page, const char *format, const char *options, ::fz_matrix transform, ::fz_cookie *cookie)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_page_with_format():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		if (format) std::cerr << " format='" << format << "'";
		else std::cerr << " format:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << " transform=" << transform;
		std::cerr << " cookie=" << cookie;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_page_with_format(auto_ctx, page, format, options, transform, cookie);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_page_with_format(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_pixmap_as_jpeg()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_pixmap_as_jpeg(::fz_pixmap *pixmap, ::fz_color_params color_params, int quality, int invert_cmyk)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_pixmap_as_jpeg():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << " color_params=" << color_params;
		std::cerr << " quality=" << quality;
		std::cerr << " invert_cmyk=" << invert_cmyk;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_pixmap_as_jpeg(auto_ctx, pixmap, color_params, quality, invert_cmyk);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_pixmap_as_jpeg(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_pixmap_as_jpx()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_pixmap_as_jpx(::fz_pixmap *pix, ::fz_color_params color_params, int quality)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_pixmap_as_jpx():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << " color_params=" << color_params;
		std::cerr << " quality=" << quality;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_pixmap_as_jpx(auto_ctx, pix, color_params, quality);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_pixmap_as_jpx(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_pixmap_as_pam()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_pixmap_as_pam(::fz_pixmap *pixmap, ::fz_color_params color_params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_pixmap_as_pam():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << " color_params=" << color_params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_pixmap_as_pam(auto_ctx, pixmap, color_params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_pixmap_as_pam(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_pixmap_as_png()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_pixmap_as_png(::fz_pixmap *pixmap, ::fz_color_params color_params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_pixmap_as_png():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << " color_params=" << color_params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_pixmap_as_png(auto_ctx, pixmap, color_params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_pixmap_as_png(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_pixmap_as_pnm()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_pixmap_as_pnm(::fz_pixmap *pixmap, ::fz_color_params color_params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_pixmap_as_pnm():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << " color_params=" << color_params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_pixmap_as_pnm(auto_ctx, pixmap, color_params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_pixmap_as_pnm(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_pixmap_as_psd()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_pixmap_as_psd(::fz_pixmap *pix, ::fz_color_params color_params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_pixmap_as_psd():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << " color_params=" << color_params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_pixmap_as_psd(auto_ctx, pix, color_params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_pixmap_as_psd(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_shared_data()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_shared_data(const unsigned char *data, size_t size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_shared_data():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " data=" << ((void*) data);
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_shared_data(auto_ctx, data, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_shared_data(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_buffer_from_stext_page()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_new_buffer_from_stext_page(::fz_stext_page *text)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_buffer_from_stext_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " text=" << text;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_buffer_from_stext_page(auto_ctx, text);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_buffer_from_stext_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_builtin_font()`. */
FZ_FUNCTION ::fz_font *ll_fz_new_builtin_font(const char *name, int is_bold, int is_italic)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_builtin_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << " is_bold=" << is_bold;
		std::cerr << " is_italic=" << is_italic;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_font * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_builtin_font(auto_ctx, name, is_bold, is_italic);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_builtin_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_cal_gray_colorspace()`. */
FZ_FUNCTION ::fz_colorspace *ll_fz_new_cal_gray_colorspace(float wp[3], float bp[3], float gamma)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_cal_gray_colorspace():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " wp=" << wp;
		std::cerr << " bp=" << bp;
		std::cerr << " gamma=" << gamma;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_cal_gray_colorspace(auto_ctx, wp, bp, gamma);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_cal_gray_colorspace(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_cal_rgb_colorspace()`. */
FZ_FUNCTION ::fz_colorspace *ll_fz_new_cal_rgb_colorspace(float wp[3], float bp[3], float gamma[3], float matrix[9])
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_cal_rgb_colorspace():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " wp=" << wp;
		std::cerr << " bp=" << bp;
		std::cerr << " gamma=" << gamma;
		std::cerr << " matrix=" << matrix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_cal_rgb_colorspace(auto_ctx, wp, bp, gamma, matrix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_cal_rgb_colorspace(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_cbz_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_cbz_writer(const char *path, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_cbz_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_cbz_writer(auto_ctx, path, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_cbz_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_cbz_writer_with_output()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_cbz_writer_with_output(::fz_output *out, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_cbz_writer_with_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_cbz_writer_with_output(auto_ctx, out, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_cbz_writer_with_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_cjk_font()`. */
FZ_FUNCTION ::fz_font *ll_fz_new_cjk_font(int ordering)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_cjk_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " ordering=" << ordering;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_font * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_cjk_font(auto_ctx, ordering);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_cjk_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_color_pcl_band_writer()`. */
FZ_FUNCTION ::fz_band_writer *ll_fz_new_color_pcl_band_writer(::fz_output *out, const ::fz_pcl_options *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_color_pcl_band_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " options=" << options;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_band_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_color_pcl_band_writer(auto_ctx, out, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_color_pcl_band_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_colorspace()`. */
FZ_FUNCTION ::fz_colorspace *ll_fz_new_colorspace(enum fz_colorspace_type type, int flags, int n, const char *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_colorspace():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " type=" << type;
		std::cerr << " flags=" << flags;
		std::cerr << " n=" << n;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_colorspace(auto_ctx, type, flags, n, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_colorspace(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_compressed_buffer()`. */
FZ_FUNCTION ::fz_compressed_buffer *ll_fz_new_compressed_buffer()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_compressed_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_compressed_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_compressed_buffer(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_compressed_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_context_imp()`. */
FZ_FUNCTION ::fz_context *ll_fz_new_context_imp(const ::fz_alloc_context *alloc, const ::fz_locks_context *locks, size_t max_store, const char *version)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_context_imp():";
		if (s_trace > 1) std::cerr << " alloc=" << alloc;
		if (s_trace > 1) std::cerr << " locks=" << locks;
		std::cerr << " max_store=" << max_store;
		if (version) std::cerr << " version='" << version << "'";
		else std::cerr << " version:null";
		std::cerr << "\n";
	}
	#endif
	fz_context * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_new_context_imp(alloc, locks, max_store, version);
	return ret;
}

/** Low-level wrapper for `::fz_new_default_colorspaces()`. */
FZ_FUNCTION ::fz_default_colorspaces *ll_fz_new_default_colorspaces()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_default_colorspaces():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_default_colorspaces * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_default_colorspaces(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_default_colorspaces(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_deflate_output()`. */
FZ_FUNCTION ::fz_output *ll_fz_new_deflate_output(::fz_output *chain, int effort, int raw)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_deflate_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << " effort=" << effort;
		std::cerr << " raw=" << raw;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_output * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_deflate_output(auto_ctx, chain, effort, raw);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_deflate_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_deflated_data()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_new_deflated_data(const unsigned char *source, size_t source_length, ::fz_deflate_level level)` => `(unsigned char *, size_t compressed_length)`
*/
FZ_FUNCTION unsigned char *ll_fz_new_deflated_data(size_t *compressed_length, const unsigned char *source, size_t source_length, ::fz_deflate_level level)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_deflated_data():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " compressed_length=" << (void*) compressed_length;
		std::cerr << " source=" << ((void*) source);
		std::cerr << " source_length=" << source_length;
		std::cerr << " level=" << level;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_deflated_data(auto_ctx, compressed_length, source, source_length, level);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_deflated_data(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_deflated_data_from_buffer()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_new_deflated_data_from_buffer(::fz_buffer *buffer, ::fz_deflate_level level)` => `(unsigned char *, size_t compressed_length)`
*/
FZ_FUNCTION unsigned char *ll_fz_new_deflated_data_from_buffer(size_t *compressed_length, ::fz_buffer *buffer, ::fz_deflate_level level)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_deflated_data_from_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " compressed_length=" << (void*) compressed_length;
		if (s_trace > 1) std::cerr << " buffer=" << buffer;
		std::cerr << " level=" << level;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_deflated_data_from_buffer(auto_ctx, compressed_length, buffer, level);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_deflated_data_from_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_device_of_size()`. */
FZ_FUNCTION ::fz_device *ll_fz_new_device_of_size(int size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_device_of_size():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_device * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_device_of_size(auto_ctx, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_device_of_size(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_display_list()`. */
FZ_FUNCTION ::fz_display_list *ll_fz_new_display_list(::fz_rect mediabox)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_display_list():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " mediabox=" << mediabox;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_display_list * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_display_list(auto_ctx, mediabox);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_display_list(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_display_list_from_page()`. */
FZ_FUNCTION ::fz_display_list *ll_fz_new_display_list_from_page(::fz_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_display_list_from_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_display_list * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_display_list_from_page(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_display_list_from_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_display_list_from_page_contents()`. */
FZ_FUNCTION ::fz_display_list *ll_fz_new_display_list_from_page_contents(::fz_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_display_list_from_page_contents():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_display_list * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_display_list_from_page_contents(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_display_list_from_page_contents(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_display_list_from_page_number()`. */
FZ_FUNCTION ::fz_display_list *ll_fz_new_display_list_from_page_number(::fz_document *doc, int number)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_display_list_from_page_number():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " number=" << number;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_display_list * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_display_list_from_page_number(auto_ctx, doc, number);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_display_list_from_page_number(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_display_list_from_svg()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_new_display_list_from_svg(::fz_buffer *buf, const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`
*/
FZ_FUNCTION ::fz_display_list *ll_fz_new_display_list_from_svg(::fz_buffer *buf, const char *base_uri, ::fz_archive *dir, float *w, float *h)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_display_list_from_svg():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		if (base_uri) std::cerr << " base_uri='" << base_uri << "'";
		else std::cerr << " base_uri:null";
		if (s_trace > 1) std::cerr << " dir=" << dir;
		if (s_trace > 1) std::cerr << " w=" << (void*) w;
		if (s_trace > 1) std::cerr << " h=" << (void*) h;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_display_list * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_display_list_from_svg(auto_ctx, buf, base_uri, dir, w, h);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_display_list_from_svg(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_display_list_from_svg_xml()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_new_display_list_from_svg_xml(::fz_xml_doc *xmldoc, ::fz_xml *xml, const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`
*/
FZ_FUNCTION ::fz_display_list *ll_fz_new_display_list_from_svg_xml(::fz_xml_doc *xmldoc, ::fz_xml *xml, const char *base_uri, ::fz_archive *dir, float *w, float *h)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_display_list_from_svg_xml():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " xmldoc=" << xmldoc;
		if (s_trace > 1) std::cerr << " xml=" << xml;
		if (base_uri) std::cerr << " base_uri='" << base_uri << "'";
		else std::cerr << " base_uri:null";
		if (s_trace > 1) std::cerr << " dir=" << dir;
		if (s_trace > 1) std::cerr << " w=" << (void*) w;
		if (s_trace > 1) std::cerr << " h=" << (void*) h;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_display_list * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_display_list_from_svg_xml(auto_ctx, xmldoc, xml, base_uri, dir, w, h);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_display_list_from_svg_xml(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_document_of_size()`. */
FZ_FUNCTION void *ll_fz_new_document_of_size(int size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_document_of_size():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_document_of_size(auto_ctx, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_document_of_size(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_document_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_document_writer(const char *path, const char *format, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_document_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (format) std::cerr << " format='" << format << "'";
		else std::cerr << " format:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_document_writer(auto_ctx, path, format, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_document_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_document_writer_of_size()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_document_writer_of_size(size_t size, ::fz_document_writer_begin_page_fn *begin_page, ::fz_document_writer_end_page_fn *end_page, ::fz_document_writer_close_writer_fn *close, ::fz_document_writer_drop_writer_fn *drop)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_document_writer_of_size():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " size=" << size;
		if (s_trace > 1) std::cerr << " begin_page=" << (void*) begin_page;
		if (s_trace > 1) std::cerr << " end_page=" << (void*) end_page;
		if (s_trace > 1) std::cerr << " close=" << (void*) close;
		if (s_trace > 1) std::cerr << " drop=" << (void*) drop;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_document_writer_of_size(auto_ctx, size, begin_page, end_page, close, drop);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_document_writer_of_size(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_document_writer_with_buffer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_document_writer_with_buffer(::fz_buffer *buf, const char *format, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_document_writer_with_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		if (format) std::cerr << " format='" << format << "'";
		else std::cerr << " format:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_document_writer_with_buffer(auto_ctx, buf, format, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_document_writer_with_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_document_writer_with_output()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_document_writer_with_output(::fz_output *out, const char *format, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_document_writer_with_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (format) std::cerr << " format='" << format << "'";
		else std::cerr << " format:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_document_writer_with_output(auto_ctx, out, format, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_document_writer_with_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_docx_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_docx_writer(const char *path, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_docx_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_docx_writer(auto_ctx, path, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_docx_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_docx_writer_with_output()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_docx_writer_with_output(::fz_output *out, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_docx_writer_with_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_docx_writer_with_output(auto_ctx, out, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_docx_writer_with_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_draw_device()`. */
FZ_FUNCTION ::fz_device *ll_fz_new_draw_device(::fz_matrix transform, ::fz_pixmap *dest)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_draw_device():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " transform=" << transform;
		if (s_trace > 1) std::cerr << " dest=" << dest;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_device * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_draw_device(auto_ctx, transform, dest);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_draw_device(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_draw_device_type3()`. */
FZ_FUNCTION ::fz_device *ll_fz_new_draw_device_type3(::fz_matrix transform, ::fz_pixmap *dest)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_draw_device_type3():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " transform=" << transform;
		if (s_trace > 1) std::cerr << " dest=" << dest;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_device * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_draw_device_type3(auto_ctx, transform, dest);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_draw_device_type3(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_draw_device_with_bbox()`. */
FZ_FUNCTION ::fz_device *ll_fz_new_draw_device_with_bbox(::fz_matrix transform, ::fz_pixmap *dest, const ::fz_irect *clip)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_draw_device_with_bbox():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " transform=" << transform;
		if (s_trace > 1) std::cerr << " dest=" << dest;
		std::cerr << " clip=" << clip;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_device * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_draw_device_with_bbox(auto_ctx, transform, dest, clip);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_draw_device_with_bbox(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_draw_device_with_bbox_proof()`. */
FZ_FUNCTION ::fz_device *ll_fz_new_draw_device_with_bbox_proof(::fz_matrix transform, ::fz_pixmap *dest, const ::fz_irect *clip, ::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_draw_device_with_bbox_proof():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " transform=" << transform;
		if (s_trace > 1) std::cerr << " dest=" << dest;
		std::cerr << " clip=" << clip;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_device * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_draw_device_with_bbox_proof(auto_ctx, transform, dest, clip, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_draw_device_with_bbox_proof(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_draw_device_with_options()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_new_draw_device_with_options(const ::fz_draw_options *options, ::fz_rect mediabox, ::fz_pixmap **pixmap)` => `(fz_device *)`
*/
FZ_FUNCTION ::fz_device *ll_fz_new_draw_device_with_options(const ::fz_draw_options *options, ::fz_rect mediabox, ::fz_pixmap **pixmap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_draw_device_with_options():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " options=" << options;
		std::cerr << " mediabox=" << mediabox;
		if (s_trace > 1) std::cerr << " pixmap=" << (void*) pixmap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_device * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_draw_device_with_options(auto_ctx, options, mediabox, pixmap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_draw_device_with_options(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_draw_device_with_proof()`. */
FZ_FUNCTION ::fz_device *ll_fz_new_draw_device_with_proof(::fz_matrix transform, ::fz_pixmap *dest, ::fz_colorspace *proof_cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_draw_device_with_proof():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " transform=" << transform;
		if (s_trace > 1) std::cerr << " dest=" << dest;
		if (s_trace > 1) std::cerr << " proof_cs=" << proof_cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_device * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_draw_device_with_proof(auto_ctx, transform, dest, proof_cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_draw_device_with_proof(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_font_from_buffer()`. */
FZ_FUNCTION ::fz_font *ll_fz_new_font_from_buffer(const char *name, ::fz_buffer *buffer, int index, int use_glyph_bbox)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_font_from_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		if (s_trace > 1) std::cerr << " buffer=" << buffer;
		std::cerr << " index=" << index;
		std::cerr << " use_glyph_bbox=" << use_glyph_bbox;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_font * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_font_from_buffer(auto_ctx, name, buffer, index, use_glyph_bbox);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_font_from_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_font_from_file()`. */
FZ_FUNCTION ::fz_font *ll_fz_new_font_from_file(const char *name, const char *path, int index, int use_glyph_bbox)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_font_from_file():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		std::cerr << " index=" << index;
		std::cerr << " use_glyph_bbox=" << use_glyph_bbox;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_font * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_font_from_file(auto_ctx, name, path, index, use_glyph_bbox);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_font_from_file(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_font_from_memory()`. */
FZ_FUNCTION ::fz_font *ll_fz_new_font_from_memory(const char *name, const unsigned char *data, int len, int index, int use_glyph_bbox)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_font_from_memory():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << " data=" << ((void*) data);
		std::cerr << " len=" << len;
		std::cerr << " index=" << index;
		std::cerr << " use_glyph_bbox=" << use_glyph_bbox;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_font * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_font_from_memory(auto_ctx, name, data, len, index, use_glyph_bbox);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_font_from_memory(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_function_of_size()`. */
FZ_FUNCTION ::fz_function *ll_fz_new_function_of_size(int size, size_t size2, int m, int n, ::fz_function_eval_fn *eval, ::fz_store_drop_fn *drop)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_function_of_size():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " size=" << size;
		std::cerr << " size2=" << size2;
		std::cerr << " m=" << m;
		std::cerr << " n=" << n;
		if (s_trace > 1) std::cerr << " eval=" << (void*) eval;
		if (s_trace > 1) std::cerr << " drop=" << (void*) drop;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_function * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_function_of_size(auto_ctx, size, size2, m, n, eval, drop);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_function_of_size(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_hash_table()`. */
FZ_FUNCTION ::fz_hash_table *ll_fz_new_hash_table(int initialsize, int keylen, int lock, ::fz_hash_table_drop_fn *drop_val)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_hash_table():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " initialsize=" << initialsize;
		std::cerr << " keylen=" << keylen;
		std::cerr << " lock=" << lock;
		if (s_trace > 1) std::cerr << " drop_val=" << (void*) drop_val;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_hash_table * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_hash_table(auto_ctx, initialsize, keylen, lock, drop_val);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_hash_table(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_icc_colorspace()`. */
FZ_FUNCTION ::fz_colorspace *ll_fz_new_icc_colorspace(enum fz_colorspace_type type, int flags, const char *name, ::fz_buffer *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_icc_colorspace():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " type=" << type;
		std::cerr << " flags=" << flags;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_icc_colorspace(auto_ctx, type, flags, name, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_icc_colorspace(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_image_from_buffer()`. */
FZ_FUNCTION ::fz_image *ll_fz_new_image_from_buffer(::fz_buffer *buffer)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_image_from_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buffer=" << buffer;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_image * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_image_from_buffer(auto_ctx, buffer);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_image_from_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_image_from_compressed_buffer()`. */
FZ_FUNCTION ::fz_image *ll_fz_new_image_from_compressed_buffer(int w, int h, int bpc, ::fz_colorspace *colorspace, int xres, int yres, int interpolate, int imagemask, const float *decode, const int *colorkey, ::fz_compressed_buffer *buffer, ::fz_image *mask)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_image_from_compressed_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " w=" << w;
		std::cerr << " h=" << h;
		std::cerr << " bpc=" << bpc;
		if (s_trace > 1) std::cerr << " colorspace=" << colorspace;
		std::cerr << " xres=" << xres;
		std::cerr << " yres=" << yres;
		std::cerr << " interpolate=" << interpolate;
		std::cerr << " imagemask=" << imagemask;
		if (s_trace > 1) std::cerr << " decode=" << (void*) decode;
		if (s_trace > 1) std::cerr << " colorkey=" << (void*) colorkey;
		if (s_trace > 1) std::cerr << " buffer=" << buffer;
		if (s_trace > 1) std::cerr << " mask=" << mask;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_image * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_image_from_compressed_buffer(auto_ctx, w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_image_from_compressed_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_image_from_compressed_buffer2()`. */
FZ_FUNCTION ::fz_image *ll_fz_new_image_from_compressed_buffer2(int w, int h, int bpc, ::fz_colorspace *colorspace, int xres, int yres, int interpolate, int imagemask, const std::vector<float> &decode, const std::vector<int> &colorkey, ::fz_compressed_buffer *buffer, ::fz_image *mask)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_image_from_compressed_buffer2():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " w=" << w;
		std::cerr << " h=" << h;
		std::cerr << " bpc=" << bpc;
		if (s_trace > 1) std::cerr << " colorspace=" << colorspace;
		std::cerr << " xres=" << xres;
		std::cerr << " yres=" << yres;
		std::cerr << " interpolate=" << interpolate;
		std::cerr << " imagemask=" << imagemask;
		if (s_trace > 1) std::cerr << " &decode=" << &decode;
		if (s_trace > 1) std::cerr << " &colorkey=" << &colorkey;
		if (s_trace > 1) std::cerr << " buffer=" << buffer;
		if (s_trace > 1) std::cerr << " mask=" << mask;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_image * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_image_from_compressed_buffer2(auto_ctx, w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_image_from_compressed_buffer2(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_image_from_display_list()`. */
FZ_FUNCTION ::fz_image *ll_fz_new_image_from_display_list(float w, float h, ::fz_display_list *list)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_image_from_display_list():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " w=" << w;
		std::cerr << " h=" << h;
		if (s_trace > 1) std::cerr << " list=" << list;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_image * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_image_from_display_list(auto_ctx, w, h, list);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_image_from_display_list(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_image_from_file()`. */
FZ_FUNCTION ::fz_image *ll_fz_new_image_from_file(const char *path)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_image_from_file():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_image * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_image_from_file(auto_ctx, path);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_image_from_file(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_image_from_pixmap()`. */
FZ_FUNCTION ::fz_image *ll_fz_new_image_from_pixmap(::fz_pixmap *pixmap, ::fz_image *mask)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_image_from_pixmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		if (s_trace > 1) std::cerr << " mask=" << mask;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_image * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_image_from_pixmap(auto_ctx, pixmap, mask);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_image_from_pixmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_image_from_svg()`. */
FZ_FUNCTION ::fz_image *ll_fz_new_image_from_svg(::fz_buffer *buf, const char *base_uri, ::fz_archive *dir)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_image_from_svg():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		if (base_uri) std::cerr << " base_uri='" << base_uri << "'";
		else std::cerr << " base_uri:null";
		if (s_trace > 1) std::cerr << " dir=" << dir;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_image * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_image_from_svg(auto_ctx, buf, base_uri, dir);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_image_from_svg(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_image_from_svg_xml()`. */
FZ_FUNCTION ::fz_image *ll_fz_new_image_from_svg_xml(::fz_xml_doc *xmldoc, ::fz_xml *xml, const char *base_uri, ::fz_archive *dir)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_image_from_svg_xml():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " xmldoc=" << xmldoc;
		if (s_trace > 1) std::cerr << " xml=" << xml;
		if (base_uri) std::cerr << " base_uri='" << base_uri << "'";
		else std::cerr << " base_uri:null";
		if (s_trace > 1) std::cerr << " dir=" << dir;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_image * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_image_from_svg_xml(auto_ctx, xmldoc, xml, base_uri, dir);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_image_from_svg_xml(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_image_of_size()`. */
FZ_FUNCTION ::fz_image *ll_fz_new_image_of_size(int w, int h, int bpc, ::fz_colorspace *colorspace, int xres, int yres, int interpolate, int imagemask, const float *decode, const int *colorkey, ::fz_image *mask, size_t size, ::fz_image_get_pixmap_fn *get_pixmap, ::fz_image_get_size_fn *get_size, ::fz_drop_image_fn *drop)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_image_of_size():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " w=" << w;
		std::cerr << " h=" << h;
		std::cerr << " bpc=" << bpc;
		if (s_trace > 1) std::cerr << " colorspace=" << colorspace;
		std::cerr << " xres=" << xres;
		std::cerr << " yres=" << yres;
		std::cerr << " interpolate=" << interpolate;
		std::cerr << " imagemask=" << imagemask;
		if (s_trace > 1) std::cerr << " decode=" << (void*) decode;
		if (s_trace > 1) std::cerr << " colorkey=" << (void*) colorkey;
		if (s_trace > 1) std::cerr << " mask=" << mask;
		std::cerr << " size=" << size;
		if (s_trace > 1) std::cerr << " get_pixmap=" << (void*) get_pixmap;
		if (s_trace > 1) std::cerr << " get_size=" << (void*) get_size;
		if (s_trace > 1) std::cerr << " drop=" << (void*) drop;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_image * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_image_of_size(auto_ctx, w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, mask, size, get_pixmap, get_size, drop);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_image_of_size(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_indexed_colorspace()`. */
FZ_FUNCTION ::fz_colorspace *ll_fz_new_indexed_colorspace(::fz_colorspace *base, int high, unsigned char *lookup)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_indexed_colorspace():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " base=" << base;
		std::cerr << " high=" << high;
		std::cerr << " lookup=" << ((void*) lookup);
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_indexed_colorspace(auto_ctx, base, high, lookup);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_indexed_colorspace(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_jpeg_pixmap_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_jpeg_pixmap_writer(const char *path, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_jpeg_pixmap_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_jpeg_pixmap_writer(auto_ctx, path, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_jpeg_pixmap_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_layout()`. */
FZ_FUNCTION ::fz_layout_block *ll_fz_new_layout()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_layout():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_layout_block * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_layout(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_layout(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_link_of_size()`. */
FZ_FUNCTION ::fz_link *ll_fz_new_link_of_size(int size, ::fz_rect rect, const char *uri)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_link_of_size():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " size=" << size;
		std::cerr << " rect=" << rect;
		if (uri) std::cerr << " uri='" << uri << "'";
		else std::cerr << " uri:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_link * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_link_of_size(auto_ctx, size, rect, uri);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_link_of_size(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_list_device()`. */
FZ_FUNCTION ::fz_device *ll_fz_new_list_device(::fz_display_list *list)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_list_device():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " list=" << list;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_device * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_list_device(auto_ctx, list);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_list_device(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_log_for_module()`. */
FZ_FUNCTION ::fz_output *ll_fz_new_log_for_module(const char *module)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_log_for_module():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (module) std::cerr << " module='" << module << "'";
		else std::cerr << " module:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_output * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_log_for_module(auto_ctx, module);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_log_for_module(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_mono_pcl_band_writer()`. */
FZ_FUNCTION ::fz_band_writer *ll_fz_new_mono_pcl_band_writer(::fz_output *out, const ::fz_pcl_options *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_mono_pcl_band_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " options=" << options;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_band_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_mono_pcl_band_writer(auto_ctx, out, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_mono_pcl_band_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_mono_pwg_band_writer()`. */
FZ_FUNCTION ::fz_band_writer *ll_fz_new_mono_pwg_band_writer(::fz_output *out, const ::fz_pwg_options *pwg)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_mono_pwg_band_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " pwg=" << pwg;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_band_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_mono_pwg_band_writer(auto_ctx, out, pwg);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_mono_pwg_band_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_multi_archive()`. */
FZ_FUNCTION ::fz_archive *ll_fz_new_multi_archive()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_multi_archive():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_archive * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_multi_archive(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_multi_archive(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_ocr_device()`. */
FZ_FUNCTION ::fz_device *ll_fz_new_ocr_device(::fz_device *target, ::fz_matrix ctm, ::fz_rect mediabox, int with_list, const char *language, const char *datadir, int (*progress)(::fz_context *, void *, int ), void *progress_arg)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_ocr_device():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " target=" << target;
		std::cerr << " ctm=" << ctm;
		std::cerr << " mediabox=" << mediabox;
		std::cerr << " with_list=" << with_list;
		if (language) std::cerr << " language='" << language << "'";
		else std::cerr << " language:null";
		if (datadir) std::cerr << " datadir='" << datadir << "'";
		else std::cerr << " datadir:null";
		if (s_trace > 1) std::cerr << " progress=" << (void*) progress;
		if (s_trace > 1) std::cerr << " progress_arg=" << (void*) progress_arg;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_device * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_ocr_device(auto_ctx, target, ctm, mediabox, with_list, language, datadir, progress, progress_arg);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_ocr_device(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_odt_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_odt_writer(const char *path, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_odt_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_odt_writer(auto_ctx, path, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_odt_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_odt_writer_with_output()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_odt_writer_with_output(::fz_output *out, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_odt_writer_with_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_odt_writer_with_output(auto_ctx, out, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_odt_writer_with_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_outline()`. */
FZ_FUNCTION ::fz_outline *ll_fz_new_outline()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_outline():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_outline * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_outline(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_outline(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_outline_iterator()`. */
FZ_FUNCTION ::fz_outline_iterator *ll_fz_new_outline_iterator(::fz_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_outline_iterator():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_outline_iterator * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_outline_iterator(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_outline_iterator(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_outline_iterator_of_size()`. */
FZ_FUNCTION ::fz_outline_iterator *ll_fz_new_outline_iterator_of_size(size_t size, ::fz_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_outline_iterator_of_size():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " size=" << size;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_outline_iterator * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_outline_iterator_of_size(auto_ctx, size, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_outline_iterator_of_size(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_output()`. */
FZ_FUNCTION ::fz_output *ll_fz_new_output(int bufsiz, void *state, ::fz_output_write_fn *write, ::fz_output_close_fn *close, ::fz_output_drop_fn *drop)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " bufsiz=" << bufsiz;
		if (s_trace > 1) std::cerr << " state=" << (void*) state;
		if (s_trace > 1) std::cerr << " write=" << (void*) write;
		if (s_trace > 1) std::cerr << " close=" << (void*) close;
		if (s_trace > 1) std::cerr << " drop=" << (void*) drop;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_output * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_output(auto_ctx, bufsiz, state, write, close, drop);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_output_with_buffer()`. */
FZ_FUNCTION ::fz_output *ll_fz_new_output_with_buffer(::fz_buffer *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_output_with_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_output * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_output_with_buffer(auto_ctx, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_output_with_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_output_with_path()`. */
FZ_FUNCTION ::fz_output *ll_fz_new_output_with_path(const char *filename, int append)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_output_with_path():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << " append=" << append;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_output * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_output_with_path(auto_ctx, filename, append);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_output_with_path(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_page_of_size()`. */
FZ_FUNCTION ::fz_page *ll_fz_new_page_of_size(int size, ::fz_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_page_of_size():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " size=" << size;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_page * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_page_of_size(auto_ctx, size, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_page_of_size(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pam_band_writer()`. */
FZ_FUNCTION ::fz_band_writer *ll_fz_new_pam_band_writer(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pam_band_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_band_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pam_band_writer(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pam_band_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pam_pixmap_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_pam_pixmap_writer(const char *path, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pam_pixmap_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pam_pixmap_writer(auto_ctx, path, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pam_pixmap_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_path()`. */
FZ_FUNCTION ::fz_path *ll_fz_new_path()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_path():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_path * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_path(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_path(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pbm_band_writer()`. */
FZ_FUNCTION ::fz_band_writer *ll_fz_new_pbm_band_writer(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pbm_band_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_band_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pbm_band_writer(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pbm_band_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pbm_pixmap_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_pbm_pixmap_writer(const char *path, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pbm_pixmap_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pbm_pixmap_writer(auto_ctx, path, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pbm_pixmap_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pcl_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_pcl_writer(const char *path, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pcl_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pcl_writer(auto_ctx, path, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pcl_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pcl_writer_with_output()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_pcl_writer_with_output(::fz_output *out, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pcl_writer_with_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pcl_writer_with_output(auto_ctx, out, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pcl_writer_with_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pclm_band_writer()`. */
FZ_FUNCTION ::fz_band_writer *ll_fz_new_pclm_band_writer(::fz_output *out, const ::fz_pclm_options *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pclm_band_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " options=" << options;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_band_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pclm_band_writer(auto_ctx, out, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pclm_band_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pclm_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_pclm_writer(const char *path, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pclm_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pclm_writer(auto_ctx, path, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pclm_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pclm_writer_with_output()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_pclm_writer_with_output(::fz_output *out, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pclm_writer_with_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pclm_writer_with_output(auto_ctx, out, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pclm_writer_with_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pdf_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_pdf_writer(const char *path, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pdf_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pdf_writer(auto_ctx, path, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pdf_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pdf_writer_with_output()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_pdf_writer_with_output(::fz_output *out, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pdf_writer_with_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pdf_writer_with_output(auto_ctx, out, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pdf_writer_with_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pdfocr_band_writer()`. */
FZ_FUNCTION ::fz_band_writer *ll_fz_new_pdfocr_band_writer(::fz_output *out, const ::fz_pdfocr_options *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pdfocr_band_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " options=" << options;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_band_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pdfocr_band_writer(auto_ctx, out, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pdfocr_band_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pdfocr_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_pdfocr_writer(const char *path, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pdfocr_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pdfocr_writer(auto_ctx, path, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pdfocr_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pdfocr_writer_with_output()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_pdfocr_writer_with_output(::fz_output *out, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pdfocr_writer_with_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pdfocr_writer_with_output(auto_ctx, out, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pdfocr_writer_with_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pgm_pixmap_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_pgm_pixmap_writer(const char *path, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pgm_pixmap_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pgm_pixmap_writer(auto_ctx, path, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pgm_pixmap_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pixmap()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_new_pixmap(::fz_colorspace *cs, int w, int h, ::fz_separations *seps, int alpha)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pixmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << " w=" << w;
		std::cerr << " h=" << h;
		if (s_trace > 1) std::cerr << " seps=" << seps;
		std::cerr << " alpha=" << alpha;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pixmap(auto_ctx, cs, w, h, seps, alpha);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pixmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pixmap_from_alpha_channel()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_new_pixmap_from_alpha_channel(::fz_pixmap *src)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pixmap_from_alpha_channel():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " src=" << src;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pixmap_from_alpha_channel(auto_ctx, src);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pixmap_from_alpha_channel(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pixmap_from_color_and_mask()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_new_pixmap_from_color_and_mask(::fz_pixmap *color, ::fz_pixmap *mask)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pixmap_from_color_and_mask():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " color=" << color;
		if (s_trace > 1) std::cerr << " mask=" << mask;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pixmap_from_color_and_mask(auto_ctx, color, mask);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pixmap_from_color_and_mask(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pixmap_from_display_list()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_new_pixmap_from_display_list(::fz_display_list *list, ::fz_matrix ctm, ::fz_colorspace *cs, int alpha)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pixmap_from_display_list():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " list=" << list;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << " alpha=" << alpha;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pixmap_from_display_list(auto_ctx, list, ctm, cs, alpha);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pixmap_from_display_list(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pixmap_from_display_list_with_separations()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_new_pixmap_from_display_list_with_separations(::fz_display_list *list, ::fz_matrix ctm, ::fz_colorspace *cs, ::fz_separations *seps, int alpha)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pixmap_from_display_list_with_separations():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " list=" << list;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		if (s_trace > 1) std::cerr << " seps=" << seps;
		std::cerr << " alpha=" << alpha;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pixmap_from_display_list_with_separations(auto_ctx, list, ctm, cs, seps, alpha);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pixmap_from_display_list_with_separations(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pixmap_from_page()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_new_pixmap_from_page(::fz_page *page, ::fz_matrix ctm, ::fz_colorspace *cs, int alpha)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pixmap_from_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << " alpha=" << alpha;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pixmap_from_page(auto_ctx, page, ctm, cs, alpha);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pixmap_from_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pixmap_from_page_contents()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_new_pixmap_from_page_contents(::fz_page *page, ::fz_matrix ctm, ::fz_colorspace *cs, int alpha)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pixmap_from_page_contents():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << " alpha=" << alpha;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pixmap_from_page_contents(auto_ctx, page, ctm, cs, alpha);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pixmap_from_page_contents(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pixmap_from_page_contents_with_separations()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_new_pixmap_from_page_contents_with_separations(::fz_page *page, ::fz_matrix ctm, ::fz_colorspace *cs, ::fz_separations *seps, int alpha)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pixmap_from_page_contents_with_separations():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		if (s_trace > 1) std::cerr << " seps=" << seps;
		std::cerr << " alpha=" << alpha;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pixmap_from_page_contents_with_separations(auto_ctx, page, ctm, cs, seps, alpha);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pixmap_from_page_contents_with_separations(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pixmap_from_page_number()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_new_pixmap_from_page_number(::fz_document *doc, int number, ::fz_matrix ctm, ::fz_colorspace *cs, int alpha)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pixmap_from_page_number():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " number=" << number;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << " alpha=" << alpha;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pixmap_from_page_number(auto_ctx, doc, number, ctm, cs, alpha);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pixmap_from_page_number(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pixmap_from_page_number_with_separations()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_new_pixmap_from_page_number_with_separations(::fz_document *doc, int number, ::fz_matrix ctm, ::fz_colorspace *cs, ::fz_separations *seps, int alpha)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pixmap_from_page_number_with_separations():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " number=" << number;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		if (s_trace > 1) std::cerr << " seps=" << seps;
		std::cerr << " alpha=" << alpha;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pixmap_from_page_number_with_separations(auto_ctx, doc, number, ctm, cs, seps, alpha);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pixmap_from_page_number_with_separations(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pixmap_from_page_with_separations()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_new_pixmap_from_page_with_separations(::fz_page *page, ::fz_matrix ctm, ::fz_colorspace *cs, ::fz_separations *seps, int alpha)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pixmap_from_page_with_separations():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		if (s_trace > 1) std::cerr << " seps=" << seps;
		std::cerr << " alpha=" << alpha;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pixmap_from_page_with_separations(auto_ctx, page, ctm, cs, seps, alpha);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pixmap_from_page_with_separations(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pixmap_from_pixmap()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_new_pixmap_from_pixmap(::fz_pixmap *pixmap, const ::fz_irect *rect)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pixmap_from_pixmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << " rect=" << rect;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pixmap_from_pixmap(auto_ctx, pixmap, rect);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pixmap_from_pixmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pixmap_with_bbox()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_new_pixmap_with_bbox(::fz_colorspace *colorspace, ::fz_irect bbox, ::fz_separations *seps, int alpha)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pixmap_with_bbox():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " colorspace=" << colorspace;
		std::cerr << " bbox=" << bbox;
		if (s_trace > 1) std::cerr << " seps=" << seps;
		std::cerr << " alpha=" << alpha;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pixmap_with_bbox(auto_ctx, colorspace, bbox, seps, alpha);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pixmap_with_bbox(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pixmap_with_bbox_and_data()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_new_pixmap_with_bbox_and_data(::fz_colorspace *colorspace, ::fz_irect rect, ::fz_separations *seps, int alpha, unsigned char *samples)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pixmap_with_bbox_and_data():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " colorspace=" << colorspace;
		std::cerr << " rect=" << rect;
		if (s_trace > 1) std::cerr << " seps=" << seps;
		std::cerr << " alpha=" << alpha;
		std::cerr << " samples=" << ((void*) samples);
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pixmap_with_bbox_and_data(auto_ctx, colorspace, rect, seps, alpha, samples);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pixmap_with_bbox_and_data(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pixmap_with_data()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_new_pixmap_with_data(::fz_colorspace *colorspace, int w, int h, ::fz_separations *seps, int alpha, int stride, unsigned char *samples)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pixmap_with_data():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " colorspace=" << colorspace;
		std::cerr << " w=" << w;
		std::cerr << " h=" << h;
		if (s_trace > 1) std::cerr << " seps=" << seps;
		std::cerr << " alpha=" << alpha;
		std::cerr << " stride=" << stride;
		std::cerr << " samples=" << ((void*) samples);
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pixmap_with_data(auto_ctx, colorspace, w, h, seps, alpha, stride, samples);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pixmap_with_data(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pixmap_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_pixmap_writer(const char *path, const char *options, const char *default_path, int n, void (*save)(::fz_context *, ::fz_pixmap *, const char *))
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pixmap_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		if (default_path) std::cerr << " default_path='" << default_path << "'";
		else std::cerr << " default_path:null";
		std::cerr << " n=" << n;
		if (s_trace > 1) std::cerr << " save=" << (void*) save;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pixmap_writer(auto_ctx, path, options, default_path, n, save);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pixmap_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pkm_band_writer()`. */
FZ_FUNCTION ::fz_band_writer *ll_fz_new_pkm_band_writer(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pkm_band_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_band_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pkm_band_writer(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pkm_band_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pkm_pixmap_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_pkm_pixmap_writer(const char *path, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pkm_pixmap_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pkm_pixmap_writer(auto_ctx, path, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pkm_pixmap_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_png_band_writer()`. */
FZ_FUNCTION ::fz_band_writer *ll_fz_new_png_band_writer(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_png_band_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_band_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_png_band_writer(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_png_band_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_png_pixmap_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_png_pixmap_writer(const char *path, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_png_pixmap_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_png_pixmap_writer(auto_ctx, path, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_png_pixmap_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pnm_band_writer()`. */
FZ_FUNCTION ::fz_band_writer *ll_fz_new_pnm_band_writer(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pnm_band_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_band_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pnm_band_writer(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pnm_band_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pnm_pixmap_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_pnm_pixmap_writer(const char *path, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pnm_pixmap_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pnm_pixmap_writer(auto_ctx, path, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pnm_pixmap_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pool()`. */
FZ_FUNCTION ::fz_pool *ll_fz_new_pool()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pool():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pool * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pool(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pool(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_ppm_pixmap_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_ppm_pixmap_writer(const char *path, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_ppm_pixmap_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_ppm_pixmap_writer(auto_ctx, path, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_ppm_pixmap_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_ps_band_writer()`. */
FZ_FUNCTION ::fz_band_writer *ll_fz_new_ps_band_writer(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_ps_band_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_band_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_ps_band_writer(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_ps_band_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_ps_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_ps_writer(const char *path, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_ps_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_ps_writer(auto_ctx, path, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_ps_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_ps_writer_with_output()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_ps_writer_with_output(::fz_output *out, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_ps_writer_with_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_ps_writer_with_output(auto_ctx, out, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_ps_writer_with_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_psd_band_writer()`. */
FZ_FUNCTION ::fz_band_writer *ll_fz_new_psd_band_writer(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_psd_band_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_band_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_psd_band_writer(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_psd_band_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pwg_band_writer()`. */
FZ_FUNCTION ::fz_band_writer *ll_fz_new_pwg_band_writer(::fz_output *out, const ::fz_pwg_options *pwg)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pwg_band_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " pwg=" << pwg;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_band_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pwg_band_writer(auto_ctx, out, pwg);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pwg_band_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pwg_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_pwg_writer(const char *path, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pwg_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pwg_writer(auto_ctx, path, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pwg_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_pwg_writer_with_output()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_pwg_writer_with_output(::fz_output *out, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_pwg_writer_with_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_pwg_writer_with_output(auto_ctx, out, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_pwg_writer_with_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_rle_output()`. */
FZ_FUNCTION ::fz_output *ll_fz_new_rle_output(::fz_output *chain)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_rle_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_output * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_rle_output(auto_ctx, chain);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_rle_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_separations()`. */
FZ_FUNCTION ::fz_separations *ll_fz_new_separations(int controllable)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_separations():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " controllable=" << controllable;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_separations * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_separations(auto_ctx, controllable);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_separations(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_stext_device()`. */
FZ_FUNCTION ::fz_device *ll_fz_new_stext_device(::fz_stext_page *page, const ::fz_stext_options *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_stext_device():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " options=" << options;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_device * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_stext_device(auto_ctx, page, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_stext_device(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_stext_page()`. */
FZ_FUNCTION ::fz_stext_page *ll_fz_new_stext_page(::fz_rect mediabox)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_stext_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " mediabox=" << mediabox;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stext_page * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_stext_page(auto_ctx, mediabox);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_stext_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_stext_page_from_chapter_page_number()`. */
FZ_FUNCTION ::fz_stext_page *ll_fz_new_stext_page_from_chapter_page_number(::fz_document *doc, int chapter, int number, const ::fz_stext_options *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_stext_page_from_chapter_page_number():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " chapter=" << chapter;
		std::cerr << " number=" << number;
		std::cerr << " options=" << options;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stext_page * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_stext_page_from_chapter_page_number(auto_ctx, doc, chapter, number, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_stext_page_from_chapter_page_number(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_stext_page_from_display_list()`. */
FZ_FUNCTION ::fz_stext_page *ll_fz_new_stext_page_from_display_list(::fz_display_list *list, const ::fz_stext_options *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_stext_page_from_display_list():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " list=" << list;
		std::cerr << " options=" << options;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stext_page * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_stext_page_from_display_list(auto_ctx, list, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_stext_page_from_display_list(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_stext_page_from_page()`. */
FZ_FUNCTION ::fz_stext_page *ll_fz_new_stext_page_from_page(::fz_page *page, const ::fz_stext_options *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_stext_page_from_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " options=" << options;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stext_page * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_stext_page_from_page(auto_ctx, page, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_stext_page_from_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_stext_page_from_page_number()`. */
FZ_FUNCTION ::fz_stext_page *ll_fz_new_stext_page_from_page_number(::fz_document *doc, int number, const ::fz_stext_options *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_stext_page_from_page_number():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " number=" << number;
		std::cerr << " options=" << options;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stext_page * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_stext_page_from_page_number(auto_ctx, doc, number, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_stext_page_from_page_number(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_store_context()`. */
FZ_FUNCTION void ll_fz_new_store_context(size_t max)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_store_context():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " max=" << max;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_new_store_context(auto_ctx, max);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_store_context(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_new_story()`. */
FZ_FUNCTION ::fz_story *ll_fz_new_story(::fz_buffer *buf, const char *user_css, float em, ::fz_archive *dir)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_story():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		if (user_css) std::cerr << " user_css='" << user_css << "'";
		else std::cerr << " user_css:null";
		std::cerr << " em=" << em;
		if (s_trace > 1) std::cerr << " dir=" << dir;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_story * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_story(auto_ctx, buf, user_css, em, dir);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_story(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_stream()`. */
FZ_FUNCTION ::fz_stream *ll_fz_new_stream(void *state, ::fz_stream_next_fn *next, ::fz_stream_drop_fn *drop)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " state=" << (void*) state;
		if (s_trace > 1) std::cerr << " next=" << (void*) next;
		if (s_trace > 1) std::cerr << " drop=" << (void*) drop;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_stream(auto_ctx, state, next, drop);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_string()`. */
FZ_FUNCTION ::fz_string *ll_fz_new_string(const char *str)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (str) std::cerr << " str='" << str << "'";
		else std::cerr << " str:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_string * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_string(auto_ctx, str);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_stroke_state()`. */
FZ_FUNCTION ::fz_stroke_state *ll_fz_new_stroke_state()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_stroke_state():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stroke_state * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_stroke_state(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_stroke_state(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_stroke_state_with_dash_len()`. */
FZ_FUNCTION ::fz_stroke_state *ll_fz_new_stroke_state_with_dash_len(int len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_stroke_state_with_dash_len():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " len=" << len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stroke_state * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_stroke_state_with_dash_len(auto_ctx, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_stroke_state_with_dash_len(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_svg_device()`. */
FZ_FUNCTION ::fz_device *ll_fz_new_svg_device(::fz_output *out, float page_width, float page_height, int text_format, int reuse_images)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_svg_device():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " page_width=" << page_width;
		std::cerr << " page_height=" << page_height;
		std::cerr << " text_format=" << text_format;
		std::cerr << " reuse_images=" << reuse_images;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_device * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_svg_device(auto_ctx, out, page_width, page_height, text_format, reuse_images);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_svg_device(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_svg_device_with_id()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_new_svg_device_with_id(::fz_output *out, float page_width, float page_height, int text_format, int reuse_images)` => `(fz_device *, int id)`
*/
FZ_FUNCTION ::fz_device *ll_fz_new_svg_device_with_id(::fz_output *out, float page_width, float page_height, int text_format, int reuse_images, int *id)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_svg_device_with_id():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " page_width=" << page_width;
		std::cerr << " page_height=" << page_height;
		std::cerr << " text_format=" << text_format;
		std::cerr << " reuse_images=" << reuse_images;
		if (s_trace > 1) std::cerr << " id=" << (void*) id;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_device * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_svg_device_with_id(auto_ctx, out, page_width, page_height, text_format, reuse_images, id);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_svg_device_with_id(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_svg_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_svg_writer(const char *path, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_svg_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_svg_writer(auto_ctx, path, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_svg_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_svg_writer_with_output()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_svg_writer_with_output(::fz_output *out, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_svg_writer_with_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_svg_writer_with_output(auto_ctx, out, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_svg_writer_with_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_test_device()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_new_test_device(float threshold, int options, ::fz_device *passthrough)` => `(fz_device *, int is_color)`
*/
FZ_FUNCTION ::fz_device *ll_fz_new_test_device(int *is_color, float threshold, int options, ::fz_device *passthrough)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_test_device():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " is_color=" << (void*) is_color;
		std::cerr << " threshold=" << threshold;
		std::cerr << " options=" << options;
		if (s_trace > 1) std::cerr << " passthrough=" << passthrough;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_device * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_test_device(auto_ctx, is_color, threshold, options, passthrough);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_test_device(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_text()`. */
FZ_FUNCTION ::fz_text *ll_fz_new_text()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_text():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_text * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_text(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_text(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_text_writer()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_text_writer(const char *format, const char *path, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_text_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (format) std::cerr << " format='" << format << "'";
		else std::cerr << " format:null";
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_text_writer(auto_ctx, format, path, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_text_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_text_writer_with_output()`. */
FZ_FUNCTION ::fz_document_writer *ll_fz_new_text_writer_with_output(const char *format, ::fz_output *out, const char *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_text_writer_with_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (format) std::cerr << " format='" << format << "'";
		else std::cerr << " format:null";
		if (s_trace > 1) std::cerr << " out=" << out;
		if (options) std::cerr << " options='" << options << "'";
		else std::cerr << " options:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_text_writer_with_output(auto_ctx, format, out, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_text_writer_with_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_trace_device()`. */
FZ_FUNCTION ::fz_device *ll_fz_new_trace_device(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_trace_device():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_device * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_trace_device(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_trace_device(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_tree_archive()`. */
FZ_FUNCTION ::fz_archive *ll_fz_new_tree_archive(::fz_tree *tree)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_tree_archive():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " tree=" << tree;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_archive * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_tree_archive(auto_ctx, tree);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_tree_archive(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_type3_font()`. */
FZ_FUNCTION ::fz_font *ll_fz_new_type3_font(const char *name, ::fz_matrix matrix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_type3_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << " matrix=" << matrix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_font * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_type3_font(auto_ctx, name, matrix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_type3_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_xhtml_document_from_document()`. */
FZ_FUNCTION ::fz_document *ll_fz_new_xhtml_document_from_document(::fz_document *old_doc, const ::fz_stext_options *opts)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_xhtml_document_from_document():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " old_doc=" << old_doc;
		std::cerr << " opts=" << opts;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_xhtml_document_from_document(auto_ctx, old_doc, opts);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_xhtml_document_from_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_xmltext_device()`. */
FZ_FUNCTION ::fz_device *ll_fz_new_xmltext_device(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_xmltext_device():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_device * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_xmltext_device(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_xmltext_device(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_zip_writer()`. */
FZ_FUNCTION ::fz_zip_writer *ll_fz_new_zip_writer(const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_zip_writer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_zip_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_zip_writer(auto_ctx, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_zip_writer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_new_zip_writer_with_output()`. */
FZ_FUNCTION ::fz_zip_writer *ll_fz_new_zip_writer_with_output(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_new_zip_writer_with_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_zip_writer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_new_zip_writer_with_output(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_new_zip_writer_with_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_next_page()`. */
FZ_FUNCTION ::fz_location ll_fz_next_page(::fz_document *doc, ::fz_location loc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_next_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " loc=" << loc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_location ret;
	fz_try(auto_ctx) {
		ret = ::fz_next_page(auto_ctx, doc, loc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_next_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_normalize_vector()`. */
FZ_FUNCTION ::fz_point ll_fz_normalize_vector(::fz_point p)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_normalize_vector():";
		std::cerr << " p=" << p;
		std::cerr << "\n";
	}
	#endif
	fz_point ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_normalize_vector(p);
	return ret;
}

/** Low-level wrapper for `::fz_open_a85d()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_a85d(::fz_stream *chain)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_a85d():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_a85d(auto_ctx, chain);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_a85d(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_accelerated_document()`. */
FZ_FUNCTION ::fz_document *ll_fz_open_accelerated_document(const char *filename, const char *accel)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_accelerated_document():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		if (accel) std::cerr << " accel='" << accel << "'";
		else std::cerr << " accel:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_accelerated_document(auto_ctx, filename, accel);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_accelerated_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_accelerated_document_with_stream()`. */
FZ_FUNCTION ::fz_document *ll_fz_open_accelerated_document_with_stream(const char *magic, ::fz_stream *stream, ::fz_stream *accel)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_accelerated_document_with_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (magic) std::cerr << " magic='" << magic << "'";
		else std::cerr << " magic:null";
		if (s_trace > 1) std::cerr << " stream=" << stream;
		if (s_trace > 1) std::cerr << " accel=" << accel;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_accelerated_document_with_stream(auto_ctx, magic, stream, accel);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_accelerated_document_with_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_accelerated_document_with_stream_and_dir()`. */
FZ_FUNCTION ::fz_document *ll_fz_open_accelerated_document_with_stream_and_dir(const char *magic, ::fz_stream *stream, ::fz_stream *accel, ::fz_archive *dir)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_accelerated_document_with_stream_and_dir():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (magic) std::cerr << " magic='" << magic << "'";
		else std::cerr << " magic:null";
		if (s_trace > 1) std::cerr << " stream=" << stream;
		if (s_trace > 1) std::cerr << " accel=" << accel;
		if (s_trace > 1) std::cerr << " dir=" << dir;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_accelerated_document_with_stream_and_dir(auto_ctx, magic, stream, accel, dir);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_accelerated_document_with_stream_and_dir(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_aesd()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_aesd(::fz_stream *chain, unsigned char *key, unsigned int keylen)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_aesd():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << " key=" << ((void*) key);
		std::cerr << " keylen=" << keylen;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_aesd(auto_ctx, chain, key, keylen);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_aesd(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_ahxd()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_ahxd(::fz_stream *chain)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_ahxd():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_ahxd(auto_ctx, chain);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_ahxd(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_arc4()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_arc4(::fz_stream *chain, unsigned char *key, unsigned int keylen)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_arc4():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << " key=" << ((void*) key);
		std::cerr << " keylen=" << keylen;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_arc4(auto_ctx, chain, key, keylen);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_arc4(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_archive()`. */
FZ_FUNCTION ::fz_archive *ll_fz_open_archive(const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_archive():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_archive * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_archive(auto_ctx, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_archive(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_archive_entry()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_archive_entry(::fz_archive *arch, const char *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_archive_entry():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " arch=" << arch;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_archive_entry(auto_ctx, arch, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_archive_entry(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_archive_with_stream()`. */
FZ_FUNCTION ::fz_archive *ll_fz_open_archive_with_stream(::fz_stream *file)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_archive_with_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " file=" << file;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_archive * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_archive_with_stream(auto_ctx, file);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_archive_with_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_buffer()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_buffer(::fz_buffer *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_buffer(auto_ctx, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_cfb_archive()`. */
FZ_FUNCTION ::fz_archive *ll_fz_open_cfb_archive(const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_cfb_archive():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_archive * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_cfb_archive(auto_ctx, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_cfb_archive(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_cfb_archive_with_stream()`. */
FZ_FUNCTION ::fz_archive *ll_fz_open_cfb_archive_with_stream(::fz_stream *file)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_cfb_archive_with_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " file=" << file;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_archive * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_cfb_archive_with_stream(auto_ctx, file);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_cfb_archive_with_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_compressed_buffer()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_compressed_buffer(::fz_compressed_buffer *arg_1)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_compressed_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " arg_1=" << arg_1;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_compressed_buffer(auto_ctx, arg_1);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_compressed_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_concat()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_concat(int max, int pad)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_concat():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " max=" << max;
		std::cerr << " pad=" << pad;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_concat(auto_ctx, max, pad);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_concat(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_dctd()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_dctd(::fz_stream *chain, int color_transform, int invert_cmyk, int l2factor, ::fz_stream *jpegtables)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_dctd():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << " color_transform=" << color_transform;
		std::cerr << " invert_cmyk=" << invert_cmyk;
		std::cerr << " l2factor=" << l2factor;
		if (s_trace > 1) std::cerr << " jpegtables=" << jpegtables;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_dctd(auto_ctx, chain, color_transform, invert_cmyk, l2factor, jpegtables);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_dctd(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_directory()`. */
FZ_FUNCTION ::fz_archive *ll_fz_open_directory(const char *path)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_directory():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_archive * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_directory(auto_ctx, path);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_directory(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_document()`. */
FZ_FUNCTION ::fz_document *ll_fz_open_document(const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_document():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_document(auto_ctx, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_document_with_buffer()`. */
FZ_FUNCTION ::fz_document *ll_fz_open_document_with_buffer(const char *magic, ::fz_buffer *buffer)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_document_with_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (magic) std::cerr << " magic='" << magic << "'";
		else std::cerr << " magic:null";
		if (s_trace > 1) std::cerr << " buffer=" << buffer;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_document_with_buffer(auto_ctx, magic, buffer);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_document_with_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_document_with_stream()`. */
FZ_FUNCTION ::fz_document *ll_fz_open_document_with_stream(const char *magic, ::fz_stream *stream)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_document_with_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (magic) std::cerr << " magic='" << magic << "'";
		else std::cerr << " magic:null";
		if (s_trace > 1) std::cerr << " stream=" << stream;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_document_with_stream(auto_ctx, magic, stream);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_document_with_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_document_with_stream_and_dir()`. */
FZ_FUNCTION ::fz_document *ll_fz_open_document_with_stream_and_dir(const char *magic, ::fz_stream *stream, ::fz_archive *dir)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_document_with_stream_and_dir():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (magic) std::cerr << " magic='" << magic << "'";
		else std::cerr << " magic:null";
		if (s_trace > 1) std::cerr << " stream=" << stream;
		if (s_trace > 1) std::cerr << " dir=" << dir;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_document_with_stream_and_dir(auto_ctx, magic, stream, dir);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_document_with_stream_and_dir(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_endstream_filter()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_endstream_filter(::fz_stream *chain, uint64_t len, int64_t offset)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_endstream_filter():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << " len=" << len;
		std::cerr << " offset=" << offset;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_endstream_filter(auto_ctx, chain, len, offset);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_endstream_filter(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_faxd()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_faxd(::fz_stream *chain, int k, int end_of_line, int encoded_byte_align, int columns, int rows, int end_of_block, int black_is_1)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_faxd():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << " k=" << k;
		std::cerr << " end_of_line=" << end_of_line;
		std::cerr << " encoded_byte_align=" << encoded_byte_align;
		std::cerr << " columns=" << columns;
		std::cerr << " rows=" << rows;
		std::cerr << " end_of_block=" << end_of_block;
		std::cerr << " black_is_1=" << black_is_1;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_faxd(auto_ctx, chain, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_faxd(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_file()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_file(const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_file():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_file(auto_ctx, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_file(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_file_ptr_no_close()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_file_ptr_no_close(FILE *file)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_file_ptr_no_close():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " file=" << (void*) file;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_file_ptr_no_close(auto_ctx, file);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_file_ptr_no_close(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_flated()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_flated(::fz_stream *chain, int window_bits)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_flated():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << " window_bits=" << window_bits;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_flated(auto_ctx, chain, window_bits);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_flated(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_image_decomp_stream()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_open_image_decomp_stream(::fz_stream *arg_0, ::fz_compression_params *arg_1)` => `(fz_stream *, int l2factor)`
*/
FZ_FUNCTION ::fz_stream *ll_fz_open_image_decomp_stream(::fz_stream *arg_1, ::fz_compression_params *arg_2, int *l2factor)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_image_decomp_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " arg_1=" << arg_1;
		if (s_trace > 1) std::cerr << " arg_2=" << arg_2;
		if (s_trace > 1) std::cerr << " l2factor=" << (void*) l2factor;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_image_decomp_stream(auto_ctx, arg_1, arg_2, l2factor);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_image_decomp_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_image_decomp_stream_from_buffer()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_open_image_decomp_stream_from_buffer(::fz_compressed_buffer *arg_0)` => `(fz_stream *, int l2factor)`
*/
FZ_FUNCTION ::fz_stream *ll_fz_open_image_decomp_stream_from_buffer(::fz_compressed_buffer *arg_1, int *l2factor)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_image_decomp_stream_from_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " arg_1=" << arg_1;
		if (s_trace > 1) std::cerr << " l2factor=" << (void*) l2factor;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_image_decomp_stream_from_buffer(auto_ctx, arg_1, l2factor);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_image_decomp_stream_from_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_jbig2d()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_jbig2d(::fz_stream *chain, ::fz_jbig2_globals *globals, int embedded)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_jbig2d():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		if (s_trace > 1) std::cerr << " globals=" << globals;
		std::cerr << " embedded=" << embedded;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_jbig2d(auto_ctx, chain, globals, embedded);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_jbig2d(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_leecher()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_leecher(::fz_stream *chain, ::fz_buffer *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_leecher():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_leecher(auto_ctx, chain, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_leecher(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_libarchive_archive()`. */
FZ_FUNCTION ::fz_archive *ll_fz_open_libarchive_archive(const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_libarchive_archive():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_archive * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_libarchive_archive(auto_ctx, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_libarchive_archive(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_libarchive_archive_with_stream()`. */
FZ_FUNCTION ::fz_archive *ll_fz_open_libarchive_archive_with_stream(::fz_stream *file)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_libarchive_archive_with_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " file=" << file;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_archive * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_libarchive_archive_with_stream(auto_ctx, file);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_libarchive_archive_with_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_libarchived()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_libarchived(::fz_stream *chain)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_libarchived():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_libarchived(auto_ctx, chain);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_libarchived(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_lzwd()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_lzwd(::fz_stream *chain, int early_change, int min_bits, int reverse_bits, int old_tiff)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_lzwd():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << " early_change=" << early_change;
		std::cerr << " min_bits=" << min_bits;
		std::cerr << " reverse_bits=" << reverse_bits;
		std::cerr << " old_tiff=" << old_tiff;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_lzwd(auto_ctx, chain, early_change, min_bits, reverse_bits, old_tiff);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_lzwd(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_memory()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_memory(const unsigned char *data, size_t len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_memory():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " data=" << ((void*) data);
		std::cerr << " len=" << len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_memory(auto_ctx, data, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_memory(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_null_filter()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_null_filter(::fz_stream *chain, uint64_t len, int64_t offset)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_null_filter():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << " len=" << len;
		std::cerr << " offset=" << offset;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_null_filter(auto_ctx, chain, len, offset);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_null_filter(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_predict()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_predict(::fz_stream *chain, int predictor, int columns, int colors, int bpc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_predict():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << " predictor=" << predictor;
		std::cerr << " columns=" << columns;
		std::cerr << " colors=" << colors;
		std::cerr << " bpc=" << bpc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_predict(auto_ctx, chain, predictor, columns, colors, bpc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_predict(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_range_filter()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_range_filter(::fz_stream *chain, ::fz_range *ranges, int nranges)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_range_filter():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		if (s_trace > 1) std::cerr << " ranges=" << ranges;
		std::cerr << " nranges=" << nranges;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_range_filter(auto_ctx, chain, ranges, nranges);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_range_filter(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_reflowed_document()`. */
FZ_FUNCTION ::fz_document *ll_fz_open_reflowed_document(::fz_document *underdoc, const ::fz_stext_options *opts)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_reflowed_document():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " underdoc=" << underdoc;
		std::cerr << " opts=" << opts;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_document * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_reflowed_document(auto_ctx, underdoc, opts);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_reflowed_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_rld()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_rld(::fz_stream *chain)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_rld():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_rld(auto_ctx, chain);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_rld(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_sgilog16()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_sgilog16(::fz_stream *chain, int w)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_sgilog16():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << " w=" << w;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_sgilog16(auto_ctx, chain, w);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_sgilog16(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_sgilog24()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_sgilog24(::fz_stream *chain, int w)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_sgilog24():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << " w=" << w;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_sgilog24(auto_ctx, chain, w);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_sgilog24(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_sgilog32()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_sgilog32(::fz_stream *chain, int w)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_sgilog32():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << " w=" << w;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_sgilog32(auto_ctx, chain, w);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_sgilog32(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_tar_archive()`. */
FZ_FUNCTION ::fz_archive *ll_fz_open_tar_archive(const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_tar_archive():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_archive * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_tar_archive(auto_ctx, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_tar_archive(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_tar_archive_with_stream()`. */
FZ_FUNCTION ::fz_archive *ll_fz_open_tar_archive_with_stream(::fz_stream *file)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_tar_archive_with_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " file=" << file;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_archive * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_tar_archive_with_stream(auto_ctx, file);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_tar_archive_with_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_thunder()`. */
FZ_FUNCTION ::fz_stream *ll_fz_open_thunder(::fz_stream *chain, int w)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_thunder():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << " w=" << w;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_thunder(auto_ctx, chain, w);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_thunder(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_zip_archive()`. */
FZ_FUNCTION ::fz_archive *ll_fz_open_zip_archive(const char *path)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_zip_archive():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_archive * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_zip_archive(auto_ctx, path);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_zip_archive(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_open_zip_archive_with_stream()`. */
FZ_FUNCTION ::fz_archive *ll_fz_open_zip_archive_with_stream(::fz_stream *file)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_open_zip_archive_with_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " file=" << file;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_archive * ret;
	fz_try(auto_ctx) {
		ret = ::fz_open_zip_archive_with_stream(auto_ctx, file);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_open_zip_archive_with_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_opt_from_list()`. */
FZ_FUNCTION int ll_fz_opt_from_list(char *opt, const char *optlist)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_opt_from_list():";
		if (s_trace > 1) std::cerr << " opt=" << (void*) opt;
		if (optlist) std::cerr << " optlist='" << optlist << "'";
		else std::cerr << " optlist:null";
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_opt_from_list(opt, optlist);
	return ret;
}

/** Low-level wrapper for `::fz_option_eq()`. */
FZ_FUNCTION int ll_fz_option_eq(const char *a, const char *b)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_option_eq():";
		if (a) std::cerr << " a='" << a << "'";
		else std::cerr << " a:null";
		if (b) std::cerr << " b='" << b << "'";
		else std::cerr << " b:null";
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_option_eq(a, b);
	return ret;
}

/** Low-level wrapper for `::fz_outline_glyph()`. */
FZ_FUNCTION ::fz_path *ll_fz_outline_glyph(::fz_font *font, int gid, ::fz_matrix ctm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_outline_glyph():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " gid=" << gid;
		std::cerr << " ctm=" << ctm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_path * ret;
	fz_try(auto_ctx) {
		ret = ::fz_outline_glyph(auto_ctx, font, gid, ctm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_outline_glyph(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_outline_iterator_delete()`. */
FZ_FUNCTION int ll_fz_outline_iterator_delete(::fz_outline_iterator *iter)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_outline_iterator_delete():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " iter=" << iter;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_outline_iterator_delete(auto_ctx, iter);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_outline_iterator_delete(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_outline_iterator_down()`. */
FZ_FUNCTION int ll_fz_outline_iterator_down(::fz_outline_iterator *iter)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_outline_iterator_down():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " iter=" << iter;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_outline_iterator_down(auto_ctx, iter);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_outline_iterator_down(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_outline_iterator_from_outline()`. */
FZ_FUNCTION ::fz_outline_iterator *ll_fz_outline_iterator_from_outline(::fz_outline *outline)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_outline_iterator_from_outline():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " outline=" << outline;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_outline_iterator * ret;
	fz_try(auto_ctx) {
		ret = ::fz_outline_iterator_from_outline(auto_ctx, outline);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_outline_iterator_from_outline(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_outline_iterator_insert()`. */
FZ_FUNCTION int ll_fz_outline_iterator_insert(::fz_outline_iterator *iter, ::fz_outline_item *item)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_outline_iterator_insert():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " iter=" << iter;
		std::cerr << " item=" << item;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_outline_iterator_insert(auto_ctx, iter, item);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_outline_iterator_insert(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_outline_iterator_item()`. */
FZ_FUNCTION ::fz_outline_item *ll_fz_outline_iterator_item(::fz_outline_iterator *iter)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_outline_iterator_item():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " iter=" << iter;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_outline_item * ret;
	fz_try(auto_ctx) {
		ret = ::fz_outline_iterator_item(auto_ctx, iter);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_outline_iterator_item(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_outline_iterator_next()`. */
FZ_FUNCTION int ll_fz_outline_iterator_next(::fz_outline_iterator *iter)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_outline_iterator_next():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " iter=" << iter;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_outline_iterator_next(auto_ctx, iter);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_outline_iterator_next(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_outline_iterator_prev()`. */
FZ_FUNCTION int ll_fz_outline_iterator_prev(::fz_outline_iterator *iter)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_outline_iterator_prev():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " iter=" << iter;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_outline_iterator_prev(auto_ctx, iter);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_outline_iterator_prev(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_outline_iterator_up()`. */
FZ_FUNCTION int ll_fz_outline_iterator_up(::fz_outline_iterator *iter)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_outline_iterator_up():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " iter=" << iter;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_outline_iterator_up(auto_ctx, iter);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_outline_iterator_up(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_outline_iterator_update()`. */
FZ_FUNCTION void ll_fz_outline_iterator_update(::fz_outline_iterator *iter, ::fz_outline_item *item)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_outline_iterator_update():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " iter=" << iter;
		std::cerr << " item=" << item;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_outline_iterator_update(auto_ctx, iter, item);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_outline_iterator_update(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_output_accelerator()`. */
FZ_FUNCTION void ll_fz_output_accelerator(::fz_document *doc, ::fz_output *accel)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_output_accelerator():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " accel=" << accel;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_output_accelerator(auto_ctx, doc, accel);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_output_accelerator(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_output_supports_stream()`. */
FZ_FUNCTION int ll_fz_output_supports_stream(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_output_supports_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_output_supports_stream(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_output_supports_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_output_xml()`. */
FZ_FUNCTION void ll_fz_output_xml(::fz_output *out, ::fz_xml *item, int level)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_output_xml():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " item=" << item;
		std::cerr << " level=" << level;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_output_xml(auto_ctx, out, item, level);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_output_xml(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_pack_path()`. */
FZ_FUNCTION size_t ll_fz_pack_path(uint8_t *pack, const ::fz_path *path)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pack_path():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pack=" << (void*) pack;
		if (s_trace > 1) std::cerr << " path=" << path;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	size_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_pack_path(auto_ctx, pack, path);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pack_path(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_packed_path_size()`. */
FZ_FUNCTION int ll_fz_packed_path_size(const ::fz_path *path)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_packed_path_size():";
		if (s_trace > 1) std::cerr << " path=" << path;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_packed_path_size(path);
	return ret;
}

/** Low-level wrapper for `::fz_page_label()`. */
FZ_FUNCTION const char *ll_fz_page_label(::fz_page *page, char *buf, int size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_page_label():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		if (s_trace > 1) std::cerr << " buf=" << (void*) buf;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_page_label(auto_ctx, page, buf, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_page_label(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_page_number_from_location()`. */
FZ_FUNCTION int ll_fz_page_number_from_location(::fz_document *doc, ::fz_location loc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_page_number_from_location():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " loc=" << loc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_page_number_from_location(auto_ctx, doc, loc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_page_number_from_location(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_page_presentation()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_page_presentation(::fz_page *page, ::fz_transition *transition)` => `(fz_transition *, float duration)`
*/
FZ_FUNCTION ::fz_transition *ll_fz_page_presentation(::fz_page *page, ::fz_transition *transition, float *duration)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_page_presentation():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " transition=" << transition;
		if (s_trace > 1) std::cerr << " duration=" << (void*) duration;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_transition * ret;
	fz_try(auto_ctx) {
		ret = ::fz_page_presentation(auto_ctx, page, transition, duration);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_page_presentation(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_page_separations()`. */
FZ_FUNCTION ::fz_separations *ll_fz_page_separations(::fz_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_page_separations():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_separations * ret;
	fz_try(auto_ctx) {
		ret = ::fz_page_separations(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_page_separations(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_page_uses_overprint()`. */
FZ_FUNCTION int ll_fz_page_uses_overprint(::fz_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_page_uses_overprint():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_page_uses_overprint(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_page_uses_overprint(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_paint_shade()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_paint_shade(::fz_shade *shade, ::fz_colorspace *override_cs, ::fz_matrix ctm, ::fz_pixmap *dest, ::fz_color_params color_params, ::fz_irect bbox, const ::fz_overprint *eop, ::fz_shade_color_cache **cache)` => 
*/
FZ_FUNCTION void ll_fz_paint_shade(::fz_shade *shade, ::fz_colorspace *override_cs, ::fz_matrix ctm, ::fz_pixmap *dest, ::fz_color_params color_params, ::fz_irect bbox, const ::fz_overprint *eop, ::fz_shade_color_cache **cache)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_paint_shade():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " shade=" << shade;
		if (s_trace > 1) std::cerr << " override_cs=" << override_cs;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " dest=" << dest;
		std::cerr << " color_params=" << color_params;
		std::cerr << " bbox=" << bbox;
		if (s_trace > 1) std::cerr << " eop=" << eop;
		if (s_trace > 1) std::cerr << " cache=" << (void*) cache;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_paint_shade(auto_ctx, shade, override_cs, ctm, dest, color_params, bbox, eop, cache);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_paint_shade(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_parse_draw_options()`. */
FZ_FUNCTION ::fz_draw_options *ll_fz_parse_draw_options(::fz_draw_options *options, const char *string)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_parse_draw_options():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " options=" << options;
		if (string) std::cerr << " string='" << string << "'";
		else std::cerr << " string:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_draw_options * ret;
	fz_try(auto_ctx) {
		ret = ::fz_parse_draw_options(auto_ctx, options, string);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_parse_draw_options(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_parse_page_range()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_parse_page_range(const char *s, int n)` => `(const char *, int a, int b)`
*/
FZ_FUNCTION const char *ll_fz_parse_page_range(const char *s, int *a, int *b, int n)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_parse_page_range():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s) std::cerr << " s='" << s << "'";
		else std::cerr << " s:null";
		if (s_trace > 1) std::cerr << " a=" << (void*) a;
		if (s_trace > 1) std::cerr << " b=" << (void*) b;
		std::cerr << " n=" << n;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_parse_page_range(auto_ctx, s, a, b, n);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_parse_page_range(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_parse_pcl_options()`. */
FZ_FUNCTION ::fz_pcl_options *ll_fz_parse_pcl_options(::fz_pcl_options *opts, const char *args)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_parse_pcl_options():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " opts=" << opts;
		if (args) std::cerr << " args='" << args << "'";
		else std::cerr << " args:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pcl_options * ret;
	fz_try(auto_ctx) {
		ret = ::fz_parse_pcl_options(auto_ctx, opts, args);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_parse_pcl_options(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_parse_pclm_options()`. */
FZ_FUNCTION ::fz_pclm_options *ll_fz_parse_pclm_options(::fz_pclm_options *opts, const char *args)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_parse_pclm_options():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " opts=" << opts;
		if (args) std::cerr << " args='" << args << "'";
		else std::cerr << " args:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pclm_options * ret;
	fz_try(auto_ctx) {
		ret = ::fz_parse_pclm_options(auto_ctx, opts, args);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_parse_pclm_options(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_parse_pdfocr_options()`. */
FZ_FUNCTION ::fz_pdfocr_options *ll_fz_parse_pdfocr_options(::fz_pdfocr_options *opts, const char *args)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_parse_pdfocr_options():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " opts=" << opts;
		if (args) std::cerr << " args='" << args << "'";
		else std::cerr << " args:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pdfocr_options * ret;
	fz_try(auto_ctx) {
		ret = ::fz_parse_pdfocr_options(auto_ctx, opts, args);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_parse_pdfocr_options(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_parse_stext_options()`. */
FZ_FUNCTION ::fz_stext_options *ll_fz_parse_stext_options(::fz_stext_options *opts, const char *string)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_parse_stext_options():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " opts=" << opts;
		if (string) std::cerr << " string='" << string << "'";
		else std::cerr << " string:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stext_options * ret;
	fz_try(auto_ctx) {
		ret = ::fz_parse_stext_options(auto_ctx, opts, string);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_parse_stext_options(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_parse_xml()`. */
FZ_FUNCTION ::fz_xml *ll_fz_parse_xml(::fz_buffer *buf, int preserve_white)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_parse_xml():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << " preserve_white=" << preserve_white;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_xml * ret;
	fz_try(auto_ctx) {
		ret = ::fz_parse_xml(auto_ctx, buf, preserve_white);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_parse_xml(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_parse_xml_archive_entry()`. */
FZ_FUNCTION ::fz_xml *ll_fz_parse_xml_archive_entry(::fz_archive *dir, const char *filename, int preserve_white)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_parse_xml_archive_entry():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dir=" << dir;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << " preserve_white=" << preserve_white;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_xml * ret;
	fz_try(auto_ctx) {
		ret = ::fz_parse_xml_archive_entry(auto_ctx, dir, filename, preserve_white);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_parse_xml_archive_entry(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_parse_xml_from_html5()`. */
FZ_FUNCTION ::fz_xml *ll_fz_parse_xml_from_html5(::fz_buffer *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_parse_xml_from_html5():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_xml * ret;
	fz_try(auto_ctx) {
		ret = ::fz_parse_xml_from_html5(auto_ctx, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_parse_xml_from_html5(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_parse_xml_stream()`. */
FZ_FUNCTION ::fz_xml *ll_fz_parse_xml_stream(::fz_stream *stream, int preserve_white)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_parse_xml_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stream=" << stream;
		std::cerr << " preserve_white=" << preserve_white;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_xml * ret;
	fz_try(auto_ctx) {
		ret = ::fz_parse_xml_stream(auto_ctx, stream, preserve_white);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_parse_xml_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_pcl_preset()`. */
FZ_FUNCTION void ll_fz_pcl_preset(::fz_pcl_options *opts, const char *preset)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pcl_preset():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " opts=" << opts;
		if (preset) std::cerr << " preset='" << preset << "'";
		else std::cerr << " preset:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_pcl_preset(auto_ctx, opts, preset);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pcl_preset(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_pdfocr_band_writer_set_progress()`. */
FZ_FUNCTION void ll_fz_pdfocr_band_writer_set_progress(::fz_band_writer *writer, ::fz_pdfocr_progress_fn *progress_fn, void *progress_arg)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pdfocr_band_writer_set_progress():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " writer=" << writer;
		if (s_trace > 1) std::cerr << " progress_fn=" << (void*) progress_fn;
		if (s_trace > 1) std::cerr << " progress_arg=" << (void*) progress_arg;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_pdfocr_band_writer_set_progress(auto_ctx, writer, progress_fn, progress_arg);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pdfocr_band_writer_set_progress(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_pdfocr_writer_set_progress()`. */
FZ_FUNCTION void ll_fz_pdfocr_writer_set_progress(::fz_document_writer *writer, ::fz_pdfocr_progress_fn *progress, void *arg_3)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pdfocr_writer_set_progress():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " writer=" << writer;
		if (s_trace > 1) std::cerr << " progress=" << (void*) progress;
		if (s_trace > 1) std::cerr << " arg_3=" << (void*) arg_3;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_pdfocr_writer_set_progress(auto_ctx, writer, progress, arg_3);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pdfocr_writer_set_progress(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_peek_byte()`. */
FZ_FUNCTION int ll_fz_peek_byte(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_peek_byte():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_peek_byte(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_peek_byte(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_pixmap_alpha()`. */
FZ_FUNCTION int ll_fz_pixmap_alpha(const ::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pixmap_alpha():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_pixmap_alpha(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pixmap_alpha(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_pixmap_bbox()`. */
FZ_FUNCTION ::fz_irect ll_fz_pixmap_bbox(const ::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pixmap_bbox():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_irect ret;
	fz_try(auto_ctx) {
		ret = ::fz_pixmap_bbox(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pixmap_bbox(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_pixmap_colorants()`. */
FZ_FUNCTION int ll_fz_pixmap_colorants(const ::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pixmap_colorants():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_pixmap_colorants(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pixmap_colorants(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_pixmap_colorspace()`. */
FZ_FUNCTION ::fz_colorspace *ll_fz_pixmap_colorspace(const ::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pixmap_colorspace():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::fz_pixmap_colorspace(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pixmap_colorspace(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_pixmap_components()`. */
FZ_FUNCTION int ll_fz_pixmap_components(const ::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pixmap_components():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_pixmap_components(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pixmap_components(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_pixmap_height()`. */
FZ_FUNCTION int ll_fz_pixmap_height(const ::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pixmap_height():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_pixmap_height(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pixmap_height(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_pixmap_image_tile()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_pixmap_image_tile(::fz_pixmap_image *cimg)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pixmap_image_tile():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cimg=" << cimg;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_pixmap_image_tile(auto_ctx, cimg);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pixmap_image_tile(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_pixmap_samples()`. */
FZ_FUNCTION unsigned char *ll_fz_pixmap_samples(const ::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pixmap_samples():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_pixmap_samples(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pixmap_samples(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_pixmap_samples_int()`. */
FZ_FUNCTION long long ll_fz_pixmap_samples_int(::fz_pixmap *pixmap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pixmap_samples_int():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	long long ret;
	fz_try(auto_ctx) {
		ret = ::fz_pixmap_samples_int(auto_ctx, pixmap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pixmap_samples_int(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_pixmap_size()`. */
FZ_FUNCTION size_t ll_fz_pixmap_size(::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pixmap_size():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	size_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_pixmap_size(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pixmap_size(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_pixmap_spots()`. */
FZ_FUNCTION int ll_fz_pixmap_spots(const ::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pixmap_spots():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_pixmap_spots(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pixmap_spots(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_pixmap_stride()`. */
FZ_FUNCTION int ll_fz_pixmap_stride(const ::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pixmap_stride():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_pixmap_stride(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pixmap_stride(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_pixmap_width()`. */
FZ_FUNCTION int ll_fz_pixmap_width(const ::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pixmap_width():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_pixmap_width(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pixmap_width(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_pixmap_x()`. */
FZ_FUNCTION int ll_fz_pixmap_x(const ::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pixmap_x():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_pixmap_x(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pixmap_x(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_pixmap_y()`. */
FZ_FUNCTION int ll_fz_pixmap_y(const ::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pixmap_y():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_pixmap_y(auto_ctx, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pixmap_y(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_place_story()`. */
FZ_FUNCTION int ll_fz_place_story(::fz_story *story, ::fz_rect where, ::fz_rect *filled)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_place_story():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " story=" << story;
		std::cerr << " where=" << where;
		std::cerr << " filled=" << filled;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_place_story(auto_ctx, story, where, filled);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_place_story(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_place_story_flags()`. */
FZ_FUNCTION int ll_fz_place_story_flags(::fz_story *story, ::fz_rect where, ::fz_rect *filled, int flags)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_place_story_flags():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " story=" << story;
		std::cerr << " where=" << where;
		std::cerr << " filled=" << filled;
		std::cerr << " flags=" << flags;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_place_story_flags(auto_ctx, story, where, filled, flags);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_place_story_flags(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_pool_alloc()`. */
FZ_FUNCTION void *ll_fz_pool_alloc(::fz_pool *pool, size_t size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pool_alloc():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pool=" << pool;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_pool_alloc(auto_ctx, pool, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pool_alloc(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_pool_size()`. */
FZ_FUNCTION size_t ll_fz_pool_size(::fz_pool *pool)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pool_size():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pool=" << pool;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	size_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_pool_size(auto_ctx, pool);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pool_size(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_pool_strdup()`. */
FZ_FUNCTION char *ll_fz_pool_strdup(::fz_pool *pool, const char *s)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pool_strdup():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pool=" << pool;
		if (s) std::cerr << " s='" << s << "'";
		else std::cerr << " s:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_pool_strdup(auto_ctx, pool, s);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pool_strdup(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_pop_clip()`. */
FZ_FUNCTION void ll_fz_pop_clip(::fz_device *dev)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pop_clip():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_pop_clip(auto_ctx, dev);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_pop_clip(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_post_scale()`. */
FZ_FUNCTION ::fz_matrix ll_fz_post_scale(::fz_matrix m, float sx, float sy)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_post_scale():";
		std::cerr << " m=" << m;
		std::cerr << " sx=" << sx;
		std::cerr << " sy=" << sy;
		std::cerr << "\n";
	}
	#endif
	fz_matrix ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_post_scale(m, sx, sy);
	return ret;
}

/** Low-level wrapper for `::fz_pre_rotate()`. */
FZ_FUNCTION ::fz_matrix ll_fz_pre_rotate(::fz_matrix m, float degrees)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pre_rotate():";
		std::cerr << " m=" << m;
		std::cerr << " degrees=" << degrees;
		std::cerr << "\n";
	}
	#endif
	fz_matrix ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_pre_rotate(m, degrees);
	return ret;
}

/** Low-level wrapper for `::fz_pre_scale()`. */
FZ_FUNCTION ::fz_matrix ll_fz_pre_scale(::fz_matrix m, float sx, float sy)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pre_scale():";
		std::cerr << " m=" << m;
		std::cerr << " sx=" << sx;
		std::cerr << " sy=" << sy;
		std::cerr << "\n";
	}
	#endif
	fz_matrix ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_pre_scale(m, sx, sy);
	return ret;
}

/** Low-level wrapper for `::fz_pre_shear()`. */
FZ_FUNCTION ::fz_matrix ll_fz_pre_shear(::fz_matrix m, float sx, float sy)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pre_shear():";
		std::cerr << " m=" << m;
		std::cerr << " sx=" << sx;
		std::cerr << " sy=" << sy;
		std::cerr << "\n";
	}
	#endif
	fz_matrix ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_pre_shear(m, sx, sy);
	return ret;
}

/** Low-level wrapper for `::fz_pre_translate()`. */
FZ_FUNCTION ::fz_matrix ll_fz_pre_translate(::fz_matrix m, float tx, float ty)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_pre_translate():";
		std::cerr << " m=" << m;
		std::cerr << " tx=" << tx;
		std::cerr << " ty=" << ty;
		std::cerr << "\n";
	}
	#endif
	fz_matrix ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_pre_translate(m, tx, ty);
	return ret;
}

/** Low-level wrapper for `::fz_prepare_t3_glyph()`. */
FZ_FUNCTION void ll_fz_prepare_t3_glyph(::fz_font *font, int gid)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_prepare_t3_glyph():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " gid=" << gid;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_prepare_t3_glyph(auto_ctx, font, gid);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_prepare_t3_glyph(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_previous_page()`. */
FZ_FUNCTION ::fz_location ll_fz_previous_page(::fz_document *doc, ::fz_location loc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_previous_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " loc=" << loc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_location ret;
	fz_try(auto_ctx) {
		ret = ::fz_previous_page(auto_ctx, doc, loc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_previous_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_print_stext_header_as_html()`. */
FZ_FUNCTION void ll_fz_print_stext_header_as_html(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_print_stext_header_as_html():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_print_stext_header_as_html(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_print_stext_header_as_html(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_print_stext_header_as_xhtml()`. */
FZ_FUNCTION void ll_fz_print_stext_header_as_xhtml(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_print_stext_header_as_xhtml():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_print_stext_header_as_xhtml(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_print_stext_header_as_xhtml(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_print_stext_page_as_html()`. */
FZ_FUNCTION void ll_fz_print_stext_page_as_html(::fz_output *out, ::fz_stext_page *page, int id)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_print_stext_page_as_html():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " id=" << id;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_print_stext_page_as_html(auto_ctx, out, page, id);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_print_stext_page_as_html(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_print_stext_page_as_json()`. */
FZ_FUNCTION void ll_fz_print_stext_page_as_json(::fz_output *out, ::fz_stext_page *page, float scale)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_print_stext_page_as_json():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " scale=" << scale;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_print_stext_page_as_json(auto_ctx, out, page, scale);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_print_stext_page_as_json(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_print_stext_page_as_text()`. */
FZ_FUNCTION void ll_fz_print_stext_page_as_text(::fz_output *out, ::fz_stext_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_print_stext_page_as_text():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_print_stext_page_as_text(auto_ctx, out, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_print_stext_page_as_text(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_print_stext_page_as_xhtml()`. */
FZ_FUNCTION void ll_fz_print_stext_page_as_xhtml(::fz_output *out, ::fz_stext_page *page, int id)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_print_stext_page_as_xhtml():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " id=" << id;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_print_stext_page_as_xhtml(auto_ctx, out, page, id);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_print_stext_page_as_xhtml(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_print_stext_page_as_xml()`. */
FZ_FUNCTION void ll_fz_print_stext_page_as_xml(::fz_output *out, ::fz_stext_page *page, int id)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_print_stext_page_as_xml():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " id=" << id;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_print_stext_page_as_xml(auto_ctx, out, page, id);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_print_stext_page_as_xml(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_print_stext_trailer_as_html()`. */
FZ_FUNCTION void ll_fz_print_stext_trailer_as_html(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_print_stext_trailer_as_html():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_print_stext_trailer_as_html(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_print_stext_trailer_as_html(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_print_stext_trailer_as_xhtml()`. */
FZ_FUNCTION void ll_fz_print_stext_trailer_as_xhtml(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_print_stext_trailer_as_xhtml():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_print_stext_trailer_as_xhtml(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_print_stext_trailer_as_xhtml(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_process_opened_pages()`. */
FZ_FUNCTION void *ll_fz_process_opened_pages(::fz_document *doc, ::fz_process_opened_page_fn *process_openend_page, void *state)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_process_opened_pages():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " process_openend_page=" << (void*) process_openend_page;
		if (s_trace > 1) std::cerr << " state=" << (void*) state;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_process_opened_pages(auto_ctx, doc, process_openend_page, state);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_process_opened_pages(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_process_shade()`. */
FZ_FUNCTION void ll_fz_process_shade(::fz_shade *shade, ::fz_matrix ctm, ::fz_rect scissor, ::fz_shade_prepare_fn *prepare, ::fz_shade_process_fn *process, void *process_arg)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_process_shade():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " shade=" << shade;
		std::cerr << " ctm=" << ctm;
		std::cerr << " scissor=" << scissor;
		if (s_trace > 1) std::cerr << " prepare=" << (void*) prepare;
		if (s_trace > 1) std::cerr << " process=" << (void*) process;
		if (s_trace > 1) std::cerr << " process_arg=" << (void*) process_arg;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_process_shade(auto_ctx, shade, ctm, scissor, prepare, process, process_arg);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_process_shade(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_ptr_heap_insert()`. */
FZ_FUNCTION void ll_fz_ptr_heap_insert(::fz_ptr_heap *heap, void *v, int (*HEAP_CMP)(void **, void **))
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_ptr_heap_insert():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " heap=" << heap;
		if (s_trace > 1) std::cerr << " v=" << (void*) v;
		if (s_trace > 1) std::cerr << " HEAP_CMP=" << (void*) HEAP_CMP;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_ptr_heap_insert(auto_ctx, heap, v, HEAP_CMP);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_ptr_heap_insert(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_ptr_heap_sort()`. */
FZ_FUNCTION void ll_fz_ptr_heap_sort(::fz_ptr_heap *heap, int (*HEAP_CMP)(void **, void **))
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_ptr_heap_sort():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " heap=" << heap;
		if (s_trace > 1) std::cerr << " HEAP_CMP=" << (void*) HEAP_CMP;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_ptr_heap_sort(auto_ctx, heap, HEAP_CMP);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_ptr_heap_sort(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_ptr_heap_uniq()`. */
FZ_FUNCTION void ll_fz_ptr_heap_uniq(::fz_ptr_heap *heap, int (*HEAP_CMP)(void **, void **))
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_ptr_heap_uniq():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " heap=" << heap;
		if (s_trace > 1) std::cerr << " HEAP_CMP=" << (void*) HEAP_CMP;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_ptr_heap_uniq(auto_ctx, heap, HEAP_CMP);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_ptr_heap_uniq(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_purge_glyph_cache()`. */
FZ_FUNCTION void ll_fz_purge_glyph_cache()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_purge_glyph_cache():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_purge_glyph_cache(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_purge_glyph_cache(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_quad_from_rect()`. */
FZ_FUNCTION ::fz_quad ll_fz_quad_from_rect(::fz_rect r)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_quad_from_rect():";
		std::cerr << " r=" << r;
		std::cerr << "\n";
	}
	#endif
	fz_quad ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_quad_from_rect(r);
	return ret;
}

/** Low-level wrapper for `::fz_quadto()`. */
FZ_FUNCTION void ll_fz_quadto(::fz_path *path, float x0, float y0, float x1, float y1)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_quadto():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " path=" << path;
		std::cerr << " x0=" << x0;
		std::cerr << " y0=" << y0;
		std::cerr << " x1=" << x1;
		std::cerr << " y1=" << y1;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_quadto(auto_ctx, path, x0, y0, x1, y1);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_quadto(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_read()`. */
FZ_FUNCTION size_t ll_fz_read(::fz_stream *stm, unsigned char *data, size_t len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << " data=" << ((void*) data);
		std::cerr << " len=" << len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	size_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_read(auto_ctx, stm, data, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_all()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_read_all(::fz_stream *stm, size_t initial)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_all():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << " initial=" << initial;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_all(auto_ctx, stm, initial);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_all(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_archive_entry()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_read_archive_entry(::fz_archive *arch, const char *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_archive_entry():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " arch=" << arch;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_archive_entry(auto_ctx, arch, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_archive_entry(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_best()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_read_best(::fz_stream *stm, size_t initial, size_t worst_case)` => `(fz_buffer *, int truncated)`
*/
FZ_FUNCTION ::fz_buffer *ll_fz_read_best(::fz_stream *stm, size_t initial, int *truncated, size_t worst_case)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_best():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << " initial=" << initial;
		if (s_trace > 1) std::cerr << " truncated=" << (void*) truncated;
		std::cerr << " worst_case=" << worst_case;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_best(auto_ctx, stm, initial, truncated, worst_case);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_best(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_bits()`. */
FZ_FUNCTION unsigned int ll_fz_read_bits(::fz_stream *stm, int n)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_bits():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << " n=" << n;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	unsigned int ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_bits(auto_ctx, stm, n);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_bits(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_byte()`. */
FZ_FUNCTION int ll_fz_read_byte(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_byte():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_byte(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_byte(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_file()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_read_file(const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_file():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_file(auto_ctx, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_file(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_float()`. */
FZ_FUNCTION float ll_fz_read_float(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_float():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	float ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_float(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_float(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_float_le()`. */
FZ_FUNCTION float ll_fz_read_float_le(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_float_le():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	float ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_float_le(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_float_le(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_int16()`. */
FZ_FUNCTION int16_t ll_fz_read_int16(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_int16():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int16_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_int16(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_int16(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_int16_le()`. */
FZ_FUNCTION int16_t ll_fz_read_int16_le(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_int16_le():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int16_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_int16_le(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_int16_le(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_int32()`. */
FZ_FUNCTION int32_t ll_fz_read_int32(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_int32():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int32_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_int32(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_int32(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_int32_le()`. */
FZ_FUNCTION int32_t ll_fz_read_int32_le(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_int32_le():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int32_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_int32_le(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_int32_le(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_int64()`. */
FZ_FUNCTION int64_t ll_fz_read_int64(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_int64():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int64_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_int64(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_int64(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_int64_le()`. */
FZ_FUNCTION int64_t ll_fz_read_int64_le(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_int64_le():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int64_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_int64_le(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_int64_le(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_line()`. */
FZ_FUNCTION char *ll_fz_read_line(::fz_stream *stm, char *buf, size_t max)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_line():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		if (s_trace > 1) std::cerr << " buf=" << (void*) buf;
		std::cerr << " max=" << max;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_line(auto_ctx, stm, buf, max);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_line(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_rbits()`. */
FZ_FUNCTION unsigned int ll_fz_read_rbits(::fz_stream *stm, int n)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_rbits():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << " n=" << n;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	unsigned int ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_rbits(auto_ctx, stm, n);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_rbits(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_rune()`. */
FZ_FUNCTION int ll_fz_read_rune(::fz_stream *in)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_rune():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " in=" << in;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_rune(auto_ctx, in);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_rune(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_string()`. */
FZ_FUNCTION void ll_fz_read_string(::fz_stream *stm, char *buffer, int len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		if (s_trace > 1) std::cerr << " buffer=" << (void*) buffer;
		std::cerr << " len=" << len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_read_string(auto_ctx, stm, buffer, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_read_uint16()`. */
FZ_FUNCTION uint16_t ll_fz_read_uint16(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_uint16():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	uint16_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_uint16(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_uint16(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_uint16_le()`. */
FZ_FUNCTION uint16_t ll_fz_read_uint16_le(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_uint16_le():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	uint16_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_uint16_le(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_uint16_le(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_uint24()`. */
FZ_FUNCTION uint32_t ll_fz_read_uint24(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_uint24():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	uint32_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_uint24(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_uint24(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_uint24_le()`. */
FZ_FUNCTION uint32_t ll_fz_read_uint24_le(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_uint24_le():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	uint32_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_uint24_le(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_uint24_le(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_uint32()`. */
FZ_FUNCTION uint32_t ll_fz_read_uint32(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_uint32():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	uint32_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_uint32(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_uint32(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_uint32_le()`. */
FZ_FUNCTION uint32_t ll_fz_read_uint32_le(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_uint32_le():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	uint32_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_uint32_le(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_uint32_le(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_uint64()`. */
FZ_FUNCTION uint64_t ll_fz_read_uint64(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_uint64():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	uint64_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_uint64(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_uint64(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_uint64_le()`. */
FZ_FUNCTION uint64_t ll_fz_read_uint64_le(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_uint64_le():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	uint64_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_uint64_le(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_uint64_le(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_utf16_be()`. */
FZ_FUNCTION int ll_fz_read_utf16_be(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_utf16_be():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_utf16_be(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_utf16_be(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_read_utf16_le()`. */
FZ_FUNCTION int ll_fz_read_utf16_le(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_read_utf16_le():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_read_utf16_le(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_read_utf16_le(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_realloc()`. */
FZ_FUNCTION void *ll_fz_realloc(void *p, size_t size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_realloc():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " p=" << (void*) p;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_realloc(auto_ctx, p, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_realloc(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_realloc_no_throw()`. */
FZ_FUNCTION void *ll_fz_realloc_no_throw(void *p, size_t size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_realloc_no_throw():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " p=" << (void*) p;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_realloc_no_throw(auto_ctx, p, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_realloc_no_throw(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_realpath()`. */
FZ_FUNCTION char *ll_fz_realpath(const char *path, char *resolved_path)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_realpath():";
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (s_trace > 1) std::cerr << " resolved_path=" << (void*) resolved_path;
		std::cerr << "\n";
	}
	#endif
	char * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_realpath(path, resolved_path);
	return ret;
}

/** Low-level wrapper for `::fz_recognize_document()`. */
FZ_FUNCTION const ::fz_document_handler *ll_fz_recognize_document(const char *magic)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_recognize_document():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (magic) std::cerr << " magic='" << magic << "'";
		else std::cerr << " magic:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const fz_document_handler * ret;
	fz_try(auto_ctx) {
		ret = ::fz_recognize_document(auto_ctx, magic);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_recognize_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_recognize_document_content()`. */
FZ_FUNCTION const ::fz_document_handler *ll_fz_recognize_document_content(const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_recognize_document_content():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const fz_document_handler * ret;
	fz_try(auto_ctx) {
		ret = ::fz_recognize_document_content(auto_ctx, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_recognize_document_content(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_recognize_document_stream_and_dir_content()`. */
FZ_FUNCTION const ::fz_document_handler *ll_fz_recognize_document_stream_and_dir_content(::fz_stream *stream, ::fz_archive *dir, const char *magic)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_recognize_document_stream_and_dir_content():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stream=" << stream;
		if (s_trace > 1) std::cerr << " dir=" << dir;
		if (magic) std::cerr << " magic='" << magic << "'";
		else std::cerr << " magic:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const fz_document_handler * ret;
	fz_try(auto_ctx) {
		ret = ::fz_recognize_document_stream_and_dir_content(auto_ctx, stream, dir, magic);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_recognize_document_stream_and_dir_content(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_recognize_document_stream_content()`. */
FZ_FUNCTION const ::fz_document_handler *ll_fz_recognize_document_stream_content(::fz_stream *stream, const char *magic)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_recognize_document_stream_content():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stream=" << stream;
		if (magic) std::cerr << " magic='" << magic << "'";
		else std::cerr << " magic:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const fz_document_handler * ret;
	fz_try(auto_ctx) {
		ret = ::fz_recognize_document_stream_content(auto_ctx, stream, magic);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_recognize_document_stream_content(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_recognize_image_format()`. */
FZ_FUNCTION int ll_fz_recognize_image_format(unsigned char p[8])
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_recognize_image_format():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " p=" << p;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_recognize_image_format(auto_ctx, p);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_recognize_image_format(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_rect_from_irect()`. */
FZ_FUNCTION ::fz_rect ll_fz_rect_from_irect(::fz_irect bbox)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_rect_from_irect():";
		std::cerr << " bbox=" << bbox;
		std::cerr << "\n";
	}
	#endif
	fz_rect ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_rect_from_irect(bbox);
	return ret;
}

/** Low-level wrapper for `::fz_rect_from_quad()`. */
FZ_FUNCTION ::fz_rect ll_fz_rect_from_quad(::fz_quad q)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_rect_from_quad():";
		std::cerr << " q=" << q;
		std::cerr << "\n";
	}
	#endif
	fz_rect ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_rect_from_quad(q);
	return ret;
}

/** Low-level wrapper for `::fz_rectto()`. */
FZ_FUNCTION void ll_fz_rectto(::fz_path *path, float x0, float y0, float x1, float y1)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_rectto():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " path=" << path;
		std::cerr << " x0=" << x0;
		std::cerr << " y0=" << y0;
		std::cerr << " x1=" << x1;
		std::cerr << " y1=" << y1;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_rectto(auto_ctx, path, x0, y0, x1, y1);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_rectto(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_register_archive_handler()`. */
FZ_FUNCTION void ll_fz_register_archive_handler(const ::fz_archive_handler *handler)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_register_archive_handler():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " handler=" << handler;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_register_archive_handler(auto_ctx, handler);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_register_archive_handler(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_register_document_handler()`. */
FZ_FUNCTION void ll_fz_register_document_handler(const ::fz_document_handler *handler)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_register_document_handler():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " handler=" << handler;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_register_document_handler(auto_ctx, handler);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_register_document_handler(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_register_document_handlers()`. */
FZ_FUNCTION void ll_fz_register_document_handlers()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_register_document_handlers():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_register_document_handlers(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_register_document_handlers(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_remove_item()`. */
FZ_FUNCTION void ll_fz_remove_item(::fz_store_drop_fn *drop, void *key, const ::fz_store_type *type)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_remove_item():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " drop=" << (void*) drop;
		if (s_trace > 1) std::cerr << " key=" << (void*) key;
		if (s_trace > 1) std::cerr << " type=" << type;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_remove_item(auto_ctx, drop, key, type);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_remove_item(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_render_flags()`. */
FZ_FUNCTION void ll_fz_render_flags(::fz_device *dev, int set, int clear)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_render_flags():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " set=" << set;
		std::cerr << " clear=" << clear;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_render_flags(auto_ctx, dev, set, clear);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_render_flags(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_render_glyph_pixmap()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_render_glyph_pixmap(::fz_font *font, int gid, ::fz_matrix *ctm, const ::fz_irect *scissor, int aa)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_render_glyph_pixmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " gid=" << gid;
		std::cerr << " ctm=" << ctm;
		std::cerr << " scissor=" << scissor;
		std::cerr << " aa=" << aa;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_render_glyph_pixmap(auto_ctx, font, gid, ctm, scissor, aa);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_render_glyph_pixmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_render_t3_glyph_direct()`. */
FZ_FUNCTION void ll_fz_render_t3_glyph_direct(::fz_device *dev, ::fz_font *font, int gid, ::fz_matrix trm, void *gstate, ::fz_default_colorspaces *def_cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_render_t3_glyph_direct():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " gid=" << gid;
		std::cerr << " trm=" << trm;
		if (s_trace > 1) std::cerr << " gstate=" << (void*) gstate;
		if (s_trace > 1) std::cerr << " def_cs=" << def_cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_render_t3_glyph_direct(auto_ctx, dev, font, gid, trm, gstate, def_cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_render_t3_glyph_direct(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_rendering_intent_name()`. */
FZ_FUNCTION const char *ll_fz_rendering_intent_name(int ri)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_rendering_intent_name():";
		std::cerr << " ri=" << ri;
		std::cerr << "\n";
	}
	#endif
	const char * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_rendering_intent_name(ri);
	return ret;
}

/** Low-level wrapper for `::fz_report_error()`. */
FZ_FUNCTION void ll_fz_report_error()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_report_error():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_report_error(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_report_error(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_reset_output()`. */
FZ_FUNCTION void ll_fz_reset_output(::fz_output *arg_1)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_reset_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " arg_1=" << arg_1;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_reset_output(auto_ctx, arg_1);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_reset_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_reset_story()`. */
FZ_FUNCTION void ll_fz_reset_story(::fz_story *story)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_reset_story():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " story=" << story;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_reset_story(auto_ctx, story);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_reset_story(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_resize_buffer()`. */
FZ_FUNCTION void ll_fz_resize_buffer(::fz_buffer *buf, size_t capacity)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_resize_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << " capacity=" << capacity;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_resize_buffer(auto_ctx, buf, capacity);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_resize_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_resolve_link()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_resolve_link(::fz_document *doc, const char *uri)` => `(fz_location, float xp, float yp)`
*/
FZ_FUNCTION ::fz_location ll_fz_resolve_link(::fz_document *doc, const char *uri, float *xp, float *yp)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_resolve_link():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (uri) std::cerr << " uri='" << uri << "'";
		else std::cerr << " uri:null";
		if (s_trace > 1) std::cerr << " xp=" << (void*) xp;
		if (s_trace > 1) std::cerr << " yp=" << (void*) yp;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_location ret;
	fz_try(auto_ctx) {
		ret = ::fz_resolve_link(auto_ctx, doc, uri, xp, yp);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_resolve_link(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_resolve_link_dest()`. */
FZ_FUNCTION ::fz_link_dest ll_fz_resolve_link_dest(::fz_document *doc, const char *uri)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_resolve_link_dest():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (uri) std::cerr << " uri='" << uri << "'";
		else std::cerr << " uri:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_link_dest ret;
	fz_try(auto_ctx) {
		ret = ::fz_resolve_link_dest(auto_ctx, doc, uri);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_resolve_link_dest(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_rethrow()`. */
FZ_FUNCTION void ll_fz_rethrow()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_rethrow():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_rethrow(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_rethrow(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_rethrow_if()`. */
FZ_FUNCTION void ll_fz_rethrow_if(int errcode)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_rethrow_if():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " errcode=" << errcode;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_rethrow_if(auto_ctx, errcode);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_rethrow_if(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_rethrow_unless()`. */
FZ_FUNCTION void ll_fz_rethrow_unless(int errcode)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_rethrow_unless():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " errcode=" << errcode;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_rethrow_unless(auto_ctx, errcode);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_rethrow_unless(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_rotate()`. */
FZ_FUNCTION ::fz_matrix ll_fz_rotate(float degrees)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_rotate():";
		std::cerr << " degrees=" << degrees;
		std::cerr << "\n";
	}
	#endif
	fz_matrix ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_rotate(degrees);
	return ret;
}

/** Low-level wrapper for `::fz_round_rect()`. */
FZ_FUNCTION ::fz_irect ll_fz_round_rect(::fz_rect rect)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_round_rect():";
		std::cerr << " rect=" << rect;
		std::cerr << "\n";
	}
	#endif
	fz_irect ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_round_rect(rect);
	return ret;
}

/** Low-level wrapper for `::fz_run_display_list()`. */
FZ_FUNCTION void ll_fz_run_display_list(::fz_display_list *list, ::fz_device *dev, ::fz_matrix ctm, ::fz_rect scissor, ::fz_cookie *cookie)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_run_display_list():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " list=" << list;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " ctm=" << ctm;
		std::cerr << " scissor=" << scissor;
		std::cerr << " cookie=" << cookie;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_run_display_list(auto_ctx, list, dev, ctm, scissor, cookie);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_run_display_list(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_run_document_structure()`. */
FZ_FUNCTION void ll_fz_run_document_structure(::fz_document *doc, ::fz_device *dev, ::fz_cookie *cookie)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_run_document_structure():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " cookie=" << cookie;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_run_document_structure(auto_ctx, doc, dev, cookie);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_run_document_structure(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_run_page()`. */
FZ_FUNCTION void ll_fz_run_page(::fz_page *page, ::fz_device *dev, ::fz_matrix transform, ::fz_cookie *cookie)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_run_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " transform=" << transform;
		std::cerr << " cookie=" << cookie;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_run_page(auto_ctx, page, dev, transform, cookie);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_run_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_run_page_annots()`. */
FZ_FUNCTION void ll_fz_run_page_annots(::fz_page *page, ::fz_device *dev, ::fz_matrix transform, ::fz_cookie *cookie)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_run_page_annots():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " transform=" << transform;
		std::cerr << " cookie=" << cookie;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_run_page_annots(auto_ctx, page, dev, transform, cookie);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_run_page_annots(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_run_page_contents()`. */
FZ_FUNCTION void ll_fz_run_page_contents(::fz_page *page, ::fz_device *dev, ::fz_matrix transform, ::fz_cookie *cookie)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_run_page_contents():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " transform=" << transform;
		std::cerr << " cookie=" << cookie;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_run_page_contents(auto_ctx, page, dev, transform, cookie);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_run_page_contents(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_run_page_widgets()`. */
FZ_FUNCTION void ll_fz_run_page_widgets(::fz_page *page, ::fz_device *dev, ::fz_matrix transform, ::fz_cookie *cookie)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_run_page_widgets():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " transform=" << transform;
		std::cerr << " cookie=" << cookie;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_run_page_widgets(auto_ctx, page, dev, transform, cookie);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_run_page_widgets(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_run_t3_glyph()`. */
FZ_FUNCTION void ll_fz_run_t3_glyph(::fz_font *font, int gid, ::fz_matrix trm, struct ::fz_device *dev)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_run_t3_glyph():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " gid=" << gid;
		std::cerr << " trm=" << trm;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_run_t3_glyph(auto_ctx, font, gid, trm, dev);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_run_t3_glyph(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_runeidx()`. */
FZ_FUNCTION int ll_fz_runeidx(const char *str, const char *p)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_runeidx():";
		if (str) std::cerr << " str='" << str << "'";
		else std::cerr << " str:null";
		if (p) std::cerr << " p='" << p << "'";
		else std::cerr << " p:null";
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_runeidx(str, p);
	return ret;
}

/** Low-level wrapper for `::fz_runelen()`. */
FZ_FUNCTION int ll_fz_runelen(int rune)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_runelen():";
		std::cerr << " rune=" << rune;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_runelen(rune);
	return ret;
}

/** Low-level wrapper for `::fz_runeptr()`. */
FZ_FUNCTION const char *ll_fz_runeptr(const char *str, int idx)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_runeptr():";
		if (str) std::cerr << " str='" << str << "'";
		else std::cerr << " str:null";
		std::cerr << " idx=" << idx;
		std::cerr << "\n";
	}
	#endif
	const char * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_runeptr(str, idx);
	return ret;
}

/** Low-level wrapper for `::fz_runetochar()`. */
FZ_FUNCTION int ll_fz_runetochar(char *str, int rune)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_runetochar():";
		if (s_trace > 1) std::cerr << " str=" << (void*) str;
		std::cerr << " rune=" << rune;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_runetochar(str, rune);
	return ret;
}

/** Low-level wrapper for `::fz_samples_get()`. */
FZ_FUNCTION int ll_fz_samples_get(::fz_pixmap *pixmap, int offset)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_samples_get():";
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << " offset=" << offset;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_samples_get(pixmap, offset);
	return ret;
}

/** Low-level wrapper for `::fz_samples_set()`. */
FZ_FUNCTION void ll_fz_samples_set(::fz_pixmap *pixmap, int offset, int value)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_samples_set():";
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << " offset=" << offset;
		std::cerr << " value=" << value;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_samples_set(pixmap, offset, value);
}

/** Low-level wrapper for `::fz_save_accelerator()`. */
FZ_FUNCTION void ll_fz_save_accelerator(::fz_document *doc, const char *accel)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_save_accelerator():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (accel) std::cerr << " accel='" << accel << "'";
		else std::cerr << " accel:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_save_accelerator(auto_ctx, doc, accel);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_save_accelerator(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_save_bitmap_as_pbm()`. */
FZ_FUNCTION void ll_fz_save_bitmap_as_pbm(::fz_bitmap *bitmap, const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_save_bitmap_as_pbm():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " bitmap=" << bitmap;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_save_bitmap_as_pbm(auto_ctx, bitmap, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_save_bitmap_as_pbm(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_save_bitmap_as_pcl()`. */
FZ_FUNCTION void ll_fz_save_bitmap_as_pcl(::fz_bitmap *bitmap, char *filename, int append, const ::fz_pcl_options *pcl)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_save_bitmap_as_pcl():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " bitmap=" << bitmap;
		if (s_trace > 1) std::cerr << " filename=" << (void*) filename;
		std::cerr << " append=" << append;
		if (s_trace > 1) std::cerr << " pcl=" << pcl;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_save_bitmap_as_pcl(auto_ctx, bitmap, filename, append, pcl);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_save_bitmap_as_pcl(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_save_bitmap_as_pkm()`. */
FZ_FUNCTION void ll_fz_save_bitmap_as_pkm(::fz_bitmap *bitmap, const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_save_bitmap_as_pkm():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " bitmap=" << bitmap;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_save_bitmap_as_pkm(auto_ctx, bitmap, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_save_bitmap_as_pkm(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_save_bitmap_as_pwg()`. */
FZ_FUNCTION void ll_fz_save_bitmap_as_pwg(::fz_bitmap *bitmap, char *filename, int append, const ::fz_pwg_options *pwg)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_save_bitmap_as_pwg():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " bitmap=" << bitmap;
		if (s_trace > 1) std::cerr << " filename=" << (void*) filename;
		std::cerr << " append=" << append;
		std::cerr << " pwg=" << pwg;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_save_bitmap_as_pwg(auto_ctx, bitmap, filename, append, pwg);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_save_bitmap_as_pwg(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_save_buffer()`. */
FZ_FUNCTION void ll_fz_save_buffer(::fz_buffer *buf, const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_save_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_save_buffer(auto_ctx, buf, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_save_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_save_pixmap_as_jpeg()`. */
FZ_FUNCTION void ll_fz_save_pixmap_as_jpeg(::fz_pixmap *pixmap, const char *filename, int quality)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_save_pixmap_as_jpeg():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << " quality=" << quality;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_save_pixmap_as_jpeg(auto_ctx, pixmap, filename, quality);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_save_pixmap_as_jpeg(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_save_pixmap_as_jpx()`. */
FZ_FUNCTION void ll_fz_save_pixmap_as_jpx(::fz_pixmap *pixmap, const char *filename, int q)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_save_pixmap_as_jpx():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << " q=" << q;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_save_pixmap_as_jpx(auto_ctx, pixmap, filename, q);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_save_pixmap_as_jpx(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_save_pixmap_as_pam()`. */
FZ_FUNCTION void ll_fz_save_pixmap_as_pam(::fz_pixmap *pixmap, const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_save_pixmap_as_pam():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_save_pixmap_as_pam(auto_ctx, pixmap, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_save_pixmap_as_pam(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_save_pixmap_as_pbm()`. */
FZ_FUNCTION void ll_fz_save_pixmap_as_pbm(::fz_pixmap *pixmap, const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_save_pixmap_as_pbm():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_save_pixmap_as_pbm(auto_ctx, pixmap, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_save_pixmap_as_pbm(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_save_pixmap_as_pcl()`. */
FZ_FUNCTION void ll_fz_save_pixmap_as_pcl(::fz_pixmap *pixmap, char *filename, int append, const ::fz_pcl_options *pcl)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_save_pixmap_as_pcl():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		if (s_trace > 1) std::cerr << " filename=" << (void*) filename;
		std::cerr << " append=" << append;
		if (s_trace > 1) std::cerr << " pcl=" << pcl;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_save_pixmap_as_pcl(auto_ctx, pixmap, filename, append, pcl);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_save_pixmap_as_pcl(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_save_pixmap_as_pclm()`. */
FZ_FUNCTION void ll_fz_save_pixmap_as_pclm(::fz_pixmap *pixmap, char *filename, int append, const ::fz_pclm_options *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_save_pixmap_as_pclm():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		if (s_trace > 1) std::cerr << " filename=" << (void*) filename;
		std::cerr << " append=" << append;
		if (s_trace > 1) std::cerr << " options=" << options;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_save_pixmap_as_pclm(auto_ctx, pixmap, filename, append, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_save_pixmap_as_pclm(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_save_pixmap_as_pdfocr()`. */
FZ_FUNCTION void ll_fz_save_pixmap_as_pdfocr(::fz_pixmap *pixmap, char *filename, int append, const ::fz_pdfocr_options *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_save_pixmap_as_pdfocr():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		if (s_trace > 1) std::cerr << " filename=" << (void*) filename;
		std::cerr << " append=" << append;
		std::cerr << " options=" << options;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_save_pixmap_as_pdfocr(auto_ctx, pixmap, filename, append, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_save_pixmap_as_pdfocr(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_save_pixmap_as_pkm()`. */
FZ_FUNCTION void ll_fz_save_pixmap_as_pkm(::fz_pixmap *pixmap, const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_save_pixmap_as_pkm():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_save_pixmap_as_pkm(auto_ctx, pixmap, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_save_pixmap_as_pkm(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_save_pixmap_as_png()`. */
FZ_FUNCTION void ll_fz_save_pixmap_as_png(::fz_pixmap *pixmap, const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_save_pixmap_as_png():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_save_pixmap_as_png(auto_ctx, pixmap, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_save_pixmap_as_png(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_save_pixmap_as_pnm()`. */
FZ_FUNCTION void ll_fz_save_pixmap_as_pnm(::fz_pixmap *pixmap, const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_save_pixmap_as_pnm():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_save_pixmap_as_pnm(auto_ctx, pixmap, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_save_pixmap_as_pnm(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_save_pixmap_as_ps()`. */
FZ_FUNCTION void ll_fz_save_pixmap_as_ps(::fz_pixmap *pixmap, char *filename, int append)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_save_pixmap_as_ps():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		if (s_trace > 1) std::cerr << " filename=" << (void*) filename;
		std::cerr << " append=" << append;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_save_pixmap_as_ps(auto_ctx, pixmap, filename, append);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_save_pixmap_as_ps(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_save_pixmap_as_psd()`. */
FZ_FUNCTION void ll_fz_save_pixmap_as_psd(::fz_pixmap *pixmap, const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_save_pixmap_as_psd():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_save_pixmap_as_psd(auto_ctx, pixmap, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_save_pixmap_as_psd(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_save_pixmap_as_pwg()`. */
FZ_FUNCTION void ll_fz_save_pixmap_as_pwg(::fz_pixmap *pixmap, char *filename, int append, const ::fz_pwg_options *pwg)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_save_pixmap_as_pwg():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		if (s_trace > 1) std::cerr << " filename=" << (void*) filename;
		std::cerr << " append=" << append;
		std::cerr << " pwg=" << pwg;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_save_pixmap_as_pwg(auto_ctx, pixmap, filename, append, pwg);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_save_pixmap_as_pwg(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_scale()`. */
FZ_FUNCTION ::fz_matrix ll_fz_scale(float sx, float sy)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_scale():";
		std::cerr << " sx=" << sx;
		std::cerr << " sy=" << sy;
		std::cerr << "\n";
	}
	#endif
	fz_matrix ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_scale(sx, sy);
	return ret;
}

/** Low-level wrapper for `::fz_scale_pixmap()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_scale_pixmap(::fz_pixmap *src, float x, float y, float w, float h, const ::fz_irect *clip)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_scale_pixmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " src=" << src;
		std::cerr << " x=" << x;
		std::cerr << " y=" << y;
		std::cerr << " w=" << w;
		std::cerr << " h=" << h;
		std::cerr << " clip=" << clip;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_scale_pixmap(auto_ctx, src, x, y, w, h, clip);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_scale_pixmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_search_chapter_page_number()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_search_chapter_page_number(::fz_document *doc, int chapter, int page, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
*/
FZ_FUNCTION int ll_fz_search_chapter_page_number(::fz_document *doc, int chapter, int page, const char *needle, int *hit_mark, ::fz_quad *hit_bbox, int hit_max)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_search_chapter_page_number():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " chapter=" << chapter;
		std::cerr << " page=" << page;
		if (needle) std::cerr << " needle='" << needle << "'";
		else std::cerr << " needle:null";
		if (s_trace > 1) std::cerr << " hit_mark=" << (void*) hit_mark;
		std::cerr << " hit_bbox=" << hit_bbox;
		std::cerr << " hit_max=" << hit_max;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_search_chapter_page_number(auto_ctx, doc, chapter, page, needle, hit_mark, hit_bbox, hit_max);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_search_chapter_page_number(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_search_display_list()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_search_display_list(::fz_display_list *list, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
*/
FZ_FUNCTION int ll_fz_search_display_list(::fz_display_list *list, const char *needle, int *hit_mark, ::fz_quad *hit_bbox, int hit_max)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_search_display_list():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " list=" << list;
		if (needle) std::cerr << " needle='" << needle << "'";
		else std::cerr << " needle:null";
		if (s_trace > 1) std::cerr << " hit_mark=" << (void*) hit_mark;
		std::cerr << " hit_bbox=" << hit_bbox;
		std::cerr << " hit_max=" << hit_max;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_search_display_list(auto_ctx, list, needle, hit_mark, hit_bbox, hit_max);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_search_display_list(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_search_page()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_search_page(::fz_page *page, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
*/
FZ_FUNCTION int ll_fz_search_page(::fz_page *page, const char *needle, int *hit_mark, ::fz_quad *hit_bbox, int hit_max)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_search_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		if (needle) std::cerr << " needle='" << needle << "'";
		else std::cerr << " needle:null";
		if (s_trace > 1) std::cerr << " hit_mark=" << (void*) hit_mark;
		std::cerr << " hit_bbox=" << hit_bbox;
		std::cerr << " hit_max=" << hit_max;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_search_page(auto_ctx, page, needle, hit_mark, hit_bbox, hit_max);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_search_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_search_page2()`. */
FZ_FUNCTION std::vector<fz_search_page2_hit> ll_fz_search_page2(::fz_document *doc, int number, const char *needle, int hit_max)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_search_page2():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " number=" << number;
		if (needle) std::cerr << " needle='" << needle << "'";
		else std::cerr << " needle:null";
		std::cerr << " hit_max=" << hit_max;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	std::vector<fz_search_page2_hit> ret;
	fz_try(auto_ctx) {
		ret = ::fz_search_page2(auto_ctx, doc, number, needle, hit_max);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_search_page2(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_search_page_number()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_search_page_number(::fz_document *doc, int number, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
*/
FZ_FUNCTION int ll_fz_search_page_number(::fz_document *doc, int number, const char *needle, int *hit_mark, ::fz_quad *hit_bbox, int hit_max)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_search_page_number():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " number=" << number;
		if (needle) std::cerr << " needle='" << needle << "'";
		else std::cerr << " needle:null";
		if (s_trace > 1) std::cerr << " hit_mark=" << (void*) hit_mark;
		std::cerr << " hit_bbox=" << hit_bbox;
		std::cerr << " hit_max=" << hit_max;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_search_page_number(auto_ctx, doc, number, needle, hit_mark, hit_bbox, hit_max);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_search_page_number(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_search_stext_page()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_search_stext_page(::fz_stext_page *text, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
*/
FZ_FUNCTION int ll_fz_search_stext_page(::fz_stext_page *text, const char *needle, int *hit_mark, ::fz_quad *hit_bbox, int hit_max)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_search_stext_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " text=" << text;
		if (needle) std::cerr << " needle='" << needle << "'";
		else std::cerr << " needle:null";
		if (s_trace > 1) std::cerr << " hit_mark=" << (void*) hit_mark;
		std::cerr << " hit_bbox=" << hit_bbox;
		std::cerr << " hit_max=" << hit_max;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_search_stext_page(auto_ctx, text, needle, hit_mark, hit_bbox, hit_max);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_search_stext_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_seek()`. */
FZ_FUNCTION void ll_fz_seek(::fz_stream *stm, int64_t offset, int whence)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_seek():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << " offset=" << offset;
		std::cerr << " whence=" << whence;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_seek(auto_ctx, stm, offset, whence);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_seek(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_seek_output()`. */
FZ_FUNCTION void ll_fz_seek_output(::fz_output *out, int64_t off, int whence)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_seek_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " off=" << off;
		std::cerr << " whence=" << whence;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_seek_output(auto_ctx, out, off, whence);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_seek_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_separation_current_behavior()`. */
FZ_FUNCTION ::fz_separation_behavior ll_fz_separation_current_behavior(const ::fz_separations *sep, int separation)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_separation_current_behavior():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " sep=" << sep;
		std::cerr << " separation=" << separation;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_separation_behavior ret;
	fz_try(auto_ctx) {
		ret = ::fz_separation_current_behavior(auto_ctx, sep, separation);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_separation_current_behavior(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_separation_equivalent()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_separation_equivalent(const ::fz_separations *seps, int idx, ::fz_colorspace *dst_cs, ::fz_colorspace *prf, ::fz_color_params color_params)` => float dst_color
*/
FZ_FUNCTION void ll_fz_separation_equivalent(const ::fz_separations *seps, int idx, ::fz_colorspace *dst_cs, float *dst_color, ::fz_colorspace *prf, ::fz_color_params color_params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_separation_equivalent():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " seps=" << seps;
		std::cerr << " idx=" << idx;
		if (s_trace > 1) std::cerr << " dst_cs=" << dst_cs;
		if (s_trace > 1) std::cerr << " dst_color=" << (void*) dst_color;
		if (s_trace > 1) std::cerr << " prf=" << prf;
		std::cerr << " color_params=" << color_params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_separation_equivalent(auto_ctx, seps, idx, dst_cs, dst_color, prf, color_params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_separation_equivalent(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_separation_name()`. */
FZ_FUNCTION const char *ll_fz_separation_name(const ::fz_separations *sep, int separation)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_separation_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " sep=" << sep;
		std::cerr << " separation=" << separation;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_separation_name(auto_ctx, sep, separation);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_separation_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_set_aa_level()`. */
FZ_FUNCTION void ll_fz_set_aa_level(int bits)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_aa_level():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " bits=" << bits;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_aa_level(auto_ctx, bits);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_aa_level(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_compressed_image_buffer()`. */
FZ_FUNCTION void ll_fz_set_compressed_image_buffer(::fz_compressed_image *cimg, ::fz_compressed_buffer *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_compressed_image_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cimg=" << cimg;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_compressed_image_buffer(auto_ctx, cimg, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_compressed_image_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_default_cmyk()`. */
FZ_FUNCTION void ll_fz_set_default_cmyk(::fz_default_colorspaces *default_cs, ::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_default_cmyk():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " default_cs=" << default_cs;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_default_cmyk(auto_ctx, default_cs, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_default_cmyk(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_default_colorspaces()`. */
FZ_FUNCTION void ll_fz_set_default_colorspaces(::fz_device *dev, ::fz_default_colorspaces *default_cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_default_colorspaces():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		if (s_trace > 1) std::cerr << " default_cs=" << default_cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_default_colorspaces(auto_ctx, dev, default_cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_default_colorspaces(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_default_gray()`. */
FZ_FUNCTION void ll_fz_set_default_gray(::fz_default_colorspaces *default_cs, ::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_default_gray():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " default_cs=" << default_cs;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_default_gray(auto_ctx, default_cs, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_default_gray(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_default_output_intent()`. */
FZ_FUNCTION void ll_fz_set_default_output_intent(::fz_default_colorspaces *default_cs, ::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_default_output_intent():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " default_cs=" << default_cs;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_default_output_intent(auto_ctx, default_cs, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_default_output_intent(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_default_rgb()`. */
FZ_FUNCTION void ll_fz_set_default_rgb(::fz_default_colorspaces *default_cs, ::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_default_rgb():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " default_cs=" << default_cs;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_default_rgb(auto_ctx, default_cs, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_default_rgb(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_error_callback()`. */
FZ_FUNCTION void ll_fz_set_error_callback(::fz_error_cb *error_cb, void *user)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_error_callback():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " error_cb=" << (void*) error_cb;
		if (s_trace > 1) std::cerr << " user=" << (void*) user;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_error_callback(auto_ctx, error_cb, user);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_error_callback(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_font_bbox()`. */
FZ_FUNCTION void ll_fz_set_font_bbox(::fz_font *font, float xmin, float ymin, float xmax, float ymax)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_font_bbox():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " xmin=" << xmin;
		std::cerr << " ymin=" << ymin;
		std::cerr << " xmax=" << xmax;
		std::cerr << " ymax=" << ymax;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_font_bbox(auto_ctx, font, xmin, ymin, xmax, ymax);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_font_bbox(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_font_embedding()`. */
FZ_FUNCTION void ll_fz_set_font_embedding(::fz_font *font, int embed)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_font_embedding():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " embed=" << embed;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_font_embedding(auto_ctx, font, embed);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_font_embedding(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_graphics_aa_level()`. */
FZ_FUNCTION void ll_fz_set_graphics_aa_level(int bits)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_graphics_aa_level():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " bits=" << bits;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_graphics_aa_level(auto_ctx, bits);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_graphics_aa_level(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_graphics_min_line_width()`. */
FZ_FUNCTION void ll_fz_set_graphics_min_line_width(float min_line_width)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_graphics_min_line_width():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " min_line_width=" << min_line_width;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_graphics_min_line_width(auto_ctx, min_line_width);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_graphics_min_line_width(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_link_rect()`. */
FZ_FUNCTION void ll_fz_set_link_rect(::fz_link *link, ::fz_rect rect)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_link_rect():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " link=" << link;
		std::cerr << " rect=" << rect;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_link_rect(auto_ctx, link, rect);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_link_rect(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_link_uri()`. */
FZ_FUNCTION void ll_fz_set_link_uri(::fz_link *link, const char *uri)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_link_uri():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " link=" << link;
		if (uri) std::cerr << " uri='" << uri << "'";
		else std::cerr << " uri:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_link_uri(auto_ctx, link, uri);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_link_uri(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_metadata()`. */
FZ_FUNCTION void ll_fz_set_metadata(::fz_document *doc, const char *key, const char *value)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_metadata():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (key) std::cerr << " key='" << key << "'";
		else std::cerr << " key:null";
		if (value) std::cerr << " value='" << value << "'";
		else std::cerr << " value:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_metadata(auto_ctx, doc, key, value);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_metadata(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_pixmap_image_tile()`. */
FZ_FUNCTION void ll_fz_set_pixmap_image_tile(::fz_pixmap_image *cimg, ::fz_pixmap *pix)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_pixmap_image_tile():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cimg=" << cimg;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_pixmap_image_tile(auto_ctx, cimg, pix);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_pixmap_image_tile(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_pixmap_resolution()`. */
FZ_FUNCTION void ll_fz_set_pixmap_resolution(::fz_pixmap *pix, int xres, int yres)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_pixmap_resolution():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << " xres=" << xres;
		std::cerr << " yres=" << yres;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_pixmap_resolution(auto_ctx, pix, xres, yres);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_pixmap_resolution(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_separation_behavior()`. */
FZ_FUNCTION void ll_fz_set_separation_behavior(::fz_separations *sep, int separation, ::fz_separation_behavior behavior)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_separation_behavior():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " sep=" << sep;
		std::cerr << " separation=" << separation;
		std::cerr << " behavior=" << behavior;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_separation_behavior(auto_ctx, sep, separation, behavior);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_separation_behavior(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_stddbg()`. */
FZ_FUNCTION void ll_fz_set_stddbg(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_stddbg():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_stddbg(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_stddbg(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_text_aa_level()`. */
FZ_FUNCTION void ll_fz_set_text_aa_level(int bits)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_text_aa_level():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " bits=" << bits;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_text_aa_level(auto_ctx, bits);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_text_aa_level(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_use_document_css()`. */
FZ_FUNCTION void ll_fz_set_use_document_css(int use)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_use_document_css():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " use=" << use;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_use_document_css(auto_ctx, use);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_use_document_css(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_user_context()`. */
FZ_FUNCTION void ll_fz_set_user_context(void *user)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_user_context():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " user=" << (void*) user;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_user_context(auto_ctx, user);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_user_context(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_user_css()`. */
FZ_FUNCTION void ll_fz_set_user_css(const char *text)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_user_css():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (text) std::cerr << " text='" << text << "'";
		else std::cerr << " text:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_user_css(auto_ctx, text);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_user_css(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_set_warning_callback()`. */
FZ_FUNCTION void ll_fz_set_warning_callback(::fz_warning_cb *warning_cb, void *user)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_set_warning_callback():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " warning_cb=" << (void*) warning_cb;
		if (s_trace > 1) std::cerr << " user=" << (void*) user;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_set_warning_callback(auto_ctx, warning_cb, user);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_set_warning_callback(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_sha256_final()`. */
FZ_FUNCTION void ll_fz_sha256_final(::fz_sha256 *state, unsigned char digest[32])
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_sha256_final():";
		if (s_trace > 1) std::cerr << " state=" << state;
		std::cerr << " digest=" << digest;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_sha256_final(state, digest);
}

/** Low-level wrapper for `::fz_sha256_init()`. */
FZ_FUNCTION void ll_fz_sha256_init(::fz_sha256 *state)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_sha256_init():";
		if (s_trace > 1) std::cerr << " state=" << state;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_sha256_init(state);
}

/** Low-level wrapper for `::fz_sha256_update()`. */
FZ_FUNCTION void ll_fz_sha256_update(::fz_sha256 *state, const unsigned char *input, size_t inlen)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_sha256_update():";
		if (s_trace > 1) std::cerr << " state=" << state;
		std::cerr << " input=" << ((void*) input);
		std::cerr << " inlen=" << inlen;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_sha256_update(state, input, inlen);
}

/** Low-level wrapper for `::fz_sha384_final()`. */
FZ_FUNCTION void ll_fz_sha384_final(::fz_sha384 *state, unsigned char digest[64])
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_sha384_final():";
		if (s_trace > 1) std::cerr << " state=" << state;
		std::cerr << " digest=" << digest;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_sha384_final(state, digest);
}

/** Low-level wrapper for `::fz_sha384_init()`. */
FZ_FUNCTION void ll_fz_sha384_init(::fz_sha384 *state)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_sha384_init():";
		if (s_trace > 1) std::cerr << " state=" << state;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_sha384_init(state);
}

/** Low-level wrapper for `::fz_sha384_update()`. */
FZ_FUNCTION void ll_fz_sha384_update(::fz_sha384 *state, const unsigned char *input, size_t inlen)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_sha384_update():";
		if (s_trace > 1) std::cerr << " state=" << state;
		std::cerr << " input=" << ((void*) input);
		std::cerr << " inlen=" << inlen;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_sha384_update(state, input, inlen);
}

/** Low-level wrapper for `::fz_sha512_final()`. */
FZ_FUNCTION void ll_fz_sha512_final(::fz_sha512 *state, unsigned char digest[64])
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_sha512_final():";
		if (s_trace > 1) std::cerr << " state=" << state;
		std::cerr << " digest=" << digest;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_sha512_final(state, digest);
}

/** Low-level wrapper for `::fz_sha512_init()`. */
FZ_FUNCTION void ll_fz_sha512_init(::fz_sha512 *state)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_sha512_init():";
		if (s_trace > 1) std::cerr << " state=" << state;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_sha512_init(state);
}

/** Low-level wrapper for `::fz_sha512_update()`. */
FZ_FUNCTION void ll_fz_sha512_update(::fz_sha512 *state, const unsigned char *input, size_t inlen)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_sha512_update():";
		if (s_trace > 1) std::cerr << " state=" << state;
		std::cerr << " input=" << ((void*) input);
		std::cerr << " inlen=" << inlen;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_sha512_update(state, input, inlen);
}

/** Low-level wrapper for `::fz_shear()`. */
FZ_FUNCTION ::fz_matrix ll_fz_shear(float sx, float sy)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_shear():";
		std::cerr << " sx=" << sx;
		std::cerr << " sy=" << sy;
		std::cerr << "\n";
	}
	#endif
	fz_matrix ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_shear(sx, sy);
	return ret;
}

/** Low-level wrapper for `::fz_show_glyph()`. */
FZ_FUNCTION void ll_fz_show_glyph(::fz_text *text, ::fz_font *font, ::fz_matrix trm, int glyph, int unicode, int wmode, int bidi_level, ::fz_bidi_direction markup_dir, ::fz_text_language language)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_show_glyph():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " text=" << text;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " trm=" << trm;
		std::cerr << " glyph=" << glyph;
		std::cerr << " unicode=" << unicode;
		std::cerr << " wmode=" << wmode;
		std::cerr << " bidi_level=" << bidi_level;
		std::cerr << " markup_dir=" << markup_dir;
		std::cerr << " language=" << language;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_show_glyph(auto_ctx, text, font, trm, glyph, unicode, wmode, bidi_level, markup_dir, language);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_show_glyph(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_show_glyph_aux()`. */
FZ_FUNCTION void ll_fz_show_glyph_aux(::fz_text *text, ::fz_font *font, ::fz_matrix trm, int glyph, int unicode, int cid, int wmode, int bidi_level, ::fz_bidi_direction markup_dir, ::fz_text_language lang)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_show_glyph_aux():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " text=" << text;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " trm=" << trm;
		std::cerr << " glyph=" << glyph;
		std::cerr << " unicode=" << unicode;
		std::cerr << " cid=" << cid;
		std::cerr << " wmode=" << wmode;
		std::cerr << " bidi_level=" << bidi_level;
		std::cerr << " markup_dir=" << markup_dir;
		std::cerr << " lang=" << lang;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_show_glyph_aux(auto_ctx, text, font, trm, glyph, unicode, cid, wmode, bidi_level, markup_dir, lang);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_show_glyph_aux(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_show_string()`. */
FZ_FUNCTION ::fz_matrix ll_fz_show_string(::fz_text *text, ::fz_font *font, ::fz_matrix trm, const char *s, int wmode, int bidi_level, ::fz_bidi_direction markup_dir, ::fz_text_language language)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_show_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " text=" << text;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " trm=" << trm;
		if (s) std::cerr << " s='" << s << "'";
		else std::cerr << " s:null";
		std::cerr << " wmode=" << wmode;
		std::cerr << " bidi_level=" << bidi_level;
		std::cerr << " markup_dir=" << markup_dir;
		std::cerr << " language=" << language;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_matrix ret;
	fz_try(auto_ctx) {
		ret = ::fz_show_string(auto_ctx, text, font, trm, s, wmode, bidi_level, markup_dir, language);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_show_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_shrink_store()`. */
FZ_FUNCTION int ll_fz_shrink_store(unsigned int percent)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_shrink_store():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " percent=" << percent;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_shrink_store(auto_ctx, percent);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_shrink_store(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_skip()`. */
FZ_FUNCTION size_t ll_fz_skip(::fz_stream *stm, size_t len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_skip():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << " len=" << len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	size_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_skip(auto_ctx, stm, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_skip(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_skip_space()`. */
FZ_FUNCTION void ll_fz_skip_space(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_skip_space():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_skip_space(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_skip_space(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_skip_string()`. */
FZ_FUNCTION int ll_fz_skip_string(::fz_stream *stm, const char *str)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_skip_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		if (str) std::cerr << " str='" << str << "'";
		else std::cerr << " str:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_skip_string(auto_ctx, stm, str);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_skip_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_slice_buffer()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_slice_buffer(::fz_buffer *buf, int64_t start, int64_t end)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_slice_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << " start=" << start;
		std::cerr << " end=" << end;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_slice_buffer(auto_ctx, buf, start, end);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_slice_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_snap_selection()`. */
FZ_FUNCTION ::fz_quad ll_fz_snap_selection(::fz_stext_page *page, ::fz_point *ap, ::fz_point *bp, int mode)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_snap_selection():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " ap=" << ap;
		std::cerr << " bp=" << bp;
		std::cerr << " mode=" << mode;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_quad ret;
	fz_try(auto_ctx) {
		ret = ::fz_snap_selection(auto_ctx, page, ap, bp, mode);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_snap_selection(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_start_throw_on_repair()`. */
FZ_FUNCTION void ll_fz_start_throw_on_repair()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_start_throw_on_repair():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_start_throw_on_repair(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_start_throw_on_repair(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_stat_ctime()`. */
FZ_FUNCTION int64_t ll_fz_stat_ctime(const char *path)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_stat_ctime():";
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		std::cerr << "\n";
	}
	#endif
	int64_t ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_stat_ctime(path);
	return ret;
}

/** Low-level wrapper for `::fz_stat_mtime()`. */
FZ_FUNCTION int64_t ll_fz_stat_mtime(const char *path)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_stat_mtime():";
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		std::cerr << "\n";
	}
	#endif
	int64_t ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_stat_mtime(path);
	return ret;
}

/** Low-level wrapper for `::fz_stddbg()`. */
FZ_FUNCTION ::fz_output *ll_fz_stddbg()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_stddbg():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_output * ret;
	fz_try(auto_ctx) {
		ret = ::fz_stddbg(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_stddbg(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_stderr()`. */
FZ_FUNCTION ::fz_output *ll_fz_stderr()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_stderr():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_output * ret;
	fz_try(auto_ctx) {
		ret = ::fz_stderr(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_stderr(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_stdout()`. */
FZ_FUNCTION ::fz_output *ll_fz_stdout()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_stdout():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_output * ret;
	fz_try(auto_ctx) {
		ret = ::fz_stdout(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_stdout(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_store_item()`. */
FZ_FUNCTION void *ll_fz_store_item(void *key, void *val, size_t itemsize, const ::fz_store_type *type)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_store_item():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " key=" << (void*) key;
		if (s_trace > 1) std::cerr << " val=" << (void*) val;
		std::cerr << " itemsize=" << itemsize;
		if (s_trace > 1) std::cerr << " type=" << type;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_store_item(auto_ctx, key, val, itemsize, type);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_store_item(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_store_scavenge()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_store_scavenge(size_t size)` => `(int, int phase)`
*/
FZ_FUNCTION int ll_fz_store_scavenge(size_t size, int *phase)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_store_scavenge():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " size=" << size;
		if (s_trace > 1) std::cerr << " phase=" << (void*) phase;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_store_scavenge(auto_ctx, size, phase);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_store_scavenge(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_store_scavenge_external()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_store_scavenge_external(size_t size)` => `(int, int phase)`
*/
FZ_FUNCTION int ll_fz_store_scavenge_external(size_t size, int *phase)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_store_scavenge_external():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " size=" << size;
		if (s_trace > 1) std::cerr << " phase=" << (void*) phase;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_store_scavenge_external(auto_ctx, size, phase);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_store_scavenge_external(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_story_document()`. */
FZ_FUNCTION ::fz_xml *ll_fz_story_document(::fz_story *story)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_story_document():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " story=" << story;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_xml * ret;
	fz_try(auto_ctx) {
		ret = ::fz_story_document(auto_ctx, story);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_story_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_story_positions()`. */
FZ_FUNCTION void ll_fz_story_positions(::fz_story *story, ::fz_story_position_callback *cb, void *arg)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_story_positions():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " story=" << story;
		if (s_trace > 1) std::cerr << " cb=" << (void*) cb;
		if (s_trace > 1) std::cerr << " arg=" << (void*) arg;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_story_positions(auto_ctx, story, cb, arg);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_story_positions(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_story_warnings()`. */
FZ_FUNCTION const char *ll_fz_story_warnings(::fz_story *story)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_story_warnings():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " story=" << story;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_story_warnings(auto_ctx, story);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_story_warnings(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_strcasecmp()`. */
FZ_FUNCTION int ll_fz_strcasecmp(const char *a, const char *b)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_strcasecmp():";
		if (a) std::cerr << " a='" << a << "'";
		else std::cerr << " a:null";
		if (b) std::cerr << " b='" << b << "'";
		else std::cerr << " b:null";
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_strcasecmp(a, b);
	return ret;
}

/** Low-level wrapper for `::fz_strdup()`. */
FZ_FUNCTION char *ll_fz_strdup(const char *s)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_strdup():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s) std::cerr << " s='" << s << "'";
		else std::cerr << " s:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_strdup(auto_ctx, s);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_strdup(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_stream_from_output()`. */
FZ_FUNCTION ::fz_stream *ll_fz_stream_from_output(::fz_output *arg_1)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_stream_from_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " arg_1=" << arg_1;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_stream_from_output(auto_ctx, arg_1);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_stream_from_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_string_from_box_type()`. */
FZ_FUNCTION const char *ll_fz_string_from_box_type(::fz_box_type box)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_string_from_box_type():";
		std::cerr << " box=" << box;
		std::cerr << "\n";
	}
	#endif
	const char * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_string_from_box_type(box);
	return ret;
}

/** Low-level wrapper for `::fz_string_from_buffer()`. */
FZ_FUNCTION const char *ll_fz_string_from_buffer(::fz_buffer *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_string_from_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_string_from_buffer(auto_ctx, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_string_from_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_string_from_text_language()`. */
FZ_FUNCTION char *ll_fz_string_from_text_language(char str[8], ::fz_text_language lang)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_string_from_text_language():";
		std::cerr << " str=" << str;
		std::cerr << " lang=" << lang;
		std::cerr << "\n";
	}
	#endif
	char * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_string_from_text_language(str, lang);
	return ret;
}

/** Low-level wrapper for `::fz_string_from_text_language2()`. */
FZ_FUNCTION std::string ll_fz_string_from_text_language2(::fz_text_language lang)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_string_from_text_language2():";
		std::cerr << " lang=" << lang;
		std::cerr << "\n";
	}
	#endif
	std::string ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_string_from_text_language2(lang);
	return ret;
}

/** Low-level wrapper for `::fz_strlcat()`. */
FZ_FUNCTION size_t ll_fz_strlcat(char *dst, const char *src, size_t n)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_strlcat():";
		if (s_trace > 1) std::cerr << " dst=" << (void*) dst;
		if (src) std::cerr << " src='" << src << "'";
		else std::cerr << " src:null";
		std::cerr << " n=" << n;
		std::cerr << "\n";
	}
	#endif
	size_t ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_strlcat(dst, src, n);
	return ret;
}

/** Low-level wrapper for `::fz_strlcpy()`. */
FZ_FUNCTION size_t ll_fz_strlcpy(char *dst, const char *src, size_t n)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_strlcpy():";
		if (s_trace > 1) std::cerr << " dst=" << (void*) dst;
		if (src) std::cerr << " src='" << src << "'";
		else std::cerr << " src:null";
		std::cerr << " n=" << n;
		std::cerr << "\n";
	}
	#endif
	size_t ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_strlcpy(dst, src, n);
	return ret;
}

/** Low-level wrapper for `::fz_strncasecmp()`. */
FZ_FUNCTION int ll_fz_strncasecmp(const char *a, const char *b, size_t n)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_strncasecmp():";
		if (a) std::cerr << " a='" << a << "'";
		else std::cerr << " a:null";
		if (b) std::cerr << " b='" << b << "'";
		else std::cerr << " b:null";
		std::cerr << " n=" << n;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_strncasecmp(a, b, n);
	return ret;
}

/** Low-level wrapper for `::fz_strnlen()`. */
FZ_FUNCTION size_t ll_fz_strnlen(const char *s, size_t maxlen)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_strnlen():";
		if (s) std::cerr << " s='" << s << "'";
		else std::cerr << " s:null";
		std::cerr << " maxlen=" << maxlen;
		std::cerr << "\n";
	}
	#endif
	size_t ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_strnlen(s, maxlen);
	return ret;
}

/** Low-level wrapper for `::fz_stroke_path()`. */
FZ_FUNCTION void ll_fz_stroke_path(::fz_device *dev, const ::fz_path *path, const ::fz_stroke_state *stroke, ::fz_matrix ctm, ::fz_colorspace *colorspace, const float *color, float alpha, ::fz_color_params color_params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_stroke_path():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		if (s_trace > 1) std::cerr << " path=" << path;
		if (s_trace > 1) std::cerr << " stroke=" << stroke;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " colorspace=" << colorspace;
		if (s_trace > 1) std::cerr << " color=" << (void*) color;
		std::cerr << " alpha=" << alpha;
		std::cerr << " color_params=" << color_params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_stroke_path(auto_ctx, dev, path, stroke, ctm, colorspace, color, alpha, color_params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_stroke_path(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_stroke_text()`. */
FZ_FUNCTION void ll_fz_stroke_text(::fz_device *dev, const ::fz_text *text, const ::fz_stroke_state *stroke, ::fz_matrix ctm, ::fz_colorspace *colorspace, const float *color, float alpha, ::fz_color_params color_params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_stroke_text():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		if (s_trace > 1) std::cerr << " text=" << text;
		if (s_trace > 1) std::cerr << " stroke=" << stroke;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " colorspace=" << colorspace;
		if (s_trace > 1) std::cerr << " color=" << (void*) color;
		std::cerr << " alpha=" << alpha;
		std::cerr << " color_params=" << color_params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_stroke_text(auto_ctx, dev, text, stroke, ctm, colorspace, color, alpha, color_params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_stroke_text(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_strsep()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_strsep(const char *delim)` => `(char *, char *stringp)`
*/
FZ_FUNCTION char *ll_fz_strsep(char **stringp, const char *delim)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_strsep():";
		if (s_trace > 1) std::cerr << " stringp=" << (void*) stringp;
		if (delim) std::cerr << " delim='" << delim << "'";
		else std::cerr << " delim:null";
		std::cerr << "\n";
	}
	#endif
	char * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_strsep(stringp, delim);
	return ret;
}

/** Low-level wrapper for `::fz_strtof()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_strtof(const char *s)` => `(float, char *es)`
*/
FZ_FUNCTION float ll_fz_strtof(const char *s, char **es)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_strtof():";
		if (s) std::cerr << " s='" << s << "'";
		else std::cerr << " s:null";
		if (s_trace > 1) std::cerr << " es=" << (void*) es;
		std::cerr << "\n";
	}
	#endif
	float ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_strtof(s, es);
	return ret;
}

/** Low-level wrapper for `::fz_structure_from_string()`. */
FZ_FUNCTION ::fz_structure ll_fz_structure_from_string(const char *str)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_structure_from_string():";
		if (str) std::cerr << " str='" << str << "'";
		else std::cerr << " str:null";
		std::cerr << "\n";
	}
	#endif
	fz_structure ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_structure_from_string(str);
	return ret;
}

/** Low-level wrapper for `::fz_structure_to_string()`. */
FZ_FUNCTION const char *ll_fz_structure_to_string(::fz_structure type)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_structure_to_string():";
		std::cerr << " type=" << type;
		std::cerr << "\n";
	}
	#endif
	const char * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_structure_to_string(type);
	return ret;
}

/** Low-level wrapper for `::fz_subpixel_adjust()`. */
FZ_FUNCTION float ll_fz_subpixel_adjust(::fz_matrix *ctm, ::fz_matrix *subpix_ctm, unsigned char *qe, unsigned char *qf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_subpixel_adjust():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " ctm=" << ctm;
		std::cerr << " subpix_ctm=" << subpix_ctm;
		std::cerr << " qe=" << ((void*) qe);
		std::cerr << " qf=" << ((void*) qf);
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	float ret;
	fz_try(auto_ctx) {
		ret = ::fz_subpixel_adjust(auto_ctx, ctm, subpix_ctm, qe, qf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_subpixel_adjust(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_subsample_pixmap()`. */
FZ_FUNCTION void ll_fz_subsample_pixmap(::fz_pixmap *tile, int factor)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_subsample_pixmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " tile=" << tile;
		std::cerr << " factor=" << factor;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_subsample_pixmap(auto_ctx, tile, factor);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_subsample_pixmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_subset_cff_for_gids()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_subset_cff_for_gids(::fz_buffer *orig, int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
*/
FZ_FUNCTION ::fz_buffer *ll_fz_subset_cff_for_gids(::fz_buffer *orig, int *gids, int num_gids, int symbolic, int cidfont)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_subset_cff_for_gids():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " orig=" << orig;
		if (s_trace > 1) std::cerr << " gids=" << (void*) gids;
		std::cerr << " num_gids=" << num_gids;
		std::cerr << " symbolic=" << symbolic;
		std::cerr << " cidfont=" << cidfont;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_subset_cff_for_gids(auto_ctx, orig, gids, num_gids, symbolic, cidfont);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_subset_cff_for_gids(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_subset_ttf_for_gids()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_subset_ttf_for_gids(::fz_buffer *orig, int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
*/
FZ_FUNCTION ::fz_buffer *ll_fz_subset_ttf_for_gids(::fz_buffer *orig, int *gids, int num_gids, int symbolic, int cidfont)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_subset_ttf_for_gids():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " orig=" << orig;
		if (s_trace > 1) std::cerr << " gids=" << (void*) gids;
		std::cerr << " num_gids=" << num_gids;
		std::cerr << " symbolic=" << symbolic;
		std::cerr << " cidfont=" << cidfont;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_subset_ttf_for_gids(auto_ctx, orig, gids, num_gids, symbolic, cidfont);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_subset_ttf_for_gids(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_sync_bits()`. */
FZ_FUNCTION void ll_fz_sync_bits(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_sync_bits():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_sync_bits(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_sync_bits(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_tell()`. */
FZ_FUNCTION int64_t ll_fz_tell(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_tell():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int64_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_tell(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_tell(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_tell_output()`. */
FZ_FUNCTION int64_t ll_fz_tell_output(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_tell_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int64_t ret;
	fz_try(auto_ctx) {
		ret = ::fz_tell_output(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_tell_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_terminate_buffer()`. */
FZ_FUNCTION void ll_fz_terminate_buffer(::fz_buffer *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_terminate_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_terminate_buffer(auto_ctx, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_terminate_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_text_aa_level()`. */
FZ_FUNCTION int ll_fz_text_aa_level()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_text_aa_level():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_text_aa_level(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_text_aa_level(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_text_language_from_string()`. */
FZ_FUNCTION ::fz_text_language ll_fz_text_language_from_string(const char *str)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_text_language_from_string():";
		if (str) std::cerr << " str='" << str << "'";
		else std::cerr << " str:null";
		std::cerr << "\n";
	}
	#endif
	fz_text_language ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_text_language_from_string(str);
	return ret;
}

/** Low-level wrapper for `::fz_tint_pixmap()`. */
FZ_FUNCTION void ll_fz_tint_pixmap(::fz_pixmap *pix, int black, int white)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_tint_pixmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << " black=" << black;
		std::cerr << " white=" << white;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_tint_pixmap(auto_ctx, pix, black, white);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_tint_pixmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_tolower()`. */
FZ_FUNCTION int ll_fz_tolower(int c)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_tolower():";
		std::cerr << " c=" << c;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_tolower(c);
	return ret;
}

/** Low-level wrapper for `::fz_toupper()`. */
FZ_FUNCTION int ll_fz_toupper(int c)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_toupper():";
		std::cerr << " c=" << c;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_toupper(c);
	return ret;
}

/** Low-level wrapper for `::fz_transform_page()`. */
FZ_FUNCTION ::fz_matrix ll_fz_transform_page(::fz_rect mediabox, float resolution, float rotate)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_transform_page():";
		std::cerr << " mediabox=" << mediabox;
		std::cerr << " resolution=" << resolution;
		std::cerr << " rotate=" << rotate;
		std::cerr << "\n";
	}
	#endif
	fz_matrix ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_transform_page(mediabox, resolution, rotate);
	return ret;
}

/** Low-level wrapper for `::fz_transform_path()`. */
FZ_FUNCTION void ll_fz_transform_path(::fz_path *path, ::fz_matrix transform)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_transform_path():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " path=" << path;
		std::cerr << " transform=" << transform;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_transform_path(auto_ctx, path, transform);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_transform_path(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_transform_point()`. */
FZ_FUNCTION ::fz_point ll_fz_transform_point(::fz_point point, ::fz_matrix m)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_transform_point():";
		std::cerr << " point=" << point;
		std::cerr << " m=" << m;
		std::cerr << "\n";
	}
	#endif
	fz_point ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_transform_point(point, m);
	return ret;
}

/** Low-level wrapper for `::fz_transform_point_xy()`. */
FZ_FUNCTION ::fz_point ll_fz_transform_point_xy(float x, float y, ::fz_matrix m)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_transform_point_xy():";
		std::cerr << " x=" << x;
		std::cerr << " y=" << y;
		std::cerr << " m=" << m;
		std::cerr << "\n";
	}
	#endif
	fz_point ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_transform_point_xy(x, y, m);
	return ret;
}

/** Low-level wrapper for `::fz_transform_quad()`. */
FZ_FUNCTION ::fz_quad ll_fz_transform_quad(::fz_quad q, ::fz_matrix m)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_transform_quad():";
		std::cerr << " q=" << q;
		std::cerr << " m=" << m;
		std::cerr << "\n";
	}
	#endif
	fz_quad ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_transform_quad(q, m);
	return ret;
}

/** Low-level wrapper for `::fz_transform_rect()`. */
FZ_FUNCTION ::fz_rect ll_fz_transform_rect(::fz_rect rect, ::fz_matrix m)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_transform_rect():";
		std::cerr << " rect=" << rect;
		std::cerr << " m=" << m;
		std::cerr << "\n";
	}
	#endif
	fz_rect ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_transform_rect(rect, m);
	return ret;
}

/** Low-level wrapper for `::fz_transform_vector()`. */
FZ_FUNCTION ::fz_point ll_fz_transform_vector(::fz_point vector, ::fz_matrix m)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_transform_vector():";
		std::cerr << " vector=" << vector;
		std::cerr << " m=" << m;
		std::cerr << "\n";
	}
	#endif
	fz_point ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_transform_vector(vector, m);
	return ret;
}

/** Low-level wrapper for `::fz_translate()`. */
FZ_FUNCTION ::fz_matrix ll_fz_translate(float tx, float ty)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_translate():";
		std::cerr << " tx=" << tx;
		std::cerr << " ty=" << ty;
		std::cerr << "\n";
	}
	#endif
	fz_matrix ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_translate(tx, ty);
	return ret;
}

/** Low-level wrapper for `::fz_translate_irect()`. */
FZ_FUNCTION ::fz_irect ll_fz_translate_irect(::fz_irect a, int xoff, int yoff)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_translate_irect():";
		std::cerr << " a=" << a;
		std::cerr << " xoff=" << xoff;
		std::cerr << " yoff=" << yoff;
		std::cerr << "\n";
	}
	#endif
	fz_irect ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_translate_irect(a, xoff, yoff);
	return ret;
}

/** Low-level wrapper for `::fz_translate_rect()`. */
FZ_FUNCTION ::fz_rect ll_fz_translate_rect(::fz_rect a, float xoff, float yoff)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_translate_rect():";
		std::cerr << " a=" << a;
		std::cerr << " xoff=" << xoff;
		std::cerr << " yoff=" << yoff;
		std::cerr << "\n";
	}
	#endif
	fz_rect ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_translate_rect(a, xoff, yoff);
	return ret;
}

/** Low-level wrapper for `::fz_tree_archive_add_buffer()`. */
FZ_FUNCTION void ll_fz_tree_archive_add_buffer(::fz_archive *arch_, const char *name, ::fz_buffer *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_tree_archive_add_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " arch_=" << arch_;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_tree_archive_add_buffer(auto_ctx, arch_, name, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_tree_archive_add_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_tree_archive_add_data()`. */
FZ_FUNCTION void ll_fz_tree_archive_add_data(::fz_archive *arch_, const char *name, const void *data, size_t size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_tree_archive_add_data():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " arch_=" << arch_;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		if (s_trace > 1) std::cerr << " data=" << (void*) data;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_tree_archive_add_data(auto_ctx, arch_, name, data, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_tree_archive_add_data(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_tree_insert()`. */
FZ_FUNCTION ::fz_tree *ll_fz_tree_insert(::fz_tree *root, const char *key, void *value)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_tree_insert():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " root=" << root;
		if (key) std::cerr << " key='" << key << "'";
		else std::cerr << " key:null";
		if (s_trace > 1) std::cerr << " value=" << (void*) value;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_tree * ret;
	fz_try(auto_ctx) {
		ret = ::fz_tree_insert(auto_ctx, root, key, value);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_tree_insert(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_tree_lookup()`. */
FZ_FUNCTION void *ll_fz_tree_lookup(::fz_tree *node, const char *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_tree_lookup():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " node=" << node;
		if (key) std::cerr << " key='" << key << "'";
		else std::cerr << " key:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_tree_lookup(auto_ctx, node, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_tree_lookup(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_trim_buffer()`. */
FZ_FUNCTION void ll_fz_trim_buffer(::fz_buffer *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_trim_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_trim_buffer(auto_ctx, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_trim_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_trim_path()`. */
FZ_FUNCTION void ll_fz_trim_path(::fz_path *path)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_trim_path():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " path=" << path;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_trim_path(auto_ctx, path);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_trim_path(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_truncate_output()`. */
FZ_FUNCTION void ll_fz_truncate_output(::fz_output *arg_1)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_truncate_output():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " arg_1=" << arg_1;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_truncate_output(auto_ctx, arg_1);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_truncate_output(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_try_invert_matrix()`. */
FZ_FUNCTION int ll_fz_try_invert_matrix(::fz_matrix *inv, ::fz_matrix src)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_try_invert_matrix():";
		std::cerr << " inv=" << inv;
		std::cerr << " src=" << src;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_try_invert_matrix(inv, src);
	return ret;
}

/** Low-level wrapper for `::fz_try_open_archive_entry()`. */
FZ_FUNCTION ::fz_stream *ll_fz_try_open_archive_entry(::fz_archive *arch, const char *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_try_open_archive_entry():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " arch=" << arch;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_try_open_archive_entry(auto_ctx, arch, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_try_open_archive_entry(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_try_open_archive_with_stream()`. */
FZ_FUNCTION ::fz_archive *ll_fz_try_open_archive_with_stream(::fz_stream *file)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_try_open_archive_with_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " file=" << file;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_archive * ret;
	fz_try(auto_ctx) {
		ret = ::fz_try_open_archive_with_stream(auto_ctx, file);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_try_open_archive_with_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_try_open_file()`. */
FZ_FUNCTION ::fz_stream *ll_fz_try_open_file(const char *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_try_open_file():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_try_open_file(auto_ctx, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_try_open_file(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_try_parse_xml_archive_entry()`. */
FZ_FUNCTION ::fz_xml *ll_fz_try_parse_xml_archive_entry(::fz_archive *dir, const char *filename, int preserve_white)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_try_parse_xml_archive_entry():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dir=" << dir;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << " preserve_white=" << preserve_white;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_xml * ret;
	fz_try(auto_ctx) {
		ret = ::fz_try_parse_xml_archive_entry(auto_ctx, dir, filename, preserve_white);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_try_parse_xml_archive_entry(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_try_read_archive_entry()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_try_read_archive_entry(::fz_archive *arch, const char *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_try_read_archive_entry():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " arch=" << arch;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_try_read_archive_entry(auto_ctx, arch, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_try_read_archive_entry(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_try_read_file()`. */
FZ_FUNCTION ::fz_buffer *ll_fz_try_read_file(const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_try_read_file():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::fz_try_read_file(auto_ctx, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_try_read_file(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_tune_image_decode()`. */
FZ_FUNCTION void ll_fz_tune_image_decode(::fz_tune_image_decode_fn *image_decode, void *arg)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_tune_image_decode():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " image_decode=" << (void*) image_decode;
		if (s_trace > 1) std::cerr << " arg=" << (void*) arg;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_tune_image_decode(auto_ctx, image_decode, arg);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_tune_image_decode(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_tune_image_scale()`. */
FZ_FUNCTION void ll_fz_tune_image_scale(::fz_tune_image_scale_fn *image_scale, void *arg)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_tune_image_scale():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " image_scale=" << (void*) image_scale;
		if (s_trace > 1) std::cerr << " arg=" << (void*) arg;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_tune_image_scale(auto_ctx, image_scale, arg);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_tune_image_scale(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_unicode_from_glyph_name()`. */
FZ_FUNCTION int ll_fz_unicode_from_glyph_name(const char *name)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_unicode_from_glyph_name():";
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_unicode_from_glyph_name(name);
	return ret;
}

/** Low-level wrapper for `::fz_unicode_from_glyph_name_strict()`. */
FZ_FUNCTION int ll_fz_unicode_from_glyph_name_strict(const char *name)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_unicode_from_glyph_name_strict():";
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_unicode_from_glyph_name_strict(name);
	return ret;
}

/** Low-level wrapper for `::fz_union_rect()`. */
FZ_FUNCTION ::fz_rect ll_fz_union_rect(::fz_rect a, ::fz_rect b)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_union_rect():";
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << "\n";
	}
	#endif
	fz_rect ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_union_rect(a, b);
	return ret;
}

/** Low-level wrapper for `::fz_unlock()`. */
FZ_FUNCTION void ll_fz_unlock(int lock)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_unlock():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " lock=" << lock;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_unlock(auto_ctx, lock);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_unlock(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_unpack_stream()`. */
FZ_FUNCTION ::fz_stream *ll_fz_unpack_stream(::fz_stream *src, int depth, int w, int h, int n, int indexed, int pad, int skip)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_unpack_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " src=" << src;
		std::cerr << " depth=" << depth;
		std::cerr << " w=" << w;
		std::cerr << " h=" << h;
		std::cerr << " n=" << n;
		std::cerr << " indexed=" << indexed;
		std::cerr << " pad=" << pad;
		std::cerr << " skip=" << skip;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::fz_unpack_stream(auto_ctx, src, depth, w, h, n, indexed, pad, skip);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_unpack_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_unread_byte()`. */
FZ_FUNCTION void ll_fz_unread_byte(::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_unread_byte():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_unread_byte(auto_ctx, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_unread_byte(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_unshare_stroke_state()`. */
FZ_FUNCTION ::fz_stroke_state *ll_fz_unshare_stroke_state(::fz_stroke_state *shared)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_unshare_stroke_state():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " shared=" << shared;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stroke_state * ret;
	fz_try(auto_ctx) {
		ret = ::fz_unshare_stroke_state(auto_ctx, shared);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_unshare_stroke_state(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_unshare_stroke_state_with_dash_len()`. */
FZ_FUNCTION ::fz_stroke_state *ll_fz_unshare_stroke_state_with_dash_len(::fz_stroke_state *shared, int len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_unshare_stroke_state_with_dash_len():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " shared=" << shared;
		std::cerr << " len=" << len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stroke_state * ret;
	fz_try(auto_ctx) {
		ret = ::fz_unshare_stroke_state_with_dash_len(auto_ctx, shared, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_unshare_stroke_state_with_dash_len(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_urldecode()`. */
FZ_FUNCTION char *ll_fz_urldecode(char *url)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_urldecode():";
		if (s_trace > 1) std::cerr << " url=" << (void*) url;
		std::cerr << "\n";
	}
	#endif
	char * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_urldecode(url);
	return ret;
}

/** Low-level wrapper for `::fz_use_document_css()`. */
FZ_FUNCTION int ll_fz_use_document_css()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_use_document_css():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::fz_use_document_css(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_use_document_css(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_user_context()`. */
FZ_FUNCTION void *ll_fz_user_context()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_user_context():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::fz_user_context(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_user_context(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_user_css()`. */
FZ_FUNCTION const char *ll_fz_user_css()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_user_css():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::fz_user_css(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_user_css(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_utflen()`. */
FZ_FUNCTION int ll_fz_utflen(const char *s)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_utflen():";
		if (s) std::cerr << " s='" << s << "'";
		else std::cerr << " s:null";
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_utflen(s);
	return ret;
}

/** Low-level wrapper for `::fz_var_imp()`. */
FZ_FUNCTION void ll_fz_var_imp(void *arg_0)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_var_imp():";
		if (s_trace > 1) std::cerr << " arg_0=" << (void*) arg_0;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::fz_var_imp(arg_0);
}

/** Low-level wrapper for `::fz_vlog_error_printf()`. */
FZ_FUNCTION void ll_fz_vlog_error_printf(const char *fmt, va_list ap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_vlog_error_printf():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (fmt) std::cerr << " fmt='" << fmt << "'";
		else std::cerr << " fmt:null";
		std::cerr << " ap:va_list";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_vlog_error_printf(auto_ctx, fmt, ap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_vlog_error_printf(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_vsnprintf()`. */
FZ_FUNCTION size_t ll_fz_vsnprintf(char *buffer, size_t space, const char *fmt, va_list args)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_vsnprintf():";
		if (s_trace > 1) std::cerr << " buffer=" << (void*) buffer;
		std::cerr << " space=" << space;
		if (fmt) std::cerr << " fmt='" << fmt << "'";
		else std::cerr << " fmt:null";
		std::cerr << " args:va_list";
		std::cerr << "\n";
	}
	#endif
	size_t ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_vsnprintf(buffer, space, fmt, args);
	return ret;
}

/** Low-level wrapper for `::fz_vthrow()`. */
FZ_FUNCTION void ll_fz_vthrow(int errcode, const char *arg_2, va_list ap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_vthrow():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " errcode=" << errcode;
		if (arg_2) std::cerr << " arg_2='" << arg_2 << "'";
		else std::cerr << " arg_2:null";
		std::cerr << " ap:va_list";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_vthrow(auto_ctx, errcode, arg_2, ap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_vthrow(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_vwarn()`. */
FZ_FUNCTION void ll_fz_vwarn(const char *fmt, va_list ap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_vwarn():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (fmt) std::cerr << " fmt='" << fmt << "'";
		else std::cerr << " fmt:null";
		std::cerr << " ap:va_list";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_vwarn(auto_ctx, fmt, ap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_vwarn(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_walk_path()`. */
FZ_FUNCTION void ll_fz_walk_path(const ::fz_path *path, const ::fz_path_walker *walker, void *arg)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_walk_path():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " path=" << path;
		if (s_trace > 1) std::cerr << " walker=" << walker;
		if (s_trace > 1) std::cerr << " arg=" << (void*) arg;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_walk_path(auto_ctx, path, walker, arg);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_walk_path(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_warn()`. */
FZ_FUNCTION void ll_fz_warn(const char *fmt, ...)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_warn():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (fmt) std::cerr << " fmt='" << fmt << "'";
		else std::cerr << " fmt:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	va_list ap;
	fz_var(ap);
	fz_try(auto_ctx) {
		va_start(ap, fmt);
		fz_vwarn(auto_ctx, fmt, ap);
	}
	fz_always(auto_ctx) {
		va_end(ap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_warn(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_warning_callback()`.

This function has out-params. Python/C# wrappers look like:
	`ll_fz_warning_callback()` => `(fz_warning_cb *, void *user)`
*/
FZ_FUNCTION ::fz_warning_cb *ll_fz_warning_callback(void **user)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_warning_callback():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " user=" << (void*) user;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_warning_cb * ret;
	fz_try(auto_ctx) {
		ret = ::fz_warning_callback(auto_ctx, user);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_warning_callback(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_warp_pixmap()`. */
FZ_FUNCTION ::fz_pixmap *ll_fz_warp_pixmap(::fz_pixmap *src, const ::fz_point points[4], int width, int height)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_warp_pixmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " src=" << src;
		std::cerr << " points=" << points;
		std::cerr << " width=" << width;
		std::cerr << " height=" << height;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::fz_warp_pixmap(auto_ctx, src, points, width, height);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_warp_pixmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::fz_windows_1250_from_unicode()`. */
FZ_FUNCTION int ll_fz_windows_1250_from_unicode(int u)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_windows_1250_from_unicode():";
		std::cerr << " u=" << u;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_windows_1250_from_unicode(u);
	return ret;
}

/** Low-level wrapper for `::fz_windows_1251_from_unicode()`. */
FZ_FUNCTION int ll_fz_windows_1251_from_unicode(int u)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_windows_1251_from_unicode():";
		std::cerr << " u=" << u;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_windows_1251_from_unicode(u);
	return ret;
}

/** Low-level wrapper for `::fz_windows_1252_from_unicode()`. */
FZ_FUNCTION int ll_fz_windows_1252_from_unicode(int u)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_windows_1252_from_unicode():";
		std::cerr << " u=" << u;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_windows_1252_from_unicode(u);
	return ret;
}

/** Low-level wrapper for `::fz_write_band()`. */
FZ_FUNCTION void ll_fz_write_band(::fz_band_writer *writer, int stride, int band_height, const unsigned char *samples)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_band():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " writer=" << writer;
		std::cerr << " stride=" << stride;
		std::cerr << " band_height=" << band_height;
		std::cerr << " samples=" << ((void*) samples);
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_band(auto_ctx, writer, stride, band_height, samples);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_band(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_base64()`. */
FZ_FUNCTION void ll_fz_write_base64(::fz_output *out, const unsigned char *data, size_t size, int newline)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_base64():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " data=" << ((void*) data);
		std::cerr << " size=" << size;
		std::cerr << " newline=" << newline;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_base64(auto_ctx, out, data, size, newline);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_base64(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_base64_buffer()`. */
FZ_FUNCTION void ll_fz_write_base64_buffer(::fz_output *out, ::fz_buffer *data, int newline)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_base64_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " data=" << data;
		std::cerr << " newline=" << newline;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_base64_buffer(auto_ctx, out, data, newline);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_base64_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_bitmap_as_pbm()`. */
FZ_FUNCTION void ll_fz_write_bitmap_as_pbm(::fz_output *out, ::fz_bitmap *bitmap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_bitmap_as_pbm():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " bitmap=" << bitmap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_bitmap_as_pbm(auto_ctx, out, bitmap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_bitmap_as_pbm(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_bitmap_as_pcl()`. */
FZ_FUNCTION void ll_fz_write_bitmap_as_pcl(::fz_output *out, const ::fz_bitmap *bitmap, const ::fz_pcl_options *pcl)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_bitmap_as_pcl():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " bitmap=" << bitmap;
		if (s_trace > 1) std::cerr << " pcl=" << pcl;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_bitmap_as_pcl(auto_ctx, out, bitmap, pcl);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_bitmap_as_pcl(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_bitmap_as_pkm()`. */
FZ_FUNCTION void ll_fz_write_bitmap_as_pkm(::fz_output *out, ::fz_bitmap *bitmap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_bitmap_as_pkm():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " bitmap=" << bitmap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_bitmap_as_pkm(auto_ctx, out, bitmap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_bitmap_as_pkm(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_bitmap_as_pwg()`. */
FZ_FUNCTION void ll_fz_write_bitmap_as_pwg(::fz_output *out, const ::fz_bitmap *bitmap, const ::fz_pwg_options *pwg)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_bitmap_as_pwg():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " bitmap=" << bitmap;
		std::cerr << " pwg=" << pwg;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_bitmap_as_pwg(auto_ctx, out, bitmap, pwg);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_bitmap_as_pwg(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_bitmap_as_pwg_page()`. */
FZ_FUNCTION void ll_fz_write_bitmap_as_pwg_page(::fz_output *out, const ::fz_bitmap *bitmap, const ::fz_pwg_options *pwg)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_bitmap_as_pwg_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " bitmap=" << bitmap;
		std::cerr << " pwg=" << pwg;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_bitmap_as_pwg_page(auto_ctx, out, bitmap, pwg);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_bitmap_as_pwg_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_bits()`. */
FZ_FUNCTION void ll_fz_write_bits(::fz_output *out, unsigned int data, int num_bits)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_bits():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " data=" << data;
		std::cerr << " num_bits=" << num_bits;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_bits(auto_ctx, out, data, num_bits);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_bits(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_bits_sync()`. */
FZ_FUNCTION void ll_fz_write_bits_sync(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_bits_sync():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_bits_sync(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_bits_sync(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_buffer()`. */
FZ_FUNCTION void ll_fz_write_buffer(::fz_output *out, ::fz_buffer *data)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_buffer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " data=" << data;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_buffer(auto_ctx, out, data);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_buffer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_byte()`. */
FZ_FUNCTION void ll_fz_write_byte(::fz_output *out, unsigned char x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_byte():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " x=" << ((int) x);
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_byte(auto_ctx, out, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_byte(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_char()`. */
FZ_FUNCTION void ll_fz_write_char(::fz_output *out, char x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_char():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_char(auto_ctx, out, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_char(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_data()`. */
FZ_FUNCTION void ll_fz_write_data(::fz_output *out, const void *data, size_t size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_data():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " data=" << (void*) data;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_data(auto_ctx, out, data, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_data(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_document()`. */
FZ_FUNCTION void ll_fz_write_document(::fz_document_writer *wri, ::fz_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_document():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " wri=" << wri;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_document(auto_ctx, wri, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_float_be()`. */
FZ_FUNCTION void ll_fz_write_float_be(::fz_output *out, float f)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_float_be():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " f=" << f;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_float_be(auto_ctx, out, f);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_float_be(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_float_le()`. */
FZ_FUNCTION void ll_fz_write_float_le(::fz_output *out, float f)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_float_le():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " f=" << f;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_float_le(auto_ctx, out, f);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_float_le(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_header()`. */
FZ_FUNCTION void ll_fz_write_header(::fz_band_writer *writer, int w, int h, int n, int alpha, int xres, int yres, int pagenum, ::fz_colorspace *cs, ::fz_separations *seps)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_header():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " writer=" << writer;
		std::cerr << " w=" << w;
		std::cerr << " h=" << h;
		std::cerr << " n=" << n;
		std::cerr << " alpha=" << alpha;
		std::cerr << " xres=" << xres;
		std::cerr << " yres=" << yres;
		std::cerr << " pagenum=" << pagenum;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		if (s_trace > 1) std::cerr << " seps=" << seps;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_header(auto_ctx, writer, w, h, n, alpha, xres, yres, pagenum, cs, seps);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_header(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_image_as_data_uri()`. */
FZ_FUNCTION void ll_fz_write_image_as_data_uri(::fz_output *out, ::fz_image *image)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_image_as_data_uri():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_image_as_data_uri(auto_ctx, out, image);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_image_as_data_uri(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_int16_be()`. */
FZ_FUNCTION void ll_fz_write_int16_be(::fz_output *out, int x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_int16_be():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_int16_be(auto_ctx, out, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_int16_be(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_int16_le()`. */
FZ_FUNCTION void ll_fz_write_int16_le(::fz_output *out, int x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_int16_le():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_int16_le(auto_ctx, out, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_int16_le(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_int32_be()`. */
FZ_FUNCTION void ll_fz_write_int32_be(::fz_output *out, int x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_int32_be():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_int32_be(auto_ctx, out, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_int32_be(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_int32_le()`. */
FZ_FUNCTION void ll_fz_write_int32_le(::fz_output *out, int x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_int32_le():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_int32_le(auto_ctx, out, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_int32_le(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_pixmap_as_data_uri()`. */
FZ_FUNCTION void ll_fz_write_pixmap_as_data_uri(::fz_output *out, ::fz_pixmap *pixmap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_pixmap_as_data_uri():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_pixmap_as_data_uri(auto_ctx, out, pixmap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_pixmap_as_data_uri(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_pixmap_as_jpeg()`. */
FZ_FUNCTION void ll_fz_write_pixmap_as_jpeg(::fz_output *out, ::fz_pixmap *pix, int quality, int invert_cmyk)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_pixmap_as_jpeg():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << " quality=" << quality;
		std::cerr << " invert_cmyk=" << invert_cmyk;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_pixmap_as_jpeg(auto_ctx, out, pix, quality, invert_cmyk);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_pixmap_as_jpeg(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_pixmap_as_jpx()`. */
FZ_FUNCTION void ll_fz_write_pixmap_as_jpx(::fz_output *out, ::fz_pixmap *pix, int quality)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_pixmap_as_jpx():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " pix=" << pix;
		std::cerr << " quality=" << quality;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_pixmap_as_jpx(auto_ctx, out, pix, quality);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_pixmap_as_jpx(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_pixmap_as_pam()`. */
FZ_FUNCTION void ll_fz_write_pixmap_as_pam(::fz_output *out, ::fz_pixmap *pixmap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_pixmap_as_pam():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_pixmap_as_pam(auto_ctx, out, pixmap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_pixmap_as_pam(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_pixmap_as_pcl()`. */
FZ_FUNCTION void ll_fz_write_pixmap_as_pcl(::fz_output *out, const ::fz_pixmap *pixmap, const ::fz_pcl_options *pcl)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_pixmap_as_pcl():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		if (s_trace > 1) std::cerr << " pcl=" << pcl;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_pixmap_as_pcl(auto_ctx, out, pixmap, pcl);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_pixmap_as_pcl(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_pixmap_as_pclm()`. */
FZ_FUNCTION void ll_fz_write_pixmap_as_pclm(::fz_output *out, const ::fz_pixmap *pixmap, const ::fz_pclm_options *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_pixmap_as_pclm():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		if (s_trace > 1) std::cerr << " options=" << options;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_pixmap_as_pclm(auto_ctx, out, pixmap, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_pixmap_as_pclm(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_pixmap_as_pdfocr()`. */
FZ_FUNCTION void ll_fz_write_pixmap_as_pdfocr(::fz_output *out, const ::fz_pixmap *pixmap, const ::fz_pdfocr_options *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_pixmap_as_pdfocr():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << " options=" << options;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_pixmap_as_pdfocr(auto_ctx, out, pixmap, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_pixmap_as_pdfocr(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_pixmap_as_png()`. */
FZ_FUNCTION void ll_fz_write_pixmap_as_png(::fz_output *out, const ::fz_pixmap *pixmap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_pixmap_as_png():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_pixmap_as_png(auto_ctx, out, pixmap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_pixmap_as_png(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_pixmap_as_pnm()`. */
FZ_FUNCTION void ll_fz_write_pixmap_as_pnm(::fz_output *out, ::fz_pixmap *pixmap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_pixmap_as_pnm():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_pixmap_as_pnm(auto_ctx, out, pixmap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_pixmap_as_pnm(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_pixmap_as_ps()`. */
FZ_FUNCTION void ll_fz_write_pixmap_as_ps(::fz_output *out, const ::fz_pixmap *pixmap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_pixmap_as_ps():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_pixmap_as_ps(auto_ctx, out, pixmap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_pixmap_as_ps(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_pixmap_as_psd()`. */
FZ_FUNCTION void ll_fz_write_pixmap_as_psd(::fz_output *out, const ::fz_pixmap *pixmap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_pixmap_as_psd():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_pixmap_as_psd(auto_ctx, out, pixmap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_pixmap_as_psd(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_pixmap_as_pwg()`. */
FZ_FUNCTION void ll_fz_write_pixmap_as_pwg(::fz_output *out, const ::fz_pixmap *pixmap, const ::fz_pwg_options *pwg)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_pixmap_as_pwg():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << " pwg=" << pwg;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_pixmap_as_pwg(auto_ctx, out, pixmap, pwg);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_pixmap_as_pwg(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_pixmap_as_pwg_page()`. */
FZ_FUNCTION void ll_fz_write_pixmap_as_pwg_page(::fz_output *out, const ::fz_pixmap *pixmap, const ::fz_pwg_options *pwg)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_pixmap_as_pwg_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " pixmap=" << pixmap;
		std::cerr << " pwg=" << pwg;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_pixmap_as_pwg_page(auto_ctx, out, pixmap, pwg);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_pixmap_as_pwg_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_ps_file_header()`. */
FZ_FUNCTION void ll_fz_write_ps_file_header(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_ps_file_header():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_ps_file_header(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_ps_file_header(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_ps_file_trailer()`. */
FZ_FUNCTION void ll_fz_write_ps_file_trailer(::fz_output *out, int pages)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_ps_file_trailer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " pages=" << pages;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_ps_file_trailer(auto_ctx, out, pages);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_ps_file_trailer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_pwg_file_header()`. */
FZ_FUNCTION void ll_fz_write_pwg_file_header(::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_pwg_file_header():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_pwg_file_header(auto_ctx, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_pwg_file_header(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_rune()`. */
FZ_FUNCTION void ll_fz_write_rune(::fz_output *out, int rune)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_rune():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " rune=" << rune;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_rune(auto_ctx, out, rune);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_rune(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_stabilized_story()`. */
FZ_FUNCTION void ll_fz_write_stabilized_story(::fz_document_writer *writer, const char *user_css, float em, ::fz_write_story_contentfn contentfn, void *contentfn_ref, ::fz_write_story_rectfn rectfn, void *rectfn_ref, ::fz_write_story_pagefn pagefn, void *pagefn_ref, ::fz_archive *dir)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_stabilized_story():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " writer=" << writer;
		if (user_css) std::cerr << " user_css='" << user_css << "'";
		else std::cerr << " user_css:null";
		std::cerr << " em=" << em;
		std::cerr << " contentfn=" << contentfn;
		if (s_trace > 1) std::cerr << " contentfn_ref=" << (void*) contentfn_ref;
		std::cerr << " rectfn=" << rectfn;
		if (s_trace > 1) std::cerr << " rectfn_ref=" << (void*) rectfn_ref;
		std::cerr << " pagefn=" << pagefn;
		if (s_trace > 1) std::cerr << " pagefn_ref=" << (void*) pagefn_ref;
		if (s_trace > 1) std::cerr << " dir=" << dir;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_stabilized_story(auto_ctx, writer, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_stabilized_story(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_story()`. */
FZ_FUNCTION void ll_fz_write_story(::fz_document_writer *writer, ::fz_story *story, ::fz_write_story_rectfn rectfn, void *rectfn_ref, ::fz_write_story_positionfn positionfn, void *positionfn_ref, ::fz_write_story_pagefn pagefn, void *pagefn_ref)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_story():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " writer=" << writer;
		if (s_trace > 1) std::cerr << " story=" << story;
		std::cerr << " rectfn=" << rectfn;
		if (s_trace > 1) std::cerr << " rectfn_ref=" << (void*) rectfn_ref;
		std::cerr << " positionfn=" << positionfn;
		if (s_trace > 1) std::cerr << " positionfn_ref=" << (void*) positionfn_ref;
		std::cerr << " pagefn=" << pagefn;
		if (s_trace > 1) std::cerr << " pagefn_ref=" << (void*) pagefn_ref;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_story(auto_ctx, writer, story, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_story(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_string()`. */
FZ_FUNCTION void ll_fz_write_string(::fz_output *out, const char *s)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s) std::cerr << " s='" << s << "'";
		else std::cerr << " s:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_string(auto_ctx, out, s);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_uint16_be()`. */
FZ_FUNCTION void ll_fz_write_uint16_be(::fz_output *out, unsigned int x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_uint16_be():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_uint16_be(auto_ctx, out, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_uint16_be(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_uint16_le()`. */
FZ_FUNCTION void ll_fz_write_uint16_le(::fz_output *out, unsigned int x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_uint16_le():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_uint16_le(auto_ctx, out, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_uint16_le(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_uint32_be()`. */
FZ_FUNCTION void ll_fz_write_uint32_be(::fz_output *out, unsigned int x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_uint32_be():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_uint32_be(auto_ctx, out, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_uint32_be(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_uint32_le()`. */
FZ_FUNCTION void ll_fz_write_uint32_le(::fz_output *out, unsigned int x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_uint32_le():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_uint32_le(auto_ctx, out, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_uint32_le(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_vprintf()`. */
FZ_FUNCTION void ll_fz_write_vprintf(::fz_output *out, const char *fmt, va_list ap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_vprintf():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (fmt) std::cerr << " fmt='" << fmt << "'";
		else std::cerr << " fmt:null";
		std::cerr << " ap:va_list";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_vprintf(auto_ctx, out, fmt, ap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_vprintf(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_write_zip_entry()`. */
FZ_FUNCTION void ll_fz_write_zip_entry(::fz_zip_writer *zip, const char *name, ::fz_buffer *buf, int compress)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_write_zip_entry():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " zip=" << zip;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << " compress=" << compress;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_write_zip_entry(auto_ctx, zip, name, buf, compress);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_write_zip_entry(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_xml_add_att()`. */
FZ_FUNCTION void ll_fz_xml_add_att(::fz_pool *pool, ::fz_xml *node, const char *key, const char *val)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_add_att():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pool=" << pool;
		if (s_trace > 1) std::cerr << " node=" << node;
		if (key) std::cerr << " key='" << key << "'";
		else std::cerr << " key:null";
		if (val) std::cerr << " val='" << val << "'";
		else std::cerr << " val:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::fz_xml_add_att(auto_ctx, pool, node, key, val);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by fz_xml_add_att(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::fz_xml_att()`. */
FZ_FUNCTION char *ll_fz_xml_att(::fz_xml *item, const char *att)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_att():";
		if (s_trace > 1) std::cerr << " item=" << item;
		if (att) std::cerr << " att='" << att << "'";
		else std::cerr << " att:null";
		std::cerr << "\n";
	}
	#endif
	char * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_att(item, att);
	return ret;
}

/** Low-level wrapper for `::fz_xml_att_alt()`. */
FZ_FUNCTION char *ll_fz_xml_att_alt(::fz_xml *item, const char *one, const char *two)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_att_alt():";
		if (s_trace > 1) std::cerr << " item=" << item;
		if (one) std::cerr << " one='" << one << "'";
		else std::cerr << " one:null";
		if (two) std::cerr << " two='" << two << "'";
		else std::cerr << " two:null";
		std::cerr << "\n";
	}
	#endif
	char * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_att_alt(item, one, two);
	return ret;
}

/** Low-level wrapper for `::fz_xml_att_eq()`. */
FZ_FUNCTION int ll_fz_xml_att_eq(::fz_xml *item, const char *name, const char *match)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_att_eq():";
		if (s_trace > 1) std::cerr << " item=" << item;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		if (match) std::cerr << " match='" << match << "'";
		else std::cerr << " match:null";
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_att_eq(item, name, match);
	return ret;
}

/** Low-level wrapper for `::fz_xml_down()`. */
FZ_FUNCTION ::fz_xml *ll_fz_xml_down(::fz_xml *item)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_down():";
		if (s_trace > 1) std::cerr << " item=" << item;
		std::cerr << "\n";
	}
	#endif
	fz_xml * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_down(item);
	return ret;
}

/** Low-level wrapper for `::fz_xml_find()`. */
FZ_FUNCTION ::fz_xml *ll_fz_xml_find(::fz_xml *item, const char *tag)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_find():";
		if (s_trace > 1) std::cerr << " item=" << item;
		if (tag) std::cerr << " tag='" << tag << "'";
		else std::cerr << " tag:null";
		std::cerr << "\n";
	}
	#endif
	fz_xml * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_find(item, tag);
	return ret;
}

/** Low-level wrapper for `::fz_xml_find_dfs()`. */
FZ_FUNCTION ::fz_xml *ll_fz_xml_find_dfs(::fz_xml *item, const char *tag, const char *att, const char *match)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_find_dfs():";
		if (s_trace > 1) std::cerr << " item=" << item;
		if (tag) std::cerr << " tag='" << tag << "'";
		else std::cerr << " tag:null";
		if (att) std::cerr << " att='" << att << "'";
		else std::cerr << " att:null";
		if (match) std::cerr << " match='" << match << "'";
		else std::cerr << " match:null";
		std::cerr << "\n";
	}
	#endif
	fz_xml * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_find_dfs(item, tag, att, match);
	return ret;
}

/** Low-level wrapper for `::fz_xml_find_dfs_top()`. */
FZ_FUNCTION ::fz_xml *ll_fz_xml_find_dfs_top(::fz_xml *item, const char *tag, const char *att, const char *match, ::fz_xml *top)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_find_dfs_top():";
		if (s_trace > 1) std::cerr << " item=" << item;
		if (tag) std::cerr << " tag='" << tag << "'";
		else std::cerr << " tag:null";
		if (att) std::cerr << " att='" << att << "'";
		else std::cerr << " att:null";
		if (match) std::cerr << " match='" << match << "'";
		else std::cerr << " match:null";
		if (s_trace > 1) std::cerr << " top=" << top;
		std::cerr << "\n";
	}
	#endif
	fz_xml * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_find_dfs_top(item, tag, att, match, top);
	return ret;
}

/** Low-level wrapper for `::fz_xml_find_down()`. */
FZ_FUNCTION ::fz_xml *ll_fz_xml_find_down(::fz_xml *item, const char *tag)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_find_down():";
		if (s_trace > 1) std::cerr << " item=" << item;
		if (tag) std::cerr << " tag='" << tag << "'";
		else std::cerr << " tag:null";
		std::cerr << "\n";
	}
	#endif
	fz_xml * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_find_down(item, tag);
	return ret;
}

/** Low-level wrapper for `::fz_xml_find_down_match()`. */
FZ_FUNCTION ::fz_xml *ll_fz_xml_find_down_match(::fz_xml *item, const char *tag, const char *att, const char *match)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_find_down_match():";
		if (s_trace > 1) std::cerr << " item=" << item;
		if (tag) std::cerr << " tag='" << tag << "'";
		else std::cerr << " tag:null";
		if (att) std::cerr << " att='" << att << "'";
		else std::cerr << " att:null";
		if (match) std::cerr << " match='" << match << "'";
		else std::cerr << " match:null";
		std::cerr << "\n";
	}
	#endif
	fz_xml * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_find_down_match(item, tag, att, match);
	return ret;
}

/** Low-level wrapper for `::fz_xml_find_match()`. */
FZ_FUNCTION ::fz_xml *ll_fz_xml_find_match(::fz_xml *item, const char *tag, const char *att, const char *match)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_find_match():";
		if (s_trace > 1) std::cerr << " item=" << item;
		if (tag) std::cerr << " tag='" << tag << "'";
		else std::cerr << " tag:null";
		if (att) std::cerr << " att='" << att << "'";
		else std::cerr << " att:null";
		if (match) std::cerr << " match='" << match << "'";
		else std::cerr << " match:null";
		std::cerr << "\n";
	}
	#endif
	fz_xml * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_find_match(item, tag, att, match);
	return ret;
}

/** Low-level wrapper for `::fz_xml_find_next()`. */
FZ_FUNCTION ::fz_xml *ll_fz_xml_find_next(::fz_xml *item, const char *tag)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_find_next():";
		if (s_trace > 1) std::cerr << " item=" << item;
		if (tag) std::cerr << " tag='" << tag << "'";
		else std::cerr << " tag:null";
		std::cerr << "\n";
	}
	#endif
	fz_xml * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_find_next(item, tag);
	return ret;
}

/** Low-level wrapper for `::fz_xml_find_next_dfs()`. */
FZ_FUNCTION ::fz_xml *ll_fz_xml_find_next_dfs(::fz_xml *item, const char *tag, const char *att, const char *match)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_find_next_dfs():";
		if (s_trace > 1) std::cerr << " item=" << item;
		if (tag) std::cerr << " tag='" << tag << "'";
		else std::cerr << " tag:null";
		if (att) std::cerr << " att='" << att << "'";
		else std::cerr << " att:null";
		if (match) std::cerr << " match='" << match << "'";
		else std::cerr << " match:null";
		std::cerr << "\n";
	}
	#endif
	fz_xml * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_find_next_dfs(item, tag, att, match);
	return ret;
}

/** Low-level wrapper for `::fz_xml_find_next_dfs_top()`. */
FZ_FUNCTION ::fz_xml *ll_fz_xml_find_next_dfs_top(::fz_xml *item, const char *tag, const char *att, const char *match, ::fz_xml *top)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_find_next_dfs_top():";
		if (s_trace > 1) std::cerr << " item=" << item;
		if (tag) std::cerr << " tag='" << tag << "'";
		else std::cerr << " tag:null";
		if (att) std::cerr << " att='" << att << "'";
		else std::cerr << " att:null";
		if (match) std::cerr << " match='" << match << "'";
		else std::cerr << " match:null";
		if (s_trace > 1) std::cerr << " top=" << top;
		std::cerr << "\n";
	}
	#endif
	fz_xml * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_find_next_dfs_top(item, tag, att, match, top);
	return ret;
}

/** Low-level wrapper for `::fz_xml_find_next_match()`. */
FZ_FUNCTION ::fz_xml *ll_fz_xml_find_next_match(::fz_xml *item, const char *tag, const char *att, const char *match)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_find_next_match():";
		if (s_trace > 1) std::cerr << " item=" << item;
		if (tag) std::cerr << " tag='" << tag << "'";
		else std::cerr << " tag:null";
		if (att) std::cerr << " att='" << att << "'";
		else std::cerr << " att:null";
		if (match) std::cerr << " match='" << match << "'";
		else std::cerr << " match:null";
		std::cerr << "\n";
	}
	#endif
	fz_xml * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_find_next_match(item, tag, att, match);
	return ret;
}

/** Low-level wrapper for `::fz_xml_is_tag()`. */
FZ_FUNCTION int ll_fz_xml_is_tag(::fz_xml *item, const char *name)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_is_tag():";
		if (s_trace > 1) std::cerr << " item=" << item;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_is_tag(item, name);
	return ret;
}

/** Low-level wrapper for `::fz_xml_next()`. */
FZ_FUNCTION ::fz_xml *ll_fz_xml_next(::fz_xml *item)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_next():";
		if (s_trace > 1) std::cerr << " item=" << item;
		std::cerr << "\n";
	}
	#endif
	fz_xml * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_next(item);
	return ret;
}

/** Low-level wrapper for `::fz_xml_prev()`. */
FZ_FUNCTION ::fz_xml *ll_fz_xml_prev(::fz_xml *item)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_prev():";
		if (s_trace > 1) std::cerr << " item=" << item;
		std::cerr << "\n";
	}
	#endif
	fz_xml * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_prev(item);
	return ret;
}

/** Low-level wrapper for `::fz_xml_root()`. */
FZ_FUNCTION ::fz_xml *ll_fz_xml_root(::fz_xml_doc *xml)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_root():";
		if (s_trace > 1) std::cerr << " xml=" << xml;
		std::cerr << "\n";
	}
	#endif
	fz_xml * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_root(xml);
	return ret;
}

/** Low-level wrapper for `::fz_xml_tag()`. */
FZ_FUNCTION char *ll_fz_xml_tag(::fz_xml *item)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_tag():";
		if (s_trace > 1) std::cerr << " item=" << item;
		std::cerr << "\n";
	}
	#endif
	char * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_tag(item);
	return ret;
}

/** Low-level wrapper for `::fz_xml_text()`. */
FZ_FUNCTION char *ll_fz_xml_text(::fz_xml *item)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_text():";
		if (s_trace > 1) std::cerr << " item=" << item;
		std::cerr << "\n";
	}
	#endif
	char * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_text(item);
	return ret;
}

/** Low-level wrapper for `::fz_xml_up()`. */
FZ_FUNCTION ::fz_xml *ll_fz_xml_up(::fz_xml *item)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling fz_xml_up():";
		if (s_trace > 1) std::cerr << " item=" << item;
		std::cerr << "\n";
	}
	#endif
	fz_xml * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::fz_xml_up(item);
	return ret;
}

/** Low-level wrapper for `::pdf_abandon_operation()`. */
FZ_FUNCTION void ll_pdf_abandon_operation(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_abandon_operation():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_abandon_operation(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_abandon_operation(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_access_alert_event()`. */
FZ_FUNCTION ::pdf_alert_event *ll_pdf_access_alert_event(::pdf_doc_event *evt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_access_alert_event():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " evt=" << evt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_alert_event * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_access_alert_event(auto_ctx, evt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_access_alert_event(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_access_exec_menu_item_event()`. */
FZ_FUNCTION const char *ll_pdf_access_exec_menu_item_event(::pdf_doc_event *evt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_access_exec_menu_item_event():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " evt=" << evt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_access_exec_menu_item_event(auto_ctx, evt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_access_exec_menu_item_event(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_access_launch_url_event()`. */
FZ_FUNCTION ::pdf_launch_url_event *ll_pdf_access_launch_url_event(::pdf_doc_event *evt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_access_launch_url_event():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " evt=" << evt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_launch_url_event * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_access_launch_url_event(auto_ctx, evt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_access_launch_url_event(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_access_mail_doc_event()`. */
FZ_FUNCTION ::pdf_mail_doc_event *ll_pdf_access_mail_doc_event(::pdf_doc_event *evt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_access_mail_doc_event():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " evt=" << evt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_mail_doc_event * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_access_mail_doc_event(auto_ctx, evt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_access_mail_doc_event(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_add_annot_border_dash_item()`. */
FZ_FUNCTION void ll_pdf_add_annot_border_dash_item(::pdf_annot *annot, float length)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_annot_border_dash_item():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " length=" << length;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_add_annot_border_dash_item(auto_ctx, annot, length);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_annot_border_dash_item(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_add_annot_ink_list()`. */
FZ_FUNCTION void ll_pdf_add_annot_ink_list(::pdf_annot *annot, int n, ::fz_point stroke[])
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_annot_ink_list():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " n=" << n;
		std::cerr << " stroke=" << stroke;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_add_annot_ink_list(auto_ctx, annot, n, stroke);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_annot_ink_list(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_add_annot_ink_list_stroke()`. */
FZ_FUNCTION void ll_pdf_add_annot_ink_list_stroke(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_annot_ink_list_stroke():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_add_annot_ink_list_stroke(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_annot_ink_list_stroke(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_add_annot_ink_list_stroke_vertex()`. */
FZ_FUNCTION void ll_pdf_add_annot_ink_list_stroke_vertex(::pdf_annot *annot, ::fz_point p)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_annot_ink_list_stroke_vertex():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " p=" << p;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_add_annot_ink_list_stroke_vertex(auto_ctx, annot, p);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_annot_ink_list_stroke_vertex(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_add_annot_quad_point()`. */
FZ_FUNCTION void ll_pdf_add_annot_quad_point(::pdf_annot *annot, ::fz_quad quad)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_annot_quad_point():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " quad=" << quad;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_add_annot_quad_point(auto_ctx, annot, quad);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_annot_quad_point(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_add_annot_vertex()`. */
FZ_FUNCTION void ll_pdf_add_annot_vertex(::pdf_annot *annot, ::fz_point p)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_annot_vertex():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " p=" << p;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_add_annot_vertex(auto_ctx, annot, p);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_annot_vertex(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_add_cid_font()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_add_cid_font(::pdf_document *doc, ::fz_font *font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_cid_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_add_cid_font(auto_ctx, doc, font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_cid_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_add_cjk_font()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_add_cjk_font(::pdf_document *doc, ::fz_font *font, int script, int wmode, int serif)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_cjk_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " script=" << script;
		std::cerr << " wmode=" << wmode;
		std::cerr << " serif=" << serif;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_add_cjk_font(auto_ctx, doc, font, script, wmode, serif);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_cjk_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_add_codespace()`. */
FZ_FUNCTION void ll_pdf_add_codespace(::pdf_cmap *cmap, unsigned int low, unsigned int high, size_t n)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_codespace():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cmap=" << cmap;
		std::cerr << " low=" << low;
		std::cerr << " high=" << high;
		std::cerr << " n=" << n;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_add_codespace(auto_ctx, cmap, low, high, n);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_codespace(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_add_embedded_file()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_add_embedded_file(::pdf_document *doc, const char *filename, const char *mimetype, ::fz_buffer *contents, int64_t created, int64_t modifed, int add_checksum)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_embedded_file():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		if (mimetype) std::cerr << " mimetype='" << mimetype << "'";
		else std::cerr << " mimetype:null";
		if (s_trace > 1) std::cerr << " contents=" << contents;
		std::cerr << " created=" << created;
		std::cerr << " modifed=" << modifed;
		std::cerr << " add_checksum=" << add_checksum;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_add_embedded_file(auto_ctx, doc, filename, mimetype, contents, created, modifed, add_checksum);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_embedded_file(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_add_hmtx()`. */
FZ_FUNCTION void ll_pdf_add_hmtx(::pdf_font_desc *font, int lo, int hi, int w)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_hmtx():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " lo=" << lo;
		std::cerr << " hi=" << hi;
		std::cerr << " w=" << w;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_add_hmtx(auto_ctx, font, lo, hi, w);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_hmtx(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_add_image()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_add_image(::pdf_document *doc, ::fz_image *image)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_image():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_add_image(auto_ctx, doc, image);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_image(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_add_journal_fragment()`. */
FZ_FUNCTION void ll_pdf_add_journal_fragment(::pdf_document *doc, int parent, ::pdf_obj *copy, ::fz_buffer *copy_stream, int newobj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_journal_fragment():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " parent=" << parent;
		if (s_trace > 1) std::cerr << " copy=" << copy;
		if (s_trace > 1) std::cerr << " copy_stream=" << copy_stream;
		std::cerr << " newobj=" << newobj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_add_journal_fragment(auto_ctx, doc, parent, copy, copy_stream, newobj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_journal_fragment(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_add_new_array()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_add_new_array(::pdf_document *doc, int initial)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_new_array():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " initial=" << initial;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_add_new_array(auto_ctx, doc, initial);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_new_array(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_add_new_dict()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_add_new_dict(::pdf_document *doc, int initial)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_new_dict():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " initial=" << initial;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_add_new_dict(auto_ctx, doc, initial);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_new_dict(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_add_object()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_add_object(::pdf_document *doc, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_object():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_add_object(auto_ctx, doc, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_object(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_add_object_drop()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_add_object_drop(::pdf_document *doc, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_object_drop():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_add_object_drop(auto_ctx, doc, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_object_drop(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_add_page()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_add_page(::pdf_document *doc, ::fz_rect mediabox, int rotate, ::pdf_obj *resources, ::fz_buffer *contents)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " mediabox=" << mediabox;
		std::cerr << " rotate=" << rotate;
		if (s_trace > 1) std::cerr << " resources=" << resources;
		if (s_trace > 1) std::cerr << " contents=" << contents;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_add_page(auto_ctx, doc, mediabox, rotate, resources, contents);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_add_simple_font()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_add_simple_font(::pdf_document *doc, ::fz_font *font, int encoding)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_simple_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " encoding=" << encoding;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_add_simple_font(auto_ctx, doc, font, encoding);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_simple_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_add_stream()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_add_stream(::pdf_document *doc, ::fz_buffer *buf, ::pdf_obj *obj, int compressed)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << " compressed=" << compressed;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_add_stream(auto_ctx, doc, buf, obj, compressed);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_add_substitute_font()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_add_substitute_font(::pdf_document *doc, ::fz_font *font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_substitute_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_add_substitute_font(auto_ctx, doc, font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_substitute_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_add_vmtx()`. */
FZ_FUNCTION void ll_pdf_add_vmtx(::pdf_font_desc *font, int lo, int hi, int x, int y, int w)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_add_vmtx():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " lo=" << lo;
		std::cerr << " hi=" << hi;
		std::cerr << " x=" << x;
		std::cerr << " y=" << y;
		std::cerr << " w=" << w;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_add_vmtx(auto_ctx, font, lo, hi, x, y, w);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_add_vmtx(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_MK_BC()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_annot_MK_BC(::pdf_annot *annot, float color[4])` => int n
*/
FZ_FUNCTION void ll_pdf_annot_MK_BC(::pdf_annot *annot, int *n, float color[4])
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_MK_BC():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		if (s_trace > 1) std::cerr << " n=" << (void*) n;
		std::cerr << " color=" << color;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_MK_BC(auto_ctx, annot, n, color);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_MK_BC(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_MK_BC_rgb()`. */
FZ_FUNCTION int ll_pdf_annot_MK_BC_rgb(::pdf_annot *annot, float rgb[3])
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_MK_BC_rgb():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " rgb=" << rgb;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_MK_BC_rgb(auto_ctx, annot, rgb);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_MK_BC_rgb(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_MK_BG()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_annot_MK_BG(::pdf_annot *annot, float color[4])` => int n
*/
FZ_FUNCTION void ll_pdf_annot_MK_BG(::pdf_annot *annot, int *n, float color[4])
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_MK_BG():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		if (s_trace > 1) std::cerr << " n=" << (void*) n;
		std::cerr << " color=" << color;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_MK_BG(auto_ctx, annot, n, color);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_MK_BG(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_MK_BG_rgb()`. */
FZ_FUNCTION int ll_pdf_annot_MK_BG_rgb(::pdf_annot *annot, float rgb[3])
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_MK_BG_rgb():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " rgb=" << rgb;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_MK_BG_rgb(auto_ctx, annot, rgb);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_MK_BG_rgb(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_active()`. */
FZ_FUNCTION int ll_pdf_annot_active(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_active():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_active(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_active(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_ap()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_annot_ap(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_ap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_ap(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_ap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_author()`. */
FZ_FUNCTION const char *ll_pdf_annot_author(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_author():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_author(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_author(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_border()`. */
FZ_FUNCTION float ll_pdf_annot_border(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_border():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	float ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_border(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_border(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_border_dash_count()`. */
FZ_FUNCTION int ll_pdf_annot_border_dash_count(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_border_dash_count():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_border_dash_count(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_border_dash_count(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_border_dash_item()`. */
FZ_FUNCTION float ll_pdf_annot_border_dash_item(::pdf_annot *annot, int i)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_border_dash_item():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " i=" << i;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	float ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_border_dash_item(auto_ctx, annot, i);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_border_dash_item(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_border_effect()`. */
FZ_FUNCTION enum pdf_border_effect ll_pdf_annot_border_effect(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_border_effect():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	enum pdf_border_effect ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_border_effect(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_border_effect(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_border_effect_intensity()`. */
FZ_FUNCTION float ll_pdf_annot_border_effect_intensity(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_border_effect_intensity():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	float ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_border_effect_intensity(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_border_effect_intensity(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_border_style()`. */
FZ_FUNCTION enum pdf_border_style ll_pdf_annot_border_style(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_border_style():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	enum pdf_border_style ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_border_style(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_border_style(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_border_width()`. */
FZ_FUNCTION float ll_pdf_annot_border_width(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_border_width():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	float ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_border_width(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_border_width(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_color()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_annot_color(::pdf_annot *annot, float color[4])` => int n
*/
FZ_FUNCTION void ll_pdf_annot_color(::pdf_annot *annot, int *n, float color[4])
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_color():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		if (s_trace > 1) std::cerr << " n=" << (void*) n;
		std::cerr << " color=" << color;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_color(auto_ctx, annot, n, color);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_color(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_contents()`. */
FZ_FUNCTION const char *ll_pdf_annot_contents(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_contents():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_contents(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_contents(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_creation_date()`. */
FZ_FUNCTION int64_t ll_pdf_annot_creation_date(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_creation_date():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int64_t ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_creation_date(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_creation_date(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_default_appearance()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_annot_default_appearance(::pdf_annot *annot, float color[4])` => `(const char *font, float size, int n)`
*/
FZ_FUNCTION void ll_pdf_annot_default_appearance(::pdf_annot *annot, const char **font, float *size, int *n, float color[4])
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_default_appearance():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		if (s_trace > 1) std::cerr << " font=" << (void*) font;
		if (s_trace > 1) std::cerr << " size=" << (void*) size;
		if (s_trace > 1) std::cerr << " n=" << (void*) n;
		std::cerr << " color=" << color;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_default_appearance(auto_ctx, annot, font, size, n, color);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_default_appearance(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_ensure_local_xref()`. */
FZ_FUNCTION void ll_pdf_annot_ensure_local_xref(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_ensure_local_xref():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_ensure_local_xref(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_ensure_local_xref(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_event_blur()`. */
FZ_FUNCTION void ll_pdf_annot_event_blur(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_event_blur():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_event_blur(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_event_blur(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_event_down()`. */
FZ_FUNCTION void ll_pdf_annot_event_down(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_event_down():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_event_down(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_event_down(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_event_enter()`. */
FZ_FUNCTION void ll_pdf_annot_event_enter(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_event_enter():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_event_enter(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_event_enter(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_event_exit()`. */
FZ_FUNCTION void ll_pdf_annot_event_exit(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_event_exit():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_event_exit(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_event_exit(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_event_focus()`. */
FZ_FUNCTION void ll_pdf_annot_event_focus(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_event_focus():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_event_focus(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_event_focus(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_event_page_close()`. */
FZ_FUNCTION void ll_pdf_annot_event_page_close(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_event_page_close():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_event_page_close(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_event_page_close(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_event_page_invisible()`. */
FZ_FUNCTION void ll_pdf_annot_event_page_invisible(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_event_page_invisible():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_event_page_invisible(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_event_page_invisible(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_event_page_open()`. */
FZ_FUNCTION void ll_pdf_annot_event_page_open(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_event_page_open():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_event_page_open(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_event_page_open(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_event_page_visible()`. */
FZ_FUNCTION void ll_pdf_annot_event_page_visible(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_event_page_visible():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_event_page_visible(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_event_page_visible(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_event_up()`. */
FZ_FUNCTION void ll_pdf_annot_event_up(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_event_up():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_event_up(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_event_up(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_field_event_keystroke()`. */
FZ_FUNCTION int ll_pdf_annot_field_event_keystroke(::pdf_document *doc, ::pdf_annot *annot, ::pdf_keystroke_event *evt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_field_event_keystroke():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		if (s_trace > 1) std::cerr << " evt=" << evt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_field_event_keystroke(auto_ctx, doc, annot, evt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_field_event_keystroke(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_field_flags()`. */
FZ_FUNCTION int ll_pdf_annot_field_flags(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_field_flags():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_field_flags(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_field_flags(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_field_label()`. */
FZ_FUNCTION const char *ll_pdf_annot_field_label(::pdf_annot *widget)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_field_label():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " widget=" << widget;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_field_label(auto_ctx, widget);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_field_label(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_field_value()`. */
FZ_FUNCTION const char *ll_pdf_annot_field_value(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_field_value():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_field_value(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_field_value(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_filespec()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_annot_filespec(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_filespec():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_filespec(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_filespec(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_flags()`. */
FZ_FUNCTION int ll_pdf_annot_flags(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_flags():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_flags(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_flags(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_has_author()`. */
FZ_FUNCTION int ll_pdf_annot_has_author(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_has_author():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_has_author(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_has_author(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_has_border()`. */
FZ_FUNCTION int ll_pdf_annot_has_border(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_has_border():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_has_border(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_has_border(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_has_border_effect()`. */
FZ_FUNCTION int ll_pdf_annot_has_border_effect(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_has_border_effect():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_has_border_effect(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_has_border_effect(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_has_filespec()`. */
FZ_FUNCTION int ll_pdf_annot_has_filespec(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_has_filespec():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_has_filespec(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_has_filespec(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_has_icon_name()`. */
FZ_FUNCTION int ll_pdf_annot_has_icon_name(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_has_icon_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_has_icon_name(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_has_icon_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_has_ink_list()`. */
FZ_FUNCTION int ll_pdf_annot_has_ink_list(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_has_ink_list():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_has_ink_list(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_has_ink_list(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_has_intent()`. */
FZ_FUNCTION int ll_pdf_annot_has_intent(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_has_intent():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_has_intent(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_has_intent(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_has_interior_color()`. */
FZ_FUNCTION int ll_pdf_annot_has_interior_color(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_has_interior_color():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_has_interior_color(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_has_interior_color(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_has_line()`. */
FZ_FUNCTION int ll_pdf_annot_has_line(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_has_line():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_has_line(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_has_line(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_has_line_ending_styles()`. */
FZ_FUNCTION int ll_pdf_annot_has_line_ending_styles(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_has_line_ending_styles():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_has_line_ending_styles(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_has_line_ending_styles(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_has_open()`. */
FZ_FUNCTION int ll_pdf_annot_has_open(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_has_open():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_has_open(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_has_open(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_has_quad_points()`. */
FZ_FUNCTION int ll_pdf_annot_has_quad_points(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_has_quad_points():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_has_quad_points(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_has_quad_points(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_has_quadding()`. */
FZ_FUNCTION int ll_pdf_annot_has_quadding(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_has_quadding():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_has_quadding(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_has_quadding(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_has_rect()`. */
FZ_FUNCTION int ll_pdf_annot_has_rect(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_has_rect():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_has_rect(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_has_rect(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_has_vertices()`. */
FZ_FUNCTION int ll_pdf_annot_has_vertices(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_has_vertices():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_has_vertices(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_has_vertices(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_hidden_for_editing()`. */
FZ_FUNCTION int ll_pdf_annot_hidden_for_editing(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_hidden_for_editing():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_hidden_for_editing(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_hidden_for_editing(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_hot()`. */
FZ_FUNCTION int ll_pdf_annot_hot(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_hot():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_hot(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_hot(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_icon_name()`. */
FZ_FUNCTION const char *ll_pdf_annot_icon_name(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_icon_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_icon_name(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_icon_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_ink_list_count()`. */
FZ_FUNCTION int ll_pdf_annot_ink_list_count(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_ink_list_count():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_ink_list_count(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_ink_list_count(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_ink_list_stroke_count()`. */
FZ_FUNCTION int ll_pdf_annot_ink_list_stroke_count(::pdf_annot *annot, int i)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_ink_list_stroke_count():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " i=" << i;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_ink_list_stroke_count(auto_ctx, annot, i);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_ink_list_stroke_count(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_ink_list_stroke_vertex()`. */
FZ_FUNCTION ::fz_point ll_pdf_annot_ink_list_stroke_vertex(::pdf_annot *annot, int i, int k)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_ink_list_stroke_vertex():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " i=" << i;
		std::cerr << " k=" << k;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_point ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_ink_list_stroke_vertex(auto_ctx, annot, i, k);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_ink_list_stroke_vertex(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_intent()`. */
FZ_FUNCTION enum pdf_intent ll_pdf_annot_intent(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_intent():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	enum pdf_intent ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_intent(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_intent(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_interior_color()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_annot_interior_color(::pdf_annot *annot, float color[4])` => int n
*/
FZ_FUNCTION void ll_pdf_annot_interior_color(::pdf_annot *annot, int *n, float color[4])
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_interior_color():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		if (s_trace > 1) std::cerr << " n=" << (void*) n;
		std::cerr << " color=" << color;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_interior_color(auto_ctx, annot, n, color);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_interior_color(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_is_open()`. */
FZ_FUNCTION int ll_pdf_annot_is_open(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_is_open():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_is_open(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_is_open(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_is_standard_stamp()`. */
FZ_FUNCTION int ll_pdf_annot_is_standard_stamp(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_is_standard_stamp():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_is_standard_stamp(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_is_standard_stamp(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_language()`. */
FZ_FUNCTION ::fz_text_language ll_pdf_annot_language(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_language():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_text_language ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_language(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_language(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_line()`. */
FZ_FUNCTION void ll_pdf_annot_line(::pdf_annot *annot, ::fz_point *a, ::fz_point *b)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_line():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_line(auto_ctx, annot, a, b);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_line(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_line_end_style()`. */
FZ_FUNCTION enum pdf_line_ending ll_pdf_annot_line_end_style(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_line_end_style():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	enum pdf_line_ending ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_line_end_style(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_line_end_style(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_line_ending_styles()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_annot_line_ending_styles(::pdf_annot *annot)` => `(enum pdf_line_ending start_style, enum pdf_line_ending end_style)`
*/
FZ_FUNCTION void ll_pdf_annot_line_ending_styles(::pdf_annot *annot, enum pdf_line_ending *start_style, enum pdf_line_ending *end_style)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_line_ending_styles():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		if (s_trace > 1) std::cerr << " start_style=" << (void*) start_style;
		if (s_trace > 1) std::cerr << " end_style=" << (void*) end_style;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_line_ending_styles(auto_ctx, annot, start_style, end_style);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_line_ending_styles(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_line_start_style()`. */
FZ_FUNCTION enum pdf_line_ending ll_pdf_annot_line_start_style(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_line_start_style():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	enum pdf_line_ending ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_line_start_style(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_line_start_style(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_modification_date()`. */
FZ_FUNCTION int64_t ll_pdf_annot_modification_date(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_modification_date():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int64_t ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_modification_date(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_modification_date(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_needs_resynthesis()`. */
FZ_FUNCTION int ll_pdf_annot_needs_resynthesis(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_needs_resynthesis():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_needs_resynthesis(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_needs_resynthesis(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_obj()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_annot_obj(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_obj():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_obj(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_opacity()`. */
FZ_FUNCTION float ll_pdf_annot_opacity(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_opacity():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	float ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_opacity(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_opacity(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_page()`. */
FZ_FUNCTION ::pdf_page *ll_pdf_annot_page(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_page * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_page(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_pop_and_discard_local_xref()`. */
FZ_FUNCTION void ll_pdf_annot_pop_and_discard_local_xref(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_pop_and_discard_local_xref():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_pop_and_discard_local_xref(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_pop_and_discard_local_xref(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_pop_local_xref()`. */
FZ_FUNCTION void ll_pdf_annot_pop_local_xref(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_pop_local_xref():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_pop_local_xref(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_pop_local_xref(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_popup()`. */
FZ_FUNCTION ::fz_rect ll_pdf_annot_popup(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_popup():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_rect ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_popup(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_popup(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_push_local_xref()`. */
FZ_FUNCTION void ll_pdf_annot_push_local_xref(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_push_local_xref():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_push_local_xref(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_push_local_xref(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_quad_point()`. */
FZ_FUNCTION ::fz_quad ll_pdf_annot_quad_point(::pdf_annot *annot, int i)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_quad_point():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " i=" << i;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_quad ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_quad_point(auto_ctx, annot, i);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_quad_point(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_quad_point_count()`. */
FZ_FUNCTION int ll_pdf_annot_quad_point_count(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_quad_point_count():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_quad_point_count(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_quad_point_count(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_quadding()`. */
FZ_FUNCTION int ll_pdf_annot_quadding(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_quadding():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_quadding(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_quadding(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_rect()`. */
FZ_FUNCTION ::fz_rect ll_pdf_annot_rect(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_rect():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_rect ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_rect(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_rect(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_request_resynthesis()`. */
FZ_FUNCTION void ll_pdf_annot_request_resynthesis(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_request_resynthesis():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_request_resynthesis(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_request_resynthesis(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_request_synthesis()`. */
FZ_FUNCTION void ll_pdf_annot_request_synthesis(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_request_synthesis():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_annot_request_synthesis(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_request_synthesis(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_annot_transform()`. */
FZ_FUNCTION ::fz_matrix ll_pdf_annot_transform(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_transform():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_matrix ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_transform(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_transform(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_type()`. */
FZ_FUNCTION enum pdf_annot_type ll_pdf_annot_type(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_type():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	enum pdf_annot_type ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_type(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_type(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_type_from_string()`. */
FZ_FUNCTION enum pdf_annot_type ll_pdf_annot_type_from_string(const char *subtype)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_type_from_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (subtype) std::cerr << " subtype='" << subtype << "'";
		else std::cerr << " subtype:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	enum pdf_annot_type ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_type_from_string(auto_ctx, subtype);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_type_from_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_vertex()`. */
FZ_FUNCTION ::fz_point ll_pdf_annot_vertex(::pdf_annot *annot, int i)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_vertex():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " i=" << i;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_point ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_vertex(auto_ctx, annot, i);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_vertex(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_annot_vertex_count()`. */
FZ_FUNCTION int ll_pdf_annot_vertex_count(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_annot_vertex_count():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_annot_vertex_count(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_annot_vertex_count(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_append_explicit_dest_to_uri()`. */
FZ_FUNCTION char *ll_pdf_append_explicit_dest_to_uri(const char *url, ::fz_link_dest dest)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_append_explicit_dest_to_uri():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (url) std::cerr << " url='" << url << "'";
		else std::cerr << " url:null";
		std::cerr << " &dest=" << &dest;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_append_explicit_dest_to_uri(auto_ctx, url, dest);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_append_explicit_dest_to_uri(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_append_named_dest_to_uri()`. */
FZ_FUNCTION char *ll_pdf_append_named_dest_to_uri(const char *url, const char *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_append_named_dest_to_uri():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (url) std::cerr << " url='" << url << "'";
		else std::cerr << " url:null";
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_append_named_dest_to_uri(auto_ctx, url, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_append_named_dest_to_uri(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_append_token()`. */
FZ_FUNCTION void ll_pdf_append_token(::fz_buffer *buf, int tok, ::pdf_lexbuf *lex)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_append_token():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << " tok=" << tok;
		if (s_trace > 1) std::cerr << " lex=" << lex;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_append_token(auto_ctx, buf, tok, lex);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_append_token(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_apply_redaction()`. */
FZ_FUNCTION int ll_pdf_apply_redaction(::pdf_annot *annot, ::pdf_redact_options *opts)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_apply_redaction():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " opts=" << opts;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_apply_redaction(auto_ctx, annot, opts);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_apply_redaction(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_array_contains()`. */
FZ_FUNCTION int ll_pdf_array_contains(::pdf_obj *array, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_contains():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_array_contains(auto_ctx, array, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_contains(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_array_delete()`. */
FZ_FUNCTION void ll_pdf_array_delete(::pdf_obj *array, int index)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_delete():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " index=" << index;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_array_delete(auto_ctx, array, index);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_delete(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_array_find()`. */
FZ_FUNCTION int ll_pdf_array_find(::pdf_obj *array, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_find():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_array_find(auto_ctx, array, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_find(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_array_get()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_array_get(::pdf_obj *array, int i)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_get():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " i=" << i;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_array_get(auto_ctx, array, i);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_get(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_array_get_bool()`. */
FZ_FUNCTION int ll_pdf_array_get_bool(::pdf_obj *array, int index)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_get_bool():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " index=" << index;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_array_get_bool(auto_ctx, array, index);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_get_bool(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_array_get_int()`. */
FZ_FUNCTION int ll_pdf_array_get_int(::pdf_obj *array, int index)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_get_int():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " index=" << index;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_array_get_int(auto_ctx, array, index);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_get_int(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_array_get_matrix()`. */
FZ_FUNCTION ::fz_matrix ll_pdf_array_get_matrix(::pdf_obj *array, int index)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_get_matrix():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " index=" << index;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_matrix ret;
	fz_try(auto_ctx) {
		ret = ::pdf_array_get_matrix(auto_ctx, array, index);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_get_matrix(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_array_get_name()`. */
FZ_FUNCTION const char *ll_pdf_array_get_name(::pdf_obj *array, int index)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_get_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " index=" << index;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_array_get_name(auto_ctx, array, index);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_get_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_array_get_real()`. */
FZ_FUNCTION float ll_pdf_array_get_real(::pdf_obj *array, int index)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_get_real():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " index=" << index;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	float ret;
	fz_try(auto_ctx) {
		ret = ::pdf_array_get_real(auto_ctx, array, index);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_get_real(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_array_get_rect()`. */
FZ_FUNCTION ::fz_rect ll_pdf_array_get_rect(::pdf_obj *array, int index)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_get_rect():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " index=" << index;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_rect ret;
	fz_try(auto_ctx) {
		ret = ::pdf_array_get_rect(auto_ctx, array, index);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_get_rect(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_array_get_string()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_array_get_string(::pdf_obj *array, int index)` => `(const char *, size_t sizep)`
*/
FZ_FUNCTION const char *ll_pdf_array_get_string(::pdf_obj *array, int index, size_t *sizep)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_get_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " index=" << index;
		if (s_trace > 1) std::cerr << " sizep=" << (void*) sizep;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_array_get_string(auto_ctx, array, index, sizep);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_get_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_array_get_text_string()`. */
FZ_FUNCTION const char *ll_pdf_array_get_text_string(::pdf_obj *array, int index)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_get_text_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " index=" << index;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_array_get_text_string(auto_ctx, array, index);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_get_text_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_array_insert()`. */
FZ_FUNCTION void ll_pdf_array_insert(::pdf_obj *array, ::pdf_obj *obj, int index)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_insert():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << " index=" << index;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_array_insert(auto_ctx, array, obj, index);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_insert(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_array_insert_drop()`. */
FZ_FUNCTION void ll_pdf_array_insert_drop(::pdf_obj *array, ::pdf_obj *obj, int index)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_insert_drop():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << " index=" << index;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_array_insert_drop(auto_ctx, array, obj, index);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_insert_drop(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_array_len()`. */
FZ_FUNCTION int ll_pdf_array_len(::pdf_obj *array)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_len():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_array_len(auto_ctx, array);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_len(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_array_push()`. */
FZ_FUNCTION void ll_pdf_array_push(::pdf_obj *array, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_push():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_array_push(auto_ctx, array, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_push(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_array_push_array()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_array_push_array(::pdf_obj *array, int initial)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_push_array():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " initial=" << initial;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_array_push_array(auto_ctx, array, initial);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_push_array(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_array_push_bool()`. */
FZ_FUNCTION void ll_pdf_array_push_bool(::pdf_obj *array, int x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_push_bool():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_array_push_bool(auto_ctx, array, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_push_bool(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_array_push_dict()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_array_push_dict(::pdf_obj *array, int initial)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_push_dict():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " initial=" << initial;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_array_push_dict(auto_ctx, array, initial);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_push_dict(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_array_push_drop()`. */
FZ_FUNCTION void ll_pdf_array_push_drop(::pdf_obj *array, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_push_drop():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_array_push_drop(auto_ctx, array, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_push_drop(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_array_push_int()`. */
FZ_FUNCTION void ll_pdf_array_push_int(::pdf_obj *array, int64_t x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_push_int():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_array_push_int(auto_ctx, array, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_push_int(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_array_push_name()`. */
FZ_FUNCTION void ll_pdf_array_push_name(::pdf_obj *array, const char *x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_push_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		if (x) std::cerr << " x='" << x << "'";
		else std::cerr << " x:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_array_push_name(auto_ctx, array, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_push_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_array_push_real()`. */
FZ_FUNCTION void ll_pdf_array_push_real(::pdf_obj *array, double x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_push_real():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_array_push_real(auto_ctx, array, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_push_real(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_array_push_string()`. */
FZ_FUNCTION void ll_pdf_array_push_string(::pdf_obj *array, const char *x, size_t n)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_push_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		if (x) std::cerr << " x='" << x << "'";
		else std::cerr << " x:null";
		std::cerr << " n=" << n;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_array_push_string(auto_ctx, array, x, n);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_push_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_array_push_text_string()`. */
FZ_FUNCTION void ll_pdf_array_push_text_string(::pdf_obj *array, const char *x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_push_text_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		if (x) std::cerr << " x='" << x << "'";
		else std::cerr << " x:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_array_push_text_string(auto_ctx, array, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_push_text_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_array_put()`. */
FZ_FUNCTION void ll_pdf_array_put(::pdf_obj *array, int i, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_put():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " i=" << i;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_array_put(auto_ctx, array, i, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_put(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_array_put_array()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_array_put_array(::pdf_obj *array, int i, int initial)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_put_array():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " i=" << i;
		std::cerr << " initial=" << initial;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_array_put_array(auto_ctx, array, i, initial);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_put_array(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_array_put_bool()`. */
FZ_FUNCTION void ll_pdf_array_put_bool(::pdf_obj *array, int i, int x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_put_bool():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " i=" << i;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_array_put_bool(auto_ctx, array, i, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_put_bool(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_array_put_dict()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_array_put_dict(::pdf_obj *array, int i, int initial)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_put_dict():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " i=" << i;
		std::cerr << " initial=" << initial;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_array_put_dict(auto_ctx, array, i, initial);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_put_dict(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_array_put_drop()`. */
FZ_FUNCTION void ll_pdf_array_put_drop(::pdf_obj *array, int i, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_put_drop():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " i=" << i;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_array_put_drop(auto_ctx, array, i, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_put_drop(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_array_put_int()`. */
FZ_FUNCTION void ll_pdf_array_put_int(::pdf_obj *array, int i, int64_t x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_put_int():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " i=" << i;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_array_put_int(auto_ctx, array, i, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_put_int(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_array_put_name()`. */
FZ_FUNCTION void ll_pdf_array_put_name(::pdf_obj *array, int i, const char *x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_put_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " i=" << i;
		if (x) std::cerr << " x='" << x << "'";
		else std::cerr << " x:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_array_put_name(auto_ctx, array, i, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_put_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_array_put_real()`. */
FZ_FUNCTION void ll_pdf_array_put_real(::pdf_obj *array, int i, double x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_put_real():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " i=" << i;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_array_put_real(auto_ctx, array, i, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_put_real(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_array_put_string()`. */
FZ_FUNCTION void ll_pdf_array_put_string(::pdf_obj *array, int i, const char *x, size_t n)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_put_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " i=" << i;
		if (x) std::cerr << " x='" << x << "'";
		else std::cerr << " x:null";
		std::cerr << " n=" << n;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_array_put_string(auto_ctx, array, i, x, n);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_put_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_array_put_text_string()`. */
FZ_FUNCTION void ll_pdf_array_put_text_string(::pdf_obj *array, int i, const char *x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_array_put_text_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " i=" << i;
		if (x) std::cerr << " x='" << x << "'";
		else std::cerr << " x:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_array_put_text_string(auto_ctx, array, i, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_array_put_text_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_authenticate_password()`. */
FZ_FUNCTION int ll_pdf_authenticate_password(::pdf_document *doc, const char *pw)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_authenticate_password():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (pw) std::cerr << " pw='" << pw << "'";
		else std::cerr << " pw:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_authenticate_password(auto_ctx, doc, pw);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_authenticate_password(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_bake_document()`. */
FZ_FUNCTION void ll_pdf_bake_document(::pdf_document *doc, int bake_annots, int bake_widgets)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_bake_document():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " bake_annots=" << bake_annots;
		std::cerr << " bake_widgets=" << bake_widgets;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_bake_document(auto_ctx, doc, bake_annots, bake_widgets);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_bake_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_begin_implicit_operation()`. */
FZ_FUNCTION void ll_pdf_begin_implicit_operation(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_begin_implicit_operation():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_begin_implicit_operation(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_begin_implicit_operation(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_begin_operation()`. */
FZ_FUNCTION void ll_pdf_begin_operation(::pdf_document *doc, const char *operation)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_begin_operation():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (operation) std::cerr << " operation='" << operation << "'";
		else std::cerr << " operation:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_begin_operation(auto_ctx, doc, operation);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_begin_operation(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_bound_annot()`. */
FZ_FUNCTION ::fz_rect ll_pdf_bound_annot(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_bound_annot():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_rect ret;
	fz_try(auto_ctx) {
		ret = ::pdf_bound_annot(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_bound_annot(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_bound_page()`. */
FZ_FUNCTION ::fz_rect ll_pdf_bound_page(::pdf_page *page, ::fz_box_type box)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_bound_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " box=" << box;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_rect ret;
	fz_try(auto_ctx) {
		ret = ::pdf_bound_page(auto_ctx, page, box);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_bound_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_bound_widget()`. */
FZ_FUNCTION ::fz_rect ll_pdf_bound_widget(::pdf_annot *widget)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_bound_widget():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " widget=" << widget;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_rect ret;
	fz_try(auto_ctx) {
		ret = ::pdf_bound_widget(auto_ctx, widget);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_bound_widget(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_button_field_on_state()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_button_field_on_state(::pdf_obj *field)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_button_field_on_state():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " field=" << field;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_button_field_on_state(auto_ctx, field);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_button_field_on_state(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_cache_object()`. */
FZ_FUNCTION ::pdf_xref_entry *ll_pdf_cache_object(::pdf_document *doc, int num)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_cache_object():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " num=" << num;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_xref_entry * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_cache_object(auto_ctx, doc, num);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_cache_object(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_calculate_form()`. */
FZ_FUNCTION void ll_pdf_calculate_form(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_calculate_form():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_calculate_form(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_calculate_form(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_can_be_saved_incrementally()`. */
FZ_FUNCTION int ll_pdf_can_be_saved_incrementally(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_can_be_saved_incrementally():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_can_be_saved_incrementally(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_can_be_saved_incrementally(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_can_redo()`. */
FZ_FUNCTION int ll_pdf_can_redo(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_can_redo():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_can_redo(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_can_redo(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_can_undo()`. */
FZ_FUNCTION int ll_pdf_can_undo(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_can_undo():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_can_undo(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_can_undo(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_check_certificate()`. */
FZ_FUNCTION ::pdf_signature_error ll_pdf_check_certificate(::pdf_pkcs7_verifier *verifier, ::pdf_document *doc, ::pdf_obj *signature)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_check_certificate():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " verifier=" << verifier;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " signature=" << signature;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_signature_error ret;
	fz_try(auto_ctx) {
		ret = ::pdf_check_certificate(auto_ctx, verifier, doc, signature);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_check_certificate(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_check_digest()`. */
FZ_FUNCTION ::pdf_signature_error ll_pdf_check_digest(::pdf_pkcs7_verifier *verifier, ::pdf_document *doc, ::pdf_obj *signature)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_check_digest():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " verifier=" << verifier;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " signature=" << signature;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_signature_error ret;
	fz_try(auto_ctx) {
		ret = ::pdf_check_digest(auto_ctx, verifier, doc, signature);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_check_digest(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_check_widget_certificate()`. */
FZ_FUNCTION ::pdf_signature_error ll_pdf_check_widget_certificate(::pdf_pkcs7_verifier *verifier, ::pdf_annot *widget)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_check_widget_certificate():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " verifier=" << verifier;
		if (s_trace > 1) std::cerr << " widget=" << widget;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_signature_error ret;
	fz_try(auto_ctx) {
		ret = ::pdf_check_widget_certificate(auto_ctx, verifier, widget);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_check_widget_certificate(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_check_widget_digest()`. */
FZ_FUNCTION ::pdf_signature_error ll_pdf_check_widget_digest(::pdf_pkcs7_verifier *verifier, ::pdf_annot *widget)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_check_widget_digest():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " verifier=" << verifier;
		if (s_trace > 1) std::cerr << " widget=" << widget;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_signature_error ret;
	fz_try(auto_ctx) {
		ret = ::pdf_check_widget_digest(auto_ctx, verifier, widget);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_check_widget_digest(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_choice_field_option()`. */
FZ_FUNCTION const char *ll_pdf_choice_field_option(::pdf_obj *field, int exportval, int i)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_choice_field_option():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " field=" << field;
		std::cerr << " exportval=" << exportval;
		std::cerr << " i=" << i;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_choice_field_option(auto_ctx, field, exportval, i);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_choice_field_option(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_choice_field_option_count()`. */
FZ_FUNCTION int ll_pdf_choice_field_option_count(::pdf_obj *field)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_choice_field_option_count():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " field=" << field;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_choice_field_option_count(auto_ctx, field);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_choice_field_option_count(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_choice_widget_is_multiselect()`. */
FZ_FUNCTION int ll_pdf_choice_widget_is_multiselect(::pdf_annot *tw)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_choice_widget_is_multiselect():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " tw=" << tw;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_choice_widget_is_multiselect(auto_ctx, tw);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_choice_widget_is_multiselect(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_choice_widget_options()`. */
FZ_FUNCTION int ll_pdf_choice_widget_options(::pdf_annot *tw, int exportval, const char *opts[])
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_choice_widget_options():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " tw=" << tw;
		std::cerr << " exportval=" << exportval;
		std::cerr << " opts=" << opts;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_choice_widget_options(auto_ctx, tw, exportval, opts);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_choice_widget_options(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_choice_widget_options2()`. */
FZ_FUNCTION std::vector<std::string> ll_pdf_choice_widget_options2(::pdf_annot *tw, int exportval)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_choice_widget_options2():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " tw=" << tw;
		std::cerr << " exportval=" << exportval;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	std::vector<std::string> ret;
	fz_try(auto_ctx) {
		ret = ::pdf_choice_widget_options2(auto_ctx, tw, exportval);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_choice_widget_options2(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_choice_widget_set_value()`. */
FZ_FUNCTION void ll_pdf_choice_widget_set_value(::pdf_annot *tw, int n, const char *opts[])
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_choice_widget_set_value():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " tw=" << tw;
		std::cerr << " n=" << n;
		std::cerr << " opts=" << opts;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_choice_widget_set_value(auto_ctx, tw, n, opts);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_choice_widget_set_value(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_choice_widget_value()`. */
FZ_FUNCTION int ll_pdf_choice_widget_value(::pdf_annot *tw, const char *opts[])
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_choice_widget_value():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " tw=" << tw;
		std::cerr << " opts=" << opts;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_choice_widget_value(auto_ctx, tw, opts);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_choice_widget_value(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_clean_file()`. */
FZ_FUNCTION void ll_pdf_clean_file(char *infile, char *outfile, char *password, ::pdf_clean_options *opts, int retainlen, char *retainlist[])
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_clean_file():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " infile=" << (void*) infile;
		if (s_trace > 1) std::cerr << " outfile=" << (void*) outfile;
		if (s_trace > 1) std::cerr << " password=" << (void*) password;
		std::cerr << " opts=" << opts;
		std::cerr << " retainlen=" << retainlen;
		std::cerr << " retainlist=" << retainlist;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_clean_file(auto_ctx, infile, outfile, password, opts, retainlen, retainlist);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_clean_file(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_clean_font_name()`. */
FZ_FUNCTION const char *ll_pdf_clean_font_name(const char *fontname)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_clean_font_name():";
		if (fontname) std::cerr << " fontname='" << fontname << "'";
		else std::cerr << " fontname:null";
		std::cerr << "\n";
	}
	#endif
	const char * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::pdf_clean_font_name(fontname);
	return ret;
}

/** Low-level wrapper for `::pdf_clean_obj()`. */
FZ_FUNCTION void ll_pdf_clean_obj(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_clean_obj():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_clean_obj(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_clean_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_clear_annot_border_dash()`. */
FZ_FUNCTION void ll_pdf_clear_annot_border_dash(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_clear_annot_border_dash():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_clear_annot_border_dash(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_clear_annot_border_dash(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_clear_annot_ink_list()`. */
FZ_FUNCTION void ll_pdf_clear_annot_ink_list(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_clear_annot_ink_list():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_clear_annot_ink_list(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_clear_annot_ink_list(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_clear_annot_quad_points()`. */
FZ_FUNCTION void ll_pdf_clear_annot_quad_points(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_clear_annot_quad_points():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_clear_annot_quad_points(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_clear_annot_quad_points(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_clear_annot_vertices()`. */
FZ_FUNCTION void ll_pdf_clear_annot_vertices(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_clear_annot_vertices():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_clear_annot_vertices(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_clear_annot_vertices(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_clear_signature()`. */
FZ_FUNCTION void ll_pdf_clear_signature(::pdf_annot *widget)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_clear_signature():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " widget=" << widget;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_clear_signature(auto_ctx, widget);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_clear_signature(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_clear_xref()`. */
FZ_FUNCTION void ll_pdf_clear_xref(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_clear_xref():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_clear_xref(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_clear_xref(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_clear_xref_to_mark()`. */
FZ_FUNCTION void ll_pdf_clear_xref_to_mark(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_clear_xref_to_mark():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_clear_xref_to_mark(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_clear_xref_to_mark(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_close_processor()`. */
FZ_FUNCTION void ll_pdf_close_processor(::pdf_processor *proc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_close_processor():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " proc=" << proc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_close_processor(auto_ctx, proc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_close_processor(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_cmap_size()`. */
FZ_FUNCTION size_t ll_pdf_cmap_size(::pdf_cmap *cmap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_cmap_size():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cmap=" << cmap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	size_t ret;
	fz_try(auto_ctx) {
		ret = ::pdf_cmap_size(auto_ctx, cmap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_cmap_size(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_cmap_wmode()`. */
FZ_FUNCTION int ll_pdf_cmap_wmode(::pdf_cmap *cmap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_cmap_wmode():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cmap=" << cmap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_cmap_wmode(auto_ctx, cmap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_cmap_wmode(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_copy_array()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_copy_array(::pdf_obj *array)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_copy_array():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_copy_array(auto_ctx, array);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_copy_array(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_copy_dict()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_copy_dict(::pdf_obj *dict)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_copy_dict():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_copy_dict(auto_ctx, dict);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_copy_dict(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_count_layer_config_ui()`. */
FZ_FUNCTION int ll_pdf_count_layer_config_ui(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_count_layer_config_ui():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_count_layer_config_ui(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_count_layer_config_ui(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_count_layer_configs()`. */
FZ_FUNCTION int ll_pdf_count_layer_configs(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_count_layer_configs():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_count_layer_configs(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_count_layer_configs(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_count_layers()`. */
FZ_FUNCTION int ll_pdf_count_layers(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_count_layers():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_count_layers(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_count_layers(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_count_objects()`. */
FZ_FUNCTION int ll_pdf_count_objects(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_count_objects():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_count_objects(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_count_objects(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_count_pages()`. */
FZ_FUNCTION int ll_pdf_count_pages(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_count_pages():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_count_pages(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_count_pages(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_count_pages_imp()`. */
FZ_FUNCTION int ll_pdf_count_pages_imp(::fz_document *doc, int chapter)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_count_pages_imp():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " chapter=" << chapter;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_count_pages_imp(auto_ctx, doc, chapter);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_count_pages_imp(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_count_q_balance()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_count_q_balance(::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm)` => `(int prepend, int append)`
*/
FZ_FUNCTION void ll_pdf_count_q_balance(::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm, int *prepend, int *append)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_count_q_balance():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " res=" << res;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		if (s_trace > 1) std::cerr << " prepend=" << (void*) prepend;
		if (s_trace > 1) std::cerr << " append=" << (void*) append;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_count_q_balance(auto_ctx, doc, res, stm, prepend, append);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_count_q_balance(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_count_signatures()`. */
FZ_FUNCTION int ll_pdf_count_signatures(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_count_signatures():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_count_signatures(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_count_signatures(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_count_unsaved_versions()`. */
FZ_FUNCTION int ll_pdf_count_unsaved_versions(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_count_unsaved_versions():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_count_unsaved_versions(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_count_unsaved_versions(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_count_versions()`. */
FZ_FUNCTION int ll_pdf_count_versions(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_count_versions():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_count_versions(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_count_versions(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_create_annot()`. */
FZ_FUNCTION ::pdf_annot *ll_pdf_create_annot(::pdf_page *page, enum pdf_annot_type type)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_create_annot():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " type=" << type;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_annot * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_create_annot(auto_ctx, page, type);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_create_annot(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_create_annot_raw()`. */
FZ_FUNCTION ::pdf_annot *ll_pdf_create_annot_raw(::pdf_page *page, enum pdf_annot_type type)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_create_annot_raw():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " type=" << type;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_annot * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_create_annot_raw(auto_ctx, page, type);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_create_annot_raw(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_create_document()`. */
FZ_FUNCTION ::pdf_document *ll_pdf_create_document()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_create_document():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_document * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_create_document(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_create_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_create_field_name()`. */
FZ_FUNCTION void ll_pdf_create_field_name(::pdf_document *doc, const char *prefix, char *buf, size_t len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_create_field_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (prefix) std::cerr << " prefix='" << prefix << "'";
		else std::cerr << " prefix:null";
		if (s_trace > 1) std::cerr << " buf=" << (void*) buf;
		std::cerr << " len=" << len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_create_field_name(auto_ctx, doc, prefix, buf, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_create_field_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_create_link()`. */
FZ_FUNCTION ::fz_link *ll_pdf_create_link(::pdf_page *page, ::fz_rect bbox, const char *uri)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_create_link():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " bbox=" << bbox;
		if (uri) std::cerr << " uri='" << uri << "'";
		else std::cerr << " uri:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_link * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_create_link(auto_ctx, page, bbox, uri);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_create_link(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_create_object()`. */
FZ_FUNCTION int ll_pdf_create_object(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_create_object():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_create_object(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_create_object(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_create_signature_widget()`. */
FZ_FUNCTION ::pdf_annot *ll_pdf_create_signature_widget(::pdf_page *page, char *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_create_signature_widget():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		if (s_trace > 1) std::cerr << " name=" << (void*) name;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_annot * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_create_signature_widget(auto_ctx, page, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_create_signature_widget(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_crypt_encrypt_metadata()`. */
FZ_FUNCTION int ll_pdf_crypt_encrypt_metadata(::pdf_crypt *crypt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_crypt_encrypt_metadata():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_crypt_encrypt_metadata(auto_ctx, crypt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_crypt_encrypt_metadata(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_crypt_key()`. */
FZ_FUNCTION unsigned char *ll_pdf_crypt_key(::pdf_crypt *crypt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_crypt_key():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_crypt_key(auto_ctx, crypt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_crypt_key(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_crypt_length()`. */
FZ_FUNCTION int ll_pdf_crypt_length(::pdf_crypt *crypt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_crypt_length():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_crypt_length(auto_ctx, crypt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_crypt_length(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_crypt_method()`. */
FZ_FUNCTION const char *ll_pdf_crypt_method(::pdf_crypt *crypt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_crypt_method():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_crypt_method(auto_ctx, crypt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_crypt_method(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_crypt_obj()`. */
FZ_FUNCTION void ll_pdf_crypt_obj(::pdf_crypt *crypt, ::pdf_obj *obj, int num, int gen)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_crypt_obj():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << " num=" << num;
		std::cerr << " gen=" << gen;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_crypt_obj(auto_ctx, crypt, obj, num, gen);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_crypt_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_crypt_owner_encryption()`. */
FZ_FUNCTION unsigned char *ll_pdf_crypt_owner_encryption(::pdf_crypt *crypt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_crypt_owner_encryption():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_crypt_owner_encryption(auto_ctx, crypt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_crypt_owner_encryption(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_crypt_owner_password()`. */
FZ_FUNCTION unsigned char *ll_pdf_crypt_owner_password(::pdf_crypt *crypt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_crypt_owner_password():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_crypt_owner_password(auto_ctx, crypt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_crypt_owner_password(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_crypt_permissions()`. */
FZ_FUNCTION int ll_pdf_crypt_permissions(::pdf_crypt *crypt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_crypt_permissions():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_crypt_permissions(auto_ctx, crypt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_crypt_permissions(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_crypt_permissions_encryption()`. */
FZ_FUNCTION unsigned char *ll_pdf_crypt_permissions_encryption(::pdf_crypt *crypt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_crypt_permissions_encryption():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_crypt_permissions_encryption(auto_ctx, crypt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_crypt_permissions_encryption(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_crypt_revision()`. */
FZ_FUNCTION int ll_pdf_crypt_revision(::pdf_crypt *crypt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_crypt_revision():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_crypt_revision(auto_ctx, crypt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_crypt_revision(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_crypt_stream_method()`. */
FZ_FUNCTION const char *ll_pdf_crypt_stream_method(::pdf_crypt *crypt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_crypt_stream_method():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_crypt_stream_method(auto_ctx, crypt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_crypt_stream_method(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_crypt_string_method()`. */
FZ_FUNCTION const char *ll_pdf_crypt_string_method(::pdf_crypt *crypt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_crypt_string_method():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_crypt_string_method(auto_ctx, crypt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_crypt_string_method(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_crypt_user_encryption()`. */
FZ_FUNCTION unsigned char *ll_pdf_crypt_user_encryption(::pdf_crypt *crypt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_crypt_user_encryption():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_crypt_user_encryption(auto_ctx, crypt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_crypt_user_encryption(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_crypt_user_password()`. */
FZ_FUNCTION unsigned char *ll_pdf_crypt_user_password(::pdf_crypt *crypt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_crypt_user_password():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_crypt_user_password(auto_ctx, crypt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_crypt_user_password(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_crypt_version()`. */
FZ_FUNCTION int ll_pdf_crypt_version(::pdf_crypt *crypt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_crypt_version():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_crypt_version(auto_ctx, crypt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_crypt_version(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_cycle()`. */
FZ_FUNCTION int ll_pdf_cycle(::pdf_cycle_list *here, ::pdf_cycle_list *prev, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_cycle():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " here=" << here;
		if (s_trace > 1) std::cerr << " prev=" << prev;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_cycle(auto_ctx, here, prev, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_cycle(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_debug_doc_changes()`. */
FZ_FUNCTION void ll_pdf_debug_doc_changes(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_debug_doc_changes():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_debug_doc_changes(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_debug_doc_changes(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_debug_obj()`. */
FZ_FUNCTION void ll_pdf_debug_obj(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_debug_obj():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_debug_obj(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_debug_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_debug_ref()`. */
FZ_FUNCTION void ll_pdf_debug_ref(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_debug_ref():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_debug_ref(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_debug_ref(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_decode_cmap()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_decode_cmap(::pdf_cmap *cmap, unsigned char *s, unsigned char *e)` => `(int, unsigned int cpt)`
*/
FZ_FUNCTION int ll_pdf_decode_cmap(::pdf_cmap *cmap, unsigned char *s, unsigned char *e, unsigned int *cpt)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_decode_cmap():";
		if (s_trace > 1) std::cerr << " cmap=" << cmap;
		std::cerr << " s=" << ((void*) s);
		std::cerr << " e=" << ((void*) e);
		if (s_trace > 1) std::cerr << " cpt=" << (void*) cpt;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::pdf_decode_cmap(cmap, s, e, cpt);
	return ret;
}

/** Low-level wrapper for `::pdf_deep_copy_obj()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_deep_copy_obj(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_deep_copy_obj():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_deep_copy_obj(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_deep_copy_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_delete_annot()`. */
FZ_FUNCTION void ll_pdf_delete_annot(::pdf_page *page, ::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_delete_annot():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_delete_annot(auto_ctx, page, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_delete_annot(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_delete_link()`. */
FZ_FUNCTION void ll_pdf_delete_link(::pdf_page *page, ::fz_link *link)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_delete_link():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		if (s_trace > 1) std::cerr << " link=" << link;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_delete_link(auto_ctx, page, link);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_delete_link(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_delete_object()`. */
FZ_FUNCTION void ll_pdf_delete_object(::pdf_document *doc, int num)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_delete_object():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " num=" << num;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_delete_object(auto_ctx, doc, num);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_delete_object(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_delete_page()`. */
FZ_FUNCTION void ll_pdf_delete_page(::pdf_document *doc, int number)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_delete_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " number=" << number;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_delete_page(auto_ctx, doc, number);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_delete_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_delete_page_labels()`. */
FZ_FUNCTION void ll_pdf_delete_page_labels(::pdf_document *doc, int index)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_delete_page_labels():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " index=" << index;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_delete_page_labels(auto_ctx, doc, index);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_delete_page_labels(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_delete_page_range()`. */
FZ_FUNCTION void ll_pdf_delete_page_range(::pdf_document *doc, int start, int end)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_delete_page_range():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " start=" << start;
		std::cerr << " end=" << end;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_delete_page_range(auto_ctx, doc, start, end);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_delete_page_range(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_deselect_layer_config_ui()`. */
FZ_FUNCTION void ll_pdf_deselect_layer_config_ui(::pdf_document *doc, int ui)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_deselect_layer_config_ui():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " ui=" << ui;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_deselect_layer_config_ui(auto_ctx, doc, ui);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_deselect_layer_config_ui(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_deserialise_journal()`. */
FZ_FUNCTION void ll_pdf_deserialise_journal(::pdf_document *doc, ::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_deserialise_journal():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_deserialise_journal(auto_ctx, doc, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_deserialise_journal(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dict_del()`. */
FZ_FUNCTION void ll_pdf_dict_del(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_del():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dict_del(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_del(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dict_dels()`. */
FZ_FUNCTION void ll_pdf_dict_dels(::pdf_obj *dict, const char *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_dels():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (key) std::cerr << " key='" << key << "'";
		else std::cerr << " key:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dict_dels(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_dels(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dict_get()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_dict_get(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_bool()`. */
FZ_FUNCTION int ll_pdf_dict_get_bool(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_bool():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_bool(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_bool(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_bool_default()`. */
FZ_FUNCTION int ll_pdf_dict_get_bool_default(::pdf_obj *dict, ::pdf_obj *key, int def)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_bool_default():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << " def=" << def;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_bool_default(auto_ctx, dict, key, def);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_bool_default(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_date()`. */
FZ_FUNCTION int64_t ll_pdf_dict_get_date(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_date():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int64_t ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_date(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_date(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_inheritable()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_dict_get_inheritable(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_inheritable():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_inheritable(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_inheritable(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_inheritable_bool()`. */
FZ_FUNCTION int ll_pdf_dict_get_inheritable_bool(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_inheritable_bool():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_inheritable_bool(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_inheritable_bool(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_inheritable_date()`. */
FZ_FUNCTION int64_t ll_pdf_dict_get_inheritable_date(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_inheritable_date():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int64_t ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_inheritable_date(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_inheritable_date(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_inheritable_int()`. */
FZ_FUNCTION int ll_pdf_dict_get_inheritable_int(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_inheritable_int():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_inheritable_int(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_inheritable_int(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_inheritable_int64()`. */
FZ_FUNCTION int64_t ll_pdf_dict_get_inheritable_int64(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_inheritable_int64():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int64_t ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_inheritable_int64(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_inheritable_int64(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_inheritable_matrix()`. */
FZ_FUNCTION ::fz_matrix ll_pdf_dict_get_inheritable_matrix(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_inheritable_matrix():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_matrix ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_inheritable_matrix(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_inheritable_matrix(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_inheritable_name()`. */
FZ_FUNCTION const char *ll_pdf_dict_get_inheritable_name(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_inheritable_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_inheritable_name(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_inheritable_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_inheritable_real()`. */
FZ_FUNCTION float ll_pdf_dict_get_inheritable_real(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_inheritable_real():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	float ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_inheritable_real(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_inheritable_real(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_inheritable_rect()`. */
FZ_FUNCTION ::fz_rect ll_pdf_dict_get_inheritable_rect(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_inheritable_rect():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_rect ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_inheritable_rect(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_inheritable_rect(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_inheritable_string()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_dict_get_inheritable_string(::pdf_obj *dict, ::pdf_obj *key)` => `(const char *, size_t sizep)`
*/
FZ_FUNCTION const char *ll_pdf_dict_get_inheritable_string(::pdf_obj *dict, ::pdf_obj *key, size_t *sizep)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_inheritable_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		if (s_trace > 1) std::cerr << " sizep=" << (void*) sizep;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_inheritable_string(auto_ctx, dict, key, sizep);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_inheritable_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_inheritable_text_string()`. */
FZ_FUNCTION const char *ll_pdf_dict_get_inheritable_text_string(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_inheritable_text_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_inheritable_text_string(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_inheritable_text_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_int()`. */
FZ_FUNCTION int ll_pdf_dict_get_int(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_int():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_int(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_int(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_int64()`. */
FZ_FUNCTION int64_t ll_pdf_dict_get_int64(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_int64():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int64_t ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_int64(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_int64(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_int_default()`. */
FZ_FUNCTION int ll_pdf_dict_get_int_default(::pdf_obj *dict, ::pdf_obj *key, int def)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_int_default():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << " def=" << def;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_int_default(auto_ctx, dict, key, def);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_int_default(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_key()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_dict_get_key(::pdf_obj *dict, int idx)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_key():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		std::cerr << " idx=" << idx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_key(auto_ctx, dict, idx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_key(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_matrix()`. */
FZ_FUNCTION ::fz_matrix ll_pdf_dict_get_matrix(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_matrix():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_matrix ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_matrix(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_matrix(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_name()`. */
FZ_FUNCTION const char *ll_pdf_dict_get_name(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_name(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_put_drop()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_dict_get_put_drop(::pdf_obj *dict, ::pdf_obj *key, ::pdf_obj *val, ::pdf_obj **old_val)` => 
*/
FZ_FUNCTION void ll_pdf_dict_get_put_drop(::pdf_obj *dict, ::pdf_obj *key, ::pdf_obj *val, ::pdf_obj **old_val)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_put_drop():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		if (s_trace > 1) std::cerr << " val=" << val;
		if (s_trace > 1) std::cerr << " old_val=" << (void*) old_val;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dict_get_put_drop(auto_ctx, dict, key, val, old_val);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_put_drop(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dict_get_real()`. */
FZ_FUNCTION float ll_pdf_dict_get_real(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_real():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	float ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_real(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_real(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_real_default()`. */
FZ_FUNCTION float ll_pdf_dict_get_real_default(::pdf_obj *dict, ::pdf_obj *key, float def)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_real_default():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << " def=" << def;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	float ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_real_default(auto_ctx, dict, key, def);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_real_default(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_rect()`. */
FZ_FUNCTION ::fz_rect ll_pdf_dict_get_rect(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_rect():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_rect ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_rect(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_rect(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_string()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_dict_get_string(::pdf_obj *dict, ::pdf_obj *key)` => `(const char *, size_t sizep)`
*/
FZ_FUNCTION const char *ll_pdf_dict_get_string(::pdf_obj *dict, ::pdf_obj *key, size_t *sizep)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		if (s_trace > 1) std::cerr << " sizep=" << (void*) sizep;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_string(auto_ctx, dict, key, sizep);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_text_string()`. */
FZ_FUNCTION const char *ll_pdf_dict_get_text_string(::pdf_obj *dict, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_text_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_text_string(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_text_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_get_val()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_dict_get_val(::pdf_obj *dict, int idx)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_get_val():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		std::cerr << " idx=" << idx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_get_val(auto_ctx, dict, idx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_get_val(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_geta()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_dict_geta(::pdf_obj *dict, ::pdf_obj *key, ::pdf_obj *abbrev)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_geta():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		if (s_trace > 1) std::cerr << " abbrev=" << abbrev;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_geta(auto_ctx, dict, key, abbrev);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_geta(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_getp()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_dict_getp(::pdf_obj *dict, const char *path)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_getp():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_getp(auto_ctx, dict, path);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_getp(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_getp_inheritable()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_dict_getp_inheritable(::pdf_obj *dict, const char *path)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_getp_inheritable():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_getp_inheritable(auto_ctx, dict, path);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_getp_inheritable(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_gets()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_dict_gets(::pdf_obj *dict, const char *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_gets():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (key) std::cerr << " key='" << key << "'";
		else std::cerr << " key:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_gets(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_gets(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_gets_inheritable()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_dict_gets_inheritable(::pdf_obj *dict, const char *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_gets_inheritable():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (key) std::cerr << " key='" << key << "'";
		else std::cerr << " key:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_gets_inheritable(auto_ctx, dict, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_gets_inheritable(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_getsa()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_dict_getsa(::pdf_obj *dict, const char *key, const char *abbrev)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_getsa():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (key) std::cerr << " key='" << key << "'";
		else std::cerr << " key:null";
		if (abbrev) std::cerr << " abbrev='" << abbrev << "'";
		else std::cerr << " abbrev:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_getsa(auto_ctx, dict, key, abbrev);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_getsa(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_len()`. */
FZ_FUNCTION int ll_pdf_dict_len(::pdf_obj *dict)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_len():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_len(auto_ctx, dict);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_len(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_put()`. */
FZ_FUNCTION void ll_pdf_dict_put(::pdf_obj *dict, ::pdf_obj *key, ::pdf_obj *val)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_put():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		if (s_trace > 1) std::cerr << " val=" << val;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dict_put(auto_ctx, dict, key, val);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_put(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dict_put_array()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_dict_put_array(::pdf_obj *dict, ::pdf_obj *key, int initial)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_put_array():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << " initial=" << initial;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_put_array(auto_ctx, dict, key, initial);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_put_array(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_put_bool()`. */
FZ_FUNCTION void ll_pdf_dict_put_bool(::pdf_obj *dict, ::pdf_obj *key, int x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_put_bool():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dict_put_bool(auto_ctx, dict, key, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_put_bool(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dict_put_date()`. */
FZ_FUNCTION void ll_pdf_dict_put_date(::pdf_obj *dict, ::pdf_obj *key, int64_t time)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_put_date():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << " time=" << time;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dict_put_date(auto_ctx, dict, key, time);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_put_date(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dict_put_dict()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_dict_put_dict(::pdf_obj *dict, ::pdf_obj *key, int initial)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_put_dict():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << " initial=" << initial;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_put_dict(auto_ctx, dict, key, initial);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_put_dict(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_put_drop()`. */
FZ_FUNCTION void ll_pdf_dict_put_drop(::pdf_obj *dict, ::pdf_obj *key, ::pdf_obj *val)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_put_drop():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		if (s_trace > 1) std::cerr << " val=" << val;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dict_put_drop(auto_ctx, dict, key, val);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_put_drop(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dict_put_int()`. */
FZ_FUNCTION void ll_pdf_dict_put_int(::pdf_obj *dict, ::pdf_obj *key, int64_t x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_put_int():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dict_put_int(auto_ctx, dict, key, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_put_int(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dict_put_matrix()`. */
FZ_FUNCTION void ll_pdf_dict_put_matrix(::pdf_obj *dict, ::pdf_obj *key, ::fz_matrix x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_put_matrix():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dict_put_matrix(auto_ctx, dict, key, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_put_matrix(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dict_put_name()`. */
FZ_FUNCTION void ll_pdf_dict_put_name(::pdf_obj *dict, ::pdf_obj *key, const char *x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_put_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		if (x) std::cerr << " x='" << x << "'";
		else std::cerr << " x:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dict_put_name(auto_ctx, dict, key, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_put_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dict_put_real()`. */
FZ_FUNCTION void ll_pdf_dict_put_real(::pdf_obj *dict, ::pdf_obj *key, double x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_put_real():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dict_put_real(auto_ctx, dict, key, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_put_real(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dict_put_rect()`. */
FZ_FUNCTION void ll_pdf_dict_put_rect(::pdf_obj *dict, ::pdf_obj *key, ::fz_rect x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_put_rect():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << " x=" << x;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dict_put_rect(auto_ctx, dict, key, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_put_rect(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dict_put_string()`. */
FZ_FUNCTION void ll_pdf_dict_put_string(::pdf_obj *dict, ::pdf_obj *key, const char *x, size_t n)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_put_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		if (x) std::cerr << " x='" << x << "'";
		else std::cerr << " x:null";
		std::cerr << " n=" << n;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dict_put_string(auto_ctx, dict, key, x, n);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_put_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dict_put_text_string()`. */
FZ_FUNCTION void ll_pdf_dict_put_text_string(::pdf_obj *dict, ::pdf_obj *key, const char *x)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_put_text_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " key=" << key;
		if (x) std::cerr << " x='" << x << "'";
		else std::cerr << " x:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dict_put_text_string(auto_ctx, dict, key, x);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_put_text_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dict_put_val_null()`. */
FZ_FUNCTION void ll_pdf_dict_put_val_null(::pdf_obj *obj, int idx)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_put_val_null():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << " idx=" << idx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dict_put_val_null(auto_ctx, obj, idx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_put_val_null(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dict_putp()`. */
FZ_FUNCTION void ll_pdf_dict_putp(::pdf_obj *dict, const char *path, ::pdf_obj *val)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_putp():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (s_trace > 1) std::cerr << " val=" << val;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dict_putp(auto_ctx, dict, path, val);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_putp(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dict_putp_drop()`. */
FZ_FUNCTION void ll_pdf_dict_putp_drop(::pdf_obj *dict, const char *path, ::pdf_obj *val)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_putp_drop():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (s_trace > 1) std::cerr << " val=" << val;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dict_putp_drop(auto_ctx, dict, path, val);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_putp_drop(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dict_puts()`. */
FZ_FUNCTION void ll_pdf_dict_puts(::pdf_obj *dict, const char *key, ::pdf_obj *val)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_puts():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (key) std::cerr << " key='" << key << "'";
		else std::cerr << " key:null";
		if (s_trace > 1) std::cerr << " val=" << val;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dict_puts(auto_ctx, dict, key, val);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_puts(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dict_puts_dict()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_dict_puts_dict(::pdf_obj *dict, const char *key, int initial)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_puts_dict():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (key) std::cerr << " key='" << key << "'";
		else std::cerr << " key:null";
		std::cerr << " initial=" << initial;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_dict_puts_dict(auto_ctx, dict, key, initial);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_puts_dict(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_dict_puts_drop()`. */
FZ_FUNCTION void ll_pdf_dict_puts_drop(::pdf_obj *dict, const char *key, ::pdf_obj *val)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dict_puts_drop():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (key) std::cerr << " key='" << key << "'";
		else std::cerr << " key:null";
		if (s_trace > 1) std::cerr << " val=" << val;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dict_puts_drop(auto_ctx, dict, key, val);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dict_puts_drop(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dirty_annot()`. */
FZ_FUNCTION void ll_pdf_dirty_annot(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dirty_annot():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dirty_annot(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dirty_annot(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_dirty_obj()`. */
FZ_FUNCTION void ll_pdf_dirty_obj(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_dirty_obj():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_dirty_obj(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_dirty_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_disable_js()`. */
FZ_FUNCTION void ll_pdf_disable_js(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_disable_js():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_disable_js(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_disable_js(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_discard_journal()`. */
FZ_FUNCTION void ll_pdf_discard_journal(::pdf_journal *journal)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_discard_journal():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " journal=" << journal;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_discard_journal(auto_ctx, journal);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_discard_journal(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_doc_was_linearized()`. */
FZ_FUNCTION int ll_pdf_doc_was_linearized(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_doc_was_linearized():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_doc_was_linearized(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_doc_was_linearized(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_document_event_did_print()`. */
FZ_FUNCTION void ll_pdf_document_event_did_print(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_document_event_did_print():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_document_event_did_print(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_document_event_did_print(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_document_event_did_save()`. */
FZ_FUNCTION void ll_pdf_document_event_did_save(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_document_event_did_save():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_document_event_did_save(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_document_event_did_save(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_document_event_will_close()`. */
FZ_FUNCTION void ll_pdf_document_event_will_close(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_document_event_will_close():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_document_event_will_close(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_document_event_will_close(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_document_event_will_print()`. */
FZ_FUNCTION void ll_pdf_document_event_will_print(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_document_event_will_print():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_document_event_will_print(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_document_event_will_print(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_document_event_will_save()`. */
FZ_FUNCTION void ll_pdf_document_event_will_save(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_document_event_will_save():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_document_event_will_save(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_document_event_will_save(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_document_from_fz_document()`. */
FZ_FUNCTION ::pdf_document *ll_pdf_document_from_fz_document(::fz_document *ptr)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_document_from_fz_document():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " ptr=" << ptr;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_document * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_document_from_fz_document(auto_ctx, ptr);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_document_from_fz_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_document_language()`. */
FZ_FUNCTION ::fz_text_language ll_pdf_document_language(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_document_language():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_text_language ret;
	fz_try(auto_ctx) {
		ret = ::pdf_document_language(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_document_language(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_document_output_intent()`. */
FZ_FUNCTION ::fz_colorspace *ll_pdf_document_output_intent(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_document_output_intent():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_document_output_intent(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_document_output_intent(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_document_permissions()`. */
FZ_FUNCTION int ll_pdf_document_permissions(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_document_permissions():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_document_permissions(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_document_permissions(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_drop_annot()`. */
FZ_FUNCTION void ll_pdf_drop_annot(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_annot():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_annot(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_annot(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_cmap()`. */
FZ_FUNCTION void ll_pdf_drop_cmap(::pdf_cmap *cmap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_cmap():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " cmap=" << cmap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_cmap(auto_ctx, cmap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_cmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_cmap_imp()`. */
FZ_FUNCTION void ll_pdf_drop_cmap_imp(::fz_storable *cmap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_cmap_imp():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " cmap=" << cmap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_cmap_imp(auto_ctx, cmap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_cmap_imp(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_crypt()`. */
FZ_FUNCTION void ll_pdf_drop_crypt(::pdf_crypt *crypt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_crypt():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " crypt=" << crypt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_crypt(auto_ctx, crypt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_crypt(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_document()`. */
FZ_FUNCTION void ll_pdf_drop_document(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_document():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_document(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_font()`. */
FZ_FUNCTION void ll_pdf_drop_font(::pdf_font_desc *font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_font():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_font(auto_ctx, font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_function()`. */
FZ_FUNCTION void ll_pdf_drop_function(::pdf_function *func)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_function():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " func=" << func;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_function(auto_ctx, func);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_function(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_graft_map()`. */
FZ_FUNCTION void ll_pdf_drop_graft_map(::pdf_graft_map *map)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_graft_map():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " map=" << map;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_graft_map(auto_ctx, map);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_graft_map(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_journal()`. */
FZ_FUNCTION void ll_pdf_drop_journal(::pdf_journal *journal)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_journal():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " journal=" << journal;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_journal(auto_ctx, journal);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_journal(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_js()`. */
FZ_FUNCTION void ll_pdf_drop_js(::pdf_js *js)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_js():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " js=" << js;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_js(auto_ctx, js);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_js(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_local_xref()`. */
FZ_FUNCTION void ll_pdf_drop_local_xref(::pdf_xref *xref)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_local_xref():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " xref=" << xref;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_local_xref(auto_ctx, xref);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_local_xref(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_local_xref_and_resources()`. */
FZ_FUNCTION void ll_pdf_drop_local_xref_and_resources(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_local_xref_and_resources():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_local_xref_and_resources(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_local_xref_and_resources(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_locked_fields()`. */
FZ_FUNCTION void ll_pdf_drop_locked_fields(::pdf_locked_fields *locked)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_locked_fields():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " locked=" << locked;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_locked_fields(auto_ctx, locked);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_locked_fields(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_mark_bits()`. */
FZ_FUNCTION void ll_pdf_drop_mark_bits(::pdf_mark_bits *marks)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_mark_bits():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " marks=" << marks;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_mark_bits(auto_ctx, marks);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_mark_bits(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_obj()`. */
FZ_FUNCTION void ll_pdf_drop_obj(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_obj():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_obj(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_ocg()`. */
FZ_FUNCTION void ll_pdf_drop_ocg(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_ocg():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_ocg(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_ocg(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_page()`. */
FZ_FUNCTION void ll_pdf_drop_page(::pdf_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_page():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_page(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_page_tree()`. */
FZ_FUNCTION void ll_pdf_drop_page_tree(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_page_tree():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_page_tree(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_page_tree(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_page_tree_internal()`. */
FZ_FUNCTION void ll_pdf_drop_page_tree_internal(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_page_tree_internal():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_page_tree_internal(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_page_tree_internal(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_pattern()`. */
FZ_FUNCTION void ll_pdf_drop_pattern(::pdf_pattern *pat)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_pattern():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " pat=" << pat;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_pattern(auto_ctx, pat);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_pattern(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_processor()`. */
FZ_FUNCTION void ll_pdf_drop_processor(::pdf_processor *proc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_processor():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " proc=" << proc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_processor(auto_ctx, proc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_processor(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_resource_tables()`. */
FZ_FUNCTION void ll_pdf_drop_resource_tables(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_resource_tables():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_resource_tables(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_resource_tables(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_signer()`. */
FZ_FUNCTION void ll_pdf_drop_signer(::pdf_pkcs7_signer *signer)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_signer():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " signer=" << signer;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_signer(auto_ctx, signer);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_signer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_singleton_obj()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_drop_singleton_obj(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_singleton_obj():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_drop_singleton_obj(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_singleton_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_drop_verifier()`. */
FZ_FUNCTION void ll_pdf_drop_verifier(::pdf_pkcs7_verifier *verifier)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_verifier():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " verifier=" << verifier;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_verifier(auto_ctx, verifier);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_verifier(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_drop_widget()`. */
FZ_FUNCTION void ll_pdf_drop_widget(::pdf_annot *widget)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_drop_widget():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " widget=" << widget;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_drop_widget(auto_ctx, widget);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_drop_widget(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_edit_text_field_value()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_edit_text_field_value(::pdf_annot *widget, const char *value, const char *change)` => `(int, int selStart, int selEnd, char *newvalue)`
*/
FZ_FUNCTION int ll_pdf_edit_text_field_value(::pdf_annot *widget, const char *value, const char *change, int *selStart, int *selEnd, char **newvalue)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_edit_text_field_value():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " widget=" << widget;
		if (value) std::cerr << " value='" << value << "'";
		else std::cerr << " value:null";
		if (change) std::cerr << " change='" << change << "'";
		else std::cerr << " change:null";
		if (s_trace > 1) std::cerr << " selStart=" << (void*) selStart;
		if (s_trace > 1) std::cerr << " selEnd=" << (void*) selEnd;
		if (s_trace > 1) std::cerr << " newvalue=" << (void*) newvalue;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_edit_text_field_value(auto_ctx, widget, value, change, selStart, selEnd, newvalue);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_edit_text_field_value(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_empty_store()`. */
FZ_FUNCTION void ll_pdf_empty_store(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_empty_store():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_empty_store(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_empty_store(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_enable_journal()`. */
FZ_FUNCTION void ll_pdf_enable_journal(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_enable_journal():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_enable_journal(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_enable_journal(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_enable_js()`. */
FZ_FUNCTION void ll_pdf_enable_js(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_enable_js():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_enable_js(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_enable_js(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_enable_layer()`. */
FZ_FUNCTION void ll_pdf_enable_layer(::pdf_document *doc, int layer, int enabled)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_enable_layer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " layer=" << layer;
		std::cerr << " enabled=" << enabled;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_enable_layer(auto_ctx, doc, layer, enabled);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_enable_layer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_encrypt_data()`. */
FZ_FUNCTION void ll_pdf_encrypt_data(::pdf_crypt *crypt, int num, int gen, void (*fmt_str_out)(::fz_context *, void *, const unsigned char *, size_t ), void *arg, const unsigned char *s, size_t n)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_encrypt_data():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		std::cerr << " num=" << num;
		std::cerr << " gen=" << gen;
		if (s_trace > 1) std::cerr << " fmt_str_out=" << (void*) fmt_str_out;
		if (s_trace > 1) std::cerr << " arg=" << (void*) arg;
		std::cerr << " s=" << ((void*) s);
		std::cerr << " n=" << n;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_encrypt_data(auto_ctx, crypt, num, gen, fmt_str_out, arg, s, n);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_encrypt_data(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_encrypted_len()`. */
FZ_FUNCTION size_t ll_pdf_encrypted_len(::pdf_crypt *crypt, int num, int gen, size_t len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_encrypted_len():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		std::cerr << " num=" << num;
		std::cerr << " gen=" << gen;
		std::cerr << " len=" << len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	size_t ret;
	fz_try(auto_ctx) {
		ret = ::pdf_encrypted_len(auto_ctx, crypt, num, gen, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_encrypted_len(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_end_hmtx()`. */
FZ_FUNCTION void ll_pdf_end_hmtx(::pdf_font_desc *font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_end_hmtx():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_end_hmtx(auto_ctx, font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_end_hmtx(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_end_operation()`. */
FZ_FUNCTION void ll_pdf_end_operation(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_end_operation():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_end_operation(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_end_operation(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_end_vmtx()`. */
FZ_FUNCTION void ll_pdf_end_vmtx(::pdf_font_desc *font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_end_vmtx():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_end_vmtx(auto_ctx, font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_end_vmtx(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_ensure_solid_xref()`. */
FZ_FUNCTION void ll_pdf_ensure_solid_xref(::pdf_document *doc, int num)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_ensure_solid_xref():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " num=" << num;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_ensure_solid_xref(auto_ctx, doc, num);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_ensure_solid_xref(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_eval_function()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_eval_function(::pdf_function *func, const float *in, int inlen, int outlen)` => float out
*/
FZ_FUNCTION void ll_pdf_eval_function(::pdf_function *func, const float *in, int inlen, float *out, int outlen)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_eval_function():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " func=" << func;
		if (s_trace > 1) std::cerr << " in=" << (void*) in;
		std::cerr << " inlen=" << inlen;
		if (s_trace > 1) std::cerr << " out=" << (void*) out;
		std::cerr << " outlen=" << outlen;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_eval_function(auto_ctx, func, in, inlen, out, outlen);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_eval_function(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_event_issue_alert()`. */
FZ_FUNCTION void ll_pdf_event_issue_alert(::pdf_document *doc, ::pdf_alert_event *evt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_event_issue_alert():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " evt=" << evt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_event_issue_alert(auto_ctx, doc, evt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_event_issue_alert(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_event_issue_exec_menu_item()`. */
FZ_FUNCTION void ll_pdf_event_issue_exec_menu_item(::pdf_document *doc, const char *item)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_event_issue_exec_menu_item():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (item) std::cerr << " item='" << item << "'";
		else std::cerr << " item:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_event_issue_exec_menu_item(auto_ctx, doc, item);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_event_issue_exec_menu_item(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_event_issue_launch_url()`. */
FZ_FUNCTION void ll_pdf_event_issue_launch_url(::pdf_document *doc, const char *url, int new_frame)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_event_issue_launch_url():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (url) std::cerr << " url='" << url << "'";
		else std::cerr << " url:null";
		std::cerr << " new_frame=" << new_frame;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_event_issue_launch_url(auto_ctx, doc, url, new_frame);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_event_issue_launch_url(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_event_issue_mail_doc()`. */
FZ_FUNCTION void ll_pdf_event_issue_mail_doc(::pdf_document *doc, ::pdf_mail_doc_event *evt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_event_issue_mail_doc():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " evt=" << evt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_event_issue_mail_doc(auto_ctx, doc, evt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_event_issue_mail_doc(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_event_issue_print()`. */
FZ_FUNCTION void ll_pdf_event_issue_print(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_event_issue_print():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_event_issue_print(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_event_issue_print(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_field_border_style()`. */
FZ_FUNCTION char *ll_pdf_field_border_style(::pdf_obj *field)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_field_border_style():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " field=" << field;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_field_border_style(auto_ctx, field);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_field_border_style(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_field_display()`. */
FZ_FUNCTION int ll_pdf_field_display(::pdf_obj *field)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_field_display():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " field=" << field;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_field_display(auto_ctx, field);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_field_display(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_field_event_calculate()`. */
FZ_FUNCTION void ll_pdf_field_event_calculate(::pdf_document *doc, ::pdf_obj *field)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_field_event_calculate():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " field=" << field;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_field_event_calculate(auto_ctx, doc, field);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_field_event_calculate(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_field_event_format()`. */
FZ_FUNCTION char *ll_pdf_field_event_format(::pdf_document *doc, ::pdf_obj *field)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_field_event_format():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " field=" << field;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_field_event_format(auto_ctx, doc, field);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_field_event_format(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_field_event_keystroke()`. */
FZ_FUNCTION int ll_pdf_field_event_keystroke(::pdf_document *doc, ::pdf_obj *field, ::pdf_keystroke_event *evt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_field_event_keystroke():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " field=" << field;
		if (s_trace > 1) std::cerr << " evt=" << evt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_field_event_keystroke(auto_ctx, doc, field, evt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_field_event_keystroke(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_field_event_validate()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_field_event_validate(::pdf_document *doc, ::pdf_obj *field, const char *value)` => `(int, char *newvalue)`
*/
FZ_FUNCTION int ll_pdf_field_event_validate(::pdf_document *doc, ::pdf_obj *field, const char *value, char **newvalue)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_field_event_validate():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " field=" << field;
		if (value) std::cerr << " value='" << value << "'";
		else std::cerr << " value:null";
		if (s_trace > 1) std::cerr << " newvalue=" << (void*) newvalue;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_field_event_validate(auto_ctx, doc, field, value, newvalue);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_field_event_validate(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_field_flags()`. */
FZ_FUNCTION int ll_pdf_field_flags(::pdf_obj *field)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_field_flags():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " field=" << field;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_field_flags(auto_ctx, field);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_field_flags(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_field_label()`. */
FZ_FUNCTION const char *ll_pdf_field_label(::pdf_obj *field)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_field_label():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " field=" << field;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_field_label(auto_ctx, field);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_field_label(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_field_reset()`. */
FZ_FUNCTION void ll_pdf_field_reset(::pdf_document *doc, ::pdf_obj *field)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_field_reset():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " field=" << field;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_field_reset(auto_ctx, doc, field);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_field_reset(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_field_set_border_style()`. */
FZ_FUNCTION void ll_pdf_field_set_border_style(::pdf_obj *field, const char *text)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_field_set_border_style():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " field=" << field;
		if (text) std::cerr << " text='" << text << "'";
		else std::cerr << " text:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_field_set_border_style(auto_ctx, field, text);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_field_set_border_style(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_field_set_button_caption()`. */
FZ_FUNCTION void ll_pdf_field_set_button_caption(::pdf_obj *field, const char *text)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_field_set_button_caption():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " field=" << field;
		if (text) std::cerr << " text='" << text << "'";
		else std::cerr << " text:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_field_set_button_caption(auto_ctx, field, text);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_field_set_button_caption(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_field_set_display()`. */
FZ_FUNCTION void ll_pdf_field_set_display(::pdf_obj *field, int d)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_field_set_display():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " field=" << field;
		std::cerr << " d=" << d;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_field_set_display(auto_ctx, field, d);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_field_set_display(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_field_set_fill_color()`. */
FZ_FUNCTION void ll_pdf_field_set_fill_color(::pdf_obj *field, ::pdf_obj *col)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_field_set_fill_color():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " field=" << field;
		if (s_trace > 1) std::cerr << " col=" << col;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_field_set_fill_color(auto_ctx, field, col);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_field_set_fill_color(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_field_set_text_color()`. */
FZ_FUNCTION void ll_pdf_field_set_text_color(::pdf_obj *field, ::pdf_obj *col)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_field_set_text_color():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " field=" << field;
		if (s_trace > 1) std::cerr << " col=" << col;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_field_set_text_color(auto_ctx, field, col);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_field_set_text_color(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_field_type()`. */
FZ_FUNCTION int ll_pdf_field_type(::pdf_obj *field)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_field_type():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " field=" << field;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_field_type(auto_ctx, field);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_field_type(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_field_type_string()`. */
FZ_FUNCTION const char *ll_pdf_field_type_string(::pdf_obj *field)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_field_type_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " field=" << field;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_field_type_string(auto_ctx, field);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_field_type_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_field_value()`. */
FZ_FUNCTION const char *ll_pdf_field_value(::pdf_obj *field)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_field_value():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " field=" << field;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_field_value(auto_ctx, field);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_field_value(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_filter_annot_contents()`. */
FZ_FUNCTION void ll_pdf_filter_annot_contents(::pdf_document *doc, ::pdf_annot *annot, ::pdf_filter_options *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_filter_annot_contents():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " options=" << options;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_filter_annot_contents(auto_ctx, doc, annot, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_filter_annot_contents(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_filter_page_contents()`. */
FZ_FUNCTION void ll_pdf_filter_page_contents(::pdf_document *doc, ::pdf_page *page, ::pdf_filter_options *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_filter_page_contents():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " options=" << options;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_filter_page_contents(auto_ctx, doc, page, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_filter_page_contents(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_filter_xobject_instance()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_filter_xobject_instance(::pdf_obj *old_xobj, ::pdf_obj *page_res, ::fz_matrix ctm, ::pdf_filter_options *options, ::pdf_cycle_list *cycle_up)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_filter_xobject_instance():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " old_xobj=" << old_xobj;
		if (s_trace > 1) std::cerr << " page_res=" << page_res;
		std::cerr << " ctm=" << ctm;
		std::cerr << " options=" << options;
		if (s_trace > 1) std::cerr << " cycle_up=" << cycle_up;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_filter_xobject_instance(auto_ctx, old_xobj, page_res, ctm, options, cycle_up);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_filter_xobject_instance(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_find_font_resource()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_find_font_resource(::pdf_document *doc, int type, int encoding, ::fz_font *item, ::pdf_font_resource_key *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_find_font_resource():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " type=" << type;
		std::cerr << " encoding=" << encoding;
		if (s_trace > 1) std::cerr << " item=" << item;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_find_font_resource(auto_ctx, doc, type, encoding, item, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_find_font_resource(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_find_item()`. */
FZ_FUNCTION void *ll_pdf_find_item(::fz_store_drop_fn *drop, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_find_item():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " drop=" << (void*) drop;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_find_item(auto_ctx, drop, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_find_item(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_find_locked_fields()`. */
FZ_FUNCTION ::pdf_locked_fields *ll_pdf_find_locked_fields(::pdf_document *doc, int version)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_find_locked_fields():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " version=" << version;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_locked_fields * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_find_locked_fields(auto_ctx, doc, version);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_find_locked_fields(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_find_locked_fields_for_sig()`. */
FZ_FUNCTION ::pdf_locked_fields *ll_pdf_find_locked_fields_for_sig(::pdf_document *doc, ::pdf_obj *sig)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_find_locked_fields_for_sig():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " sig=" << sig;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_locked_fields * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_find_locked_fields_for_sig(auto_ctx, doc, sig);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_find_locked_fields_for_sig(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_find_version_for_obj()`. */
FZ_FUNCTION int ll_pdf_find_version_for_obj(::pdf_document *doc, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_find_version_for_obj():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_find_version_for_obj(auto_ctx, doc, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_find_version_for_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_first_annot()`. */
FZ_FUNCTION ::pdf_annot *ll_pdf_first_annot(::pdf_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_first_annot():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_annot * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_first_annot(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_first_annot(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_first_widget()`. */
FZ_FUNCTION ::pdf_annot *ll_pdf_first_widget(::pdf_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_first_widget():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_annot * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_first_widget(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_first_widget(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_flatten_inheritable_page_items()`. */
FZ_FUNCTION void ll_pdf_flatten_inheritable_page_items(::pdf_obj *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_flatten_inheritable_page_items():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_flatten_inheritable_page_items(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_flatten_inheritable_page_items(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_font_cid_to_gid()`. */
FZ_FUNCTION int ll_pdf_font_cid_to_gid(::pdf_font_desc *fontdesc, int cid)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_font_cid_to_gid():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " fontdesc=" << fontdesc;
		std::cerr << " cid=" << cid;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_font_cid_to_gid(auto_ctx, fontdesc, cid);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_font_cid_to_gid(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_font_writing_supported()`. */
FZ_FUNCTION int ll_pdf_font_writing_supported(::fz_font *font)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_font_writing_supported():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_font_writing_supported(auto_ctx, font);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_font_writing_supported(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_forget_xref()`. */
FZ_FUNCTION void ll_pdf_forget_xref(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_forget_xref():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_forget_xref(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_forget_xref(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_format_date()`. */
FZ_FUNCTION char *ll_pdf_format_date(int64_t time, char *s, size_t n)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_format_date():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " time=" << time;
		if (s_trace > 1) std::cerr << " s=" << (void*) s;
		std::cerr << " n=" << n;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_format_date(auto_ctx, time, s, n);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_format_date(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_format_write_options()`. */
FZ_FUNCTION char *ll_pdf_format_write_options(char *buffer, size_t buffer_len, const ::pdf_write_options *opts)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_format_write_options():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buffer=" << (void*) buffer;
		std::cerr << " buffer_len=" << buffer_len;
		std::cerr << " opts=" << opts;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_format_write_options(auto_ctx, buffer, buffer_len, opts);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_format_write_options(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_function_size()`. */
FZ_FUNCTION size_t ll_pdf_function_size(::pdf_function *func)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_function_size():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " func=" << func;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	size_t ret;
	fz_try(auto_ctx) {
		ret = ::pdf_function_size(auto_ctx, func);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_function_size(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_get_bound_document()`. */
FZ_FUNCTION ::pdf_document *ll_pdf_get_bound_document(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_get_bound_document():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_document * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_get_bound_document(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_get_bound_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_get_doc_event_callback_data()`. */
FZ_FUNCTION void *ll_pdf_get_doc_event_callback_data(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_get_doc_event_callback_data():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_get_doc_event_callback_data(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_get_doc_event_callback_data(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_get_embedded_file_params()`. */
FZ_FUNCTION void ll_pdf_get_embedded_file_params(::pdf_obj *fs, ::pdf_embedded_file_params *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_get_embedded_file_params():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " fs=" << fs;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_get_embedded_file_params(auto_ctx, fs, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_get_embedded_file_params(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_get_incremental_xref_entry()`. */
FZ_FUNCTION ::pdf_xref_entry *ll_pdf_get_incremental_xref_entry(::pdf_document *doc, int i)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_get_incremental_xref_entry():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " i=" << i;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_xref_entry * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_get_incremental_xref_entry(auto_ctx, doc, i);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_get_incremental_xref_entry(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_get_indirect_document()`. */
FZ_FUNCTION ::pdf_document *ll_pdf_get_indirect_document(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_get_indirect_document():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_document * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_get_indirect_document(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_get_indirect_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_get_populating_xref_entry()`. */
FZ_FUNCTION ::pdf_xref_entry *ll_pdf_get_populating_xref_entry(::pdf_document *doc, int i)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_get_populating_xref_entry():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " i=" << i;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_xref_entry * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_get_populating_xref_entry(auto_ctx, doc, i);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_get_populating_xref_entry(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_get_widget_editing_state()`. */
FZ_FUNCTION int ll_pdf_get_widget_editing_state(::pdf_annot *widget)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_get_widget_editing_state():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " widget=" << widget;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_get_widget_editing_state(auto_ctx, widget);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_get_widget_editing_state(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_get_xref_entry()`. */
FZ_FUNCTION ::pdf_xref_entry *ll_pdf_get_xref_entry(::pdf_document *doc, int i)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_get_xref_entry():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " i=" << i;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_xref_entry * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_get_xref_entry(auto_ctx, doc, i);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_get_xref_entry(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_get_xref_entry_no_change()`. */
FZ_FUNCTION ::pdf_xref_entry *ll_pdf_get_xref_entry_no_change(::pdf_document *doc, int i)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_get_xref_entry_no_change():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " i=" << i;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_xref_entry * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_get_xref_entry_no_change(auto_ctx, doc, i);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_get_xref_entry_no_change(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_get_xref_entry_no_null()`. */
FZ_FUNCTION ::pdf_xref_entry *ll_pdf_get_xref_entry_no_null(::pdf_document *doc, int i)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_get_xref_entry_no_null():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " i=" << i;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_xref_entry * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_get_xref_entry_no_null(auto_ctx, doc, i);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_get_xref_entry_no_null(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_graft_mapped_object()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_graft_mapped_object(::pdf_graft_map *map, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_graft_mapped_object():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " map=" << map;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_graft_mapped_object(auto_ctx, map, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_graft_mapped_object(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_graft_mapped_page()`. */
FZ_FUNCTION void ll_pdf_graft_mapped_page(::pdf_graft_map *map, int page_to, ::pdf_document *src, int page_from)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_graft_mapped_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " map=" << map;
		std::cerr << " page_to=" << page_to;
		if (s_trace > 1) std::cerr << " src=" << src;
		std::cerr << " page_from=" << page_from;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_graft_mapped_page(auto_ctx, map, page_to, src, page_from);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_graft_mapped_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_graft_object()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_graft_object(::pdf_document *dst, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_graft_object():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dst=" << dst;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_graft_object(auto_ctx, dst, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_graft_object(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_graft_page()`. */
FZ_FUNCTION void ll_pdf_graft_page(::pdf_document *dst, int page_to, ::pdf_document *src, int page_from)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_graft_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dst=" << dst;
		std::cerr << " page_to=" << page_to;
		if (s_trace > 1) std::cerr << " src=" << src;
		std::cerr << " page_from=" << page_from;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_graft_page(auto_ctx, dst, page_to, src, page_from);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_graft_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_has_permission()`. */
FZ_FUNCTION int ll_pdf_has_permission(::pdf_document *doc, ::fz_permission p)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_has_permission():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " p=" << p;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_has_permission(auto_ctx, doc, p);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_has_permission(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_has_unsaved_changes()`. */
FZ_FUNCTION int ll_pdf_has_unsaved_changes(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_has_unsaved_changes():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_has_unsaved_changes(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_has_unsaved_changes(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_has_unsaved_sigs()`. */
FZ_FUNCTION int ll_pdf_has_unsaved_sigs(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_has_unsaved_sigs():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_has_unsaved_sigs(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_has_unsaved_sigs(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_insert_font_resource()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_insert_font_resource(::pdf_document *doc, ::pdf_font_resource_key *key, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_insert_font_resource():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " key=" << key;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_insert_font_resource(auto_ctx, doc, key, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_insert_font_resource(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_insert_page()`. */
FZ_FUNCTION void ll_pdf_insert_page(::pdf_document *doc, int at, ::pdf_obj *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_insert_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " at=" << at;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_insert_page(auto_ctx, doc, at, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_insert_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_intent_from_name()`. */
FZ_FUNCTION enum pdf_intent ll_pdf_intent_from_name(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_intent_from_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	enum pdf_intent ret;
	fz_try(auto_ctx) {
		ret = ::pdf_intent_from_name(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_intent_from_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_intent_from_string()`. */
FZ_FUNCTION enum pdf_intent ll_pdf_intent_from_string(const char *str)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_intent_from_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (str) std::cerr << " str='" << str << "'";
		else std::cerr << " str:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	enum pdf_intent ret;
	fz_try(auto_ctx) {
		ret = ::pdf_intent_from_string(auto_ctx, str);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_intent_from_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_invalidate_xfa()`. */
FZ_FUNCTION void ll_pdf_invalidate_xfa(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_invalidate_xfa():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_invalidate_xfa(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_invalidate_xfa(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_is_array()`. */
FZ_FUNCTION int ll_pdf_is_array(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_is_array():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_is_array(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_is_array(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_is_bool()`. */
FZ_FUNCTION int ll_pdf_is_bool(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_is_bool():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_is_bool(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_is_bool(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_is_dict()`. */
FZ_FUNCTION int ll_pdf_is_dict(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_is_dict():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_is_dict(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_is_dict(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_is_embedded_file()`. */
FZ_FUNCTION int ll_pdf_is_embedded_file(::pdf_obj *fs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_is_embedded_file():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " fs=" << fs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_is_embedded_file(auto_ctx, fs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_is_embedded_file(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_is_field_locked()`. */
FZ_FUNCTION int ll_pdf_is_field_locked(::pdf_locked_fields *locked, const char *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_is_field_locked():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " locked=" << locked;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_is_field_locked(auto_ctx, locked, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_is_field_locked(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_is_indirect()`. */
FZ_FUNCTION int ll_pdf_is_indirect(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_is_indirect():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_is_indirect(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_is_indirect(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_is_int()`. */
FZ_FUNCTION int ll_pdf_is_int(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_is_int():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_is_int(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_is_int(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_is_jpx_image()`. */
FZ_FUNCTION int ll_pdf_is_jpx_image(::pdf_obj *dict)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_is_jpx_image():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_is_jpx_image(auto_ctx, dict);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_is_jpx_image(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_is_local_object()`. */
FZ_FUNCTION int ll_pdf_is_local_object(::pdf_document *doc, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_is_local_object():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_is_local_object(auto_ctx, doc, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_is_local_object(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_is_name()`. */
FZ_FUNCTION int ll_pdf_is_name(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_is_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_is_name(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_is_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_is_null()`. */
FZ_FUNCTION int ll_pdf_is_null(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_is_null():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_is_null(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_is_null(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_is_number()`. */
FZ_FUNCTION int ll_pdf_is_number(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_is_number():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_is_number(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_is_number(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_is_ocg_hidden()`. */
FZ_FUNCTION int ll_pdf_is_ocg_hidden(::pdf_document *doc, ::pdf_obj *rdb, const char *usage, ::pdf_obj *ocg)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_is_ocg_hidden():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " rdb=" << rdb;
		if (usage) std::cerr << " usage='" << usage << "'";
		else std::cerr << " usage:null";
		if (s_trace > 1) std::cerr << " ocg=" << ocg;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_is_ocg_hidden(auto_ctx, doc, rdb, usage, ocg);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_is_ocg_hidden(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_is_real()`. */
FZ_FUNCTION int ll_pdf_is_real(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_is_real():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_is_real(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_is_real(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_is_stream()`. */
FZ_FUNCTION int ll_pdf_is_stream(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_is_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_is_stream(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_is_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_is_string()`. */
FZ_FUNCTION int ll_pdf_is_string(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_is_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_is_string(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_is_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_is_tint_colorspace()`. */
FZ_FUNCTION int ll_pdf_is_tint_colorspace(::fz_colorspace *cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_is_tint_colorspace():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_is_tint_colorspace(auto_ctx, cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_is_tint_colorspace(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_js_event_init()`. */
FZ_FUNCTION void ll_pdf_js_event_init(::pdf_js *js, ::pdf_obj *target, const char *value, int willCommit)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_js_event_init():";
		if (s_trace > 1) std::cerr << " js=" << js;
		if (s_trace > 1) std::cerr << " target=" << target;
		if (value) std::cerr << " value='" << value << "'";
		else std::cerr << " value:null";
		std::cerr << " willCommit=" << willCommit;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::pdf_js_event_init(js, target, value, willCommit);
}

/** Low-level wrapper for `::pdf_js_event_init_keystroke()`. */
FZ_FUNCTION void ll_pdf_js_event_init_keystroke(::pdf_js *js, ::pdf_obj *target, ::pdf_keystroke_event *evt)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_js_event_init_keystroke():";
		if (s_trace > 1) std::cerr << " js=" << js;
		if (s_trace > 1) std::cerr << " target=" << target;
		if (s_trace > 1) std::cerr << " evt=" << evt;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::pdf_js_event_init_keystroke(js, target, evt);
}

/** Low-level wrapper for `::pdf_js_event_result()`. */
FZ_FUNCTION int ll_pdf_js_event_result(::pdf_js *js)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_js_event_result():";
		if (s_trace > 1) std::cerr << " js=" << js;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::pdf_js_event_result(js);
	return ret;
}

/** Low-level wrapper for `::pdf_js_event_result_keystroke()`. */
FZ_FUNCTION int ll_pdf_js_event_result_keystroke(::pdf_js *js, ::pdf_keystroke_event *evt)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_js_event_result_keystroke():";
		if (s_trace > 1) std::cerr << " js=" << js;
		if (s_trace > 1) std::cerr << " evt=" << evt;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::pdf_js_event_result_keystroke(js, evt);
	return ret;
}

/** Low-level wrapper for `::pdf_js_event_result_validate()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_js_event_result_validate(::pdf_js *js)` => `(int, char *newvalue)`
*/
FZ_FUNCTION int ll_pdf_js_event_result_validate(::pdf_js *js, char **newvalue)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_js_event_result_validate():";
		if (s_trace > 1) std::cerr << " js=" << js;
		if (s_trace > 1) std::cerr << " newvalue=" << (void*) newvalue;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::pdf_js_event_result_validate(js, newvalue);
	return ret;
}

/** Low-level wrapper for `::pdf_js_event_value()`. */
FZ_FUNCTION char *ll_pdf_js_event_value(::pdf_js *js)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_js_event_value():";
		if (s_trace > 1) std::cerr << " js=" << js;
		std::cerr << "\n";
	}
	#endif
	char * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::pdf_js_event_value(js);
	return ret;
}

/** Low-level wrapper for `::pdf_js_execute()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_js_execute(::pdf_js *js, const char *name, const char *code)` => char *result
*/
FZ_FUNCTION void ll_pdf_js_execute(::pdf_js *js, const char *name, const char *code, char **result)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_js_execute():";
		if (s_trace > 1) std::cerr << " js=" << js;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		if (code) std::cerr << " code='" << code << "'";
		else std::cerr << " code:null";
		if (s_trace > 1) std::cerr << " result=" << (void*) result;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::pdf_js_execute(js, name, code, result);
}

/** Low-level wrapper for `::pdf_js_get_console()`. */
FZ_FUNCTION ::pdf_js_console *ll_pdf_js_get_console(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_js_get_console():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_js_console * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_js_get_console(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_js_get_console(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_js_set_console()`. */
FZ_FUNCTION void ll_pdf_js_set_console(::pdf_document *doc, ::pdf_js_console *console, void *user)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_js_set_console():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " console=" << console;
		if (s_trace > 1) std::cerr << " user=" << (void*) user;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_js_set_console(auto_ctx, doc, console, user);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_js_set_console(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_js_supported()`. */
FZ_FUNCTION int ll_pdf_js_supported(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_js_supported():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_js_supported(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_js_supported(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_keep_annot()`. */
FZ_FUNCTION ::pdf_annot *ll_pdf_keep_annot(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_keep_annot():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_annot * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_keep_annot(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_keep_annot(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_keep_cmap()`. */
FZ_FUNCTION ::pdf_cmap *ll_pdf_keep_cmap(::pdf_cmap *cmap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_keep_cmap():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " cmap=" << cmap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_cmap * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_keep_cmap(auto_ctx, cmap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_keep_cmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_keep_document()`. */
FZ_FUNCTION ::pdf_document *ll_pdf_keep_document(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_keep_document():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_document * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_keep_document(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_keep_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_keep_font()`. */
FZ_FUNCTION ::pdf_font_desc *ll_pdf_keep_font(::pdf_font_desc *fontdesc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_keep_font():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " fontdesc=" << fontdesc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_font_desc * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_keep_font(auto_ctx, fontdesc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_keep_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_keep_function()`. */
FZ_FUNCTION ::pdf_function *ll_pdf_keep_function(::pdf_function *func)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_keep_function():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " func=" << func;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_function * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_keep_function(auto_ctx, func);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_keep_function(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_keep_graft_map()`. */
FZ_FUNCTION ::pdf_graft_map *ll_pdf_keep_graft_map(::pdf_graft_map *map)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_keep_graft_map():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " map=" << map;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_graft_map * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_keep_graft_map(auto_ctx, map);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_keep_graft_map(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_keep_obj()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_keep_obj(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_keep_obj():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_keep_obj(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_keep_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_keep_page()`. */
FZ_FUNCTION ::pdf_page *ll_pdf_keep_page(::pdf_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_keep_page():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_page * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_keep_page(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_keep_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_keep_pattern()`. */
FZ_FUNCTION ::pdf_pattern *ll_pdf_keep_pattern(::pdf_pattern *pat)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_keep_pattern():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " pat=" << pat;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_pattern * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_keep_pattern(auto_ctx, pat);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_keep_pattern(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_keep_processor()`. */
FZ_FUNCTION ::pdf_processor *ll_pdf_keep_processor(::pdf_processor *proc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_keep_processor():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " proc=" << proc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_processor * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_keep_processor(auto_ctx, proc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_keep_processor(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_keep_widget()`. */
FZ_FUNCTION ::pdf_annot *ll_pdf_keep_widget(::pdf_annot *widget)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace_keepdrop) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_keep_widget():";
		if (s_trace_keepdrop) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace_keepdrop) std::cerr << " widget=" << widget;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_annot * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_keep_widget(auto_ctx, widget);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_keep_widget(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_layer_config_info()`. */
FZ_FUNCTION void ll_pdf_layer_config_info(::pdf_document *doc, int config_num, ::pdf_layer_config *info)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_layer_config_info():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " config_num=" << config_num;
		std::cerr << " info=" << info;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_layer_config_info(auto_ctx, doc, config_num, info);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_layer_config_info(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_layer_config_ui_info()`. */
FZ_FUNCTION void ll_pdf_layer_config_ui_info(::pdf_document *doc, int ui, ::pdf_layer_config_ui *info)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_layer_config_ui_info():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " ui=" << ui;
		std::cerr << " info=" << info;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_layer_config_ui_info(auto_ctx, doc, ui, info);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_layer_config_ui_info(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_layer_is_enabled()`. */
FZ_FUNCTION int ll_pdf_layer_is_enabled(::pdf_document *doc, int layer)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_layer_is_enabled():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " layer=" << layer;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_layer_is_enabled(auto_ctx, doc, layer);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_layer_is_enabled(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_layer_name()`. */
FZ_FUNCTION const char *ll_pdf_layer_name(::pdf_document *doc, int layer)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_layer_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " layer=" << layer;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_layer_name(auto_ctx, doc, layer);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_layer_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_layout_fit_text()`. */
FZ_FUNCTION ::fz_text *ll_pdf_layout_fit_text(::fz_font *font, ::fz_text_language lang, const char *str, ::fz_rect bounds)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_layout_fit_text():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " lang=" << lang;
		if (str) std::cerr << " str='" << str << "'";
		else std::cerr << " str:null";
		std::cerr << " bounds=" << bounds;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_text * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_layout_fit_text(auto_ctx, font, lang, str, bounds);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_layout_fit_text(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_layout_text_widget()`. */
FZ_FUNCTION ::fz_layout_block *ll_pdf_layout_text_widget(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_layout_text_widget():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_layout_block * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_layout_text_widget(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_layout_text_widget(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_lex()`. */
FZ_FUNCTION ::pdf_token ll_pdf_lex(::fz_stream *f, ::pdf_lexbuf *lexbuf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_lex():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " f=" << f;
		if (s_trace > 1) std::cerr << " lexbuf=" << lexbuf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_token ret;
	fz_try(auto_ctx) {
		ret = ::pdf_lex(auto_ctx, f, lexbuf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_lex(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_lex_no_string()`. */
FZ_FUNCTION ::pdf_token ll_pdf_lex_no_string(::fz_stream *f, ::pdf_lexbuf *lexbuf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_lex_no_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " f=" << f;
		if (s_trace > 1) std::cerr << " lexbuf=" << lexbuf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_token ret;
	fz_try(auto_ctx) {
		ret = ::pdf_lex_no_string(auto_ctx, f, lexbuf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_lex_no_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_lexbuf_fin()`. */
FZ_FUNCTION void ll_pdf_lexbuf_fin(::pdf_lexbuf *lexbuf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_lexbuf_fin():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " lexbuf=" << lexbuf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_lexbuf_fin(auto_ctx, lexbuf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_lexbuf_fin(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_lexbuf_grow()`. */
FZ_FUNCTION int ll_pdf_lexbuf_grow(::pdf_lexbuf *lexbuf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_lexbuf_grow():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " lexbuf=" << lexbuf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_lexbuf_grow(auto_ctx, lexbuf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_lexbuf_grow(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_lexbuf_init()`. */
FZ_FUNCTION void ll_pdf_lexbuf_init(::pdf_lexbuf *lexbuf, int size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_lexbuf_init():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " lexbuf=" << lexbuf;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_lexbuf_init(auto_ctx, lexbuf, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_lexbuf_init(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_line_ending_from_name()`. */
FZ_FUNCTION enum pdf_line_ending ll_pdf_line_ending_from_name(::pdf_obj *end)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_line_ending_from_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " end=" << end;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	enum pdf_line_ending ret;
	fz_try(auto_ctx) {
		ret = ::pdf_line_ending_from_name(auto_ctx, end);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_line_ending_from_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_line_ending_from_string()`. */
FZ_FUNCTION enum pdf_line_ending ll_pdf_line_ending_from_string(const char *end)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_line_ending_from_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (end) std::cerr << " end='" << end << "'";
		else std::cerr << " end:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	enum pdf_line_ending ret;
	fz_try(auto_ctx) {
		ret = ::pdf_line_ending_from_string(auto_ctx, end);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_line_ending_from_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_builtin_cmap()`. */
FZ_FUNCTION ::pdf_cmap *ll_pdf_load_builtin_cmap(const char *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_builtin_cmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_cmap * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_builtin_cmap(auto_ctx, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_builtin_cmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_cmap()`. */
FZ_FUNCTION ::pdf_cmap *ll_pdf_load_cmap(::fz_stream *file)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_cmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " file=" << file;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_cmap * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_cmap(auto_ctx, file);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_cmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_colorspace()`. */
FZ_FUNCTION ::fz_colorspace *ll_pdf_load_colorspace(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_colorspace():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_colorspace(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_colorspace(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_compressed_inline_image()`. */
FZ_FUNCTION void ll_pdf_load_compressed_inline_image(::pdf_document *doc, ::pdf_obj *dict, int length, ::fz_stream *cstm, int indexed, ::fz_compressed_image *image)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_compressed_inline_image():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		std::cerr << " length=" << length;
		if (s_trace > 1) std::cerr << " cstm=" << cstm;
		std::cerr << " indexed=" << indexed;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_load_compressed_inline_image(auto_ctx, doc, dict, length, cstm, indexed, image);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_compressed_inline_image(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_load_compressed_stream()`. */
FZ_FUNCTION ::fz_compressed_buffer *ll_pdf_load_compressed_stream(::pdf_document *doc, int num, size_t worst_case)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_compressed_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " num=" << num;
		std::cerr << " worst_case=" << worst_case;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_compressed_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_compressed_stream(auto_ctx, doc, num, worst_case);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_compressed_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_default_colorspaces()`. */
FZ_FUNCTION ::fz_default_colorspaces *ll_pdf_load_default_colorspaces(::pdf_document *doc, ::pdf_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_default_colorspaces():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_default_colorspaces * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_default_colorspaces(auto_ctx, doc, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_default_colorspaces(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_embedded_cmap()`. */
FZ_FUNCTION ::pdf_cmap *ll_pdf_load_embedded_cmap(::pdf_document *doc, ::pdf_obj *ref)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_embedded_cmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " ref=" << ref;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_cmap * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_embedded_cmap(auto_ctx, doc, ref);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_embedded_cmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_embedded_file_contents()`. */
FZ_FUNCTION ::fz_buffer *ll_pdf_load_embedded_file_contents(::pdf_obj *fs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_embedded_file_contents():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " fs=" << fs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_embedded_file_contents(auto_ctx, fs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_embedded_file_contents(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_encoding()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_load_encoding(const char *encoding)` => const char *estrings
*/
FZ_FUNCTION void ll_pdf_load_encoding(const char **estrings, const char *encoding)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_encoding():";
		if (s_trace > 1) std::cerr << " estrings=" << (void*) estrings;
		if (encoding) std::cerr << " encoding='" << encoding << "'";
		else std::cerr << " encoding:null";
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::pdf_load_encoding(estrings, encoding);
}

/** Low-level wrapper for `::pdf_load_field_name()`. */
FZ_FUNCTION char *ll_pdf_load_field_name(::pdf_obj *field)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_field_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " field=" << field;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_field_name(auto_ctx, field);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_field_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}


FZ_FUNCTION std::string ll_pdf_load_field_name2(pdf_obj* field)
{
	char* buffer = ll_pdf_load_field_name( field);
	std::string ret( buffer);
	ll_fz_free( buffer);
	return ret;
}
/** Low-level wrapper for `::pdf_load_font()`. */
FZ_FUNCTION ::pdf_font_desc *ll_pdf_load_font(::pdf_document *doc, ::pdf_obj *rdb, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " rdb=" << rdb;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_font_desc * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_font(auto_ctx, doc, rdb, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_function()`. */
FZ_FUNCTION ::pdf_function *ll_pdf_load_function(::pdf_obj *ref, int in, int out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_function():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " ref=" << ref;
		std::cerr << " in=" << in;
		std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_function * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_function(auto_ctx, ref, in, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_function(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_hail_mary_font()`. */
FZ_FUNCTION ::pdf_font_desc *ll_pdf_load_hail_mary_font(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_hail_mary_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_font_desc * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_hail_mary_font(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_hail_mary_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_image()`. */
FZ_FUNCTION ::fz_image *ll_pdf_load_image(::pdf_document *doc, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_image():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_image * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_image(auto_ctx, doc, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_image(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_inline_image()`. */
FZ_FUNCTION ::fz_image *ll_pdf_load_inline_image(::pdf_document *doc, ::pdf_obj *rdb, ::pdf_obj *dict, ::fz_stream *file)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_inline_image():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " rdb=" << rdb;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		if (s_trace > 1) std::cerr << " file=" << file;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_image * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_inline_image(auto_ctx, doc, rdb, dict, file);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_inline_image(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_journal()`. */
FZ_FUNCTION void ll_pdf_load_journal(::pdf_document *doc, const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_journal():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_load_journal(auto_ctx, doc, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_journal(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_load_link_annots()`. */
FZ_FUNCTION ::fz_link *ll_pdf_load_link_annots(::pdf_document *arg_1, ::pdf_page *arg_2, ::pdf_obj *annots, int pagenum, ::fz_matrix page_ctm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_link_annots():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " arg_1=" << arg_1;
		if (s_trace > 1) std::cerr << " arg_2=" << arg_2;
		if (s_trace > 1) std::cerr << " annots=" << annots;
		std::cerr << " pagenum=" << pagenum;
		std::cerr << " page_ctm=" << page_ctm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_link * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_link_annots(auto_ctx, arg_1, arg_2, annots, pagenum, page_ctm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_link_annots(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_links()`. */
FZ_FUNCTION ::fz_link *ll_pdf_load_links(::pdf_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_links():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_link * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_links(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_links(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_name_tree()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_load_name_tree(::pdf_document *doc, ::pdf_obj *which)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_name_tree():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " which=" << which;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_name_tree(auto_ctx, doc, which);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_name_tree(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_object()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_load_object(::pdf_document *doc, int num)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_object():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " num=" << num;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_object(auto_ctx, doc, num);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_object(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_outline()`. */
FZ_FUNCTION ::fz_outline *ll_pdf_load_outline(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_outline():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_outline * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_outline(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_outline(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_page()`. */
FZ_FUNCTION ::pdf_page *ll_pdf_load_page(::pdf_document *doc, int number)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " number=" << number;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_page * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_page(auto_ctx, doc, number);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_page_imp()`. */
FZ_FUNCTION ::fz_page *ll_pdf_load_page_imp(::fz_document *doc, int chapter, int number)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_page_imp():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " chapter=" << chapter;
		std::cerr << " number=" << number;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_page * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_page_imp(auto_ctx, doc, chapter, number);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_page_imp(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_page_tree()`. */
FZ_FUNCTION void ll_pdf_load_page_tree(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_page_tree():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_load_page_tree(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_page_tree(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_load_pattern()`. */
FZ_FUNCTION ::pdf_pattern *ll_pdf_load_pattern(::pdf_document *doc, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_pattern():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_pattern * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_pattern(auto_ctx, doc, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_pattern(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_raw_stream()`. */
FZ_FUNCTION ::fz_buffer *ll_pdf_load_raw_stream(::pdf_obj *ref)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_raw_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " ref=" << ref;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_raw_stream(auto_ctx, ref);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_raw_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_raw_stream_number()`. */
FZ_FUNCTION ::fz_buffer *ll_pdf_load_raw_stream_number(::pdf_document *doc, int num)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_raw_stream_number():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " num=" << num;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_raw_stream_number(auto_ctx, doc, num);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_raw_stream_number(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_shading()`. */
FZ_FUNCTION ::fz_shade *ll_pdf_load_shading(::pdf_document *doc, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_shading():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_shade * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_shading(auto_ctx, doc, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_shading(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_stream()`. */
FZ_FUNCTION ::fz_buffer *ll_pdf_load_stream(::pdf_obj *ref)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " ref=" << ref;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_stream(auto_ctx, ref);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_stream_number()`. */
FZ_FUNCTION ::fz_buffer *ll_pdf_load_stream_number(::pdf_document *doc, int num)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_stream_number():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " num=" << num;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_buffer * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_stream_number(auto_ctx, doc, num);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_stream_number(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_stream_or_string_as_utf8()`. */
FZ_FUNCTION char *ll_pdf_load_stream_or_string_as_utf8(::pdf_obj *src)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_stream_or_string_as_utf8():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " src=" << src;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_stream_or_string_as_utf8(auto_ctx, src);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_stream_or_string_as_utf8(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_system_cmap()`. */
FZ_FUNCTION ::pdf_cmap *ll_pdf_load_system_cmap(const char *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_system_cmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_cmap * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_system_cmap(auto_ctx, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_system_cmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_to_unicode()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_load_to_unicode(::pdf_document *doc, ::pdf_font_desc *font, char *collection, ::pdf_obj *cmapstm)` => const char *strings
*/
FZ_FUNCTION void ll_pdf_load_to_unicode(::pdf_document *doc, ::pdf_font_desc *font, const char **strings, char *collection, ::pdf_obj *cmapstm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_to_unicode():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " font=" << font;
		if (s_trace > 1) std::cerr << " strings=" << (void*) strings;
		if (s_trace > 1) std::cerr << " collection=" << (void*) collection;
		if (s_trace > 1) std::cerr << " cmapstm=" << cmapstm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_load_to_unicode(auto_ctx, doc, font, strings, collection, cmapstm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_to_unicode(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_load_type3_font()`. */
FZ_FUNCTION ::pdf_font_desc *ll_pdf_load_type3_font(::pdf_document *doc, ::pdf_obj *rdb, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_type3_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " rdb=" << rdb;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_font_desc * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_type3_font(auto_ctx, doc, rdb, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_type3_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_load_type3_glyphs()`. */
FZ_FUNCTION void ll_pdf_load_type3_glyphs(::pdf_document *doc, ::pdf_font_desc *fontdesc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_type3_glyphs():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " fontdesc=" << fontdesc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_load_type3_glyphs(auto_ctx, doc, fontdesc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_type3_glyphs(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_load_unencrypted_object()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_load_unencrypted_object(::pdf_document *doc, int num)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_load_unencrypted_object():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " num=" << num;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_load_unencrypted_object(auto_ctx, doc, num);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_load_unencrypted_object(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_lookup_cmap()`. */
FZ_FUNCTION int ll_pdf_lookup_cmap(::pdf_cmap *cmap, unsigned int cpt)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_lookup_cmap():";
		if (s_trace > 1) std::cerr << " cmap=" << cmap;
		std::cerr << " cpt=" << cpt;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::pdf_lookup_cmap(cmap, cpt);
	return ret;
}

/** Low-level wrapper for `::pdf_lookup_cmap_full()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_lookup_cmap_full(::pdf_cmap *cmap, unsigned int cpt)` => `(int, int out)`
*/
FZ_FUNCTION int ll_pdf_lookup_cmap_full(::pdf_cmap *cmap, unsigned int cpt, int *out)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_lookup_cmap_full():";
		if (s_trace > 1) std::cerr << " cmap=" << cmap;
		std::cerr << " cpt=" << cpt;
		if (s_trace > 1) std::cerr << " out=" << (void*) out;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::pdf_lookup_cmap_full(cmap, cpt, out);
	return ret;
}

/** Low-level wrapper for `::pdf_lookup_dest()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_lookup_dest(::pdf_document *doc, ::pdf_obj *needle)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_lookup_dest():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " needle=" << needle;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_lookup_dest(auto_ctx, doc, needle);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_lookup_dest(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_lookup_field()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_lookup_field(::pdf_obj *form, const char *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_lookup_field():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " form=" << form;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_lookup_field(auto_ctx, form, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_lookup_field(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_lookup_hmtx()`. */
FZ_FUNCTION ::pdf_hmtx ll_pdf_lookup_hmtx(::pdf_font_desc *font, int cid)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_lookup_hmtx():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " cid=" << cid;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_hmtx ret;
	fz_try(auto_ctx) {
		ret = ::pdf_lookup_hmtx(auto_ctx, font, cid);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_lookup_hmtx(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_lookup_metadata()`. */
FZ_FUNCTION int ll_pdf_lookup_metadata(::pdf_document *doc, const char *key, char *ptr, int size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_lookup_metadata():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (key) std::cerr << " key='" << key << "'";
		else std::cerr << " key:null";
		if (s_trace > 1) std::cerr << " ptr=" << (void*) ptr;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_lookup_metadata(auto_ctx, doc, key, ptr, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_lookup_metadata(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_lookup_metadata2()`. */
FZ_FUNCTION std::string ll_pdf_lookup_metadata2(::pdf_document *doc, const char *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_lookup_metadata2():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (key) std::cerr << " key='" << key << "'";
		else std::cerr << " key:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	std::string ret;
	fz_try(auto_ctx) {
		ret = ::pdf_lookup_metadata2(auto_ctx, doc, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_lookup_metadata2(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_lookup_name()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_lookup_name(::pdf_document *doc, ::pdf_obj *which, ::pdf_obj *needle)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_lookup_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " which=" << which;
		if (s_trace > 1) std::cerr << " needle=" << needle;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_lookup_name(auto_ctx, doc, which, needle);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_lookup_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_lookup_number()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_lookup_number(::pdf_obj *root, int needle)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_lookup_number():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " root=" << root;
		std::cerr << " needle=" << needle;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_lookup_number(auto_ctx, root, needle);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_lookup_number(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_lookup_page_loc()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_lookup_page_loc(::pdf_document *doc, int needle, ::pdf_obj **parentp)` => `(pdf_obj *, int indexp)`
*/
FZ_FUNCTION ::pdf_obj *ll_pdf_lookup_page_loc(::pdf_document *doc, int needle, ::pdf_obj **parentp, int *indexp)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_lookup_page_loc():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " needle=" << needle;
		if (s_trace > 1) std::cerr << " parentp=" << (void*) parentp;
		if (s_trace > 1) std::cerr << " indexp=" << (void*) indexp;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_lookup_page_loc(auto_ctx, doc, needle, parentp, indexp);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_lookup_page_loc(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_lookup_page_number()`. */
FZ_FUNCTION int ll_pdf_lookup_page_number(::pdf_document *doc, ::pdf_obj *pageobj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_lookup_page_number():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " pageobj=" << pageobj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_lookup_page_number(auto_ctx, doc, pageobj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_lookup_page_number(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_lookup_page_obj()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_lookup_page_obj(::pdf_document *doc, int needle)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_lookup_page_obj():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " needle=" << needle;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_lookup_page_obj(auto_ctx, doc, needle);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_lookup_page_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_lookup_substitute_font()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_lookup_substitute_font(int mono, int serif, int bold, int italic)` => `(const unsigned char *, int len)`
*/
FZ_FUNCTION const unsigned char *ll_pdf_lookup_substitute_font(int mono, int serif, int bold, int italic, int *len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_lookup_substitute_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " mono=" << mono;
		std::cerr << " serif=" << serif;
		std::cerr << " bold=" << bold;
		std::cerr << " italic=" << italic;
		if (s_trace > 1) std::cerr << " len=" << (void*) len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const unsigned char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_lookup_substitute_font(auto_ctx, mono, serif, bold, italic, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_lookup_substitute_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_lookup_vmtx()`. */
FZ_FUNCTION ::pdf_vmtx ll_pdf_lookup_vmtx(::pdf_font_desc *font, int cid)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_lookup_vmtx():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " cid=" << cid;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_vmtx ret;
	fz_try(auto_ctx) {
		ret = ::pdf_lookup_vmtx(auto_ctx, font, cid);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_lookup_vmtx(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_map_one_to_many()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_map_one_to_many(::pdf_cmap *cmap, unsigned int one, size_t len)` => int many
*/
FZ_FUNCTION void ll_pdf_map_one_to_many(::pdf_cmap *cmap, unsigned int one, int *many, size_t len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_map_one_to_many():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cmap=" << cmap;
		std::cerr << " one=" << one;
		if (s_trace > 1) std::cerr << " many=" << (void*) many;
		std::cerr << " len=" << len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_map_one_to_many(auto_ctx, cmap, one, many, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_map_one_to_many(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_map_range_to_range()`. */
FZ_FUNCTION void ll_pdf_map_range_to_range(::pdf_cmap *cmap, unsigned int srclo, unsigned int srchi, int dstlo)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_map_range_to_range():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cmap=" << cmap;
		std::cerr << " srclo=" << srclo;
		std::cerr << " srchi=" << srchi;
		std::cerr << " dstlo=" << dstlo;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_map_range_to_range(auto_ctx, cmap, srclo, srchi, dstlo);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_map_range_to_range(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_mark_bits_reset()`. */
FZ_FUNCTION void ll_pdf_mark_bits_reset(::pdf_mark_bits *marks)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_mark_bits_reset():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " marks=" << marks;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_mark_bits_reset(auto_ctx, marks);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_mark_bits_reset(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_mark_bits_set()`. */
FZ_FUNCTION int ll_pdf_mark_bits_set(::pdf_mark_bits *marks, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_mark_bits_set():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " marks=" << marks;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_mark_bits_set(auto_ctx, marks, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_mark_bits_set(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_mark_list_check()`. */
FZ_FUNCTION int ll_pdf_mark_list_check(::pdf_mark_list *list, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_mark_list_check():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " list=" << list;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_mark_list_check(auto_ctx, list, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_mark_list_check(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_mark_list_free()`. */
FZ_FUNCTION void ll_pdf_mark_list_free(::pdf_mark_list *list)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_mark_list_free():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " list=" << list;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_mark_list_free(auto_ctx, list);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_mark_list_free(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_mark_list_init()`. */
FZ_FUNCTION void ll_pdf_mark_list_init(::pdf_mark_list *list)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_mark_list_init():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " list=" << list;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_mark_list_init(auto_ctx, list);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_mark_list_init(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_mark_list_pop()`. */
FZ_FUNCTION void ll_pdf_mark_list_pop(::pdf_mark_list *list)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_mark_list_pop():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " list=" << list;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_mark_list_pop(auto_ctx, list);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_mark_list_pop(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_mark_list_push()`. */
FZ_FUNCTION int ll_pdf_mark_list_push(::pdf_mark_list *list, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_mark_list_push():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " list=" << list;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_mark_list_push(auto_ctx, list, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_mark_list_push(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_mark_obj()`. */
FZ_FUNCTION int ll_pdf_mark_obj(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_mark_obj():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_mark_obj(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_mark_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_mark_xref()`. */
FZ_FUNCTION void ll_pdf_mark_xref(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_mark_xref():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_mark_xref(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_mark_xref(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_metadata()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_metadata(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_metadata():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_metadata(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_metadata(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_minimize_document()`. */
FZ_FUNCTION void ll_pdf_minimize_document(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_minimize_document():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_minimize_document(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_minimize_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_name_eq()`. */
FZ_FUNCTION int ll_pdf_name_eq(::pdf_obj *a, ::pdf_obj *b)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_name_eq():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " a=" << a;
		if (s_trace > 1) std::cerr << " b=" << b;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_name_eq(auto_ctx, a, b);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_name_eq(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_name_from_intent()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_name_from_intent(enum pdf_intent intent)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_name_from_intent():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " intent=" << intent;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_name_from_intent(auto_ctx, intent);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_name_from_intent(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_name_from_line_ending()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_name_from_line_ending(enum pdf_line_ending end)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_name_from_line_ending():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " end=" << end;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_name_from_line_ending(auto_ctx, end);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_name_from_line_ending(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_needs_password()`. */
FZ_FUNCTION int ll_pdf_needs_password(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_needs_password():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_needs_password(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_needs_password(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_action_from_link()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_new_action_from_link(::pdf_document *doc, const char *uri)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_action_from_link():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (uri) std::cerr << " uri='" << uri << "'";
		else std::cerr << " uri:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_action_from_link(auto_ctx, doc, uri);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_action_from_link(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_array()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_new_array(::pdf_document *doc, int initialcap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_array():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " initialcap=" << initialcap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_array(auto_ctx, doc, initialcap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_array(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_buffer_processor()`. */
FZ_FUNCTION ::pdf_processor *ll_pdf_new_buffer_processor(::fz_buffer *buffer, int ahxencode, int newlines)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_buffer_processor():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buffer=" << buffer;
		std::cerr << " ahxencode=" << ahxencode;
		std::cerr << " newlines=" << newlines;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_processor * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_buffer_processor(auto_ctx, buffer, ahxencode, newlines);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_buffer_processor(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_cmap()`. */
FZ_FUNCTION ::pdf_cmap *ll_pdf_new_cmap()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_cmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_cmap * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_cmap(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_cmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_color_filter()`. */
FZ_FUNCTION ::pdf_processor *ll_pdf_new_color_filter(::pdf_document *doc, ::pdf_processor *chain, int struct_parents, ::fz_matrix transform, ::pdf_filter_options *options, void *copts)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_color_filter():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << " struct_parents=" << struct_parents;
		std::cerr << " transform=" << transform;
		std::cerr << " options=" << options;
		if (s_trace > 1) std::cerr << " copts=" << (void*) copts;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_processor * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_color_filter(auto_ctx, doc, chain, struct_parents, transform, options, copts);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_color_filter(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_crypt()`. */
FZ_FUNCTION ::pdf_crypt *ll_pdf_new_crypt(::pdf_obj *enc, ::pdf_obj *id)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_crypt():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " enc=" << enc;
		if (s_trace > 1) std::cerr << " id=" << id;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_crypt * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_crypt(auto_ctx, enc, id);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_crypt(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_date()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_new_date(::pdf_document *doc, int64_t time)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_date():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " time=" << time;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_date(auto_ctx, doc, time);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_date(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_dest_from_link()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_new_dest_from_link(::pdf_document *doc, const char *uri, int is_remote)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_dest_from_link():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (uri) std::cerr << " uri='" << uri << "'";
		else std::cerr << " uri:null";
		std::cerr << " is_remote=" << is_remote;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_dest_from_link(auto_ctx, doc, uri, is_remote);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_dest_from_link(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_dict()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_new_dict(::pdf_document *doc, int initialcap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_dict():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " initialcap=" << initialcap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_dict(auto_ctx, doc, initialcap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_dict(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_display_list_from_annot()`. */
FZ_FUNCTION ::fz_display_list *ll_pdf_new_display_list_from_annot(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_display_list_from_annot():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_display_list * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_display_list_from_annot(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_display_list_from_annot(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_encrypt()`. */
FZ_FUNCTION ::pdf_crypt *ll_pdf_new_encrypt(const char *opwd_utf8, const char *upwd_utf8, ::pdf_obj *id, int permissions, int algorithm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_encrypt():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (opwd_utf8) std::cerr << " opwd_utf8='" << opwd_utf8 << "'";
		else std::cerr << " opwd_utf8:null";
		if (upwd_utf8) std::cerr << " upwd_utf8='" << upwd_utf8 << "'";
		else std::cerr << " upwd_utf8:null";
		if (s_trace > 1) std::cerr << " id=" << id;
		std::cerr << " permissions=" << permissions;
		std::cerr << " algorithm=" << algorithm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_crypt * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_encrypt(auto_ctx, opwd_utf8, upwd_utf8, id, permissions, algorithm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_encrypt(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_font_desc()`. */
FZ_FUNCTION ::pdf_font_desc *ll_pdf_new_font_desc()
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_font_desc():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_font_desc * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_font_desc(auto_ctx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_font_desc(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_graft_map()`. */
FZ_FUNCTION ::pdf_graft_map *ll_pdf_new_graft_map(::pdf_document *dst)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_graft_map():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dst=" << dst;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_graft_map * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_graft_map(auto_ctx, dst);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_graft_map(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_identity_cmap()`. */
FZ_FUNCTION ::pdf_cmap *ll_pdf_new_identity_cmap(int wmode, int bytes)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_identity_cmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " wmode=" << wmode;
		std::cerr << " bytes=" << bytes;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_cmap * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_identity_cmap(auto_ctx, wmode, bytes);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_identity_cmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_indirect()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_new_indirect(::pdf_document *doc, int num, int gen)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_indirect():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " num=" << num;
		std::cerr << " gen=" << gen;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_indirect(auto_ctx, doc, num, gen);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_indirect(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_int()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_new_int(int64_t i)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_int():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " i=" << i;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_int(auto_ctx, i);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_int(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_link()`. */
FZ_FUNCTION ::fz_link *ll_pdf_new_link(::pdf_page *page, ::fz_rect rect, const char *uri, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_link():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " rect=" << rect;
		if (uri) std::cerr << " uri='" << uri << "'";
		else std::cerr << " uri:null";
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_link * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_link(auto_ctx, page, rect, uri, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_link(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_local_xref()`. */
FZ_FUNCTION ::pdf_xref *ll_pdf_new_local_xref(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_local_xref():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_xref * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_local_xref(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_local_xref(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_mark_bits()`. */
FZ_FUNCTION ::pdf_mark_bits *ll_pdf_new_mark_bits(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_mark_bits():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_mark_bits * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_mark_bits(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_mark_bits(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_matrix()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_new_matrix(::pdf_document *doc, ::fz_matrix mtx)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_matrix():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " mtx=" << mtx;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_matrix(auto_ctx, doc, mtx);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_matrix(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_name()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_new_name(const char *str)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (str) std::cerr << " str='" << str << "'";
		else std::cerr << " str:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_name(auto_ctx, str);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_outline_iterator()`. */
FZ_FUNCTION ::fz_outline_iterator *ll_pdf_new_outline_iterator(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_outline_iterator():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_outline_iterator * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_outline_iterator(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_outline_iterator(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_output_processor()`. */
FZ_FUNCTION ::pdf_processor *ll_pdf_new_output_processor(::fz_output *out, int ahxencode, int newlines)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_output_processor():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " ahxencode=" << ahxencode;
		std::cerr << " newlines=" << newlines;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_processor * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_output_processor(auto_ctx, out, ahxencode, newlines);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_output_processor(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_pdf_device()`. */
FZ_FUNCTION ::fz_device *ll_pdf_new_pdf_device(::pdf_document *doc, ::fz_matrix topctm, ::pdf_obj *resources, ::fz_buffer *contents)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_pdf_device():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " topctm=" << topctm;
		if (s_trace > 1) std::cerr << " resources=" << resources;
		if (s_trace > 1) std::cerr << " contents=" << contents;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_device * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_pdf_device(auto_ctx, doc, topctm, resources, contents);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_pdf_device(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_pixmap_from_annot()`. */
FZ_FUNCTION ::fz_pixmap *ll_pdf_new_pixmap_from_annot(::pdf_annot *annot, ::fz_matrix ctm, ::fz_colorspace *cs, ::fz_separations *seps, int alpha)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_pixmap_from_annot():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		if (s_trace > 1) std::cerr << " seps=" << seps;
		std::cerr << " alpha=" << alpha;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_pixmap_from_annot(auto_ctx, annot, ctm, cs, seps, alpha);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_pixmap_from_annot(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_pixmap_from_page_contents_with_separations_and_usage()`. */
FZ_FUNCTION ::fz_pixmap *ll_pdf_new_pixmap_from_page_contents_with_separations_and_usage(::pdf_page *page, ::fz_matrix ctm, ::fz_colorspace *cs, ::fz_separations *seps, int alpha, const char *usage, ::fz_box_type box)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_pixmap_from_page_contents_with_separations_and_usage():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		if (s_trace > 1) std::cerr << " seps=" << seps;
		std::cerr << " alpha=" << alpha;
		if (usage) std::cerr << " usage='" << usage << "'";
		else std::cerr << " usage:null";
		std::cerr << " box=" << box;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_pixmap_from_page_contents_with_separations_and_usage(auto_ctx, page, ctm, cs, seps, alpha, usage, box);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_pixmap_from_page_contents_with_separations_and_usage(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_pixmap_from_page_contents_with_usage()`. */
FZ_FUNCTION ::fz_pixmap *ll_pdf_new_pixmap_from_page_contents_with_usage(::pdf_page *page, ::fz_matrix ctm, ::fz_colorspace *cs, int alpha, const char *usage, ::fz_box_type box)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_pixmap_from_page_contents_with_usage():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << " alpha=" << alpha;
		if (usage) std::cerr << " usage='" << usage << "'";
		else std::cerr << " usage:null";
		std::cerr << " box=" << box;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_pixmap_from_page_contents_with_usage(auto_ctx, page, ctm, cs, alpha, usage, box);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_pixmap_from_page_contents_with_usage(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_pixmap_from_page_with_separations_and_usage()`. */
FZ_FUNCTION ::fz_pixmap *ll_pdf_new_pixmap_from_page_with_separations_and_usage(::pdf_page *page, ::fz_matrix ctm, ::fz_colorspace *cs, ::fz_separations *seps, int alpha, const char *usage, ::fz_box_type box)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_pixmap_from_page_with_separations_and_usage():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		if (s_trace > 1) std::cerr << " seps=" << seps;
		std::cerr << " alpha=" << alpha;
		if (usage) std::cerr << " usage='" << usage << "'";
		else std::cerr << " usage:null";
		std::cerr << " box=" << box;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_pixmap_from_page_with_separations_and_usage(auto_ctx, page, ctm, cs, seps, alpha, usage, box);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_pixmap_from_page_with_separations_and_usage(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_pixmap_from_page_with_usage()`. */
FZ_FUNCTION ::fz_pixmap *ll_pdf_new_pixmap_from_page_with_usage(::pdf_page *page, ::fz_matrix ctm, ::fz_colorspace *cs, int alpha, const char *usage, ::fz_box_type box)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_pixmap_from_page_with_usage():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " cs=" << cs;
		std::cerr << " alpha=" << alpha;
		if (usage) std::cerr << " usage='" << usage << "'";
		else std::cerr << " usage:null";
		std::cerr << " box=" << box;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_pixmap_from_page_with_usage(auto_ctx, page, ctm, cs, alpha, usage, box);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_pixmap_from_page_with_usage(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_processor()`. */
FZ_FUNCTION void *ll_pdf_new_processor(int size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_processor():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	void * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_processor(auto_ctx, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_processor(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_real()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_new_real(float f)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_real():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " f=" << f;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_real(auto_ctx, f);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_real(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_rect()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_new_rect(::pdf_document *doc, ::fz_rect rect)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_rect():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " rect=" << rect;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_rect(auto_ctx, doc, rect);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_rect(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_run_processor()`. */
FZ_FUNCTION ::pdf_processor *ll_pdf_new_run_processor(::pdf_document *doc, ::fz_device *dev, ::fz_matrix ctm, int struct_parent, const char *usage, ::pdf_gstate *gstate, ::fz_default_colorspaces *default_cs, ::fz_cookie *cookie)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_run_processor():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " ctm=" << ctm;
		std::cerr << " struct_parent=" << struct_parent;
		if (usage) std::cerr << " usage='" << usage << "'";
		else std::cerr << " usage:null";
		if (s_trace > 1) std::cerr << " gstate=" << gstate;
		if (s_trace > 1) std::cerr << " default_cs=" << default_cs;
		std::cerr << " cookie=" << cookie;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_processor * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_run_processor(auto_ctx, doc, dev, ctm, struct_parent, usage, gstate, default_cs, cookie);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_run_processor(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_sanitize_filter()`. */
FZ_FUNCTION ::pdf_processor *ll_pdf_new_sanitize_filter(::pdf_document *doc, ::pdf_processor *chain, int struct_parents, ::fz_matrix transform, ::pdf_filter_options *options, void *sopts)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_sanitize_filter():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		std::cerr << " struct_parents=" << struct_parents;
		std::cerr << " transform=" << transform;
		std::cerr << " options=" << options;
		if (s_trace > 1) std::cerr << " sopts=" << (void*) sopts;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_processor * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_sanitize_filter(auto_ctx, doc, chain, struct_parents, transform, options, sopts);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_sanitize_filter(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_stext_page_from_annot()`. */
FZ_FUNCTION ::fz_stext_page *ll_pdf_new_stext_page_from_annot(::pdf_annot *annot, const ::fz_stext_options *options)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_stext_page_from_annot():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " options=" << options;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stext_page * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_stext_page_from_annot(auto_ctx, annot, options);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_stext_page_from_annot(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_string()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_new_string(const char *str, size_t len)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (str) std::cerr << " str='" << str << "'";
		else std::cerr << " str:null";
		std::cerr << " len=" << len;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_string(auto_ctx, str, len);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_text_string()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_new_text_string(const char *s)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_text_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s) std::cerr << " s='" << s << "'";
		else std::cerr << " s:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_text_string(auto_ctx, s);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_text_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_uri_from_explicit_dest()`. */
FZ_FUNCTION char *ll_pdf_new_uri_from_explicit_dest(::fz_link_dest dest)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_uri_from_explicit_dest():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " &dest=" << &dest;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_uri_from_explicit_dest(auto_ctx, dest);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_uri_from_explicit_dest(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_uri_from_path_and_explicit_dest()`. */
FZ_FUNCTION char *ll_pdf_new_uri_from_path_and_explicit_dest(const char *path, ::fz_link_dest dest)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_uri_from_path_and_explicit_dest():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		std::cerr << " &dest=" << &dest;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_uri_from_path_and_explicit_dest(auto_ctx, path, dest);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_uri_from_path_and_explicit_dest(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_uri_from_path_and_named_dest()`. */
FZ_FUNCTION char *ll_pdf_new_uri_from_path_and_named_dest(const char *path, const char *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_uri_from_path_and_named_dest():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (path) std::cerr << " path='" << path << "'";
		else std::cerr << " path:null";
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_uri_from_path_and_named_dest(auto_ctx, path, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_uri_from_path_and_named_dest(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_utf8_from_pdf_stream_obj()`. */
FZ_FUNCTION char *ll_pdf_new_utf8_from_pdf_stream_obj(::pdf_obj *src)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_utf8_from_pdf_stream_obj():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " src=" << src;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_utf8_from_pdf_stream_obj(auto_ctx, src);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_utf8_from_pdf_stream_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_utf8_from_pdf_string()`. */
FZ_FUNCTION char *ll_pdf_new_utf8_from_pdf_string(const char *srcptr, size_t srclen)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_utf8_from_pdf_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (srcptr) std::cerr << " srcptr='" << srcptr << "'";
		else std::cerr << " srcptr:null";
		std::cerr << " srclen=" << srclen;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_utf8_from_pdf_string(auto_ctx, srcptr, srclen);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_utf8_from_pdf_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_utf8_from_pdf_string_obj()`. */
FZ_FUNCTION char *ll_pdf_new_utf8_from_pdf_string_obj(::pdf_obj *src)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_utf8_from_pdf_string_obj():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " src=" << src;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_utf8_from_pdf_string_obj(auto_ctx, src);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_utf8_from_pdf_string_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_new_xobject()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_new_xobject(::pdf_document *doc, ::fz_rect bbox, ::fz_matrix matrix, ::pdf_obj *res, ::fz_buffer *buffer)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_new_xobject():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " bbox=" << bbox;
		std::cerr << " matrix=" << matrix;
		if (s_trace > 1) std::cerr << " res=" << res;
		if (s_trace > 1) std::cerr << " buffer=" << buffer;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_new_xobject(auto_ctx, doc, bbox, matrix, res, buffer);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_new_xobject(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_next_annot()`. */
FZ_FUNCTION ::pdf_annot *ll_pdf_next_annot(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_next_annot():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_annot * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_next_annot(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_next_annot(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_next_widget()`. */
FZ_FUNCTION ::pdf_annot *ll_pdf_next_widget(::pdf_annot *previous)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_next_widget():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " previous=" << previous;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_annot * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_next_widget(auto_ctx, previous);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_next_widget(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_obj_is_dirty()`. */
FZ_FUNCTION int ll_pdf_obj_is_dirty(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_obj_is_dirty():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_obj_is_dirty(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_obj_is_dirty(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_obj_is_incremental()`. */
FZ_FUNCTION int ll_pdf_obj_is_incremental(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_obj_is_incremental():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_obj_is_incremental(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_obj_is_incremental(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_obj_marked()`. */
FZ_FUNCTION int ll_pdf_obj_marked(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_obj_marked():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_obj_marked(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_obj_marked(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_obj_memo()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_obj_memo(::pdf_obj *obj, int bit)` => `(int, int memo)`
*/
FZ_FUNCTION int ll_pdf_obj_memo(::pdf_obj *obj, int bit, int *memo)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_obj_memo():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << " bit=" << bit;
		if (s_trace > 1) std::cerr << " memo=" << (void*) memo;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_obj_memo(auto_ctx, obj, bit, memo);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_obj_memo(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_obj_num_is_stream()`. */
FZ_FUNCTION int ll_pdf_obj_num_is_stream(::pdf_document *doc, int num)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_obj_num_is_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " num=" << num;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_obj_num_is_stream(auto_ctx, doc, num);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_obj_num_is_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_obj_parent_num()`. */
FZ_FUNCTION int ll_pdf_obj_parent_num(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_obj_parent_num():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_obj_parent_num(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_obj_parent_num(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_obj_refs()`. */
FZ_FUNCTION int ll_pdf_obj_refs(::pdf_obj *ref)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_obj_refs():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " ref=" << ref;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_obj_refs(auto_ctx, ref);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_obj_refs(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_objcmp()`. */
FZ_FUNCTION int ll_pdf_objcmp(::pdf_obj *a, ::pdf_obj *b)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_objcmp():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " a=" << a;
		if (s_trace > 1) std::cerr << " b=" << b;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_objcmp(auto_ctx, a, b);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_objcmp(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_objcmp_deep()`. */
FZ_FUNCTION int ll_pdf_objcmp_deep(::pdf_obj *a, ::pdf_obj *b)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_objcmp_deep():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " a=" << a;
		if (s_trace > 1) std::cerr << " b=" << b;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_objcmp_deep(auto_ctx, a, b);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_objcmp_deep(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_objcmp_resolve()`. */
FZ_FUNCTION int ll_pdf_objcmp_resolve(::pdf_obj *a, ::pdf_obj *b)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_objcmp_resolve():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " a=" << a;
		if (s_trace > 1) std::cerr << " b=" << b;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_objcmp_resolve(auto_ctx, a, b);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_objcmp_resolve(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_open_contents_stream()`. */
FZ_FUNCTION ::fz_stream *ll_pdf_open_contents_stream(::pdf_document *doc, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_open_contents_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_open_contents_stream(auto_ctx, doc, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_open_contents_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_open_crypt()`. */
FZ_FUNCTION ::fz_stream *ll_pdf_open_crypt(::fz_stream *chain, ::pdf_crypt *crypt, int num, int gen)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_open_crypt():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		std::cerr << " num=" << num;
		std::cerr << " gen=" << gen;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_open_crypt(auto_ctx, chain, crypt, num, gen);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_open_crypt(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_open_crypt_with_filter()`. */
FZ_FUNCTION ::fz_stream *ll_pdf_open_crypt_with_filter(::fz_stream *chain, ::pdf_crypt *crypt, ::pdf_obj *name, int num, int gen)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_open_crypt_with_filter():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		if (s_trace > 1) std::cerr << " name=" << name;
		std::cerr << " num=" << num;
		std::cerr << " gen=" << gen;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_open_crypt_with_filter(auto_ctx, chain, crypt, name, num, gen);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_open_crypt_with_filter(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_open_document()`. */
FZ_FUNCTION ::pdf_document *ll_pdf_open_document(const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_open_document():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_document * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_open_document(auto_ctx, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_open_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_open_document_with_stream()`. */
FZ_FUNCTION ::pdf_document *ll_pdf_open_document_with_stream(::fz_stream *file)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_open_document_with_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " file=" << file;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_document * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_open_document_with_stream(auto_ctx, file);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_open_document_with_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_open_inline_stream()`. */
FZ_FUNCTION ::fz_stream *ll_pdf_open_inline_stream(::pdf_document *doc, ::pdf_obj *stmobj, int length, ::fz_stream *chain, ::fz_compression_params *params)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_open_inline_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " stmobj=" << stmobj;
		std::cerr << " length=" << length;
		if (s_trace > 1) std::cerr << " chain=" << chain;
		if (s_trace > 1) std::cerr << " params=" << params;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_open_inline_stream(auto_ctx, doc, stmobj, length, chain, params);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_open_inline_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_open_raw_stream()`. */
FZ_FUNCTION ::fz_stream *ll_pdf_open_raw_stream(::pdf_obj *ref)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_open_raw_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " ref=" << ref;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_open_raw_stream(auto_ctx, ref);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_open_raw_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_open_raw_stream_number()`. */
FZ_FUNCTION ::fz_stream *ll_pdf_open_raw_stream_number(::pdf_document *doc, int num)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_open_raw_stream_number():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " num=" << num;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_open_raw_stream_number(auto_ctx, doc, num);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_open_raw_stream_number(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_open_stream()`. */
FZ_FUNCTION ::fz_stream *ll_pdf_open_stream(::pdf_obj *ref)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_open_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " ref=" << ref;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_open_stream(auto_ctx, ref);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_open_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_open_stream_number()`. */
FZ_FUNCTION ::fz_stream *ll_pdf_open_stream_number(::pdf_document *doc, int num)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_open_stream_number():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " num=" << num;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_open_stream_number(auto_ctx, doc, num);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_open_stream_number(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_open_stream_with_offset()`. */
FZ_FUNCTION ::fz_stream *ll_pdf_open_stream_with_offset(::pdf_document *doc, int num, ::pdf_obj *dict, int64_t stm_ofs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_open_stream_with_offset():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " num=" << num;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		std::cerr << " stm_ofs=" << stm_ofs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_open_stream_with_offset(auto_ctx, doc, num, dict, stm_ofs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_open_stream_with_offset(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_page_contents()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_page_contents(::pdf_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_page_contents():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_page_contents(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_page_contents(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_page_event_close()`. */
FZ_FUNCTION void ll_pdf_page_event_close(::pdf_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_page_event_close():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_page_event_close(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_page_event_close(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_page_event_open()`. */
FZ_FUNCTION void ll_pdf_page_event_open(::pdf_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_page_event_open():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_page_event_open(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_page_event_open(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_page_from_fz_page()`. */
FZ_FUNCTION ::pdf_page *ll_pdf_page_from_fz_page(::fz_page *ptr)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_page_from_fz_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " ptr=" << ptr;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_page * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_page_from_fz_page(auto_ctx, ptr);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_page_from_fz_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_page_group()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_page_group(::pdf_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_page_group():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_page_group(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_page_group(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_page_has_transparency()`. */
FZ_FUNCTION int ll_pdf_page_has_transparency(::pdf_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_page_has_transparency():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_page_has_transparency(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_page_has_transparency(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_page_label()`. */
FZ_FUNCTION void ll_pdf_page_label(::pdf_document *doc, int page, char *buf, size_t size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_page_label():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " page=" << page;
		if (s_trace > 1) std::cerr << " buf=" << (void*) buf;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_page_label(auto_ctx, doc, page, buf, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_page_label(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_page_label_imp()`. */
FZ_FUNCTION void ll_pdf_page_label_imp(::fz_document *doc, int chapter, int page, char *buf, size_t size)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_page_label_imp():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " chapter=" << chapter;
		std::cerr << " page=" << page;
		if (s_trace > 1) std::cerr << " buf=" << (void*) buf;
		std::cerr << " size=" << size;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_page_label_imp(auto_ctx, doc, chapter, page, buf, size);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_page_label_imp(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_page_obj_transform()`. */
FZ_FUNCTION void ll_pdf_page_obj_transform(::pdf_obj *pageobj, ::fz_rect *outbox, ::fz_matrix *outctm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_page_obj_transform():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pageobj=" << pageobj;
		std::cerr << " outbox=" << outbox;
		std::cerr << " outctm=" << outctm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_page_obj_transform(auto_ctx, pageobj, outbox, outctm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_page_obj_transform(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_page_obj_transform_box()`. */
FZ_FUNCTION void ll_pdf_page_obj_transform_box(::pdf_obj *pageobj, ::fz_rect *outbox, ::fz_matrix *out, ::fz_box_type box)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_page_obj_transform_box():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " pageobj=" << pageobj;
		std::cerr << " outbox=" << outbox;
		std::cerr << " out=" << out;
		std::cerr << " box=" << box;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_page_obj_transform_box(auto_ctx, pageobj, outbox, out, box);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_page_obj_transform_box(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_page_presentation()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_page_presentation(::pdf_page *page, ::fz_transition *transition)` => `(fz_transition *, float duration)`
*/
FZ_FUNCTION ::fz_transition *ll_pdf_page_presentation(::pdf_page *page, ::fz_transition *transition, float *duration)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_page_presentation():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " transition=" << transition;
		if (s_trace > 1) std::cerr << " duration=" << (void*) duration;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_transition * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_page_presentation(auto_ctx, page, transition, duration);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_page_presentation(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_page_resources()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_page_resources(::pdf_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_page_resources():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_page_resources(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_page_resources(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_page_separations()`. */
FZ_FUNCTION ::fz_separations *ll_pdf_page_separations(::pdf_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_page_separations():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_separations * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_page_separations(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_page_separations(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_page_transform()`. */
FZ_FUNCTION void ll_pdf_page_transform(::pdf_page *page, ::fz_rect *mediabox, ::fz_matrix *ctm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_page_transform():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " mediabox=" << mediabox;
		std::cerr << " ctm=" << ctm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_page_transform(auto_ctx, page, mediabox, ctm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_page_transform(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_page_transform_box()`. */
FZ_FUNCTION void ll_pdf_page_transform_box(::pdf_page *page, ::fz_rect *mediabox, ::fz_matrix *ctm, ::fz_box_type box)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_page_transform_box():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " mediabox=" << mediabox;
		std::cerr << " ctm=" << ctm;
		std::cerr << " box=" << box;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_page_transform_box(auto_ctx, page, mediabox, ctm, box);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_page_transform_box(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_page_write()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_page_write(::pdf_document *doc, ::fz_rect mediabox, ::pdf_obj **presources, ::fz_buffer **pcontents)` => `(fz_device *)`
*/
FZ_FUNCTION ::fz_device *ll_pdf_page_write(::pdf_document *doc, ::fz_rect mediabox, ::pdf_obj **presources, ::fz_buffer **pcontents)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_page_write():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " mediabox=" << mediabox;
		if (s_trace > 1) std::cerr << " presources=" << (void*) presources;
		if (s_trace > 1) std::cerr << " pcontents=" << (void*) pcontents;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_device * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_page_write(auto_ctx, doc, mediabox, presources, pcontents);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_page_write(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_parse_array()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_parse_array(::pdf_document *doc, ::fz_stream *f, ::pdf_lexbuf *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_parse_array():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " f=" << f;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_parse_array(auto_ctx, doc, f, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_parse_array(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_parse_date()`. */
FZ_FUNCTION int64_t ll_pdf_parse_date(const char *s)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_parse_date():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s) std::cerr << " s='" << s << "'";
		else std::cerr << " s:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int64_t ret;
	fz_try(auto_ctx) {
		ret = ::pdf_parse_date(auto_ctx, s);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_parse_date(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_parse_default_appearance()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_parse_default_appearance(const char *da, float color[4])` => `(const char *font, float size, int n)`
*/
FZ_FUNCTION void ll_pdf_parse_default_appearance(const char *da, const char **font, float *size, int *n, float color[4])
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_parse_default_appearance():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (da) std::cerr << " da='" << da << "'";
		else std::cerr << " da:null";
		if (s_trace > 1) std::cerr << " font=" << (void*) font;
		if (s_trace > 1) std::cerr << " size=" << (void*) size;
		if (s_trace > 1) std::cerr << " n=" << (void*) n;
		std::cerr << " color=" << color;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_parse_default_appearance(auto_ctx, da, font, size, n, color);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_parse_default_appearance(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_parse_dict()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_parse_dict(::pdf_document *doc, ::fz_stream *f, ::pdf_lexbuf *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_parse_dict():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " f=" << f;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_parse_dict(auto_ctx, doc, f, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_parse_dict(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_parse_ind_obj()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_parse_ind_obj(::pdf_document *doc, ::fz_stream *f)` => `(pdf_obj *, int num, int gen, int64_t stm_ofs, int try_repair)`
*/
FZ_FUNCTION ::pdf_obj *ll_pdf_parse_ind_obj(::pdf_document *doc, ::fz_stream *f, int *num, int *gen, int64_t *stm_ofs, int *try_repair)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_parse_ind_obj():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " f=" << f;
		if (s_trace > 1) std::cerr << " num=" << (void*) num;
		if (s_trace > 1) std::cerr << " gen=" << (void*) gen;
		if (s_trace > 1) std::cerr << " stm_ofs=" << (void*) stm_ofs;
		if (s_trace > 1) std::cerr << " try_repair=" << (void*) try_repair;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_parse_ind_obj(auto_ctx, doc, f, num, gen, stm_ofs, try_repair);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_parse_ind_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_parse_journal_obj()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_parse_journal_obj(::pdf_document *doc, ::fz_stream *stm, ::fz_buffer **ostm)` => `(pdf_obj *, int onum, int newobj)`
*/
FZ_FUNCTION ::pdf_obj *ll_pdf_parse_journal_obj(::pdf_document *doc, ::fz_stream *stm, int *onum, ::fz_buffer **ostm, int *newobj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_parse_journal_obj():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		if (s_trace > 1) std::cerr << " onum=" << (void*) onum;
		if (s_trace > 1) std::cerr << " ostm=" << (void*) ostm;
		if (s_trace > 1) std::cerr << " newobj=" << (void*) newobj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_parse_journal_obj(auto_ctx, doc, stm, onum, ostm, newobj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_parse_journal_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_parse_stm_obj()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_parse_stm_obj(::pdf_document *doc, ::fz_stream *f, ::pdf_lexbuf *buf)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_parse_stm_obj():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " f=" << f;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_parse_stm_obj(auto_ctx, doc, f, buf);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_parse_stm_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_parse_write_options()`. */
FZ_FUNCTION ::pdf_write_options *ll_pdf_parse_write_options(::pdf_write_options *opts, const char *args)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_parse_write_options():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " opts=" << opts;
		if (args) std::cerr << " args='" << args << "'";
		else std::cerr << " args:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_write_options * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_parse_write_options(auto_ctx, opts, args);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_parse_write_options(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_pin_document()`. */
FZ_FUNCTION ::pdf_document *ll_pdf_pin_document(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_pin_document():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_document * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_pin_document(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_pin_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_preview_signature_as_display_list()`. */
FZ_FUNCTION ::fz_display_list *ll_pdf_preview_signature_as_display_list(float w, float h, ::fz_text_language lang, ::pdf_pkcs7_signer *signer, int appearance_flags, ::fz_image *graphic, const char *reason, const char *location)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_preview_signature_as_display_list():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " w=" << w;
		std::cerr << " h=" << h;
		std::cerr << " lang=" << lang;
		if (s_trace > 1) std::cerr << " signer=" << signer;
		std::cerr << " appearance_flags=" << appearance_flags;
		if (s_trace > 1) std::cerr << " graphic=" << graphic;
		if (reason) std::cerr << " reason='" << reason << "'";
		else std::cerr << " reason:null";
		if (location) std::cerr << " location='" << location << "'";
		else std::cerr << " location:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_display_list * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_preview_signature_as_display_list(auto_ctx, w, h, lang, signer, appearance_flags, graphic, reason, location);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_preview_signature_as_display_list(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_preview_signature_as_pixmap()`. */
FZ_FUNCTION ::fz_pixmap *ll_pdf_preview_signature_as_pixmap(int w, int h, ::fz_text_language lang, ::pdf_pkcs7_signer *signer, int appearance_flags, ::fz_image *graphic, const char *reason, const char *location)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_preview_signature_as_pixmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " w=" << w;
		std::cerr << " h=" << h;
		std::cerr << " lang=" << lang;
		if (s_trace > 1) std::cerr << " signer=" << signer;
		std::cerr << " appearance_flags=" << appearance_flags;
		if (s_trace > 1) std::cerr << " graphic=" << graphic;
		if (reason) std::cerr << " reason='" << reason << "'";
		else std::cerr << " reason:null";
		if (location) std::cerr << " location='" << location << "'";
		else std::cerr << " location:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_pixmap * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_preview_signature_as_pixmap(auto_ctx, w, h, lang, signer, appearance_flags, graphic, reason, location);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_preview_signature_as_pixmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_print_crypt()`. */
FZ_FUNCTION void ll_pdf_print_crypt(::fz_output *out, ::pdf_crypt *crypt)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_print_crypt():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_print_crypt(auto_ctx, out, crypt);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_print_crypt(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_print_default_appearance()`. */
FZ_FUNCTION void ll_pdf_print_default_appearance(char *buf, int nbuf, const char *font, float size, int n, const float *color)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_print_default_appearance():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << (void*) buf;
		std::cerr << " nbuf=" << nbuf;
		if (font) std::cerr << " font='" << font << "'";
		else std::cerr << " font:null";
		std::cerr << " size=" << size;
		std::cerr << " n=" << n;
		if (s_trace > 1) std::cerr << " color=" << (void*) color;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_print_default_appearance(auto_ctx, buf, nbuf, font, size, n, color);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_print_default_appearance(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_print_encrypted_obj()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_print_encrypted_obj(::fz_output *out, ::pdf_obj *obj, int tight, int ascii, ::pdf_crypt *crypt, int num, int gen)` => int sep
*/
FZ_FUNCTION void ll_pdf_print_encrypted_obj(::fz_output *out, ::pdf_obj *obj, int tight, int ascii, ::pdf_crypt *crypt, int num, int gen, int *sep)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_print_encrypted_obj():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << " tight=" << tight;
		std::cerr << " ascii=" << ascii;
		if (s_trace > 1) std::cerr << " crypt=" << crypt;
		std::cerr << " num=" << num;
		std::cerr << " gen=" << gen;
		if (s_trace > 1) std::cerr << " sep=" << (void*) sep;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_print_encrypted_obj(auto_ctx, out, obj, tight, ascii, crypt, num, gen, sep);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_print_encrypted_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_print_font()`. */
FZ_FUNCTION void ll_pdf_print_font(::fz_output *out, ::pdf_font_desc *fontdesc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_print_font():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " fontdesc=" << fontdesc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_print_font(auto_ctx, out, fontdesc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_print_font(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_print_obj()`. */
FZ_FUNCTION void ll_pdf_print_obj(::fz_output *out, ::pdf_obj *obj, int tight, int ascii)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_print_obj():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << " tight=" << tight;
		std::cerr << " ascii=" << ascii;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_print_obj(auto_ctx, out, obj, tight, ascii);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_print_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_process_annot()`. */
FZ_FUNCTION void ll_pdf_process_annot(::pdf_processor *proc, ::pdf_annot *annot, ::fz_cookie *cookie)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_process_annot():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " proc=" << proc;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " cookie=" << cookie;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_process_annot(auto_ctx, proc, annot, cookie);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_process_annot(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_process_contents()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_process_contents(::pdf_processor *proc, ::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm, ::fz_cookie *cookie, ::pdf_obj **out_res)` => 
*/
FZ_FUNCTION void ll_pdf_process_contents(::pdf_processor *proc, ::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm, ::fz_cookie *cookie, ::pdf_obj **out_res)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_process_contents():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " proc=" << proc;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " res=" << res;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << " cookie=" << cookie;
		if (s_trace > 1) std::cerr << " out_res=" << (void*) out_res;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_process_contents(auto_ctx, proc, doc, res, stm, cookie, out_res);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_process_contents(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_process_glyph()`. */
FZ_FUNCTION void ll_pdf_process_glyph(::pdf_processor *proc, ::pdf_document *doc, ::pdf_obj *resources, ::fz_buffer *contents)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_process_glyph():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " proc=" << proc;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " resources=" << resources;
		if (s_trace > 1) std::cerr << " contents=" << contents;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_process_glyph(auto_ctx, proc, doc, resources, contents);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_process_glyph(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_process_raw_contents()`. */
FZ_FUNCTION void ll_pdf_process_raw_contents(::pdf_processor *proc, ::pdf_document *doc, ::pdf_obj *rdb, ::pdf_obj *stmobj, ::fz_cookie *cookie)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_process_raw_contents():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " proc=" << proc;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " rdb=" << rdb;
		if (s_trace > 1) std::cerr << " stmobj=" << stmobj;
		std::cerr << " cookie=" << cookie;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_process_raw_contents(auto_ctx, proc, doc, rdb, stmobj, cookie);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_process_raw_contents(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_processor_pop_resources()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_processor_pop_resources(::pdf_processor *proc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_processor_pop_resources():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " proc=" << proc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_processor_pop_resources(auto_ctx, proc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_processor_pop_resources(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_processor_push_resources()`. */
FZ_FUNCTION void ll_pdf_processor_push_resources(::pdf_processor *proc, ::pdf_obj *res)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_processor_push_resources():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " proc=" << proc;
		if (s_trace > 1) std::cerr << " res=" << res;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_processor_push_resources(auto_ctx, proc, res);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_processor_push_resources(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_progressive_advance()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_progressive_advance(::pdf_document *doc, int pagenum)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_progressive_advance():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " pagenum=" << pagenum;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_progressive_advance(auto_ctx, doc, pagenum);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_progressive_advance(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_purge_local_font_resources()`. */
FZ_FUNCTION void ll_pdf_purge_local_font_resources(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_purge_local_font_resources():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_purge_local_font_resources(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_purge_local_font_resources(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_purge_locals_from_store()`. */
FZ_FUNCTION void ll_pdf_purge_locals_from_store(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_purge_locals_from_store():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_purge_locals_from_store(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_purge_locals_from_store(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_read_journal()`. */
FZ_FUNCTION void ll_pdf_read_journal(::pdf_document *doc, ::fz_stream *stm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_read_journal():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " stm=" << stm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_read_journal(auto_ctx, doc, stm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_read_journal(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_read_ocg()`. */
FZ_FUNCTION ::pdf_ocg_descriptor *ll_pdf_read_ocg(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_read_ocg():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_ocg_descriptor * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_read_ocg(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_read_ocg(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_rearrange_pages()`. */
FZ_FUNCTION void ll_pdf_rearrange_pages(::pdf_document *doc, int count, const int *pages)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_rearrange_pages():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " count=" << count;
		if (s_trace > 1) std::cerr << " pages=" << (void*) pages;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_rearrange_pages(auto_ctx, doc, count, pages);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_rearrange_pages(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_rearrange_pages2()`. */
FZ_FUNCTION void ll_pdf_rearrange_pages2(::pdf_document *doc, const std::vector<int> &pages)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_rearrange_pages2():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " &pages=" << &pages;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_rearrange_pages2(auto_ctx, doc, pages);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_rearrange_pages2(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_recolor_shade()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_recolor_shade(::pdf_obj *shade, ::pdf_shade_recolorer *reshade, void *opaque)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_recolor_shade():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " shade=" << shade;
		if (s_trace > 1) std::cerr << " reshade=" << (void*) reshade;
		if (s_trace > 1) std::cerr << " opaque=" << (void*) opaque;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_recolor_shade(auto_ctx, shade, reshade, opaque);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_recolor_shade(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_redact_page()`. */
FZ_FUNCTION int ll_pdf_redact_page(::pdf_document *doc, ::pdf_page *page, ::pdf_redact_options *opts)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_redact_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " opts=" << opts;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_redact_page(auto_ctx, doc, page, opts);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_redact_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_redo()`. */
FZ_FUNCTION void ll_pdf_redo(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_redo():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_redo(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_redo(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_remove_item()`. */
FZ_FUNCTION void ll_pdf_remove_item(::fz_store_drop_fn *drop, ::pdf_obj *key)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_remove_item():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " drop=" << (void*) drop;
		if (s_trace > 1) std::cerr << " key=" << key;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_remove_item(auto_ctx, drop, key);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_remove_item(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_repair_obj()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_repair_obj(::pdf_document *doc, ::pdf_lexbuf *buf, ::pdf_obj **encrypt, ::pdf_obj **id, ::pdf_obj **page, ::pdf_obj **root)` => `(int, int64_t stmofsp, int64_t stmlenp, int64_t tmpofs)`
*/
FZ_FUNCTION int ll_pdf_repair_obj(::pdf_document *doc, ::pdf_lexbuf *buf, int64_t *stmofsp, int64_t *stmlenp, ::pdf_obj **encrypt, ::pdf_obj **id, ::pdf_obj **page, int64_t *tmpofs, ::pdf_obj **root)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_repair_obj():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		if (s_trace > 1) std::cerr << " stmofsp=" << (void*) stmofsp;
		if (s_trace > 1) std::cerr << " stmlenp=" << (void*) stmlenp;
		if (s_trace > 1) std::cerr << " encrypt=" << (void*) encrypt;
		if (s_trace > 1) std::cerr << " id=" << (void*) id;
		if (s_trace > 1) std::cerr << " page=" << (void*) page;
		if (s_trace > 1) std::cerr << " tmpofs=" << (void*) tmpofs;
		if (s_trace > 1) std::cerr << " root=" << (void*) root;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_repair_obj(auto_ctx, doc, buf, stmofsp, stmlenp, encrypt, id, page, tmpofs, root);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_repair_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_repair_obj_stms()`. */
FZ_FUNCTION void ll_pdf_repair_obj_stms(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_repair_obj_stms():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_repair_obj_stms(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_repair_obj_stms(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_repair_trailer()`. */
FZ_FUNCTION void ll_pdf_repair_trailer(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_repair_trailer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_repair_trailer(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_repair_trailer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_repair_xref()`. */
FZ_FUNCTION void ll_pdf_repair_xref(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_repair_xref():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_repair_xref(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_repair_xref(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_replace_xref()`. */
FZ_FUNCTION void ll_pdf_replace_xref(::pdf_document *doc, ::pdf_xref_entry *entries, int n)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_replace_xref():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " entries=" << entries;
		std::cerr << " n=" << n;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_replace_xref(auto_ctx, doc, entries, n);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_replace_xref(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_reset_form()`. */
FZ_FUNCTION void ll_pdf_reset_form(::pdf_document *doc, ::pdf_obj *fields, int exclude)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_reset_form():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " fields=" << fields;
		std::cerr << " exclude=" << exclude;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_reset_form(auto_ctx, doc, fields, exclude);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_reset_form(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_reset_processor()`. */
FZ_FUNCTION void ll_pdf_reset_processor(::pdf_processor *proc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_reset_processor():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " proc=" << proc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_reset_processor(auto_ctx, proc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_reset_processor(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_resolve_indirect()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_resolve_indirect(::pdf_obj *ref)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_resolve_indirect():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " ref=" << ref;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_resolve_indirect(auto_ctx, ref);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_resolve_indirect(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_resolve_indirect_chain()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_resolve_indirect_chain(::pdf_obj *ref)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_resolve_indirect_chain():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " ref=" << ref;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_resolve_indirect_chain(auto_ctx, ref);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_resolve_indirect_chain(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_resolve_link()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_resolve_link(::pdf_document *doc, const char *uri)` => `(int, float xp, float yp)`
*/
FZ_FUNCTION int ll_pdf_resolve_link(::pdf_document *doc, const char *uri, float *xp, float *yp)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_resolve_link():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (uri) std::cerr << " uri='" << uri << "'";
		else std::cerr << " uri:null";
		if (s_trace > 1) std::cerr << " xp=" << (void*) xp;
		if (s_trace > 1) std::cerr << " yp=" << (void*) yp;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_resolve_link(auto_ctx, doc, uri, xp, yp);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_resolve_link(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_resolve_link_dest()`. */
FZ_FUNCTION ::fz_link_dest ll_pdf_resolve_link_dest(::pdf_document *doc, const char *uri)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_resolve_link_dest():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (uri) std::cerr << " uri='" << uri << "'";
		else std::cerr << " uri:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_link_dest ret;
	fz_try(auto_ctx) {
		ret = ::pdf_resolve_link_dest(auto_ctx, doc, uri);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_resolve_link_dest(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_rewrite_images()`. */
FZ_FUNCTION void ll_pdf_rewrite_images(::pdf_document *doc, ::pdf_image_rewriter_options *opts)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_rewrite_images():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " opts=" << opts;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_rewrite_images(auto_ctx, doc, opts);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_rewrite_images(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_run_annot()`. */
FZ_FUNCTION void ll_pdf_run_annot(::pdf_annot *annot, ::fz_device *dev, ::fz_matrix ctm, ::fz_cookie *cookie)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_run_annot():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " ctm=" << ctm;
		std::cerr << " cookie=" << cookie;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_run_annot(auto_ctx, annot, dev, ctm, cookie);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_run_annot(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_run_document_structure()`. */
FZ_FUNCTION void ll_pdf_run_document_structure(::pdf_document *doc, ::fz_device *dev, ::fz_cookie *cookie)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_run_document_structure():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " cookie=" << cookie;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_run_document_structure(auto_ctx, doc, dev, cookie);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_run_document_structure(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_run_glyph()`. */
FZ_FUNCTION void ll_pdf_run_glyph(::pdf_document *doc, ::pdf_obj *resources, ::fz_buffer *contents, ::fz_device *dev, ::fz_matrix ctm, void *gstate, ::fz_default_colorspaces *default_cs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_run_glyph():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " resources=" << resources;
		if (s_trace > 1) std::cerr << " contents=" << contents;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " gstate=" << (void*) gstate;
		if (s_trace > 1) std::cerr << " default_cs=" << default_cs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_run_glyph(auto_ctx, doc, resources, contents, dev, ctm, gstate, default_cs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_run_glyph(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_run_page()`. */
FZ_FUNCTION void ll_pdf_run_page(::pdf_page *page, ::fz_device *dev, ::fz_matrix ctm, ::fz_cookie *cookie)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_run_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " ctm=" << ctm;
		std::cerr << " cookie=" << cookie;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_run_page(auto_ctx, page, dev, ctm, cookie);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_run_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_run_page_annots()`. */
FZ_FUNCTION void ll_pdf_run_page_annots(::pdf_page *page, ::fz_device *dev, ::fz_matrix ctm, ::fz_cookie *cookie)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_run_page_annots():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " ctm=" << ctm;
		std::cerr << " cookie=" << cookie;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_run_page_annots(auto_ctx, page, dev, ctm, cookie);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_run_page_annots(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_run_page_annots_with_usage()`. */
FZ_FUNCTION void ll_pdf_run_page_annots_with_usage(::pdf_page *page, ::fz_device *dev, ::fz_matrix ctm, const char *usage, ::fz_cookie *cookie)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_run_page_annots_with_usage():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " ctm=" << ctm;
		if (usage) std::cerr << " usage='" << usage << "'";
		else std::cerr << " usage:null";
		std::cerr << " cookie=" << cookie;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_run_page_annots_with_usage(auto_ctx, page, dev, ctm, usage, cookie);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_run_page_annots_with_usage(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_run_page_contents()`. */
FZ_FUNCTION void ll_pdf_run_page_contents(::pdf_page *page, ::fz_device *dev, ::fz_matrix ctm, ::fz_cookie *cookie)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_run_page_contents():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " ctm=" << ctm;
		std::cerr << " cookie=" << cookie;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_run_page_contents(auto_ctx, page, dev, ctm, cookie);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_run_page_contents(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_run_page_contents_with_usage()`. */
FZ_FUNCTION void ll_pdf_run_page_contents_with_usage(::pdf_page *page, ::fz_device *dev, ::fz_matrix ctm, const char *usage, ::fz_cookie *cookie)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_run_page_contents_with_usage():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " ctm=" << ctm;
		if (usage) std::cerr << " usage='" << usage << "'";
		else std::cerr << " usage:null";
		std::cerr << " cookie=" << cookie;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_run_page_contents_with_usage(auto_ctx, page, dev, ctm, usage, cookie);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_run_page_contents_with_usage(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_run_page_widgets()`. */
FZ_FUNCTION void ll_pdf_run_page_widgets(::pdf_page *page, ::fz_device *dev, ::fz_matrix ctm, ::fz_cookie *cookie)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_run_page_widgets():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " ctm=" << ctm;
		std::cerr << " cookie=" << cookie;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_run_page_widgets(auto_ctx, page, dev, ctm, cookie);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_run_page_widgets(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_run_page_widgets_with_usage()`. */
FZ_FUNCTION void ll_pdf_run_page_widgets_with_usage(::pdf_page *page, ::fz_device *dev, ::fz_matrix ctm, const char *usage, ::fz_cookie *cookie)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_run_page_widgets_with_usage():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " ctm=" << ctm;
		if (usage) std::cerr << " usage='" << usage << "'";
		else std::cerr << " usage:null";
		std::cerr << " cookie=" << cookie;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_run_page_widgets_with_usage(auto_ctx, page, dev, ctm, usage, cookie);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_run_page_widgets_with_usage(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_run_page_with_usage()`. */
FZ_FUNCTION void ll_pdf_run_page_with_usage(::pdf_page *page, ::fz_device *dev, ::fz_matrix ctm, const char *usage, ::fz_cookie *cookie)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_run_page_with_usage():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		if (s_trace > 1) std::cerr << " dev=" << dev;
		std::cerr << " ctm=" << ctm;
		if (usage) std::cerr << " usage='" << usage << "'";
		else std::cerr << " usage:null";
		std::cerr << " cookie=" << cookie;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_run_page_with_usage(auto_ctx, page, dev, ctm, usage, cookie);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_run_page_with_usage(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_sample_shade_function()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_sample_shade_function(float shade[256][33], int n, int funcs, ::pdf_function **func, float t0, float t1)` => 
*/
FZ_FUNCTION void ll_pdf_sample_shade_function(float shade[256][33], int n, int funcs, ::pdf_function **func, float t0, float t1)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_sample_shade_function():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " shade=" << shade;
		std::cerr << " n=" << n;
		std::cerr << " funcs=" << funcs;
		if (s_trace > 1) std::cerr << " func=" << (void*) func;
		std::cerr << " t0=" << t0;
		std::cerr << " t1=" << t1;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_sample_shade_function(auto_ctx, shade, n, funcs, func, t0, t1);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_sample_shade_function(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_save_document()`. */
FZ_FUNCTION void ll_pdf_save_document(::pdf_document *doc, const char *filename, const ::pdf_write_options *opts)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_save_document():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << " opts=" << opts;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_save_document(auto_ctx, doc, filename, opts);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_save_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_save_journal()`. */
FZ_FUNCTION void ll_pdf_save_journal(::pdf_document *doc, const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_save_journal():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_save_journal(auto_ctx, doc, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_save_journal(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_save_snapshot()`. */
FZ_FUNCTION void ll_pdf_save_snapshot(::pdf_document *doc, const char *filename)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_save_snapshot():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (filename) std::cerr << " filename='" << filename << "'";
		else std::cerr << " filename:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_save_snapshot(auto_ctx, doc, filename);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_save_snapshot(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_select_layer_config()`. */
FZ_FUNCTION void ll_pdf_select_layer_config(::pdf_document *doc, int config_num)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_select_layer_config():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " config_num=" << config_num;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_select_layer_config(auto_ctx, doc, config_num);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_select_layer_config(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_select_layer_config_ui()`. */
FZ_FUNCTION void ll_pdf_select_layer_config_ui(::pdf_document *doc, int ui)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_select_layer_config_ui():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " ui=" << ui;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_select_layer_config_ui(auto_ctx, doc, ui);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_select_layer_config_ui(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_serialise_journal()`. */
FZ_FUNCTION void ll_pdf_serialise_journal(::pdf_document *doc, ::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_serialise_journal():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_serialise_journal(auto_ctx, doc, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_serialise_journal(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_active()`. */
FZ_FUNCTION void ll_pdf_set_annot_active(::pdf_annot *annot, int active)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_active():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " active=" << active;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_active(auto_ctx, annot, active);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_active(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_appearance()`. */
FZ_FUNCTION void ll_pdf_set_annot_appearance(::pdf_annot *annot, const char *appearance, const char *state, ::fz_matrix ctm, ::fz_rect bbox, ::pdf_obj *res, ::fz_buffer *contents)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_appearance():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		if (appearance) std::cerr << " appearance='" << appearance << "'";
		else std::cerr << " appearance:null";
		if (state) std::cerr << " state='" << state << "'";
		else std::cerr << " state:null";
		std::cerr << " ctm=" << ctm;
		std::cerr << " bbox=" << bbox;
		if (s_trace > 1) std::cerr << " res=" << res;
		if (s_trace > 1) std::cerr << " contents=" << contents;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_appearance(auto_ctx, annot, appearance, state, ctm, bbox, res, contents);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_appearance(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_appearance_from_display_list()`. */
FZ_FUNCTION void ll_pdf_set_annot_appearance_from_display_list(::pdf_annot *annot, const char *appearance, const char *state, ::fz_matrix ctm, ::fz_display_list *list)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_appearance_from_display_list():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		if (appearance) std::cerr << " appearance='" << appearance << "'";
		else std::cerr << " appearance:null";
		if (state) std::cerr << " state='" << state << "'";
		else std::cerr << " state:null";
		std::cerr << " ctm=" << ctm;
		if (s_trace > 1) std::cerr << " list=" << list;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_appearance_from_display_list(auto_ctx, annot, appearance, state, ctm, list);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_appearance_from_display_list(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_author()`. */
FZ_FUNCTION void ll_pdf_set_annot_author(::pdf_annot *annot, const char *author)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_author():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		if (author) std::cerr << " author='" << author << "'";
		else std::cerr << " author:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_author(auto_ctx, annot, author);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_author(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_border()`. */
FZ_FUNCTION void ll_pdf_set_annot_border(::pdf_annot *annot, float width)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_border():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " width=" << width;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_border(auto_ctx, annot, width);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_border(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_border_effect()`. */
FZ_FUNCTION void ll_pdf_set_annot_border_effect(::pdf_annot *annot, enum pdf_border_effect effect)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_border_effect():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " effect=" << effect;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_border_effect(auto_ctx, annot, effect);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_border_effect(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_border_effect_intensity()`. */
FZ_FUNCTION void ll_pdf_set_annot_border_effect_intensity(::pdf_annot *annot, float intensity)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_border_effect_intensity():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " intensity=" << intensity;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_border_effect_intensity(auto_ctx, annot, intensity);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_border_effect_intensity(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_border_style()`. */
FZ_FUNCTION void ll_pdf_set_annot_border_style(::pdf_annot *annot, enum pdf_border_style style)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_border_style():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " style=" << style;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_border_style(auto_ctx, annot, style);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_border_style(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_border_width()`. */
FZ_FUNCTION void ll_pdf_set_annot_border_width(::pdf_annot *annot, float width)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_border_width():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " width=" << width;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_border_width(auto_ctx, annot, width);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_border_width(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_color()`. */
FZ_FUNCTION void ll_pdf_set_annot_color(::pdf_annot *annot, int n, const float *color)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_color():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " n=" << n;
		if (s_trace > 1) std::cerr << " color=" << (void*) color;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_color(auto_ctx, annot, n, color);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_color(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_contents()`. */
FZ_FUNCTION void ll_pdf_set_annot_contents(::pdf_annot *annot, const char *text)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_contents():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		if (text) std::cerr << " text='" << text << "'";
		else std::cerr << " text:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_contents(auto_ctx, annot, text);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_contents(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_creation_date()`. */
FZ_FUNCTION void ll_pdf_set_annot_creation_date(::pdf_annot *annot, int64_t time)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_creation_date():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " time=" << time;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_creation_date(auto_ctx, annot, time);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_creation_date(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_default_appearance()`. */
FZ_FUNCTION void ll_pdf_set_annot_default_appearance(::pdf_annot *annot, const char *font, float size, int n, const float *color)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_default_appearance():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		if (font) std::cerr << " font='" << font << "'";
		else std::cerr << " font:null";
		std::cerr << " size=" << size;
		std::cerr << " n=" << n;
		if (s_trace > 1) std::cerr << " color=" << (void*) color;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_default_appearance(auto_ctx, annot, font, size, n, color);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_default_appearance(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_field_value()`. */
FZ_FUNCTION int ll_pdf_set_annot_field_value(::pdf_document *doc, ::pdf_annot *widget, const char *text, int ignore_trigger_events)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_field_value():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " widget=" << widget;
		if (text) std::cerr << " text='" << text << "'";
		else std::cerr << " text:null";
		std::cerr << " ignore_trigger_events=" << ignore_trigger_events;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_set_annot_field_value(auto_ctx, doc, widget, text, ignore_trigger_events);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_field_value(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_set_annot_filespec()`. */
FZ_FUNCTION void ll_pdf_set_annot_filespec(::pdf_annot *annot, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_filespec():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_filespec(auto_ctx, annot, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_filespec(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_flags()`. */
FZ_FUNCTION void ll_pdf_set_annot_flags(::pdf_annot *annot, int flags)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_flags():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " flags=" << flags;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_flags(auto_ctx, annot, flags);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_flags(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_hidden_for_editing()`. */
FZ_FUNCTION void ll_pdf_set_annot_hidden_for_editing(::pdf_annot *annot, int hidden)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_hidden_for_editing():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " hidden=" << hidden;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_hidden_for_editing(auto_ctx, annot, hidden);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_hidden_for_editing(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_hot()`. */
FZ_FUNCTION void ll_pdf_set_annot_hot(::pdf_annot *annot, int hot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_hot():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " hot=" << hot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_hot(auto_ctx, annot, hot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_hot(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_icon_name()`. */
FZ_FUNCTION void ll_pdf_set_annot_icon_name(::pdf_annot *annot, const char *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_icon_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_icon_name(auto_ctx, annot, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_icon_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_ink_list()`. */
FZ_FUNCTION void ll_pdf_set_annot_ink_list(::pdf_annot *annot, int n, const int *count, const ::fz_point *v)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_ink_list():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " n=" << n;
		if (s_trace > 1) std::cerr << " count=" << (void*) count;
		std::cerr << " v=" << v;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_ink_list(auto_ctx, annot, n, count, v);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_ink_list(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_intent()`. */
FZ_FUNCTION void ll_pdf_set_annot_intent(::pdf_annot *annot, enum pdf_intent it)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_intent():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " it=" << it;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_intent(auto_ctx, annot, it);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_intent(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_interior_color()`. */
FZ_FUNCTION void ll_pdf_set_annot_interior_color(::pdf_annot *annot, int n, const float *color)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_interior_color():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " n=" << n;
		if (s_trace > 1) std::cerr << " color=" << (void*) color;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_interior_color(auto_ctx, annot, n, color);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_interior_color(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_is_open()`. */
FZ_FUNCTION void ll_pdf_set_annot_is_open(::pdf_annot *annot, int is_open)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_is_open():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " is_open=" << is_open;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_is_open(auto_ctx, annot, is_open);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_is_open(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_language()`. */
FZ_FUNCTION void ll_pdf_set_annot_language(::pdf_annot *annot, ::fz_text_language lang)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_language():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " lang=" << lang;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_language(auto_ctx, annot, lang);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_language(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_line()`. */
FZ_FUNCTION void ll_pdf_set_annot_line(::pdf_annot *annot, ::fz_point a, ::fz_point b)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_line():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_line(auto_ctx, annot, a, b);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_line(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_line_end_style()`. */
FZ_FUNCTION void ll_pdf_set_annot_line_end_style(::pdf_annot *annot, enum pdf_line_ending e)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_line_end_style():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " e=" << e;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_line_end_style(auto_ctx, annot, e);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_line_end_style(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_line_ending_styles()`. */
FZ_FUNCTION void ll_pdf_set_annot_line_ending_styles(::pdf_annot *annot, enum pdf_line_ending start_style, enum pdf_line_ending end_style)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_line_ending_styles():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " start_style=" << start_style;
		std::cerr << " end_style=" << end_style;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_line_ending_styles(auto_ctx, annot, start_style, end_style);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_line_ending_styles(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_line_start_style()`. */
FZ_FUNCTION void ll_pdf_set_annot_line_start_style(::pdf_annot *annot, enum pdf_line_ending s)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_line_start_style():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " s=" << s;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_line_start_style(auto_ctx, annot, s);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_line_start_style(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_modification_date()`. */
FZ_FUNCTION void ll_pdf_set_annot_modification_date(::pdf_annot *annot, int64_t time)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_modification_date():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " time=" << time;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_modification_date(auto_ctx, annot, time);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_modification_date(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_opacity()`. */
FZ_FUNCTION void ll_pdf_set_annot_opacity(::pdf_annot *annot, float opacity)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_opacity():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " opacity=" << opacity;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_opacity(auto_ctx, annot, opacity);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_opacity(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_popup()`. */
FZ_FUNCTION void ll_pdf_set_annot_popup(::pdf_annot *annot, ::fz_rect rect)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_popup():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " rect=" << rect;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_popup(auto_ctx, annot, rect);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_popup(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_quad_points()`. */
FZ_FUNCTION void ll_pdf_set_annot_quad_points(::pdf_annot *annot, int n, const ::fz_quad *qv)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_quad_points():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " n=" << n;
		std::cerr << " qv=" << qv;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_quad_points(auto_ctx, annot, n, qv);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_quad_points(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_quadding()`. */
FZ_FUNCTION void ll_pdf_set_annot_quadding(::pdf_annot *annot, int q)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_quadding():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " q=" << q;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_quadding(auto_ctx, annot, q);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_quadding(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_rect()`. */
FZ_FUNCTION void ll_pdf_set_annot_rect(::pdf_annot *annot, ::fz_rect rect)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_rect():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " rect=" << rect;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_rect(auto_ctx, annot, rect);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_rect(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_resynthesised()`. */
FZ_FUNCTION void ll_pdf_set_annot_resynthesised(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_resynthesised():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_resynthesised(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_resynthesised(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_stamp_image()`. */
FZ_FUNCTION void ll_pdf_set_annot_stamp_image(::pdf_annot *annot, ::fz_image *image)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_stamp_image():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		if (s_trace > 1) std::cerr << " image=" << image;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_stamp_image(auto_ctx, annot, image);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_stamp_image(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_vertex()`. */
FZ_FUNCTION void ll_pdf_set_annot_vertex(::pdf_annot *annot, int i, ::fz_point p)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_vertex():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " i=" << i;
		std::cerr << " p=" << p;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_vertex(auto_ctx, annot, i, p);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_vertex(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_annot_vertices()`. */
FZ_FUNCTION void ll_pdf_set_annot_vertices(::pdf_annot *annot, int n, const ::fz_point *v)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_annot_vertices():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << " n=" << n;
		std::cerr << " v=" << v;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_annot_vertices(auto_ctx, annot, n, v);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_annot_vertices(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_choice_field_value()`. */
FZ_FUNCTION int ll_pdf_set_choice_field_value(::pdf_annot *widget, const char *value)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_choice_field_value():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " widget=" << widget;
		if (value) std::cerr << " value='" << value << "'";
		else std::cerr << " value:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_set_choice_field_value(auto_ctx, widget, value);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_choice_field_value(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_set_cmap_wmode()`. */
FZ_FUNCTION void ll_pdf_set_cmap_wmode(::pdf_cmap *cmap, int wmode)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_cmap_wmode():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cmap=" << cmap;
		std::cerr << " wmode=" << wmode;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_cmap_wmode(auto_ctx, cmap, wmode);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_cmap_wmode(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_default_hmtx()`. */
FZ_FUNCTION void ll_pdf_set_default_hmtx(::pdf_font_desc *font, int w)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_default_hmtx():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " w=" << w;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_default_hmtx(auto_ctx, font, w);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_default_hmtx(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_default_vmtx()`. */
FZ_FUNCTION void ll_pdf_set_default_vmtx(::pdf_font_desc *font, int y, int w)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_default_vmtx():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " y=" << y;
		std::cerr << " w=" << w;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_default_vmtx(auto_ctx, font, y, w);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_default_vmtx(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_doc_event_callback()`. */
FZ_FUNCTION void ll_pdf_set_doc_event_callback(::pdf_document *doc, ::pdf_doc_event_cb *event_cb, ::pdf_free_doc_event_data_cb *free_event_data_cb, void *data)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_doc_event_callback():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " event_cb=" << (void*) event_cb;
		if (s_trace > 1) std::cerr << " free_event_data_cb=" << (void*) free_event_data_cb;
		if (s_trace > 1) std::cerr << " data=" << (void*) data;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_doc_event_callback(auto_ctx, doc, event_cb, free_event_data_cb, data);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_doc_event_callback(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_document_language()`. */
FZ_FUNCTION void ll_pdf_set_document_language(::pdf_document *doc, ::fz_text_language lang)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_document_language():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " lang=" << lang;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_document_language(auto_ctx, doc, lang);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_document_language(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_field_value()`. */
FZ_FUNCTION int ll_pdf_set_field_value(::pdf_document *doc, ::pdf_obj *field, const char *text, int ignore_trigger_events)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_field_value():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " field=" << field;
		if (text) std::cerr << " text='" << text << "'";
		else std::cerr << " text:null";
		std::cerr << " ignore_trigger_events=" << ignore_trigger_events;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_set_field_value(auto_ctx, doc, field, text, ignore_trigger_events);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_field_value(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_set_font_wmode()`. */
FZ_FUNCTION void ll_pdf_set_font_wmode(::pdf_font_desc *font, int wmode)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_font_wmode():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " font=" << font;
		std::cerr << " wmode=" << wmode;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_font_wmode(auto_ctx, font, wmode);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_font_wmode(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_int()`. */
FZ_FUNCTION void ll_pdf_set_int(::pdf_obj *obj, int64_t i)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_int():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << " i=" << i;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_int(auto_ctx, obj, i);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_int(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_layer_config_as_default()`. */
FZ_FUNCTION void ll_pdf_set_layer_config_as_default(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_layer_config_as_default():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_layer_config_as_default(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_layer_config_as_default(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_obj_memo()`. */
FZ_FUNCTION void ll_pdf_set_obj_memo(::pdf_obj *obj, int bit, int memo)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_obj_memo():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << " bit=" << bit;
		std::cerr << " memo=" << memo;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_obj_memo(auto_ctx, obj, bit, memo);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_obj_memo(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_obj_parent()`. */
FZ_FUNCTION void ll_pdf_set_obj_parent(::pdf_obj *obj, int num)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_obj_parent():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << " num=" << num;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_obj_parent(auto_ctx, obj, num);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_obj_parent(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_page_box()`. */
FZ_FUNCTION void ll_pdf_set_page_box(::pdf_page *page, ::fz_box_type box, ::fz_rect rect)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_page_box():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << " box=" << box;
		std::cerr << " rect=" << rect;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_page_box(auto_ctx, page, box, rect);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_page_box(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_page_labels()`. */
FZ_FUNCTION void ll_pdf_set_page_labels(::pdf_document *doc, int index, ::pdf_page_label_style style, const char *prefix, int start)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_page_labels():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " index=" << index;
		std::cerr << " style=" << style;
		if (prefix) std::cerr << " prefix='" << prefix << "'";
		else std::cerr << " prefix:null";
		std::cerr << " start=" << start;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_page_labels(auto_ctx, doc, index, style, prefix, start);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_page_labels(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_populating_xref_trailer()`. */
FZ_FUNCTION void ll_pdf_set_populating_xref_trailer(::pdf_document *doc, ::pdf_obj *trailer)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_populating_xref_trailer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " trailer=" << trailer;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_populating_xref_trailer(auto_ctx, doc, trailer);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_populating_xref_trailer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_str_len()`. */
FZ_FUNCTION void ll_pdf_set_str_len(::pdf_obj *obj, size_t newlen)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_str_len():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << " newlen=" << newlen;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_str_len(auto_ctx, obj, newlen);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_str_len(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_text_field_value()`. */
FZ_FUNCTION int ll_pdf_set_text_field_value(::pdf_annot *widget, const char *value)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_text_field_value():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " widget=" << widget;
		if (value) std::cerr << " value='" << value << "'";
		else std::cerr << " value:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_set_text_field_value(auto_ctx, widget, value);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_text_field_value(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_set_usecmap()`. */
FZ_FUNCTION void ll_pdf_set_usecmap(::pdf_cmap *cmap, ::pdf_cmap *usecmap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_usecmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cmap=" << cmap;
		if (s_trace > 1) std::cerr << " usecmap=" << usecmap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_usecmap(auto_ctx, cmap, usecmap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_usecmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_set_widget_editing_state()`. */
FZ_FUNCTION void ll_pdf_set_widget_editing_state(::pdf_annot *widget, int editing)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_set_widget_editing_state():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " widget=" << widget;
		std::cerr << " editing=" << editing;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_set_widget_editing_state(auto_ctx, widget, editing);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_set_widget_editing_state(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_sign_signature()`. */
FZ_FUNCTION void ll_pdf_sign_signature(::pdf_annot *widget, ::pdf_pkcs7_signer *signer, int appearance_flags, ::fz_image *graphic, const char *reason, const char *location)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_sign_signature():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " widget=" << widget;
		if (s_trace > 1) std::cerr << " signer=" << signer;
		std::cerr << " appearance_flags=" << appearance_flags;
		if (s_trace > 1) std::cerr << " graphic=" << graphic;
		if (reason) std::cerr << " reason='" << reason << "'";
		else std::cerr << " reason:null";
		if (location) std::cerr << " location='" << location << "'";
		else std::cerr << " location:null";
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_sign_signature(auto_ctx, widget, signer, appearance_flags, graphic, reason, location);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_sign_signature(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_sign_signature_with_appearance()`. */
FZ_FUNCTION void ll_pdf_sign_signature_with_appearance(::pdf_annot *widget, ::pdf_pkcs7_signer *signer, int64_t date, ::fz_display_list *disp_list)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_sign_signature_with_appearance():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " widget=" << widget;
		if (s_trace > 1) std::cerr << " signer=" << signer;
		std::cerr << " date=" << date;
		if (s_trace > 1) std::cerr << " disp_list=" << disp_list;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_sign_signature_with_appearance(auto_ctx, widget, signer, date, disp_list);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_sign_signature_with_appearance(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_signature_appearance_signed()`. */
FZ_FUNCTION ::fz_display_list *ll_pdf_signature_appearance_signed(::fz_rect rect, ::fz_text_language lang, ::fz_image *img, const char *left_text, const char *right_text, int include_logo)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_signature_appearance_signed():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " rect=" << rect;
		std::cerr << " lang=" << lang;
		if (s_trace > 1) std::cerr << " img=" << img;
		if (left_text) std::cerr << " left_text='" << left_text << "'";
		else std::cerr << " left_text:null";
		if (right_text) std::cerr << " right_text='" << right_text << "'";
		else std::cerr << " right_text:null";
		std::cerr << " include_logo=" << include_logo;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_display_list * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_signature_appearance_signed(auto_ctx, rect, lang, img, left_text, right_text, include_logo);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_signature_appearance_signed(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_signature_appearance_unsigned()`. */
FZ_FUNCTION ::fz_display_list *ll_pdf_signature_appearance_unsigned(::fz_rect rect, ::fz_text_language lang)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_signature_appearance_unsigned():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " rect=" << rect;
		std::cerr << " lang=" << lang;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_display_list * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_signature_appearance_unsigned(auto_ctx, rect, lang);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_signature_appearance_unsigned(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_signature_byte_range()`. */
FZ_FUNCTION int ll_pdf_signature_byte_range(::pdf_document *doc, ::pdf_obj *signature, ::fz_range *byte_range)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_signature_byte_range():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " signature=" << signature;
		if (s_trace > 1) std::cerr << " byte_range=" << byte_range;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_signature_byte_range(auto_ctx, doc, signature, byte_range);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_signature_byte_range(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_signature_contents()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_signature_contents(::pdf_document *doc, ::pdf_obj *signature)` => `(size_t, char *contents)`
*/
FZ_FUNCTION size_t ll_pdf_signature_contents(::pdf_document *doc, ::pdf_obj *signature, char **contents)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_signature_contents():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " signature=" << signature;
		if (s_trace > 1) std::cerr << " contents=" << (void*) contents;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	size_t ret;
	fz_try(auto_ctx) {
		ret = ::pdf_signature_contents(auto_ctx, doc, signature, contents);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_signature_contents(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_signature_drop_distinguished_name()`. */
FZ_FUNCTION void ll_pdf_signature_drop_distinguished_name(::pdf_pkcs7_distinguished_name *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_signature_drop_distinguished_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " name=" << name;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_signature_drop_distinguished_name(auto_ctx, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_signature_drop_distinguished_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_signature_error_description()`. */
FZ_FUNCTION char *ll_pdf_signature_error_description(::pdf_signature_error err)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_signature_error_description():";
		std::cerr << " err=" << err;
		std::cerr << "\n";
	}
	#endif
	char * ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::pdf_signature_error_description(err);
	return ret;
}

/** Low-level wrapper for `::pdf_signature_format_distinguished_name()`. */
FZ_FUNCTION char *ll_pdf_signature_format_distinguished_name(::pdf_pkcs7_distinguished_name *name)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_signature_format_distinguished_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " name=" << name;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_signature_format_distinguished_name(auto_ctx, name);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_signature_format_distinguished_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_signature_get_signatory()`. */
FZ_FUNCTION ::pdf_pkcs7_distinguished_name *ll_pdf_signature_get_signatory(::pdf_pkcs7_verifier *verifier, ::pdf_document *doc, ::pdf_obj *signature)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_signature_get_signatory():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " verifier=" << verifier;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " signature=" << signature;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_pkcs7_distinguished_name * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_signature_get_signatory(auto_ctx, verifier, doc, signature);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_signature_get_signatory(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_signature_get_widget_signatory()`. */
FZ_FUNCTION ::pdf_pkcs7_distinguished_name *ll_pdf_signature_get_widget_signatory(::pdf_pkcs7_verifier *verifier, ::pdf_annot *widget)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_signature_get_widget_signatory():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " verifier=" << verifier;
		if (s_trace > 1) std::cerr << " widget=" << widget;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_pkcs7_distinguished_name * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_signature_get_widget_signatory(auto_ctx, verifier, widget);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_signature_get_widget_signatory(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_signature_hash_bytes()`. */
FZ_FUNCTION ::fz_stream *ll_pdf_signature_hash_bytes(::pdf_document *doc, ::pdf_obj *signature)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_signature_hash_bytes():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " signature=" << signature;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_stream * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_signature_hash_bytes(auto_ctx, doc, signature);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_signature_hash_bytes(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_signature_incremental_change_since_signing()`. */
FZ_FUNCTION int ll_pdf_signature_incremental_change_since_signing(::pdf_document *doc, ::pdf_obj *signature)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_signature_incremental_change_since_signing():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " signature=" << signature;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_signature_incremental_change_since_signing(auto_ctx, doc, signature);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_signature_incremental_change_since_signing(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_signature_info()`. */
FZ_FUNCTION char *ll_pdf_signature_info(const char *name, ::pdf_pkcs7_distinguished_name *dn, const char *reason, const char *location, int64_t date, int include_labels)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_signature_info():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (name) std::cerr << " name='" << name << "'";
		else std::cerr << " name:null";
		if (s_trace > 1) std::cerr << " dn=" << dn;
		if (reason) std::cerr << " reason='" << reason << "'";
		else std::cerr << " reason:null";
		if (location) std::cerr << " location='" << location << "'";
		else std::cerr << " location:null";
		std::cerr << " date=" << date;
		std::cerr << " include_labels=" << include_labels;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_signature_info(auto_ctx, name, dn, reason, location, date, include_labels);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_signature_info(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_signature_is_signed()`. */
FZ_FUNCTION int ll_pdf_signature_is_signed(::pdf_document *doc, ::pdf_obj *field)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_signature_is_signed():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " field=" << field;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_signature_is_signed(auto_ctx, doc, field);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_signature_is_signed(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_signature_set_value()`. */
FZ_FUNCTION void ll_pdf_signature_set_value(::pdf_document *doc, ::pdf_obj *field, ::pdf_pkcs7_signer *signer, int64_t stime)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_signature_set_value():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " field=" << field;
		if (s_trace > 1) std::cerr << " signer=" << signer;
		std::cerr << " stime=" << stime;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_signature_set_value(auto_ctx, doc, field, signer, stime);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_signature_set_value(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_sort_cmap()`. */
FZ_FUNCTION void ll_pdf_sort_cmap(::pdf_cmap *cmap)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_sort_cmap():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " cmap=" << cmap;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_sort_cmap(auto_ctx, cmap);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_sort_cmap(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_sort_dict()`. */
FZ_FUNCTION void ll_pdf_sort_dict(::pdf_obj *dict)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_sort_dict():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " dict=" << dict;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_sort_dict(auto_ctx, dict);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_sort_dict(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_specifics()`. */
FZ_FUNCTION ::pdf_document *ll_pdf_specifics(::fz_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_specifics():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_document * ret;
	ret = ::pdf_specifics(auto_ctx, doc);
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_specifics(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_sprint_obj()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_sprint_obj(char *buf, size_t cap, ::pdf_obj *obj, int tight, int ascii)` => `(char *, size_t len)`
*/
FZ_FUNCTION char *ll_pdf_sprint_obj(char *buf, size_t cap, size_t *len, ::pdf_obj *obj, int tight, int ascii)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_sprint_obj():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " buf=" << (void*) buf;
		std::cerr << " cap=" << cap;
		if (s_trace > 1) std::cerr << " len=" << (void*) len;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << " tight=" << tight;
		std::cerr << " ascii=" << ascii;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_sprint_obj(auto_ctx, buf, cap, len, obj, tight, ascii);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_sprint_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_store_item()`. */
FZ_FUNCTION void ll_pdf_store_item(::pdf_obj *key, void *val, size_t itemsize)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_store_item():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " key=" << key;
		if (s_trace > 1) std::cerr << " val=" << (void*) val;
		std::cerr << " itemsize=" << itemsize;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_store_item(auto_ctx, key, val, itemsize);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_store_item(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_string_from_annot_type()`. */
FZ_FUNCTION const char *ll_pdf_string_from_annot_type(enum pdf_annot_type type)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_string_from_annot_type():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " type=" << type;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_string_from_annot_type(auto_ctx, type);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_string_from_annot_type(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_string_from_intent()`. */
FZ_FUNCTION const char *ll_pdf_string_from_intent(enum pdf_intent intent)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_string_from_intent():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " intent=" << intent;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_string_from_intent(auto_ctx, intent);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_string_from_intent(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_string_from_line_ending()`. */
FZ_FUNCTION const char *ll_pdf_string_from_line_ending(enum pdf_line_ending end)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_string_from_line_ending():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		std::cerr << " end=" << end;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_string_from_line_ending(auto_ctx, end);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_string_from_line_ending(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_structure_type()`. */
FZ_FUNCTION ::fz_structure ll_pdf_structure_type(::pdf_obj *role_map, ::pdf_obj *tag)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_structure_type():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " role_map=" << role_map;
		if (s_trace > 1) std::cerr << " tag=" << tag;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_structure ret;
	fz_try(auto_ctx) {
		ret = ::pdf_structure_type(auto_ctx, role_map, tag);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_structure_type(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_subset_fonts()`. */
FZ_FUNCTION void ll_pdf_subset_fonts(::pdf_document *doc, int pages_len, const int *pages)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_subset_fonts():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " pages_len=" << pages_len;
		if (s_trace > 1) std::cerr << " pages=" << (void*) pages;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_subset_fonts(auto_ctx, doc, pages_len, pages);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_subset_fonts(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_subset_fonts2()`. */
FZ_FUNCTION void ll_pdf_subset_fonts2(::pdf_document *doc, const std::vector<int> &pages)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_subset_fonts2():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " &pages=" << &pages;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_subset_fonts2(auto_ctx, doc, pages);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_subset_fonts2(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_text_widget_format()`. */
FZ_FUNCTION int ll_pdf_text_widget_format(::pdf_annot *tw)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_text_widget_format():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " tw=" << tw;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_text_widget_format(auto_ctx, tw);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_text_widget_format(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_text_widget_max_len()`. */
FZ_FUNCTION int ll_pdf_text_widget_max_len(::pdf_annot *tw)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_text_widget_max_len():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " tw=" << tw;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_text_widget_max_len(auto_ctx, tw);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_text_widget_max_len(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_to_bool()`. */
FZ_FUNCTION int ll_pdf_to_bool(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_to_bool():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_to_bool(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_to_bool(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_to_bool_default()`. */
FZ_FUNCTION int ll_pdf_to_bool_default(::pdf_obj *obj, int def)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_to_bool_default():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << " def=" << def;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_to_bool_default(auto_ctx, obj, def);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_to_bool_default(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_to_date()`. */
FZ_FUNCTION int64_t ll_pdf_to_date(::pdf_obj *time)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_to_date():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " time=" << time;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int64_t ret;
	fz_try(auto_ctx) {
		ret = ::pdf_to_date(auto_ctx, time);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_to_date(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_to_gen()`. */
FZ_FUNCTION int ll_pdf_to_gen(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_to_gen():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_to_gen(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_to_gen(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_to_int()`. */
FZ_FUNCTION int ll_pdf_to_int(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_to_int():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_to_int(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_to_int(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_to_int64()`. */
FZ_FUNCTION int64_t ll_pdf_to_int64(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_to_int64():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int64_t ret;
	fz_try(auto_ctx) {
		ret = ::pdf_to_int64(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_to_int64(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_to_int_default()`. */
FZ_FUNCTION int ll_pdf_to_int_default(::pdf_obj *obj, int def)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_to_int_default():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << " def=" << def;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_to_int_default(auto_ctx, obj, def);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_to_int_default(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_to_matrix()`. */
FZ_FUNCTION ::fz_matrix ll_pdf_to_matrix(::pdf_obj *array)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_to_matrix():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_matrix ret;
	fz_try(auto_ctx) {
		ret = ::pdf_to_matrix(auto_ctx, array);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_to_matrix(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_to_name()`. */
FZ_FUNCTION const char *ll_pdf_to_name(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_to_name():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_to_name(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_to_name(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_to_num()`. */
FZ_FUNCTION int ll_pdf_to_num(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_to_num():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_to_num(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_to_num(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_to_quad()`. */
FZ_FUNCTION ::fz_quad ll_pdf_to_quad(::pdf_obj *array, int offset)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_to_quad():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << " offset=" << offset;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_quad ret;
	fz_try(auto_ctx) {
		ret = ::pdf_to_quad(auto_ctx, array, offset);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_to_quad(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_to_real()`. */
FZ_FUNCTION float ll_pdf_to_real(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_to_real():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	float ret;
	fz_try(auto_ctx) {
		ret = ::pdf_to_real(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_to_real(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_to_real_default()`. */
FZ_FUNCTION float ll_pdf_to_real_default(::pdf_obj *obj, float def)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_to_real_default():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << " def=" << def;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	float ret;
	fz_try(auto_ctx) {
		ret = ::pdf_to_real_default(auto_ctx, obj, def);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_to_real_default(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_to_rect()`. */
FZ_FUNCTION ::fz_rect ll_pdf_to_rect(::pdf_obj *array)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_to_rect():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " array=" << array;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_rect ret;
	fz_try(auto_ctx) {
		ret = ::pdf_to_rect(auto_ctx, array);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_to_rect(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_to_str_buf()`. */
FZ_FUNCTION char *ll_pdf_to_str_buf(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_to_str_buf():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_to_str_buf(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_to_str_buf(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_to_str_len()`. */
FZ_FUNCTION size_t ll_pdf_to_str_len(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_to_str_len():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	size_t ret;
	fz_try(auto_ctx) {
		ret = ::pdf_to_str_len(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_to_str_len(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_to_string()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_to_string(::pdf_obj *obj)` => `(const char *, size_t sizep)`
*/
FZ_FUNCTION const char *ll_pdf_to_string(::pdf_obj *obj, size_t *sizep)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_to_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		if (s_trace > 1) std::cerr << " sizep=" << (void*) sizep;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_to_string(auto_ctx, obj, sizep);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_to_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_to_text_string()`. */
FZ_FUNCTION const char *ll_pdf_to_text_string(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_to_text_string():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_to_text_string(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_to_text_string(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_toggle_layer_config_ui()`. */
FZ_FUNCTION void ll_pdf_toggle_layer_config_ui(::pdf_document *doc, int ui)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_toggle_layer_config_ui():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " ui=" << ui;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_toggle_layer_config_ui(auto_ctx, doc, ui);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_toggle_layer_config_ui(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_toggle_widget()`. */
FZ_FUNCTION int ll_pdf_toggle_widget(::pdf_annot *widget)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_toggle_widget():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " widget=" << widget;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_toggle_widget(auto_ctx, widget);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_toggle_widget(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_tos_get_text()`. */
FZ_FUNCTION ::fz_text *ll_pdf_tos_get_text(::pdf_text_object_state *tos)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_tos_get_text():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " tos=" << tos;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_text * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_tos_get_text(auto_ctx, tos);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_tos_get_text(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_tos_make_trm()`. */
FZ_FUNCTION int ll_pdf_tos_make_trm(::pdf_text_object_state *tos, ::pdf_text_state *text, ::pdf_font_desc *fontdesc, int cid, ::fz_matrix *trm)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_tos_make_trm():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " tos=" << tos;
		if (s_trace > 1) std::cerr << " text=" << text;
		if (s_trace > 1) std::cerr << " fontdesc=" << fontdesc;
		std::cerr << " cid=" << cid;
		std::cerr << " trm=" << trm;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_tos_make_trm(auto_ctx, tos, text, fontdesc, cid, trm);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_tos_make_trm(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_tos_move_after_char()`. */
FZ_FUNCTION void ll_pdf_tos_move_after_char(::pdf_text_object_state *tos)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_tos_move_after_char():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " tos=" << tos;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_tos_move_after_char(auto_ctx, tos);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_tos_move_after_char(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_tos_newline()`. */
FZ_FUNCTION void ll_pdf_tos_newline(::pdf_text_object_state *tos, float leading)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_tos_newline():";
		if (s_trace > 1) std::cerr << " tos=" << tos;
		std::cerr << " leading=" << leading;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::pdf_tos_newline(tos, leading);
}

/** Low-level wrapper for `::pdf_tos_reset()`. */
FZ_FUNCTION void ll_pdf_tos_reset(::pdf_text_object_state *tos, int render)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_tos_reset():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " tos=" << tos;
		std::cerr << " render=" << render;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_tos_reset(auto_ctx, tos, render);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_tos_reset(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_tos_restore()`. */
FZ_FUNCTION void ll_pdf_tos_restore(::pdf_text_object_state *tos, ::fz_matrix save[2])
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_tos_restore():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " tos=" << tos;
		std::cerr << " save=" << save;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_tos_restore(auto_ctx, tos, save);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_tos_restore(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_tos_save()`. */
FZ_FUNCTION void ll_pdf_tos_save(::pdf_text_object_state *tos, ::fz_matrix save[2])
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_tos_save():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " tos=" << tos;
		std::cerr << " save=" << save;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_tos_save(auto_ctx, tos, save);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_tos_save(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_tos_set_matrix()`. */
FZ_FUNCTION void ll_pdf_tos_set_matrix(::pdf_text_object_state *tos, float a, float b, float c, float d, float e, float f)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_tos_set_matrix():";
		if (s_trace > 1) std::cerr << " tos=" << tos;
		std::cerr << " a=" << a;
		std::cerr << " b=" << b;
		std::cerr << " c=" << c;
		std::cerr << " d=" << d;
		std::cerr << " e=" << e;
		std::cerr << " f=" << f;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::pdf_tos_set_matrix(tos, a, b, c, d, e, f);
}

/** Low-level wrapper for `::pdf_tos_translate()`. */
FZ_FUNCTION void ll_pdf_tos_translate(::pdf_text_object_state *tos, float tx, float ty)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_tos_translate():";
		if (s_trace > 1) std::cerr << " tos=" << tos;
		std::cerr << " tx=" << tx;
		std::cerr << " ty=" << ty;
		std::cerr << "\n";
	}
	#endif
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	::pdf_tos_translate(tos, tx, ty);
}

/** Low-level wrapper for `::pdf_trailer()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_trailer(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_trailer():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_trailer(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_trailer(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_undo()`. */
FZ_FUNCTION void ll_pdf_undo(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_undo():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_undo(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_undo(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_undoredo_state()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_undoredo_state(::pdf_document *doc)` => `(int, int steps)`
*/
FZ_FUNCTION int ll_pdf_undoredo_state(::pdf_document *doc, int *steps)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_undoredo_state():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " steps=" << (void*) steps;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_undoredo_state(auto_ctx, doc, steps);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_undoredo_state(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_undoredo_step()`. */
FZ_FUNCTION const char *ll_pdf_undoredo_step(::pdf_document *doc, int step)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_undoredo_step():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " step=" << step;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	const char * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_undoredo_step(auto_ctx, doc, step);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_undoredo_step(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_unmark_obj()`. */
FZ_FUNCTION void ll_pdf_unmark_obj(::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_unmark_obj():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_unmark_obj(auto_ctx, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_unmark_obj(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_update_annot()`. */
FZ_FUNCTION int ll_pdf_update_annot(::pdf_annot *annot)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_update_annot():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " annot=" << annot;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_update_annot(auto_ctx, annot);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_update_annot(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_update_default_colorspaces()`. */
FZ_FUNCTION ::fz_default_colorspaces *ll_pdf_update_default_colorspaces(::fz_default_colorspaces *old_cs, ::pdf_obj *res)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_update_default_colorspaces():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " old_cs=" << old_cs;
		if (s_trace > 1) std::cerr << " res=" << res;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_default_colorspaces * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_update_default_colorspaces(auto_ctx, old_cs, res);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_update_default_colorspaces(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_update_object()`. */
FZ_FUNCTION void ll_pdf_update_object(::pdf_document *doc, int num, ::pdf_obj *obj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_update_object():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " num=" << num;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_update_object(auto_ctx, doc, num, obj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_update_object(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_update_page()`. */
FZ_FUNCTION int ll_pdf_update_page(::pdf_page *page)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_update_page():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " page=" << page;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_update_page(auto_ctx, page);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_update_page(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_update_stream()`. */
FZ_FUNCTION void ll_pdf_update_stream(::pdf_document *doc, ::pdf_obj *ref, ::fz_buffer *buf, int compressed)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_update_stream():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " ref=" << ref;
		if (s_trace > 1) std::cerr << " buf=" << buf;
		std::cerr << " compressed=" << compressed;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_update_stream(auto_ctx, doc, ref, buf, compressed);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_update_stream(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_update_widget()`. */
FZ_FUNCTION int ll_pdf_update_widget(::pdf_annot *widget)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_update_widget():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " widget=" << widget;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_update_widget(auto_ctx, widget);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_update_widget(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_update_xobject()`. */
FZ_FUNCTION void ll_pdf_update_xobject(::pdf_document *doc, ::pdf_obj *xobj, ::fz_rect bbox, ::fz_matrix mat, ::pdf_obj *res, ::fz_buffer *buffer)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_update_xobject():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " xobj=" << xobj;
		std::cerr << " bbox=" << bbox;
		std::cerr << " mat=" << mat;
		if (s_trace > 1) std::cerr << " res=" << res;
		if (s_trace > 1) std::cerr << " buffer=" << buffer;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_update_xobject(auto_ctx, doc, xobj, bbox, mat, res, buffer);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_update_xobject(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_validate_change_history()`. */
FZ_FUNCTION int ll_pdf_validate_change_history(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_validate_change_history():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_validate_change_history(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_validate_change_history(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_validate_changes()`. */
FZ_FUNCTION int ll_pdf_validate_changes(::pdf_document *doc, int version)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_validate_changes():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " version=" << version;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_validate_changes(auto_ctx, doc, version);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_validate_changes(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_validate_signature()`. */
FZ_FUNCTION int ll_pdf_validate_signature(::pdf_annot *widget)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_validate_signature():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " widget=" << widget;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_validate_signature(auto_ctx, widget);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_validate_signature(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_verify_embedded_file_checksum()`. */
FZ_FUNCTION int ll_pdf_verify_embedded_file_checksum(::pdf_obj *fs)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_verify_embedded_file_checksum():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " fs=" << fs;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_verify_embedded_file_checksum(auto_ctx, fs);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_verify_embedded_file_checksum(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_version()`. */
FZ_FUNCTION int ll_pdf_version(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_version():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_version(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_version(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_walk_tree()`.

This function has out-params. Python/C# wrappers look like:
	`ll_pdf_walk_tree(::pdf_obj *tree, ::pdf_obj *kid_name, void (*arrive)(::fz_context *, ::pdf_obj *, void *, ::pdf_obj **), void (*leave)(::fz_context *, ::pdf_obj *, void *), void *arg, ::pdf_obj **names, ::pdf_obj **values)` => `()`
*/
FZ_FUNCTION void ll_pdf_walk_tree(::pdf_obj *tree, ::pdf_obj *kid_name, void (*arrive)(::fz_context *, ::pdf_obj *, void *, ::pdf_obj **), void (*leave)(::fz_context *, ::pdf_obj *, void *), void *arg, ::pdf_obj **names, ::pdf_obj **values)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_walk_tree():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " tree=" << tree;
		if (s_trace > 1) std::cerr << " kid_name=" << kid_name;
		if (s_trace > 1) std::cerr << " arrive=" << (void*) arrive;
		if (s_trace > 1) std::cerr << " leave=" << (void*) leave;
		if (s_trace > 1) std::cerr << " arg=" << (void*) arg;
		if (s_trace > 1) std::cerr << " names=" << (void*) names;
		if (s_trace > 1) std::cerr << " values=" << (void*) values;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_walk_tree(auto_ctx, tree, kid_name, arrive, leave, arg, names, values);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_walk_tree(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_was_pure_xfa()`. */
FZ_FUNCTION int ll_pdf_was_pure_xfa(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_was_pure_xfa():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_was_pure_xfa(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_was_pure_xfa(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_was_repaired()`. */
FZ_FUNCTION int ll_pdf_was_repaired(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_was_repaired():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_was_repaired(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_was_repaired(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_widget_is_readonly()`. */
FZ_FUNCTION int ll_pdf_widget_is_readonly(::pdf_annot *widget)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_widget_is_readonly():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " widget=" << widget;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_widget_is_readonly(auto_ctx, widget);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_widget_is_readonly(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_widget_is_signed()`. */
FZ_FUNCTION int ll_pdf_widget_is_signed(::pdf_annot *widget)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_widget_is_signed():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " widget=" << widget;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_widget_is_signed(auto_ctx, widget);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_widget_is_signed(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_widget_type()`. */
FZ_FUNCTION enum pdf_widget_type ll_pdf_widget_type(::pdf_annot *widget)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_widget_type():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " widget=" << widget;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	enum pdf_widget_type ret;
	fz_try(auto_ctx) {
		ret = ::pdf_widget_type(auto_ctx, widget);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_widget_type(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_write_digest()`. */
FZ_FUNCTION void ll_pdf_write_digest(::fz_output *out, ::pdf_obj *byte_range, ::pdf_obj *field, size_t digest_offset, size_t digest_length, ::pdf_pkcs7_signer *signer)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_write_digest():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " out=" << out;
		if (s_trace > 1) std::cerr << " byte_range=" << byte_range;
		if (s_trace > 1) std::cerr << " field=" << field;
		std::cerr << " digest_offset=" << digest_offset;
		std::cerr << " digest_length=" << digest_length;
		if (s_trace > 1) std::cerr << " signer=" << signer;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_write_digest(auto_ctx, out, byte_range, field, digest_offset, digest_length, signer);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_write_digest(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_write_document()`. */
FZ_FUNCTION void ll_pdf_write_document(::pdf_document *doc, ::fz_output *out, const ::pdf_write_options *opts)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_write_document():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << " opts=" << opts;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_write_document(auto_ctx, doc, out, opts);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_write_document(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_write_journal()`. */
FZ_FUNCTION void ll_pdf_write_journal(::pdf_document *doc, ::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_write_journal():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_write_journal(auto_ctx, doc, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_write_journal(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_write_snapshot()`. */
FZ_FUNCTION void ll_pdf_write_snapshot(::pdf_document *doc, ::fz_output *out)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_write_snapshot():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " out=" << out;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_write_snapshot(auto_ctx, doc, out);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_write_snapshot(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_xobject_bbox()`. */
FZ_FUNCTION ::fz_rect ll_pdf_xobject_bbox(::pdf_obj *xobj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_xobject_bbox():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " xobj=" << xobj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_rect ret;
	fz_try(auto_ctx) {
		ret = ::pdf_xobject_bbox(auto_ctx, xobj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_xobject_bbox(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_xobject_colorspace()`. */
FZ_FUNCTION ::fz_colorspace *ll_pdf_xobject_colorspace(::pdf_obj *xobj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_xobject_colorspace():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " xobj=" << xobj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_colorspace * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_xobject_colorspace(auto_ctx, xobj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_xobject_colorspace(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_xobject_isolated()`. */
FZ_FUNCTION int ll_pdf_xobject_isolated(::pdf_obj *xobj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_xobject_isolated():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " xobj=" << xobj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_xobject_isolated(auto_ctx, xobj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_xobject_isolated(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_xobject_knockout()`. */
FZ_FUNCTION int ll_pdf_xobject_knockout(::pdf_obj *xobj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_xobject_knockout():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " xobj=" << xobj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_xobject_knockout(auto_ctx, xobj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_xobject_knockout(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_xobject_matrix()`. */
FZ_FUNCTION ::fz_matrix ll_pdf_xobject_matrix(::pdf_obj *xobj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_xobject_matrix():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " xobj=" << xobj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_matrix ret;
	fz_try(auto_ctx) {
		ret = ::pdf_xobject_matrix(auto_ctx, xobj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_xobject_matrix(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_xobject_resources()`. */
FZ_FUNCTION ::pdf_obj *ll_pdf_xobject_resources(::pdf_obj *xobj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_xobject_resources():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " xobj=" << xobj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	pdf_obj * ret;
	fz_try(auto_ctx) {
		ret = ::pdf_xobject_resources(auto_ctx, xobj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_xobject_resources(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_xobject_transparency()`. */
FZ_FUNCTION int ll_pdf_xobject_transparency(::pdf_obj *xobj)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_xobject_transparency():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " xobj=" << xobj;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_xobject_transparency(auto_ctx, xobj);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_xobject_transparency(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_xref_ensure_incremental_object()`. */
FZ_FUNCTION int ll_pdf_xref_ensure_incremental_object(::pdf_document *doc, int num)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_xref_ensure_incremental_object():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " num=" << num;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_xref_ensure_incremental_object(auto_ctx, doc, num);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_xref_ensure_incremental_object(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_xref_ensure_local_object()`. */
FZ_FUNCTION void ll_pdf_xref_ensure_local_object(::pdf_document *doc, int num)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_xref_ensure_local_object():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " num=" << num;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_xref_ensure_local_object(auto_ctx, doc, num);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_xref_ensure_local_object(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_xref_entry_map()`. */
FZ_FUNCTION void ll_pdf_xref_entry_map(::pdf_document *doc, void (*fn)(::fz_context *, ::pdf_xref_entry *, int , ::pdf_document *, void *), void *arg)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_xref_entry_map():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " fn=" << (void*) fn;
		if (s_trace > 1) std::cerr << " arg=" << (void*) arg;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_xref_entry_map(auto_ctx, doc, fn, arg);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_xref_entry_map(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_xref_is_incremental()`. */
FZ_FUNCTION int ll_pdf_xref_is_incremental(::pdf_document *doc, int num)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_xref_is_incremental():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << " num=" << num;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_xref_is_incremental(auto_ctx, doc, num);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_xref_is_incremental(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_xref_len()`. */
FZ_FUNCTION int ll_pdf_xref_len(::pdf_document *doc)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_xref_len():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	int ret;
	fz_try(auto_ctx) {
		ret = ::pdf_xref_len(auto_ctx, doc);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_xref_len(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
	return ret;
}

/** Low-level wrapper for `::pdf_xref_obj_is_unsaved_signature()`. */
FZ_FUNCTION int ll_pdf_xref_obj_is_unsaved_signature(::pdf_document *doc, ::pdf_obj *obj)
{
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_xref_obj_is_unsaved_signature():";
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " obj=" << obj;
		std::cerr << "\n";
	}
	#endif
	int ret;
	/* No fz_context* arg, so no need for fz_try()/fz_catch() to convert MuPDF exceptions into C++ exceptions. */
	ret = ::pdf_xref_obj_is_unsaved_signature(doc, obj);
	return ret;
}

/** Low-level wrapper for `::pdf_xref_remove_unsaved_signature()`. */
FZ_FUNCTION void ll_pdf_xref_remove_unsaved_signature(::pdf_document *doc, ::pdf_obj *field)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_xref_remove_unsaved_signature():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " field=" << field;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_xref_remove_unsaved_signature(auto_ctx, doc, field);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_xref_remove_unsaved_signature(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}

/** Low-level wrapper for `::pdf_xref_store_unsaved_signature()`. */
FZ_FUNCTION void ll_pdf_xref_store_unsaved_signature(::pdf_document *doc, ::pdf_obj *field, ::pdf_pkcs7_signer *signer)
{
	fz_context* auto_ctx = internal_context_get();
	#ifndef NDEBUG
	if (s_trace > 1) {
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): calling pdf_xref_store_unsaved_signature():";
		if (s_trace > 1) std::cerr << " auto_ctx=" << auto_ctx;
		if (s_trace > 1) std::cerr << " doc=" << doc;
		if (s_trace > 1) std::cerr << " field=" << field;
		if (s_trace > 1) std::cerr << " signer=" << signer;
		std::cerr << "\n";
	}
	#endif
	#ifndef NDEBUG
		long stack0;
		if (s_check_error_stack)
		{
			stack0 = auto_ctx->error.top - auto_ctx->error.stack_base;
		}
	#endif
	fz_try(auto_ctx) {
		::pdf_xref_store_unsaved_signature(auto_ctx, doc, field, signer);
	}
	fz_catch(auto_ctx) {
		#ifndef NDEBUG
		if (s_trace_exceptions) {
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): fz_catch() has caught exception.\n";
		}
		#endif
		internal_throw_exception(auto_ctx);
	}
	#ifndef NDEBUG
		if (s_check_error_stack)
		{
			long stack1 = auto_ctx->error.top - auto_ctx->error.stack_base;
			if (stack1 != stack0)
				std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): MuPDF error stack size changed by pdf_xref_store_unsaved_signature(): " << stack0 << " -> " << stack1 << "\n";
		}
	#endif
}


FZ_FUNCTION pdf_obj* ll_pdf_dict_getlv( pdf_obj* dict, va_list keys)
{
	pdf_obj *key;
	while (dict != NULL && (key = va_arg(keys, pdf_obj *)) != NULL)
	{
		dict = ll_pdf_dict_get( dict, key);
	}
	return dict;
}

FZ_FUNCTION pdf_obj* ll_pdf_dict_getl( pdf_obj* dict, ...)
{
	va_list keys;
	va_start(keys, dict);
	try
	{
		dict = ll_pdf_dict_getlv( dict, keys);
	}
	catch( std::exception&)
	{
		va_end(keys);
		throw;
	}
	va_end(keys);
	return dict;
}

FZ_FUNCTION std::string to_string_fz_aa_context(const ::fz_aa_context& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::fz_aa_context& s)
{
	return to_string_fz_aa_context(s);
}

FZ_FUNCTION std::string to_string_fz_color_params(const ::fz_color_params& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::fz_color_params& s)
{
	return to_string_fz_color_params(s);
}

FZ_FUNCTION std::string to_string_fz_cookie(const ::fz_cookie& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::fz_cookie& s)
{
	return to_string_fz_cookie(s);
}

FZ_FUNCTION std::string to_string_fz_draw_options(const ::fz_draw_options& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::fz_draw_options& s)
{
	return to_string_fz_draw_options(s);
}

FZ_FUNCTION std::string to_string_fz_install_load_system_font_funcs_args(const ::fz_install_load_system_font_funcs_args& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::fz_install_load_system_font_funcs_args& s)
{
	return to_string_fz_install_load_system_font_funcs_args(s);
}

FZ_FUNCTION std::string to_string_fz_irect(const ::fz_irect& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::fz_irect& s)
{
	return to_string_fz_irect(s);
}

FZ_FUNCTION std::string to_string_fz_location(const ::fz_location& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::fz_location& s)
{
	return to_string_fz_location(s);
}

FZ_FUNCTION std::string to_string_fz_matrix(const ::fz_matrix& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::fz_matrix& s)
{
	return to_string_fz_matrix(s);
}

FZ_FUNCTION std::string to_string_fz_md5(const ::fz_md5& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::fz_md5& s)
{
	return to_string_fz_md5(s);
}

FZ_FUNCTION std::string to_string_fz_outline_item(const ::fz_outline_item& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::fz_outline_item& s)
{
	return to_string_fz_outline_item(s);
}

FZ_FUNCTION std::string to_string_fz_pdfocr_options(const ::fz_pdfocr_options& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::fz_pdfocr_options& s)
{
	return to_string_fz_pdfocr_options(s);
}

FZ_FUNCTION std::string to_string_fz_point(const ::fz_point& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::fz_point& s)
{
	return to_string_fz_point(s);
}

FZ_FUNCTION std::string to_string_fz_pwg_options(const ::fz_pwg_options& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::fz_pwg_options& s)
{
	return to_string_fz_pwg_options(s);
}

FZ_FUNCTION std::string to_string_fz_quad(const ::fz_quad& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::fz_quad& s)
{
	return to_string_fz_quad(s);
}

FZ_FUNCTION std::string to_string_fz_rect(const ::fz_rect& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::fz_rect& s)
{
	return to_string_fz_rect(s);
}

FZ_FUNCTION std::string to_string_fz_stext_options(const ::fz_stext_options& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::fz_stext_options& s)
{
	return to_string_fz_stext_options(s);
}

FZ_FUNCTION std::string to_string_fz_story_element_position(const ::fz_story_element_position& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::fz_story_element_position& s)
{
	return to_string_fz_story_element_position(s);
}

FZ_FUNCTION std::string to_string_fz_transition(const ::fz_transition& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::fz_transition& s)
{
	return to_string_fz_transition(s);
}

FZ_FUNCTION std::string to_string_pdf_clean_options(const ::pdf_clean_options& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::pdf_clean_options& s)
{
	return to_string_pdf_clean_options(s);
}

FZ_FUNCTION std::string to_string_pdf_filter_factory(const ::pdf_filter_factory& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::pdf_filter_factory& s)
{
	return to_string_pdf_filter_factory(s);
}

FZ_FUNCTION std::string to_string_pdf_filter_options(const ::pdf_filter_options& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::pdf_filter_options& s)
{
	return to_string_pdf_filter_options(s);
}

FZ_FUNCTION std::string to_string_pdf_image_rewriter_options(const ::pdf_image_rewriter_options& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::pdf_image_rewriter_options& s)
{
	return to_string_pdf_image_rewriter_options(s);
}

FZ_FUNCTION std::string to_string_pdf_layer_config(const ::pdf_layer_config& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::pdf_layer_config& s)
{
	return to_string_pdf_layer_config(s);
}

FZ_FUNCTION std::string to_string_pdf_layer_config_ui(const ::pdf_layer_config_ui& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::pdf_layer_config_ui& s)
{
	return to_string_pdf_layer_config_ui(s);
}

FZ_FUNCTION std::string to_string_pdf_redact_options(const ::pdf_redact_options& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::pdf_redact_options& s)
{
	return to_string_pdf_redact_options(s);
}

FZ_FUNCTION std::string to_string_pdf_sanitize_filter_options(const ::pdf_sanitize_filter_options& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::pdf_sanitize_filter_options& s)
{
	return to_string_pdf_sanitize_filter_options(s);
}

FZ_FUNCTION std::string to_string_pdf_write_options(const ::pdf_write_options& s)
{
	std::ostringstream buffer;
	buffer << s;
	return buffer.str();
}

FZ_FUNCTION std::string to_string(const ::pdf_write_options& s)
{
	return to_string_pdf_write_options(s);
}

} /* End of namespace mupdf. */

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::fz_aa_context& rhs)
{
	out
			<< "("
			<<  "hscale=" << rhs.hscale
			<< " vscale=" << rhs.vscale
			<< " scale=" << rhs.scale
			<< " bits=" << rhs.bits
			<< " text_bits=" << rhs.text_bits
			<< " min_line_width=" << rhs.min_line_width
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::fz_aa_context& lhs, const ::fz_aa_context& rhs)
{
	if (lhs.hscale != rhs.hscale) return false;
	if (lhs.vscale != rhs.vscale) return false;
	if (lhs.scale != rhs.scale) return false;
	if (lhs.bits != rhs.bits) return false;
	if (lhs.text_bits != rhs.text_bits) return false;
	if (lhs.min_line_width != rhs.min_line_width) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::fz_aa_context& lhs, const ::fz_aa_context& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::fz_color_params& rhs)
{
	out
			<< "("
			<<  "ri=" << rhs.ri
			<< " bp=" << rhs.bp
			<< " op=" << rhs.op
			<< " opm=" << rhs.opm
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::fz_color_params& lhs, const ::fz_color_params& rhs)
{
	if (lhs.ri != rhs.ri) return false;
	if (lhs.bp != rhs.bp) return false;
	if (lhs.op != rhs.op) return false;
	if (lhs.opm != rhs.opm) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::fz_color_params& lhs, const ::fz_color_params& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::fz_cookie& rhs)
{
	out
			<< "("
			<<  "abort=" << rhs.abort
			<< " progress=" << rhs.progress
			<< " progress_max=" << rhs.progress_max
			<< " errors=" << rhs.errors
			<< " incomplete=" << rhs.incomplete
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::fz_cookie& lhs, const ::fz_cookie& rhs)
{
	if (lhs.abort != rhs.abort) return false;
	if (lhs.progress != rhs.progress) return false;
	if (lhs.progress_max != rhs.progress_max) return false;
	if (lhs.errors != rhs.errors) return false;
	if (lhs.incomplete != rhs.incomplete) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::fz_cookie& lhs, const ::fz_cookie& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::fz_draw_options& rhs)
{
	out
			<< "("
			<<  "rotate=" << rhs.rotate
			<< " x_resolution=" << rhs.x_resolution
			<< " y_resolution=" << rhs.y_resolution
			<< " width=" << rhs.width
			<< " height=" << rhs.height
			<< " colorspace=" << rhs.colorspace
			<< " alpha=" << rhs.alpha
			<< " graphics=" << rhs.graphics
			<< " text=" << rhs.text
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::fz_draw_options& lhs, const ::fz_draw_options& rhs)
{
	if (lhs.rotate != rhs.rotate) return false;
	if (lhs.x_resolution != rhs.x_resolution) return false;
	if (lhs.y_resolution != rhs.y_resolution) return false;
	if (lhs.width != rhs.width) return false;
	if (lhs.height != rhs.height) return false;
	if (lhs.colorspace != rhs.colorspace) return false;
	if (lhs.alpha != rhs.alpha) return false;
	if (lhs.graphics != rhs.graphics) return false;
	if (lhs.text != rhs.text) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::fz_draw_options& lhs, const ::fz_draw_options& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::fz_install_load_system_font_funcs_args& rhs)
{
	out
			<< "("
			<<  "f=" << rhs.f
			<< " f_cjk=" << rhs.f_cjk
			<< " f_fallback=" << rhs.f_fallback
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::fz_install_load_system_font_funcs_args& lhs, const ::fz_install_load_system_font_funcs_args& rhs)
{
	if (lhs.f != rhs.f) return false;
	if (lhs.f_cjk != rhs.f_cjk) return false;
	if (lhs.f_fallback != rhs.f_fallback) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::fz_install_load_system_font_funcs_args& lhs, const ::fz_install_load_system_font_funcs_args& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::fz_irect& rhs)
{
	out
			<< "("
			<<  "x0=" << rhs.x0
			<< " y0=" << rhs.y0
			<< " x1=" << rhs.x1
			<< " y1=" << rhs.y1
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::fz_irect& lhs, const ::fz_irect& rhs)
{
	if (lhs.x0 != rhs.x0) return false;
	if (lhs.y0 != rhs.y0) return false;
	if (lhs.x1 != rhs.x1) return false;
	if (lhs.y1 != rhs.y1) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::fz_irect& lhs, const ::fz_irect& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::fz_location& rhs)
{
	out
			<< "("
			<<  "chapter=" << rhs.chapter
			<< " page=" << rhs.page
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::fz_location& lhs, const ::fz_location& rhs)
{
	if (lhs.chapter != rhs.chapter) return false;
	if (lhs.page != rhs.page) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::fz_location& lhs, const ::fz_location& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::fz_matrix& rhs)
{
	out
			<< "("
			<<  "a=" << rhs.a
			<< " b=" << rhs.b
			<< " c=" << rhs.c
			<< " d=" << rhs.d
			<< " e=" << rhs.e
			<< " f=" << rhs.f
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::fz_matrix& lhs, const ::fz_matrix& rhs)
{
	if (lhs.a != rhs.a) return false;
	if (lhs.b != rhs.b) return false;
	if (lhs.c != rhs.c) return false;
	if (lhs.d != rhs.d) return false;
	if (lhs.e != rhs.e) return false;
	if (lhs.f != rhs.f) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::fz_matrix& lhs, const ::fz_matrix& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::fz_md5& rhs)
{
	out
			<< "("
			<<  "lo=" << rhs.lo
			<< " hi=" << rhs.hi
			<< " a=" << rhs.a
			<< " b=" << rhs.b
			<< " c=" << rhs.c
			<< " d=" << rhs.d
			<< " buffer=" << rhs.buffer
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::fz_md5& lhs, const ::fz_md5& rhs)
{
	if (lhs.lo != rhs.lo) return false;
	if (lhs.hi != rhs.hi) return false;
	if (lhs.a != rhs.a) return false;
	if (lhs.b != rhs.b) return false;
	if (lhs.c != rhs.c) return false;
	if (lhs.d != rhs.d) return false;
	if (lhs.buffer != rhs.buffer) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::fz_md5& lhs, const ::fz_md5& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::fz_outline_item& rhs)
{
	out
			<< "("
			<<  "title=" << rhs.title
			<< " uri=" << rhs.uri
			<< " is_open=" << rhs.is_open
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::fz_outline_item& lhs, const ::fz_outline_item& rhs)
{
	if (lhs.title != rhs.title) return false;
	if (lhs.uri != rhs.uri) return false;
	if (lhs.is_open != rhs.is_open) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::fz_outline_item& lhs, const ::fz_outline_item& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::fz_pdfocr_options& rhs)
{
	out
			<< "("
			<<  "compress=" << rhs.compress
			<< " strip_height=" << rhs.strip_height
			<< " language=" << rhs.language
			<< " datadir=" << rhs.datadir
			<< " page_count=" << rhs.page_count
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::fz_pdfocr_options& lhs, const ::fz_pdfocr_options& rhs)
{
	if (lhs.compress != rhs.compress) return false;
	if (lhs.strip_height != rhs.strip_height) return false;
	if (lhs.language != rhs.language) return false;
	if (lhs.datadir != rhs.datadir) return false;
	if (lhs.page_count != rhs.page_count) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::fz_pdfocr_options& lhs, const ::fz_pdfocr_options& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::fz_point& rhs)
{
	out
			<< "("
			<<  "x=" << rhs.x
			<< " y=" << rhs.y
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::fz_point& lhs, const ::fz_point& rhs)
{
	if (lhs.x != rhs.x) return false;
	if (lhs.y != rhs.y) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::fz_point& lhs, const ::fz_point& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::fz_pwg_options& rhs)
{
	out
			<< "("
			<<  "media_class=" << rhs.media_class
			<< " media_color=" << rhs.media_color
			<< " media_type=" << rhs.media_type
			<< " output_type=" << rhs.output_type
			<< " advance_distance=" << rhs.advance_distance
			<< " advance_media=" << rhs.advance_media
			<< " collate=" << rhs.collate
			<< " cut_media=" << rhs.cut_media
			<< " duplex=" << rhs.duplex
			<< " insert_sheet=" << rhs.insert_sheet
			<< " jog=" << rhs.jog
			<< " leading_edge=" << rhs.leading_edge
			<< " manual_feed=" << rhs.manual_feed
			<< " media_position=" << rhs.media_position
			<< " media_weight=" << rhs.media_weight
			<< " mirror_print=" << rhs.mirror_print
			<< " negative_print=" << rhs.negative_print
			<< " num_copies=" << rhs.num_copies
			<< " orientation=" << rhs.orientation
			<< " output_face_up=" << rhs.output_face_up
			<< " PageSize=" << rhs.PageSize
			<< " separations=" << rhs.separations
			<< " tray_switch=" << rhs.tray_switch
			<< " tumble=" << rhs.tumble
			<< " media_type_num=" << rhs.media_type_num
			<< " compression=" << rhs.compression
			<< " row_count=" << rhs.row_count
			<< " row_feed=" << rhs.row_feed
			<< " row_step=" << rhs.row_step
			<< " rendering_intent=" << rhs.rendering_intent
			<< " page_size_name=" << rhs.page_size_name
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::fz_pwg_options& lhs, const ::fz_pwg_options& rhs)
{
	if (lhs.media_class != rhs.media_class) return false;
	if (lhs.media_color != rhs.media_color) return false;
	if (lhs.media_type != rhs.media_type) return false;
	if (lhs.output_type != rhs.output_type) return false;
	if (lhs.advance_distance != rhs.advance_distance) return false;
	if (lhs.advance_media != rhs.advance_media) return false;
	if (lhs.collate != rhs.collate) return false;
	if (lhs.cut_media != rhs.cut_media) return false;
	if (lhs.duplex != rhs.duplex) return false;
	if (lhs.insert_sheet != rhs.insert_sheet) return false;
	if (lhs.jog != rhs.jog) return false;
	if (lhs.leading_edge != rhs.leading_edge) return false;
	if (lhs.manual_feed != rhs.manual_feed) return false;
	if (lhs.media_position != rhs.media_position) return false;
	if (lhs.media_weight != rhs.media_weight) return false;
	if (lhs.mirror_print != rhs.mirror_print) return false;
	if (lhs.negative_print != rhs.negative_print) return false;
	if (lhs.num_copies != rhs.num_copies) return false;
	if (lhs.orientation != rhs.orientation) return false;
	if (lhs.output_face_up != rhs.output_face_up) return false;
	if (lhs.PageSize != rhs.PageSize) return false;
	if (lhs.separations != rhs.separations) return false;
	if (lhs.tray_switch != rhs.tray_switch) return false;
	if (lhs.tumble != rhs.tumble) return false;
	if (lhs.media_type_num != rhs.media_type_num) return false;
	if (lhs.compression != rhs.compression) return false;
	if (lhs.row_count != rhs.row_count) return false;
	if (lhs.row_feed != rhs.row_feed) return false;
	if (lhs.row_step != rhs.row_step) return false;
	if (lhs.rendering_intent != rhs.rendering_intent) return false;
	if (lhs.page_size_name != rhs.page_size_name) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::fz_pwg_options& lhs, const ::fz_pwg_options& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::fz_quad& rhs)
{
	out
			<< "("
			<<  "ul=" << rhs.ul
			<< " ur=" << rhs.ur
			<< " ll=" << rhs.ll
			<< " lr=" << rhs.lr
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::fz_quad& lhs, const ::fz_quad& rhs)
{
	if (lhs.ul != rhs.ul) return false;
	if (lhs.ur != rhs.ur) return false;
	if (lhs.ll != rhs.ll) return false;
	if (lhs.lr != rhs.lr) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::fz_quad& lhs, const ::fz_quad& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::fz_rect& rhs)
{
	out
			<< "("
			<<  "x0=" << rhs.x0
			<< " y0=" << rhs.y0
			<< " x1=" << rhs.x1
			<< " y1=" << rhs.y1
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::fz_rect& lhs, const ::fz_rect& rhs)
{
	if (lhs.x0 != rhs.x0) return false;
	if (lhs.y0 != rhs.y0) return false;
	if (lhs.x1 != rhs.x1) return false;
	if (lhs.y1 != rhs.y1) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::fz_rect& lhs, const ::fz_rect& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::fz_stext_options& rhs)
{
	out
			<< "("
			<<  "flags=" << rhs.flags
			<< " scale=" << rhs.scale
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::fz_stext_options& lhs, const ::fz_stext_options& rhs)
{
	if (lhs.flags != rhs.flags) return false;
	if (lhs.scale != rhs.scale) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::fz_stext_options& lhs, const ::fz_stext_options& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::fz_story_element_position& rhs)
{
	out
			<< "("
			<<  "depth=" << rhs.depth
			<< " heading=" << rhs.heading
			<< " id=" << rhs.id
			<< " href=" << rhs.href
			<< " rect=" << rhs.rect
			<< " text=" << rhs.text
			<< " open_close=" << rhs.open_close
			<< " rectangle_num=" << rhs.rectangle_num
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::fz_story_element_position& lhs, const ::fz_story_element_position& rhs)
{
	if (lhs.depth != rhs.depth) return false;
	if (lhs.heading != rhs.heading) return false;
	if (lhs.id != rhs.id) return false;
	if (lhs.href != rhs.href) return false;
	if (lhs.rect != rhs.rect) return false;
	if (lhs.text != rhs.text) return false;
	if (lhs.open_close != rhs.open_close) return false;
	if (lhs.rectangle_num != rhs.rectangle_num) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::fz_story_element_position& lhs, const ::fz_story_element_position& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::fz_transition& rhs)
{
	out
			<< "("
			<<  "type=" << rhs.type
			<< " duration=" << rhs.duration
			<< " vertical=" << rhs.vertical
			<< " outwards=" << rhs.outwards
			<< " direction=" << rhs.direction
			<< " state0=" << rhs.state0
			<< " state1=" << rhs.state1
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::fz_transition& lhs, const ::fz_transition& rhs)
{
	if (lhs.type != rhs.type) return false;
	if (lhs.duration != rhs.duration) return false;
	if (lhs.vertical != rhs.vertical) return false;
	if (lhs.outwards != rhs.outwards) return false;
	if (lhs.direction != rhs.direction) return false;
	if (lhs.state0 != rhs.state0) return false;
	if (lhs.state1 != rhs.state1) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::fz_transition& lhs, const ::fz_transition& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::pdf_clean_options& rhs)
{
	out
			<< "("
			<<  "write=" << rhs.write
			<< " image=" << rhs.image
			<< " subset_fonts=" << rhs.subset_fonts
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::pdf_clean_options& lhs, const ::pdf_clean_options& rhs)
{
	if (lhs.write != rhs.write) return false;
	if (lhs.image != rhs.image) return false;
	if (lhs.subset_fonts != rhs.subset_fonts) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::pdf_clean_options& lhs, const ::pdf_clean_options& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::pdf_filter_factory& rhs)
{
	out
			<< "("
			<<  "filter=" << rhs.filter
			<< " options=" << rhs.options
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::pdf_filter_factory& lhs, const ::pdf_filter_factory& rhs)
{
	if (lhs.filter != rhs.filter) return false;
	if (lhs.options != rhs.options) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::pdf_filter_factory& lhs, const ::pdf_filter_factory& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::pdf_filter_options& rhs)
{
	out
			<< "("
			<<  "recurse=" << rhs.recurse
			<< " instance_forms=" << rhs.instance_forms
			<< " ascii=" << rhs.ascii
			<< " no_update=" << rhs.no_update
			<< " opaque=" << rhs.opaque
			<< " complete=" << rhs.complete
			<< " filters=" << rhs.filters
			<< " newlines=" << rhs.newlines
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::pdf_filter_options& lhs, const ::pdf_filter_options& rhs)
{
	if (lhs.recurse != rhs.recurse) return false;
	if (lhs.instance_forms != rhs.instance_forms) return false;
	if (lhs.ascii != rhs.ascii) return false;
	if (lhs.no_update != rhs.no_update) return false;
	if (lhs.opaque != rhs.opaque) return false;
	if (lhs.complete != rhs.complete) return false;
	if (lhs.filters != rhs.filters) return false;
	if (lhs.newlines != rhs.newlines) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::pdf_filter_options& lhs, const ::pdf_filter_options& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::pdf_image_rewriter_options& rhs)
{
	out
			<< "("
			<<  "color_lossless_image_subsample_method=" << rhs.color_lossless_image_subsample_method
			<< " color_lossy_image_subsample_method=" << rhs.color_lossy_image_subsample_method
			<< " color_lossless_image_subsample_threshold=" << rhs.color_lossless_image_subsample_threshold
			<< " color_lossless_image_subsample_to=" << rhs.color_lossless_image_subsample_to
			<< " color_lossy_image_subsample_threshold=" << rhs.color_lossy_image_subsample_threshold
			<< " color_lossy_image_subsample_to=" << rhs.color_lossy_image_subsample_to
			<< " color_lossless_image_recompress_method=" << rhs.color_lossless_image_recompress_method
			<< " color_lossy_image_recompress_method=" << rhs.color_lossy_image_recompress_method
			<< " color_lossy_image_recompress_quality=" << rhs.color_lossy_image_recompress_quality
			<< " color_lossless_image_recompress_quality=" << rhs.color_lossless_image_recompress_quality
			<< " gray_lossless_image_subsample_method=" << rhs.gray_lossless_image_subsample_method
			<< " gray_lossy_image_subsample_method=" << rhs.gray_lossy_image_subsample_method
			<< " gray_lossless_image_subsample_threshold=" << rhs.gray_lossless_image_subsample_threshold
			<< " gray_lossless_image_subsample_to=" << rhs.gray_lossless_image_subsample_to
			<< " gray_lossy_image_subsample_threshold=" << rhs.gray_lossy_image_subsample_threshold
			<< " gray_lossy_image_subsample_to=" << rhs.gray_lossy_image_subsample_to
			<< " gray_lossless_image_recompress_method=" << rhs.gray_lossless_image_recompress_method
			<< " gray_lossy_image_recompress_method=" << rhs.gray_lossy_image_recompress_method
			<< " gray_lossy_image_recompress_quality=" << rhs.gray_lossy_image_recompress_quality
			<< " gray_lossless_image_recompress_quality=" << rhs.gray_lossless_image_recompress_quality
			<< " bitonal_image_subsample_method=" << rhs.bitonal_image_subsample_method
			<< " bitonal_image_subsample_threshold=" << rhs.bitonal_image_subsample_threshold
			<< " bitonal_image_subsample_to=" << rhs.bitonal_image_subsample_to
			<< " bitonal_image_recompress_method=" << rhs.bitonal_image_recompress_method
			<< " bitonal_image_recompress_quality=" << rhs.bitonal_image_recompress_quality
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::pdf_image_rewriter_options& lhs, const ::pdf_image_rewriter_options& rhs)
{
	if (lhs.color_lossless_image_subsample_method != rhs.color_lossless_image_subsample_method) return false;
	if (lhs.color_lossy_image_subsample_method != rhs.color_lossy_image_subsample_method) return false;
	if (lhs.color_lossless_image_subsample_threshold != rhs.color_lossless_image_subsample_threshold) return false;
	if (lhs.color_lossless_image_subsample_to != rhs.color_lossless_image_subsample_to) return false;
	if (lhs.color_lossy_image_subsample_threshold != rhs.color_lossy_image_subsample_threshold) return false;
	if (lhs.color_lossy_image_subsample_to != rhs.color_lossy_image_subsample_to) return false;
	if (lhs.color_lossless_image_recompress_method != rhs.color_lossless_image_recompress_method) return false;
	if (lhs.color_lossy_image_recompress_method != rhs.color_lossy_image_recompress_method) return false;
	if (lhs.color_lossy_image_recompress_quality != rhs.color_lossy_image_recompress_quality) return false;
	if (lhs.color_lossless_image_recompress_quality != rhs.color_lossless_image_recompress_quality) return false;
	if (lhs.gray_lossless_image_subsample_method != rhs.gray_lossless_image_subsample_method) return false;
	if (lhs.gray_lossy_image_subsample_method != rhs.gray_lossy_image_subsample_method) return false;
	if (lhs.gray_lossless_image_subsample_threshold != rhs.gray_lossless_image_subsample_threshold) return false;
	if (lhs.gray_lossless_image_subsample_to != rhs.gray_lossless_image_subsample_to) return false;
	if (lhs.gray_lossy_image_subsample_threshold != rhs.gray_lossy_image_subsample_threshold) return false;
	if (lhs.gray_lossy_image_subsample_to != rhs.gray_lossy_image_subsample_to) return false;
	if (lhs.gray_lossless_image_recompress_method != rhs.gray_lossless_image_recompress_method) return false;
	if (lhs.gray_lossy_image_recompress_method != rhs.gray_lossy_image_recompress_method) return false;
	if (lhs.gray_lossy_image_recompress_quality != rhs.gray_lossy_image_recompress_quality) return false;
	if (lhs.gray_lossless_image_recompress_quality != rhs.gray_lossless_image_recompress_quality) return false;
	if (lhs.bitonal_image_subsample_method != rhs.bitonal_image_subsample_method) return false;
	if (lhs.bitonal_image_subsample_threshold != rhs.bitonal_image_subsample_threshold) return false;
	if (lhs.bitonal_image_subsample_to != rhs.bitonal_image_subsample_to) return false;
	if (lhs.bitonal_image_recompress_method != rhs.bitonal_image_recompress_method) return false;
	if (lhs.bitonal_image_recompress_quality != rhs.bitonal_image_recompress_quality) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::pdf_image_rewriter_options& lhs, const ::pdf_image_rewriter_options& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::pdf_layer_config& rhs)
{
	out
			<< "("
			<<  "name=" << rhs.name
			<< " creator=" << rhs.creator
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::pdf_layer_config& lhs, const ::pdf_layer_config& rhs)
{
	if (lhs.name != rhs.name) return false;
	if (lhs.creator != rhs.creator) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::pdf_layer_config& lhs, const ::pdf_layer_config& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::pdf_layer_config_ui& rhs)
{
	out
			<< "("
			<<  "text=" << rhs.text
			<< " depth=" << rhs.depth
			<< " type=" << rhs.type
			<< " selected=" << rhs.selected
			<< " locked=" << rhs.locked
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::pdf_layer_config_ui& lhs, const ::pdf_layer_config_ui& rhs)
{
	if (lhs.text != rhs.text) return false;
	if (lhs.depth != rhs.depth) return false;
	if (lhs.type != rhs.type) return false;
	if (lhs.selected != rhs.selected) return false;
	if (lhs.locked != rhs.locked) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::pdf_layer_config_ui& lhs, const ::pdf_layer_config_ui& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::pdf_redact_options& rhs)
{
	out
			<< "("
			<<  "black_boxes=" << rhs.black_boxes
			<< " image_method=" << rhs.image_method
			<< " line_art=" << rhs.line_art
			<< " text=" << rhs.text
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::pdf_redact_options& lhs, const ::pdf_redact_options& rhs)
{
	if (lhs.black_boxes != rhs.black_boxes) return false;
	if (lhs.image_method != rhs.image_method) return false;
	if (lhs.line_art != rhs.line_art) return false;
	if (lhs.text != rhs.text) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::pdf_redact_options& lhs, const ::pdf_redact_options& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::pdf_sanitize_filter_options& rhs)
{
	out
			<< "("
			<<  "opaque=" << rhs.opaque
			<< " image_filter=" << rhs.image_filter
			<< " text_filter=" << rhs.text_filter
			<< " after_text_object=" << rhs.after_text_object
			<< " culler=" << rhs.culler
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::pdf_sanitize_filter_options& lhs, const ::pdf_sanitize_filter_options& rhs)
{
	if (lhs.opaque != rhs.opaque) return false;
	if (lhs.image_filter != rhs.image_filter) return false;
	if (lhs.text_filter != rhs.text_filter) return false;
	if (lhs.after_text_object != rhs.after_text_object) return false;
	if (lhs.culler != rhs.culler) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::pdf_sanitize_filter_options& lhs, const ::pdf_sanitize_filter_options& rhs)
{
	return !(lhs == rhs);
}

FZ_FUNCTION std::ostream& operator<< (std::ostream& out, const ::pdf_write_options& rhs)
{
	out
			<< "("
			<<  "do_incremental=" << rhs.do_incremental
			<< " do_pretty=" << rhs.do_pretty
			<< " do_ascii=" << rhs.do_ascii
			<< " do_compress=" << rhs.do_compress
			<< " do_compress_images=" << rhs.do_compress_images
			<< " do_compress_fonts=" << rhs.do_compress_fonts
			<< " do_decompress=" << rhs.do_decompress
			<< " do_garbage=" << rhs.do_garbage
			<< " do_linear=" << rhs.do_linear
			<< " do_clean=" << rhs.do_clean
			<< " do_sanitize=" << rhs.do_sanitize
			<< " do_appearance=" << rhs.do_appearance
			<< " do_encrypt=" << rhs.do_encrypt
			<< " dont_regenerate_id=" << rhs.dont_regenerate_id
			<< " permissions=" << rhs.permissions
			<< " opwd_utf8=" << rhs.opwd_utf8
			<< " upwd_utf8=" << rhs.upwd_utf8
			<< " do_snapshot=" << rhs.do_snapshot
			<< " do_preserve_metadata=" << rhs.do_preserve_metadata
			<< " do_use_objstms=" << rhs.do_use_objstms
			<< " compression_effort=" << rhs.compression_effort
			<< ")"
			;
	return out;
}

FZ_FUNCTION bool operator==( const ::pdf_write_options& lhs, const ::pdf_write_options& rhs)
{
	if (lhs.do_incremental != rhs.do_incremental) return false;
	if (lhs.do_pretty != rhs.do_pretty) return false;
	if (lhs.do_ascii != rhs.do_ascii) return false;
	if (lhs.do_compress != rhs.do_compress) return false;
	if (lhs.do_compress_images != rhs.do_compress_images) return false;
	if (lhs.do_compress_fonts != rhs.do_compress_fonts) return false;
	if (lhs.do_decompress != rhs.do_decompress) return false;
	if (lhs.do_garbage != rhs.do_garbage) return false;
	if (lhs.do_linear != rhs.do_linear) return false;
	if (lhs.do_clean != rhs.do_clean) return false;
	if (lhs.do_sanitize != rhs.do_sanitize) return false;
	if (lhs.do_appearance != rhs.do_appearance) return false;
	if (lhs.do_encrypt != rhs.do_encrypt) return false;
	if (lhs.dont_regenerate_id != rhs.dont_regenerate_id) return false;
	if (lhs.permissions != rhs.permissions) return false;
	if (lhs.opwd_utf8 != rhs.opwd_utf8) return false;
	if (lhs.upwd_utf8 != rhs.upwd_utf8) return false;
	if (lhs.do_snapshot != rhs.do_snapshot) return false;
	if (lhs.do_preserve_metadata != rhs.do_preserve_metadata) return false;
	if (lhs.do_use_objstms != rhs.do_use_objstms) return false;
	if (lhs.compression_effort != rhs.compression_effort) return false;
	return true;
}
FZ_FUNCTION bool operator!=( const ::pdf_write_options& lhs, const ::pdf_write_options& rhs)
{
	return !(lhs == rhs);
}
