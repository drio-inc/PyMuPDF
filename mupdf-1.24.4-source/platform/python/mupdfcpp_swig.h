/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_mupdf_WRAP_H_
#define SWIG_mupdf_WRAP_H_

#include <map>
#include <string>


struct SwigDirector_FzDevice2 : public mupdf::FzDevice2, public Swig::Director {

public:
    SwigDirector_FzDevice2(PyObject *self);
    virtual void close_device(::fz_context *arg_0);
    virtual void drop_device(::fz_context *arg_0);
    virtual void fill_path(::fz_context *arg_0,::fz_path const *arg_2,int arg_3,::fz_matrix arg_4,::fz_colorspace *arg_5,float const *arg_6,float arg_7,::fz_color_params arg_8);
    virtual void stroke_path(::fz_context *arg_0,::fz_path const *arg_2,::fz_stroke_state const *arg_3,::fz_matrix arg_4,::fz_colorspace *arg_5,float const *arg_6,float arg_7,::fz_color_params arg_8);
    virtual void clip_path(::fz_context *arg_0,::fz_path const *arg_2,int arg_3,::fz_matrix arg_4,::fz_rect arg_5);
    virtual void clip_stroke_path(::fz_context *arg_0,::fz_path const *arg_2,::fz_stroke_state const *arg_3,::fz_matrix arg_4,::fz_rect arg_5);
    virtual void fill_text(::fz_context *arg_0,::fz_text const *arg_2,::fz_matrix arg_3,::fz_colorspace *arg_4,float const *arg_5,float arg_6,::fz_color_params arg_7);
    virtual void stroke_text(::fz_context *arg_0,::fz_text const *arg_2,::fz_stroke_state const *arg_3,::fz_matrix arg_4,::fz_colorspace *arg_5,float const *arg_6,float arg_7,::fz_color_params arg_8);
    virtual void clip_text(::fz_context *arg_0,::fz_text const *arg_2,::fz_matrix arg_3,::fz_rect arg_4);
    virtual void clip_stroke_text(::fz_context *arg_0,::fz_text const *arg_2,::fz_stroke_state const *arg_3,::fz_matrix arg_4,::fz_rect arg_5);
    virtual void ignore_text(::fz_context *arg_0,::fz_text const *arg_2,::fz_matrix arg_3);
    virtual void fill_shade(::fz_context *arg_0,::fz_shade *arg_2,::fz_matrix arg_3,float arg_4,::fz_color_params arg_5);
    virtual void fill_image(::fz_context *arg_0,::fz_image *arg_2,::fz_matrix arg_3,float arg_4,::fz_color_params arg_5);
    virtual void fill_image_mask(::fz_context *arg_0,::fz_image *arg_2,::fz_matrix arg_3,::fz_colorspace *arg_4,float const *arg_5,float arg_6,::fz_color_params arg_7);
    virtual void clip_image_mask(::fz_context *arg_0,::fz_image *arg_2,::fz_matrix arg_3,::fz_rect arg_4);
    virtual void pop_clip(::fz_context *arg_0);
    virtual void begin_mask(::fz_context *arg_0,::fz_rect arg_2,int arg_3,::fz_colorspace *arg_4,float const *arg_5,::fz_color_params arg_6);
    virtual void end_mask(::fz_context *arg_0,::fz_function *arg_2);
    virtual void begin_group(::fz_context *arg_0,::fz_rect arg_2,::fz_colorspace *arg_3,int arg_4,int arg_5,int arg_6,float arg_7);
    virtual void end_group(::fz_context *arg_0);
    virtual int begin_tile(::fz_context *arg_0,::fz_rect arg_2,::fz_rect arg_3,float arg_4,float arg_5,::fz_matrix arg_6,int arg_7);
    virtual void end_tile(::fz_context *arg_0);
    virtual void render_flags(::fz_context *arg_0,int arg_2,int arg_3);
    virtual void set_default_colorspaces(::fz_context *arg_0,::fz_default_colorspaces *arg_2);
    virtual void begin_layer(::fz_context *arg_0,char const *arg_2);
    virtual void end_layer(::fz_context *arg_0);
    virtual void begin_structure(::fz_context *arg_0,::fz_structure arg_2,char const *arg_3,int arg_4);
    virtual void end_structure(::fz_context *arg_0);
    virtual void begin_metatext(::fz_context *arg_0,::fz_metatext arg_2,char const *arg_3);
    virtual void end_metatext(::fz_context *arg_0);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FzDevice2 doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[30];
#endif

};


struct SwigDirector_FzInstallLoadSystemFontFuncsArgs2 : public mupdf::FzInstallLoadSystemFontFuncsArgs2, public Swig::Director {

public:
    SwigDirector_FzInstallLoadSystemFontFuncsArgs2(PyObject *self);
    virtual ::fz_font *f(::fz_context *arg_0,char const *arg_1,int arg_2,int arg_3,int arg_4);
    virtual ::fz_font *f_cjk(::fz_context *arg_0,char const *arg_1,int arg_2,int arg_3);
    virtual ::fz_font *f_fallback(::fz_context *arg_0,int arg_1,int arg_2,int arg_3,int arg_4,int arg_5);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FzInstallLoadSystemFontFuncsArgs2 doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


struct SwigDirector_FzOutput2 : public mupdf::FzOutput2, public Swig::Director {

public:
    SwigDirector_FzOutput2(PyObject *self);
    virtual void write(::fz_context *arg_0,void const *arg_2,unsigned long arg_3);
    virtual void seek(::fz_context *arg_0,long arg_2,int arg_3);
    virtual long tell(::fz_context *arg_0);
    virtual void close(::fz_context *arg_0);
    virtual void drop(::fz_context *arg_0);
    virtual void reset(::fz_context *arg_0);
    virtual ::fz_stream *as_stream(::fz_context *arg_0);
    virtual void truncate(::fz_context *arg_0);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FzOutput2 doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


struct SwigDirector_FzPathWalker2 : public mupdf::FzPathWalker2, public Swig::Director {

public:
    SwigDirector_FzPathWalker2(PyObject *self);
    virtual void moveto(::fz_context *arg_0,float arg_2,float arg_3);
    virtual void lineto(::fz_context *arg_0,float arg_2,float arg_3);
    virtual void curveto(::fz_context *arg_0,float arg_2,float arg_3,float arg_4,float arg_5,float arg_6,float arg_7);
    virtual void closepath(::fz_context *arg_0);
    virtual void quadto(::fz_context *arg_0,float arg_2,float arg_3,float arg_4,float arg_5);
    virtual void curvetov(::fz_context *arg_0,float arg_2,float arg_3,float arg_4,float arg_5);
    virtual void curvetoy(::fz_context *arg_0,float arg_2,float arg_3,float arg_4,float arg_5);
    virtual void rectto(::fz_context *arg_0,float arg_2,float arg_3,float arg_4,float arg_5);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FzPathWalker2 doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[8];
#endif

};


struct SwigDirector_PdfFilterFactory2 : public mupdf::PdfFilterFactory2, public Swig::Director {

public:
    SwigDirector_PdfFilterFactory2(PyObject *self);
    virtual ::pdf_processor *filter(::fz_context *arg_0,::pdf_document *arg_1,::pdf_processor *arg_2,int arg_3,::fz_matrix arg_4,::pdf_filter_options *arg_5);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class PdfFilterFactory2 doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


struct SwigDirector_PdfFilterOptions2 : public mupdf::PdfFilterOptions2, public Swig::Director {

public:
    SwigDirector_PdfFilterOptions2(PyObject *self);
    virtual void complete(::fz_context *arg_0,::fz_buffer *arg_1);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class PdfFilterOptions2 doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


struct SwigDirector_PdfProcessor2 : public mupdf::PdfProcessor2, public Swig::Director {

public:
    SwigDirector_PdfProcessor2(PyObject *self);
    virtual void close_processor(::fz_context *arg_0);
    virtual void drop_processor(::fz_context *arg_0);
    virtual void reset_processor(::fz_context *arg_0);
    virtual void push_resources(::fz_context *arg_0,::pdf_obj *arg_2);
    virtual ::pdf_obj *pop_resources(::fz_context *arg_0);
    virtual void op_w(::fz_context *arg_0,float arg_2);
    virtual void op_j(::fz_context *arg_0,int arg_2);
    virtual void op_J(::fz_context *arg_0,int arg_2);
    virtual void op_M(::fz_context *arg_0,float arg_2);
    virtual void op_d(::fz_context *arg_0,::pdf_obj *arg_2,float arg_3);
    virtual void op_ri(::fz_context *arg_0,char const *arg_2);
    virtual void op_i(::fz_context *arg_0,float arg_2);
    virtual void op_gs_begin(::fz_context *arg_0,char const *arg_2,::pdf_obj *arg_3);
    virtual void op_gs_BM(::fz_context *arg_0,char const *arg_2);
    virtual void op_gs_ca(::fz_context *arg_0,float arg_2);
    virtual void op_gs_CA(::fz_context *arg_0,float arg_2);
    virtual void op_gs_SMask(::fz_context *arg_0,::pdf_obj *arg_2,float *arg_3,int arg_4,::pdf_obj *arg_5);
    virtual void op_gs_end(::fz_context *arg_0);
    virtual void op_q(::fz_context *arg_0);
    virtual void op_Q(::fz_context *arg_0);
    virtual void op_cm(::fz_context *arg_0,float arg_2,float arg_3,float arg_4,float arg_5,float arg_6,float arg_7);
    virtual void op_m(::fz_context *arg_0,float arg_2,float arg_3);
    virtual void op_l(::fz_context *arg_0,float arg_2,float arg_3);
    virtual void op_c(::fz_context *arg_0,float arg_2,float arg_3,float arg_4,float arg_5,float arg_6,float arg_7);
    virtual void op_v(::fz_context *arg_0,float arg_2,float arg_3,float arg_4,float arg_5);
    virtual void op_y(::fz_context *arg_0,float arg_2,float arg_3,float arg_4,float arg_5);
    virtual void op_h(::fz_context *arg_0);
    virtual void op_re(::fz_context *arg_0,float arg_2,float arg_3,float arg_4,float arg_5);
    virtual void op_S(::fz_context *arg_0);
    virtual void op_s(::fz_context *arg_0);
    virtual void op_F(::fz_context *arg_0);
    virtual void op_f(::fz_context *arg_0);
    virtual void op_fstar(::fz_context *arg_0);
    virtual void op_B(::fz_context *arg_0);
    virtual void op_Bstar(::fz_context *arg_0);
    virtual void op_b(::fz_context *arg_0);
    virtual void op_bstar(::fz_context *arg_0);
    virtual void op_n(::fz_context *arg_0);
    virtual void op_W(::fz_context *arg_0);
    virtual void op_Wstar(::fz_context *arg_0);
    virtual void op_BT(::fz_context *arg_0);
    virtual void op_ET(::fz_context *arg_0);
    virtual void op_Tc(::fz_context *arg_0,float arg_2);
    virtual void op_Tw(::fz_context *arg_0,float arg_2);
    virtual void op_Tz(::fz_context *arg_0,float arg_2);
    virtual void op_TL(::fz_context *arg_0,float arg_2);
    virtual void op_Tf(::fz_context *arg_0,char const *arg_2,::pdf_font_desc *arg_3,float arg_4);
    virtual void op_Tr(::fz_context *arg_0,int arg_2);
    virtual void op_Ts(::fz_context *arg_0,float arg_2);
    virtual void op_Td(::fz_context *arg_0,float arg_2,float arg_3);
    virtual void op_TD(::fz_context *arg_0,float arg_2,float arg_3);
    virtual void op_Tm(::fz_context *arg_0,float arg_2,float arg_3,float arg_4,float arg_5,float arg_6,float arg_7);
    virtual void op_Tstar(::fz_context *arg_0);
    virtual void op_TJ(::fz_context *arg_0,::pdf_obj *arg_2);
    virtual void op_Tj(::fz_context *arg_0,char *arg_2,unsigned long arg_3);
    virtual void op_squote(::fz_context *arg_0,char *arg_2,unsigned long arg_3);
    virtual void op_dquote(::fz_context *arg_0,float arg_2,float arg_3,char *arg_4,unsigned long arg_5);
    virtual void op_d0(::fz_context *arg_0,float arg_2,float arg_3);
    virtual void op_d1(::fz_context *arg_0,float arg_2,float arg_3,float arg_4,float arg_5,float arg_6,float arg_7);
    virtual void op_CS(::fz_context *arg_0,char const *arg_2,::fz_colorspace *arg_3);
    virtual void op_cs(::fz_context *arg_0,char const *arg_2,::fz_colorspace *arg_3);
    virtual void op_SC_pattern(::fz_context *arg_0,char const *arg_2,::pdf_pattern *arg_3,int arg_4,float *arg_5);
    virtual void op_sc_pattern(::fz_context *arg_0,char const *arg_2,::pdf_pattern *arg_3,int arg_4,float *arg_5);
    virtual void op_SC_shade(::fz_context *arg_0,char const *arg_2,::fz_shade *arg_3);
    virtual void op_sc_shade(::fz_context *arg_0,char const *arg_2,::fz_shade *arg_3);
    virtual void op_SC_color(::fz_context *arg_0,int arg_2,float *arg_3);
    virtual void op_sc_color(::fz_context *arg_0,int arg_2,float *arg_3);
    virtual void op_G(::fz_context *arg_0,float arg_2);
    virtual void op_g(::fz_context *arg_0,float arg_2);
    virtual void op_RG(::fz_context *arg_0,float arg_2,float arg_3,float arg_4);
    virtual void op_rg(::fz_context *arg_0,float arg_2,float arg_3,float arg_4);
    virtual void op_K(::fz_context *arg_0,float arg_2,float arg_3,float arg_4,float arg_5);
    virtual void op_k(::fz_context *arg_0,float arg_2,float arg_3,float arg_4,float arg_5);
    virtual void op_BI(::fz_context *arg_0,::fz_image *arg_2,char const *arg_3);
    virtual void op_sh(::fz_context *arg_0,char const *arg_2,::fz_shade *arg_3);
    virtual void op_Do_image(::fz_context *arg_0,char const *arg_2,::fz_image *arg_3);
    virtual void op_Do_form(::fz_context *arg_0,char const *arg_2,::pdf_obj *arg_3);
    virtual void op_MP(::fz_context *arg_0,char const *arg_2);
    virtual void op_DP(::fz_context *arg_0,char const *arg_2,::pdf_obj *arg_3,::pdf_obj *arg_4);
    virtual void op_BMC(::fz_context *arg_0,char const *arg_2);
    virtual void op_BDC(::fz_context *arg_0,char const *arg_2,::pdf_obj *arg_3,::pdf_obj *arg_4);
    virtual void op_EMC(::fz_context *arg_0);
    virtual void op_BX(::fz_context *arg_0);
    virtual void op_EX(::fz_context *arg_0);
    virtual void op_gs_OP(::fz_context *arg_0,int arg_2);
    virtual void op_gs_op(::fz_context *arg_0,int arg_2);
    virtual void op_gs_OPM(::fz_context *arg_0,int arg_2);
    virtual void op_gs_UseBlackPtComp(::fz_context *arg_0,::pdf_obj *arg_2);
    virtual void op_END(::fz_context *arg_0);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class PdfProcessor2 doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[89];
#endif

};


struct SwigDirector_PdfSanitizeFilterOptions2 : public mupdf::PdfSanitizeFilterOptions2, public Swig::Director {

public:
    SwigDirector_PdfSanitizeFilterOptions2(PyObject *self);
    virtual ::fz_image *image_filter(::fz_context *arg_0,::fz_matrix arg_2,char const *arg_3,::fz_image *arg_4,::fz_rect arg_5);
    virtual int text_filter(::fz_context *arg_0,int *arg_2,int arg_3,::fz_matrix arg_4,::fz_matrix arg_5,::fz_rect arg_6);
    virtual void after_text_object(::fz_context *arg_0,::pdf_document *arg_2,::pdf_processor *arg_3,::fz_matrix arg_4);
    virtual int culler(::fz_context *arg_0,::fz_rect arg_2,::fz_cull_type arg_3);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class PdfSanitizeFilterOptions2 doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[4];
#endif

};


struct SwigDirector_DiagnosticCallback : public DiagnosticCallback, public Swig::Director {

public:
    SwigDirector_DiagnosticCallback(PyObject *self,char const *description);
    virtual void _print(char const *message);
    virtual ~SwigDirector_DiagnosticCallback();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class DiagnosticCallback doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


struct SwigDirector_StoryPositionsCallback : public StoryPositionsCallback, public Swig::Director {

public:
    SwigDirector_StoryPositionsCallback(PyObject *self);
    virtual void call(fz_story_element_position const *position);
    virtual ~SwigDirector_StoryPositionsCallback();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class StoryPositionsCallback doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


#endif
